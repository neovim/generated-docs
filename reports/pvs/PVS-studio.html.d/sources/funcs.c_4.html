
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>funcs.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">#include &lt;float.h&gt;</a>
<a name="ln5">#include &lt;math.h&gt;</a>
<a name="ln6"> </a>
<a name="ln7">#include &quot;nvim/api/private/helpers.h&quot;</a>
<a name="ln8">#include &quot;nvim/api/vim.h&quot;</a>
<a name="ln9">#include &quot;nvim/ascii.h&quot;</a>
<a name="ln10">#include &quot;nvim/assert.h&quot;</a>
<a name="ln11">#include &quot;nvim/buffer.h&quot;</a>
<a name="ln12">#include &quot;nvim/change.h&quot;</a>
<a name="ln13">#include &quot;nvim/channel.h&quot;</a>
<a name="ln14">#include &quot;nvim/charset.h&quot;</a>
<a name="ln15">#include &quot;nvim/context.h&quot;</a>
<a name="ln16">#include &quot;nvim/cursor.h&quot;</a>
<a name="ln17">#include &quot;nvim/diff.h&quot;</a>
<a name="ln18">#include &quot;nvim/edit.h&quot;</a>
<a name="ln19">#include &quot;nvim/eval.h&quot;</a>
<a name="ln20">#include &quot;nvim/eval/decode.h&quot;</a>
<a name="ln21">#include &quot;nvim/eval/encode.h&quot;</a>
<a name="ln22">#include &quot;nvim/eval/executor.h&quot;</a>
<a name="ln23">#include &quot;nvim/eval/funcs.h&quot;</a>
<a name="ln24">#include &quot;nvim/eval/userfunc.h&quot;</a>
<a name="ln25">#include &quot;nvim/ex_cmds2.h&quot;</a>
<a name="ln26">#include &quot;nvim/ex_docmd.h&quot;</a>
<a name="ln27">#include &quot;nvim/ex_getln.h&quot;</a>
<a name="ln28">#include &quot;nvim/file_search.h&quot;</a>
<a name="ln29">#include &quot;nvim/fileio.h&quot;</a>
<a name="ln30">#include &quot;nvim/fold.h&quot;</a>
<a name="ln31">#include &quot;nvim/if_cscope.h&quot;</a>
<a name="ln32">#include &quot;nvim/indent.h&quot;</a>
<a name="ln33">#include &quot;nvim/indent_c.h&quot;</a>
<a name="ln34">#include &quot;nvim/lua/executor.h&quot;</a>
<a name="ln35">#include &quot;nvim/macros.h&quot;</a>
<a name="ln36">#include &quot;nvim/mark.h&quot;</a>
<a name="ln37">#include &quot;nvim/math.h&quot;</a>
<a name="ln38">#include &quot;nvim/memline.h&quot;</a>
<a name="ln39">#include &quot;nvim/misc1.h&quot;</a>
<a name="ln40">#include &quot;nvim/mouse.h&quot;</a>
<a name="ln41">#include &quot;nvim/move.h&quot;</a>
<a name="ln42">#include &quot;nvim/msgpack_rpc/channel.h&quot;</a>
<a name="ln43">#include &quot;nvim/msgpack_rpc/server.h&quot;</a>
<a name="ln44">#include &quot;nvim/ops.h&quot;</a>
<a name="ln45">#include &quot;nvim/option.h&quot;</a>
<a name="ln46">#include &quot;nvim/os/dl.h&quot;</a>
<a name="ln47">#include &quot;nvim/os/input.h&quot;</a>
<a name="ln48">#include &quot;nvim/os/shell.h&quot;</a>
<a name="ln49">#include &quot;nvim/path.h&quot;</a>
<a name="ln50">#include &quot;nvim/popupmnu.h&quot;</a>
<a name="ln51">#include &quot;nvim/quickfix.h&quot;</a>
<a name="ln52">#include &quot;nvim/regexp.h&quot;</a>
<a name="ln53">#include &quot;nvim/screen.h&quot;</a>
<a name="ln54">#include &quot;nvim/search.h&quot;</a>
<a name="ln55">#include &quot;nvim/sha256.h&quot;</a>
<a name="ln56">#include &quot;nvim/sign.h&quot;</a>
<a name="ln57">#include &quot;nvim/spell.h&quot;</a>
<a name="ln58">#include &quot;nvim/state.h&quot;</a>
<a name="ln59">#include &quot;nvim/syntax.h&quot;</a>
<a name="ln60">#include &quot;nvim/tag.h&quot;</a>
<a name="ln61">#include &quot;nvim/ui.h&quot;</a>
<a name="ln62">#include &quot;nvim/undo.h&quot;</a>
<a name="ln63">#include &quot;nvim/version.h&quot;</a>
<a name="ln64">#include &quot;nvim/vim.h&quot;</a>
<a name="ln65"> </a>
<a name="ln66"> </a>
<a name="ln67">/// Describe data to return from find_some_match()</a>
<a name="ln68">typedef enum {</a>
<a name="ln69">  kSomeMatch,  ///&lt; Data for match().</a>
<a name="ln70">  kSomeMatchEnd,  ///&lt; Data for matchend().</a>
<a name="ln71">  kSomeMatchList,  ///&lt; Data for matchlist().</a>
<a name="ln72">  kSomeMatchStr,  ///&lt; Data for matchstr().</a>
<a name="ln73">  kSomeMatchStrPos,  ///&lt; Data for matchstrpos().</a>
<a name="ln74">} SomeMatchType;</a>
<a name="ln75"> </a>
<a name="ln76">KHASH_MAP_INIT_STR(functions, VimLFuncDef)</a>
<a name="ln77"> </a>
<a name="ln78"> </a>
<a name="ln79">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln80"># include &quot;eval/funcs.c.generated.h&quot;</a>
<a name="ln81"> </a>
<a name="ln82">#ifdef _MSC_VER</a>
<a name="ln83">// This prevents MSVC from replacing the functions with intrinsics,</a>
<a name="ln84">// and causing errors when trying to get their addresses in funcs.generated.h</a>
<a name="ln85">#pragma function(ceil)</a>
<a name="ln86">#pragma function(floor)</a>
<a name="ln87">#endif</a>
<a name="ln88"> </a>
<a name="ln89">PRAGMA_DIAG_PUSH_IGNORE_MISSING_PROTOTYPES</a>
<a name="ln90">PRAGMA_DIAG_PUSH_IGNORE_IMPLICIT_FALLTHROUGH</a>
<a name="ln91">#include &quot;funcs.generated.h&quot;</a>
<a name="ln92">PRAGMA_DIAG_POP</a>
<a name="ln93">PRAGMA_DIAG_POP</a>
<a name="ln94">#endif</a>
<a name="ln95"> </a>
<a name="ln96"> </a>
<a name="ln97">static char *e_listarg = N_(&quot;E686: Argument of %s must be a List&quot;);</a>
<a name="ln98">static char *e_invalwindow = N_(&quot;E957: Invalid window number&quot;);</a>
<a name="ln99"> </a>
<a name="ln100">/// Dummy va_list for passing to vim_snprintf</a>
<a name="ln101">///</a>
<a name="ln102">/// Used because:</a>
<a name="ln103">/// - passing a NULL pointer doesn't work when va_list isn't a pointer</a>
<a name="ln104">/// - locally in the function results in a &quot;used before set&quot; warning</a>
<a name="ln105">/// - using va_start() to initialize it gives &quot;function with fixed args&quot; error</a>
<a name="ln106">static va_list dummy_ap;</a>
<a name="ln107"> </a>
<a name="ln108"> </a>
<a name="ln109">/// Function given to ExpandGeneric() to obtain the list of internal</a>
<a name="ln110">/// or user defined function names.</a>
<a name="ln111">char_u *get_function_name(expand_T *xp, int idx)</a>
<a name="ln112">{</a>
<a name="ln113">  static int intidx = -1;</a>
<a name="ln114">  char_u *name;</a>
<a name="ln115"> </a>
<a name="ln116">  if (idx == 0)</a>
<a name="ln117">    intidx = -1;</a>
<a name="ln118">  if (intidx &lt; 0) {</a>
<a name="ln119">    name = get_user_func_name(xp, idx);</a>
<a name="ln120">    if (name != NULL) {</a>
<a name="ln121">      if (*name != '&lt;' &amp;&amp; STRNCMP(&quot;g:&quot;, xp-&gt;xp_pattern, 2) == 0) {</a>
<a name="ln122">        return cat_prefix_varname('g', name);</a>
<a name="ln123">      }</a>
<a name="ln124">      return name;</a>
<a name="ln125">    }</a>
<a name="ln126">  }</a>
<a name="ln127">  while ((size_t)++intidx &lt; ARRAY_SIZE(functions)</a>
<a name="ln128">         &amp;&amp; functions[intidx].name[0] == '\0') {</a>
<a name="ln129">  }</a>
<a name="ln130"> </a>
<a name="ln131">  if ((size_t)intidx &gt;= ARRAY_SIZE(functions)) {</a>
<a name="ln132">    return NULL;</a>
<a name="ln133">  }</a>
<a name="ln134"> </a>
<a name="ln135">  const char *const key = functions[intidx].name;</a>
<a name="ln136">  const size_t key_len = strlen(key);</a>
<a name="ln137">  memcpy(IObuff, key, key_len);</a>
<a name="ln138">  IObuff[key_len] = '(';</a>
<a name="ln139">  if (functions[intidx].max_argc == 0) {</a>
<a name="ln140">    IObuff[key_len + 1] = ')';</a>
<a name="ln141">    IObuff[key_len + 2] = NUL;</a>
<a name="ln142">  } else {</a>
<a name="ln143">    IObuff[key_len + 1] = NUL;</a>
<a name="ln144">  }</a>
<a name="ln145">  return IObuff;</a>
<a name="ln146">}</a>
<a name="ln147"> </a>
<a name="ln148">/// Function given to ExpandGeneric() to obtain the list of internal or</a>
<a name="ln149">/// user defined variable or function names.</a>
<a name="ln150">char_u *get_expr_name(expand_T *xp, int idx)</a>
<a name="ln151">{</a>
<a name="ln152">  static int intidx = -1;</a>
<a name="ln153">  char_u *name;</a>
<a name="ln154"> </a>
<a name="ln155">  if (idx == 0)</a>
<a name="ln156">    intidx = -1;</a>
<a name="ln157">  if (intidx &lt; 0) {</a>
<a name="ln158">    name = get_function_name(xp, idx);</a>
<a name="ln159">    if (name != NULL)</a>
<a name="ln160">      return name;</a>
<a name="ln161">  }</a>
<a name="ln162">  return get_user_var_name(xp, ++intidx);</a>
<a name="ln163">}</a>
<a name="ln164"> </a>
<a name="ln165">/// Find internal function in hash functions</a>
<a name="ln166">///</a>
<a name="ln167">/// @param[in]  name  Name of the function.</a>
<a name="ln168">///</a>
<a name="ln169">/// Returns pointer to the function definition or NULL if not found.</a>
<a name="ln170">const VimLFuncDef *find_internal_func(const char *const name)</a>
<a name="ln171">  FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_PURE FUNC_ATTR_NONNULL_ALL</a>
<a name="ln172">{</a>
<a name="ln173">  size_t len = strlen(name);</a>
<a name="ln174">  return find_internal_func_gperf(name, len);</a>
<a name="ln175">}</a>
<a name="ln176"> </a>
<a name="ln177">/*</a>
<a name="ln178"> * Return TRUE for a non-zero Number and a non-empty String.</a>
<a name="ln179"> */</a>
<a name="ln180">static int non_zero_arg(typval_T *argvars)</a>
<a name="ln181">{</a>
<a name="ln182">  return ((argvars[0].v_type == VAR_NUMBER</a>
<a name="ln183">           &amp;&amp; argvars[0].vval.v_number != 0)</a>
<a name="ln184">          || (argvars[0].v_type == VAR_BOOL</a>
<a name="ln185">              &amp;&amp; argvars[0].vval.v_bool == kBoolVarTrue)</a>
<a name="ln186">          || (argvars[0].v_type == VAR_STRING</a>
<a name="ln187">              &amp;&amp; argvars[0].vval.v_string != NULL</a>
<a name="ln188">              &amp;&amp; *argvars[0].vval.v_string != NUL));</a>
<a name="ln189">}</a>
<a name="ln190"> </a>
<a name="ln191">// Apply a floating point C function on a typval with one float_T.</a>
<a name="ln192">//</a>
<a name="ln193">// Some versions of glibc on i386 have an optimization that makes it harder to</a>
<a name="ln194">// call math functions indirectly from inside an inlined function, causing</a>
<a name="ln195">// compile-time errors. Avoid `inline` in that case. #3072</a>
<a name="ln196">static void float_op_wrapper(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln197">{</a>
<a name="ln198">  float_T f;</a>
<a name="ln199">  float_T (*function)(float_T) = (float_T (*)(float_T))fptr;</a>
<a name="ln200"> </a>
<a name="ln201">  rettv-&gt;v_type = VAR_FLOAT;</a>
<a name="ln202">  if (tv_get_float_chk(argvars, &amp;f)) {</a>
<a name="ln203">    rettv-&gt;vval.v_float = function(f);</a>
<a name="ln204">  } else {</a>
<a name="ln205">    rettv-&gt;vval.v_float = 0.0;</a>
<a name="ln206">  }</a>
<a name="ln207">}</a>
<a name="ln208"> </a>
<a name="ln209">static void api_wrapper(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln210">{</a>
<a name="ln211">  if (check_secure()) {</a>
<a name="ln212">    return;</a>
<a name="ln213">  }</a>
<a name="ln214"> </a>
<a name="ln215">  ApiDispatchWrapper fn = (ApiDispatchWrapper)fptr;</a>
<a name="ln216"> </a>
<a name="ln217">  Array args = ARRAY_DICT_INIT;</a>
<a name="ln218"> </a>
<a name="ln219">  for (typval_T *tv = argvars; tv-&gt;v_type != VAR_UNKNOWN; tv++) {</a>
<a name="ln220">    ADD(args, vim_to_object(tv));</a>
<a name="ln221">  }</a>
<a name="ln222"> </a>
<a name="ln223">  Error err = ERROR_INIT;</a>
<a name="ln224">  Object result = fn(VIML_INTERNAL_CALL, args, &amp;err);</a>
<a name="ln225"> </a>
<a name="ln226">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln227">    emsgf_multiline((const char *)e_api_error, err.msg);</a>
<a name="ln228">    goto end;</a>
<a name="ln229">  }</a>
<a name="ln230"> </a>
<a name="ln231">  if (!object_to_vim(result, rettv, &amp;err)) {</a>
<a name="ln232">    EMSG2(_(&quot;Error converting the call result: %s&quot;), err.msg);</a>
<a name="ln233">  }</a>
<a name="ln234"> </a>
<a name="ln235">end:</a>
<a name="ln236">  api_free_array(args);</a>
<a name="ln237">  api_free_object(result);</a>
<a name="ln238">  api_clear_error(&amp;err);</a>
<a name="ln239">}</a>
<a name="ln240"> </a>
<a name="ln241">/*</a>
<a name="ln242"> * &quot;abs(expr)&quot; function</a>
<a name="ln243"> */</a>
<a name="ln244">static void f_abs(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln245">{</a>
<a name="ln246">  if (argvars[0].v_type == VAR_FLOAT) {</a>
<a name="ln247">    float_op_wrapper(argvars, rettv, (FunPtr)&amp;fabs);</a>
<a name="ln248">  } else {</a>
<a name="ln249">    varnumber_T n;</a>
<a name="ln250">    bool error = false;</a>
<a name="ln251"> </a>
<a name="ln252">    n = tv_get_number_chk(&amp;argvars[0], &amp;error);</a>
<a name="ln253">    if (error) {</a>
<a name="ln254">      rettv-&gt;vval.v_number = -1;</a>
<a name="ln255">    } else if (n &gt; 0) {</a>
<a name="ln256">      rettv-&gt;vval.v_number = n;</a>
<a name="ln257">    } else {</a>
<a name="ln258">      rettv-&gt;vval.v_number = -n;</a>
<a name="ln259">    }</a>
<a name="ln260">  }</a>
<a name="ln261">}</a>
<a name="ln262"> </a>
<a name="ln263">/*</a>
<a name="ln264"> * &quot;add(list, item)&quot; function</a>
<a name="ln265"> */</a>
<a name="ln266">static void f_add(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln267">{</a>
<a name="ln268">  rettv-&gt;vval.v_number = 1;  // Default: failed.</a>
<a name="ln269">  if (argvars[0].v_type == VAR_LIST) {</a>
<a name="ln270">    list_T *const l = argvars[0].vval.v_list;</a>
<a name="ln271">    if (!var_check_lock(tv_list_locked(l), N_(&quot;add() argument&quot;),</a>
<a name="ln272">                        TV_TRANSLATE)) {</a>
<a name="ln273">      tv_list_append_tv(l, &amp;argvars[1]);</a>
<a name="ln274">      tv_copy(&amp;argvars[0], rettv);</a>
<a name="ln275">    }</a>
<a name="ln276">  } else {</a>
<a name="ln277">    EMSG(_(e_listreq));</a>
<a name="ln278">  }</a>
<a name="ln279">}</a>
<a name="ln280"> </a>
<a name="ln281">/*</a>
<a name="ln282"> * &quot;and(expr, expr)&quot; function</a>
<a name="ln283"> */</a>
<a name="ln284">static void f_and(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln285">{</a>
<a name="ln286">  rettv-&gt;vval.v_number = tv_get_number_chk(&amp;argvars[0], NULL)</a>
<a name="ln287">                         &amp; tv_get_number_chk(&amp;argvars[1], NULL);</a>
<a name="ln288">}</a>
<a name="ln289"> </a>
<a name="ln290"> </a>
<a name="ln291">/// &quot;api_info()&quot; function</a>
<a name="ln292">static void f_api_info(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln293">{</a>
<a name="ln294">  Dictionary metadata = api_metadata();</a>
<a name="ln295">  (void)object_to_vim(DICTIONARY_OBJ(metadata), rettv, NULL);</a>
<a name="ln296">  api_free_dictionary(metadata);</a>
<a name="ln297">}</a>
<a name="ln298"> </a>
<a name="ln299">// &quot;append(lnum, string/list)&quot; function</a>
<a name="ln300">static void f_append(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln301">{</a>
<a name="ln302">  const linenr_T lnum = tv_get_lnum(&amp;argvars[0]);</a>
<a name="ln303"> </a>
<a name="ln304">  set_buffer_lines(curbuf, lnum, true, &amp;argvars[1], rettv);</a>
<a name="ln305">}</a>
<a name="ln306"> </a>
<a name="ln307">// &quot;appendbufline(buf, lnum, string/list)&quot; function</a>
<a name="ln308">static void f_appendbufline(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln309">{</a>
<a name="ln310">  buf_T *const buf = tv_get_buf(&amp;argvars[0], false);</a>
<a name="ln311">  if (buf == NULL) {</a>
<a name="ln312">    rettv-&gt;vval.v_number = 1;  // FAIL</a>
<a name="ln313">  } else {</a>
<a name="ln314">    const linenr_T lnum = tv_get_lnum_buf(&amp;argvars[1], buf);</a>
<a name="ln315">    set_buffer_lines(buf, lnum, true, &amp;argvars[2], rettv);</a>
<a name="ln316">  }</a>
<a name="ln317">}</a>
<a name="ln318"> </a>
<a name="ln319">static void f_argc(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln320">{</a>
<a name="ln321">  if (argvars[0].v_type == VAR_UNKNOWN) {</a>
<a name="ln322">    // use the current window</a>
<a name="ln323">    rettv-&gt;vval.v_number = ARGCOUNT;</a>
<a name="ln324">  } else if (argvars[0].v_type == VAR_NUMBER</a>
<a name="ln325">             &amp;&amp; tv_get_number(&amp;argvars[0]) == -1) {</a>
<a name="ln326">    // use the global argument list</a>
<a name="ln327">    rettv-&gt;vval.v_number = GARGCOUNT;</a>
<a name="ln328">  } else {</a>
<a name="ln329">    // use the argument list of the specified window</a>
<a name="ln330">    win_T *wp = find_win_by_nr_or_id(&amp;argvars[0]);</a>
<a name="ln331">    if (wp != NULL) {</a>
<a name="ln332">      rettv-&gt;vval.v_number = WARGCOUNT(wp);</a>
<a name="ln333">    } else {</a>
<a name="ln334">      rettv-&gt;vval.v_number = -1;</a>
<a name="ln335">    }</a>
<a name="ln336">  }</a>
<a name="ln337">}</a>
<a name="ln338"> </a>
<a name="ln339">/*</a>
<a name="ln340"> * &quot;argidx()&quot; function</a>
<a name="ln341"> */</a>
<a name="ln342">static void f_argidx(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln343">{</a>
<a name="ln344">  rettv-&gt;vval.v_number = curwin-&gt;w_arg_idx;</a>
<a name="ln345">}</a>
<a name="ln346"> </a>
<a name="ln347">/// &quot;arglistid&quot; function</a>
<a name="ln348">static void f_arglistid(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln349">{</a>
<a name="ln350">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln351">  win_T *wp = find_tabwin(&amp;argvars[0], &amp;argvars[1]);</a>
<a name="ln352">  if (wp != NULL) {</a>
<a name="ln353">    rettv-&gt;vval.v_number = wp-&gt;w_alist-&gt;id;</a>
<a name="ln354">  }</a>
<a name="ln355">}</a>
<a name="ln356"> </a>
<a name="ln357">/*</a>
<a name="ln358"> * &quot;argv(nr)&quot; function</a>
<a name="ln359"> */</a>
<a name="ln360">static void f_argv(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln361">{</a>
<a name="ln362">  aentry_T *arglist = NULL;</a>
<a name="ln363">  int argcount = -1;</a>
<a name="ln364"> </a>
<a name="ln365">  if (argvars[0].v_type != VAR_UNKNOWN) {</a>
<a name="ln366">    if (argvars[1].v_type == VAR_UNKNOWN) {</a>
<a name="ln367">      arglist = ARGLIST;</a>
<a name="ln368">      argcount = ARGCOUNT;</a>
<a name="ln369">    } else if (argvars[1].v_type == VAR_NUMBER</a>
<a name="ln370">               &amp;&amp; tv_get_number(&amp;argvars[1]) == -1) {</a>
<a name="ln371">      arglist = GARGLIST;</a>
<a name="ln372">      argcount = GARGCOUNT;</a>
<a name="ln373">    } else {</a>
<a name="ln374">      win_T *wp = find_win_by_nr_or_id(&amp;argvars[1]);</a>
<a name="ln375">      if (wp != NULL) {</a>
<a name="ln376">        // Use the argument list of the specified window</a>
<a name="ln377">        arglist = WARGLIST(wp);</a>
<a name="ln378">        argcount = WARGCOUNT(wp);</a>
<a name="ln379">      }</a>
<a name="ln380">    }</a>
<a name="ln381">    rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln382">    rettv-&gt;vval.v_string = NULL;</a>
<a name="ln383">    int idx = tv_get_number_chk(&amp;argvars[0], NULL);</a>
<a name="ln384">    if (arglist != NULL &amp;&amp; idx &gt;= 0 &amp;&amp; idx &lt; argcount) {</a>
<a name="ln385">      rettv-&gt;vval.v_string = (char_u *)xstrdup(</a>
<a name="ln386">          (const char *)alist_name(&amp;arglist[idx]));</a>
<a name="ln387">    } else if (idx == -1) {</a>
<a name="ln388">      get_arglist_as_rettv(arglist, argcount, rettv);</a>
<a name="ln389">    }</a>
<a name="ln390">  } else {</a>
<a name="ln391">    get_arglist_as_rettv(ARGLIST, ARGCOUNT, rettv);</a>
<a name="ln392">  }</a>
<a name="ln393">}</a>
<a name="ln394"> </a>
<a name="ln395">// &quot;assert_beeps(cmd [, error])&quot; function</a>
<a name="ln396">static void f_assert_beeps(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln397">{</a>
<a name="ln398">  rettv-&gt;vval.v_number = assert_beeps(argvars, false);</a>
<a name="ln399">}</a>
<a name="ln400"> </a>
<a name="ln401">// &quot;assert_nobeep(cmd [, error])&quot; function</a>
<a name="ln402">static void f_assert_nobeep(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln403">{</a>
<a name="ln404">  rettv-&gt;vval.v_number = assert_beeps(argvars, true);</a>
<a name="ln405">}</a>
<a name="ln406"> </a>
<a name="ln407">// &quot;assert_equal(expected, actual[, msg])&quot; function</a>
<a name="ln408">static void f_assert_equal(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln409">{</a>
<a name="ln410">  rettv-&gt;vval.v_number = assert_equal_common(argvars, ASSERT_EQUAL);</a>
<a name="ln411">}</a>
<a name="ln412"> </a>
<a name="ln413">// &quot;assert_equalfile(fname-one, fname-two[, msg])&quot; function</a>
<a name="ln414">static void f_assert_equalfile(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln415">{</a>
<a name="ln416">  rettv-&gt;vval.v_number = assert_equalfile(argvars);</a>
<a name="ln417">}</a>
<a name="ln418"> </a>
<a name="ln419">// &quot;assert_notequal(expected, actual[, msg])&quot; function</a>
<a name="ln420">static void f_assert_notequal(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln421">{</a>
<a name="ln422">  rettv-&gt;vval.v_number = assert_equal_common(argvars, ASSERT_NOTEQUAL);</a>
<a name="ln423">}</a>
<a name="ln424"> </a>
<a name="ln425">/// &quot;assert_report(msg)</a>
<a name="ln426">static void f_assert_report(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln427">{</a>
<a name="ln428">    garray_T ga;</a>
<a name="ln429"> </a>
<a name="ln430">    prepare_assert_error(&amp;ga);</a>
<a name="ln431">    ga_concat(&amp;ga, (const char_u *)tv_get_string(&amp;argvars[0]));</a>
<a name="ln432">    assert_error(&amp;ga);</a>
<a name="ln433">    ga_clear(&amp;ga);</a>
<a name="ln434">    rettv-&gt;vval.v_number = 1;</a>
<a name="ln435">}</a>
<a name="ln436"> </a>
<a name="ln437">/// &quot;assert_exception(string[, msg])&quot; function</a>
<a name="ln438">static void f_assert_exception(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln439">{</a>
<a name="ln440">  rettv-&gt;vval.v_number = assert_exception(argvars);</a>
<a name="ln441">}</a>
<a name="ln442"> </a>
<a name="ln443">/// &quot;assert_fails(cmd [, error [, msg]])&quot; function</a>
<a name="ln444">static void f_assert_fails(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln445">{</a>
<a name="ln446">  rettv-&gt;vval.v_number = assert_fails(argvars);</a>
<a name="ln447">}</a>
<a name="ln448"> </a>
<a name="ln449">// &quot;assert_false(actual[, msg])&quot; function</a>
<a name="ln450">static void f_assert_false(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln451">{</a>
<a name="ln452">  rettv-&gt;vval.v_number = assert_bool(argvars, false);</a>
<a name="ln453">}</a>
<a name="ln454"> </a>
<a name="ln455">/// &quot;assert_inrange(lower, upper[, msg])&quot; function</a>
<a name="ln456">static void f_assert_inrange(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln457">{</a>
<a name="ln458">  rettv-&gt;vval.v_number = assert_inrange(argvars);</a>
<a name="ln459">}</a>
<a name="ln460"> </a>
<a name="ln461">/// &quot;assert_match(pattern, actual[, msg])&quot; function</a>
<a name="ln462">static void f_assert_match(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln463">{</a>
<a name="ln464">  rettv-&gt;vval.v_number = assert_match_common(argvars, ASSERT_MATCH);</a>
<a name="ln465">}</a>
<a name="ln466"> </a>
<a name="ln467">/// &quot;assert_notmatch(pattern, actual[, msg])&quot; function</a>
<a name="ln468">static void f_assert_notmatch(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln469">{</a>
<a name="ln470">  rettv-&gt;vval.v_number = assert_match_common(argvars, ASSERT_NOTMATCH);</a>
<a name="ln471">}</a>
<a name="ln472"> </a>
<a name="ln473">// &quot;assert_true(actual[, msg])&quot; function</a>
<a name="ln474">static void f_assert_true(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln475">{</a>
<a name="ln476">  rettv-&gt;vval.v_number = assert_bool(argvars, true);</a>
<a name="ln477">}</a>
<a name="ln478"> </a>
<a name="ln479">/*</a>
<a name="ln480"> * &quot;atan2()&quot; function</a>
<a name="ln481"> */</a>
<a name="ln482">static void f_atan2(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln483">{</a>
<a name="ln484">  float_T fx;</a>
<a name="ln485">  float_T fy;</a>
<a name="ln486"> </a>
<a name="ln487">  rettv-&gt;v_type = VAR_FLOAT;</a>
<a name="ln488">  if (tv_get_float_chk(argvars, &amp;fx) &amp;&amp; tv_get_float_chk(&amp;argvars[1], &amp;fy)) {</a>
<a name="ln489">    rettv-&gt;vval.v_float = atan2(fx, fy);</a>
<a name="ln490">  } else {</a>
<a name="ln491">    rettv-&gt;vval.v_float = 0.0;</a>
<a name="ln492">  }</a>
<a name="ln493">}</a>
<a name="ln494"> </a>
<a name="ln495">/*</a>
<a name="ln496"> * &quot;browse(save, title, initdir, default)&quot; function</a>
<a name="ln497"> */</a>
<a name="ln498">static void f_browse(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln499">{</a>
<a name="ln500">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln501">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln502">}</a>
<a name="ln503"> </a>
<a name="ln504">/*</a>
<a name="ln505"> * &quot;browsedir(title, initdir)&quot; function</a>
<a name="ln506"> */</a>
<a name="ln507">static void f_browsedir(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln508">{</a>
<a name="ln509">  f_browse(argvars, rettv, NULL);</a>
<a name="ln510">}</a>
<a name="ln511"> </a>
<a name="ln512"> </a>
<a name="ln513">/*</a>
<a name="ln514"> * Find a buffer by number or exact name.</a>
<a name="ln515"> */</a>
<a name="ln516">static buf_T *find_buffer(typval_T *avar)</a>
<a name="ln517">{</a>
<a name="ln518">  buf_T       *buf = NULL;</a>
<a name="ln519"> </a>
<a name="ln520">  if (avar-&gt;v_type == VAR_NUMBER)</a>
<a name="ln521">    buf = buflist_findnr((int)avar-&gt;vval.v_number);</a>
<a name="ln522">  else if (avar-&gt;v_type == VAR_STRING &amp;&amp; avar-&gt;vval.v_string != NULL) {</a>
<a name="ln523">    buf = buflist_findname_exp(avar-&gt;vval.v_string);</a>
<a name="ln524">    if (buf == NULL) {</a>
<a name="ln525">      /* No full path name match, try a match with a URL or a &quot;nofile&quot;</a>
<a name="ln526">       * buffer, these don't use the full path. */</a>
<a name="ln527">      FOR_ALL_BUFFERS(bp) {</a>
<a name="ln528">        if (bp-&gt;b_fname != NULL</a>
<a name="ln529">            &amp;&amp; (path_with_url((char *)bp-&gt;b_fname)</a>
<a name="ln530">                || bt_nofile(bp)</a>
<a name="ln531">                )</a>
<a name="ln532">            &amp;&amp; STRCMP(bp-&gt;b_fname, avar-&gt;vval.v_string) == 0) {</a>
<a name="ln533">          buf = bp;</a>
<a name="ln534">          break;</a>
<a name="ln535">        }</a>
<a name="ln536">      }</a>
<a name="ln537">    }</a>
<a name="ln538">  }</a>
<a name="ln539">  return buf;</a>
<a name="ln540">}</a>
<a name="ln541"> </a>
<a name="ln542">// &quot;bufadd(expr)&quot; function</a>
<a name="ln543">static void f_bufadd(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln544">{</a>
<a name="ln545">  char_u *name = (char_u *)tv_get_string(&amp;argvars[0]);</a>
<a name="ln546"> </a>
<a name="ln547">  rettv-&gt;vval.v_number = buflist_add(*name == NUL ? NULL : name, 0);</a>
<a name="ln548">}</a>
<a name="ln549"> </a>
<a name="ln550">/*</a>
<a name="ln551"> * &quot;bufexists(expr)&quot; function</a>
<a name="ln552"> */</a>
<a name="ln553">static void f_bufexists(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln554">{</a>
<a name="ln555">  rettv-&gt;vval.v_number = (find_buffer(&amp;argvars[0]) != NULL);</a>
<a name="ln556">}</a>
<a name="ln557"> </a>
<a name="ln558">/*</a>
<a name="ln559"> * &quot;buflisted(expr)&quot; function</a>
<a name="ln560"> */</a>
<a name="ln561">static void f_buflisted(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln562">{</a>
<a name="ln563">  buf_T       *buf;</a>
<a name="ln564"> </a>
<a name="ln565">  buf = find_buffer(&amp;argvars[0]);</a>
<a name="ln566">  rettv-&gt;vval.v_number = (buf != NULL &amp;&amp; buf-&gt;b_p_bl);</a>
<a name="ln567">}</a>
<a name="ln568"> </a>
<a name="ln569">// &quot;bufload(expr)&quot; function</a>
<a name="ln570">static void f_bufload(typval_T *argvars, typval_T *unused, FunPtr fptr)</a>
<a name="ln571">{</a>
<a name="ln572">  buf_T *buf = get_buf_arg(&amp;argvars[0]);</a>
<a name="ln573"> </a>
<a name="ln574">  if (buf != NULL &amp;&amp; buf-&gt;b_ml.ml_mfp == NULL) {</a>
<a name="ln575">    aco_save_T aco;</a>
<a name="ln576"> </a>
<a name="ln577">    aucmd_prepbuf(&amp;aco, buf);</a>
<a name="ln578">    swap_exists_action = SEA_NONE;</a>
<a name="ln579">    open_buffer(false, NULL, 0);</a>
<a name="ln580">    aucmd_restbuf(&amp;aco);</a>
<a name="ln581">  }</a>
<a name="ln582">}</a>
<a name="ln583"> </a>
<a name="ln584">/*</a>
<a name="ln585"> * &quot;bufloaded(expr)&quot; function</a>
<a name="ln586"> */</a>
<a name="ln587">static void f_bufloaded(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln588">{</a>
<a name="ln589">  buf_T       *buf;</a>
<a name="ln590"> </a>
<a name="ln591">  buf = find_buffer(&amp;argvars[0]);</a>
<a name="ln592">  rettv-&gt;vval.v_number = (buf != NULL &amp;&amp; buf-&gt;b_ml.ml_mfp != NULL);</a>
<a name="ln593">}</a>
<a name="ln594"> </a>
<a name="ln595">/*</a>
<a name="ln596"> * &quot;bufname(expr)&quot; function</a>
<a name="ln597"> */</a>
<a name="ln598">static void f_bufname(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln599">{</a>
<a name="ln600">  const buf_T *buf;</a>
<a name="ln601">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln602">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln603">  if (argvars[0].v_type == VAR_UNKNOWN) {</a>
<a name="ln604">    buf = curbuf;</a>
<a name="ln605">  } else {</a>
<a name="ln606">    buf = tv_get_buf_from_arg(&amp;argvars[0]);</a>
<a name="ln607">  }</a>
<a name="ln608">  if (buf != NULL &amp;&amp; buf-&gt;b_fname != NULL) {</a>
<a name="ln609">    rettv-&gt;vval.v_string = (char_u *)xstrdup((char *)buf-&gt;b_fname);</a>
<a name="ln610">  }</a>
<a name="ln611">}</a>
<a name="ln612"> </a>
<a name="ln613">/*</a>
<a name="ln614"> * &quot;bufnr(expr)&quot; function</a>
<a name="ln615"> */</a>
<a name="ln616">static void f_bufnr(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln617">{</a>
<a name="ln618">  const buf_T *buf;</a>
<a name="ln619">  bool error = false;</a>
<a name="ln620"> </a>
<a name="ln621">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln622"> </a>
<a name="ln623">  if (argvars[0].v_type == VAR_UNKNOWN) {</a>
<a name="ln624">    buf = curbuf;</a>
<a name="ln625">  } else {</a>
<a name="ln626">    // Don't use tv_get_buf_from_arg(); we continue if the buffer wasn't found</a>
<a name="ln627">    // and the second argument isn't zero, but we want to return early if the</a>
<a name="ln628">    // first argument isn't a string or number so only one error is shown.</a>
<a name="ln629">    if (!tv_check_str_or_nr(&amp;argvars[0])) {</a>
<a name="ln630">      return;</a>
<a name="ln631">    }</a>
<a name="ln632">    emsg_off++;</a>
<a name="ln633">    buf = tv_get_buf(&amp;argvars[0], false);</a>
<a name="ln634">    emsg_off--;</a>
<a name="ln635">  }</a>
<a name="ln636"> </a>
<a name="ln637">  // If the buffer isn't found and the second argument is not zero create a</a>
<a name="ln638">  // new buffer.</a>
<a name="ln639">  const char *name;</a>
<a name="ln640">  if (buf == NULL</a>
<a name="ln641">      &amp;&amp; argvars[1].v_type != VAR_UNKNOWN</a>
<a name="ln642">      &amp;&amp; tv_get_number_chk(&amp;argvars[1], &amp;error) != 0</a>
<a name="ln643">      &amp;&amp; !error</a>
<a name="ln644">      &amp;&amp; (name = tv_get_string_chk(&amp;argvars[0])) != NULL) {</a>
<a name="ln645">    buf = buflist_new((char_u *)name, NULL, 1, 0);</a>
<a name="ln646">  }</a>
<a name="ln647"> </a>
<a name="ln648">  if (buf != NULL) {</a>
<a name="ln649">    rettv-&gt;vval.v_number = buf-&gt;b_fnum;</a>
<a name="ln650">  }</a>
<a name="ln651">}</a>
<a name="ln652"> </a>
<a name="ln653">static void buf_win_common(typval_T *argvars, typval_T *rettv, bool get_nr)</a>
<a name="ln654">{</a>
<a name="ln655">  const buf_T *const buf = tv_get_buf_from_arg(&amp;argvars[0]);</a>
<a name="ln656">  if (buf == NULL) {  // no need to search if invalid arg or buffer not found</a>
<a name="ln657">    rettv-&gt;vval.v_number = -1;</a>
<a name="ln658">    return;</a>
<a name="ln659">  }</a>
<a name="ln660"> </a>
<a name="ln661">  int winnr = 0;</a>
<a name="ln662">  int winid;</a>
<a name="ln663">  bool found_buf = false;</a>
<a name="ln664">  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {</a>
<a name="ln665">    winnr++;</a>
<a name="ln666">    if (wp-&gt;w_buffer == buf) {</a>
<a name="ln667">      found_buf = true;</a>
<a name="ln668">      winid = wp-&gt;handle;</a>
<a name="ln669">      break;</a>
<a name="ln670">    }</a>
<a name="ln671">  }</a>
<a name="ln672">  rettv-&gt;vval.v_number = (found_buf ? (get_nr ? winnr : winid) : -1);</a>
<a name="ln673">}</a>
<a name="ln674"> </a>
<a name="ln675">/// &quot;bufwinid(nr)&quot; function</a>
<a name="ln676">static void f_bufwinid(typval_T *argvars, typval_T *rettv, FunPtr fptr) {</a>
<a name="ln677">  buf_win_common(argvars, rettv, false);</a>
<a name="ln678">}</a>
<a name="ln679"> </a>
<a name="ln680">/// &quot;bufwinnr(nr)&quot; function</a>
<a name="ln681">static void f_bufwinnr(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln682">{</a>
<a name="ln683">  buf_win_common(argvars, rettv, true);</a>
<a name="ln684">}</a>
<a name="ln685"> </a>
<a name="ln686">/*</a>
<a name="ln687"> * Get buffer by number or pattern.</a>
<a name="ln688"> */</a>
<a name="ln689">buf_T *tv_get_buf(typval_T *tv, int curtab_only)</a>
<a name="ln690">{</a>
<a name="ln691">  char_u      *name = tv-&gt;vval.v_string;</a>
<a name="ln692">  int save_magic;</a>
<a name="ln693">  char_u      *save_cpo;</a>
<a name="ln694">  buf_T       *buf;</a>
<a name="ln695"> </a>
<a name="ln696">  if (tv-&gt;v_type == VAR_NUMBER)</a>
<a name="ln697">    return buflist_findnr((int)tv-&gt;vval.v_number);</a>
<a name="ln698">  if (tv-&gt;v_type != VAR_STRING)</a>
<a name="ln699">    return NULL;</a>
<a name="ln700">  if (name == NULL || *name == NUL)</a>
<a name="ln701">    return curbuf;</a>
<a name="ln702">  if (name[0] == '$' &amp;&amp; name[1] == NUL)</a>
<a name="ln703">    return lastbuf;</a>
<a name="ln704"> </a>
<a name="ln705">  // Ignore 'magic' and 'cpoptions' here to make scripts portable</a>
<a name="ln706">  save_magic = p_magic;</a>
<a name="ln707">  p_magic = TRUE;</a>
<a name="ln708">  save_cpo = p_cpo;</a>
<a name="ln709">  p_cpo = (char_u *)&quot;&quot;;</a>
<a name="ln710"> </a>
<a name="ln711">  buf = buflist_findnr(buflist_findpat(name, name + STRLEN(name),</a>
<a name="ln712">                                       true, false, curtab_only));</a>
<a name="ln713"> </a>
<a name="ln714">  p_magic = save_magic;</a>
<a name="ln715">  p_cpo = save_cpo;</a>
<a name="ln716"> </a>
<a name="ln717">  // If not found, try expanding the name, like done for bufexists().</a>
<a name="ln718">  if (buf == NULL) {</a>
<a name="ln719">    buf = find_buffer(tv);</a>
<a name="ln720">  }</a>
<a name="ln721"> </a>
<a name="ln722">  return buf;</a>
<a name="ln723">}</a>
<a name="ln724"> </a>
<a name="ln725">/// Like tv_get_buf() but give an error message if the type is wrong.</a>
<a name="ln726">buf_T *tv_get_buf_from_arg(typval_T *const tv) FUNC_ATTR_NONNULL_ALL</a>
<a name="ln727">{</a>
<a name="ln728">  if (!tv_check_str_or_nr(tv)) {</a>
<a name="ln729">    return NULL;</a>
<a name="ln730">  }</a>
<a name="ln731">  emsg_off++;</a>
<a name="ln732">  buf_T *const buf = tv_get_buf(tv, false);</a>
<a name="ln733">  emsg_off--;</a>
<a name="ln734">  return buf;</a>
<a name="ln735">}</a>
<a name="ln736"> </a>
<a name="ln737">/// Get the buffer from &quot;arg&quot; and give an error and return NULL if it is not</a>
<a name="ln738">/// valid.</a>
<a name="ln739">buf_T * get_buf_arg(typval_T *arg)</a>
<a name="ln740">{</a>
<a name="ln741">  buf_T *buf;</a>
<a name="ln742"> </a>
<a name="ln743">  emsg_off++;</a>
<a name="ln744">  buf = tv_get_buf(arg, false);</a>
<a name="ln745">  emsg_off--;</a>
<a name="ln746">  if (buf == NULL) {</a>
<a name="ln747">    EMSG2(_(&quot;E158: Invalid buffer name: %s&quot;), tv_get_string(arg));</a>
<a name="ln748">  }</a>
<a name="ln749">  return buf;</a>
<a name="ln750">}</a>
<a name="ln751"> </a>
<a name="ln752">/*</a>
<a name="ln753"> * &quot;byte2line(byte)&quot; function</a>
<a name="ln754"> */</a>
<a name="ln755">static void f_byte2line(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln756">{</a>
<a name="ln757">  long boff = tv_get_number(&amp;argvars[0]) - 1;</a>
<a name="ln758">  if (boff &lt; 0) {</a>
<a name="ln759">    rettv-&gt;vval.v_number = -1;</a>
<a name="ln760">  } else {</a>
<a name="ln761">    rettv-&gt;vval.v_number = (varnumber_T)ml_find_line_or_offset(curbuf, 0,</a>
<a name="ln762">                                                               &amp;boff, false);</a>
<a name="ln763">  }</a>
<a name="ln764">}</a>
<a name="ln765"> </a>
<a name="ln766">static void byteidx(typval_T *argvars, typval_T *rettv, int comp)</a>
<a name="ln767">{</a>
<a name="ln768">  const char *const str = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln769">  varnumber_T idx = tv_get_number_chk(&amp;argvars[1], NULL);</a>
<a name="ln770">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln771">  if (str == NULL || idx &lt; 0) {</a>
<a name="ln772">    return;</a>
<a name="ln773">  }</a>
<a name="ln774"> </a>
<a name="ln775">  const char *t = str;</a>
<a name="ln776">  for (; idx &gt; 0; idx--) {</a>
<a name="ln777">    if (*t == NUL) {  // EOL reached.</a>
<a name="ln778">      return;</a>
<a name="ln779">    }</a>
<a name="ln780">    if (comp) {</a>
<a name="ln781">      t += utf_ptr2len((const char_u *)t);</a>
<a name="ln782">    } else {</a>
<a name="ln783">      t += utfc_ptr2len((const char_u *)t);</a>
<a name="ln784">    }</a>
<a name="ln785">  }</a>
<a name="ln786">  rettv-&gt;vval.v_number = (varnumber_T)(t - str);</a>
<a name="ln787">}</a>
<a name="ln788"> </a>
<a name="ln789">/*</a>
<a name="ln790"> * &quot;byteidx()&quot; function</a>
<a name="ln791"> */</a>
<a name="ln792">static void f_byteidx(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln793">{</a>
<a name="ln794">  byteidx(argvars, rettv, FALSE);</a>
<a name="ln795">}</a>
<a name="ln796"> </a>
<a name="ln797">/*</a>
<a name="ln798"> * &quot;byteidxcomp()&quot; function</a>
<a name="ln799"> */</a>
<a name="ln800">static void f_byteidxcomp(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln801">{</a>
<a name="ln802">  byteidx(argvars, rettv, TRUE);</a>
<a name="ln803">}</a>
<a name="ln804"> </a>
<a name="ln805">/// &quot;call(func, arglist [, dict])&quot; function</a>
<a name="ln806">static void f_call(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln807">{</a>
<a name="ln808">  if (argvars[1].v_type != VAR_LIST) {</a>
<a name="ln809">    EMSG(_(e_listreq));</a>
<a name="ln810">    return;</a>
<a name="ln811">  }</a>
<a name="ln812">  if (argvars[1].vval.v_list == NULL) {</a>
<a name="ln813">    return;</a>
<a name="ln814">  }</a>
<a name="ln815"> </a>
<a name="ln816">  bool owned = false;</a>
<a name="ln817">  char_u      *func;</a>
<a name="ln818">  partial_T   *partial = NULL;</a>
<a name="ln819">  dict_T      *selfdict = NULL;</a>
<a name="ln820">  if (argvars[0].v_type == VAR_FUNC) {</a>
<a name="ln821">    func = argvars[0].vval.v_string;</a>
<a name="ln822">  } else if (argvars[0].v_type == VAR_PARTIAL) {</a>
<a name="ln823">    partial = argvars[0].vval.v_partial;</a>
<a name="ln824">    func = partial_name(partial);</a>
<a name="ln825">  } else if (nlua_is_table_from_lua(&amp;argvars[0])) {</a>
<a name="ln826">    func = nlua_register_table_as_callable(&amp;argvars[0]);</a>
<a name="ln827">    owned = true;</a>
<a name="ln828">  } else {</a>
<a name="ln829">    func = (char_u *)tv_get_string(&amp;argvars[0]);</a>
<a name="ln830">  }</a>
<a name="ln831"> </a>
<a name="ln832">  if (*func == NUL) {</a>
<a name="ln833">    return;             // type error or empty name</a>
<a name="ln834">  }</a>
<a name="ln835"> </a>
<a name="ln836">  if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln837">    if (argvars[2].v_type != VAR_DICT) {</a>
<a name="ln838">      EMSG(_(e_dictreq));</a>
<a name="ln839">      return;</a>
<a name="ln840">    }</a>
<a name="ln841">    selfdict = argvars[2].vval.v_dict;</a>
<a name="ln842">  }</a>
<a name="ln843"> </a>
<a name="ln844">  func_call(func, &amp;argvars[1], partial, selfdict, rettv);</a>
<a name="ln845">  if (owned) {</a>
<a name="ln846">    func_unref(func);</a>
<a name="ln847">  }</a>
<a name="ln848">}</a>
<a name="ln849"> </a>
<a name="ln850">/*</a>
<a name="ln851"> * &quot;changenr()&quot; function</a>
<a name="ln852"> */</a>
<a name="ln853">static void f_changenr(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln854">{</a>
<a name="ln855">  rettv-&gt;vval.v_number = curbuf-&gt;b_u_seq_cur;</a>
<a name="ln856">}</a>
<a name="ln857"> </a>
<a name="ln858">// &quot;chanclose(id[, stream])&quot; function</a>
<a name="ln859">static void f_chanclose(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln860">{</a>
<a name="ln861">  rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln862">  rettv-&gt;vval.v_number = 0;</a>
<a name="ln863"> </a>
<a name="ln864">  if (check_secure()) {</a>
<a name="ln865">    return;</a>
<a name="ln866">  }</a>
<a name="ln867"> </a>
<a name="ln868">  if (argvars[0].v_type != VAR_NUMBER || (argvars[1].v_type != VAR_STRING</a>
<a name="ln869">        &amp;&amp; argvars[1].v_type != VAR_UNKNOWN)) {</a>
<a name="ln870">    EMSG(_(e_invarg));</a>
<a name="ln871">    return;</a>
<a name="ln872">  }</a>
<a name="ln873"> </a>
<a name="ln874">  ChannelPart part = kChannelPartAll;</a>
<a name="ln875">  if (argvars[1].v_type == VAR_STRING) {</a>
<a name="ln876">    char *stream = (char *)argvars[1].vval.v_string;</a>
<a name="ln877">    if (!strcmp(stream, &quot;stdin&quot;)) {</a>
<a name="ln878">      part = kChannelPartStdin;</a>
<a name="ln879">    } else if (!strcmp(stream, &quot;stdout&quot;)) {</a>
<a name="ln880">      part = kChannelPartStdout;</a>
<a name="ln881">    } else if (!strcmp(stream, &quot;stderr&quot;)) {</a>
<a name="ln882">      part = kChannelPartStderr;</a>
<a name="ln883">    } else if (!strcmp(stream, &quot;rpc&quot;)) {</a>
<a name="ln884">      part = kChannelPartRpc;</a>
<a name="ln885">    } else {</a>
<a name="ln886">      EMSG2(_(&quot;Invalid channel stream \&quot;%s\&quot;&quot;), stream);</a>
<a name="ln887">      return;</a>
<a name="ln888">    }</a>
<a name="ln889">  }</a>
<a name="ln890">  const char *error;</a>
<a name="ln891">  rettv-&gt;vval.v_number = channel_close(argvars[0].vval.v_number, part, &amp;error);</a>
<a name="ln892">  if (!rettv-&gt;vval.v_number) {</a>
<a name="ln893">    EMSG(error);</a>
<a name="ln894">  }</a>
<a name="ln895">}</a>
<a name="ln896"> </a>
<a name="ln897">// &quot;chansend(id, data)&quot; function</a>
<a name="ln898">static void f_chansend(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln899">{</a>
<a name="ln900">  rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln901">  rettv-&gt;vval.v_number = 0;</a>
<a name="ln902"> </a>
<a name="ln903">  if (check_secure()) {</a>
<a name="ln904">    return;</a>
<a name="ln905">  }</a>
<a name="ln906"> </a>
<a name="ln907">  if (argvars[0].v_type != VAR_NUMBER || argvars[1].v_type == VAR_UNKNOWN) {</a>
<a name="ln908">    // First argument is the channel id and second is the data to write</a>
<a name="ln909">    EMSG(_(e_invarg));</a>
<a name="ln910">    return;</a>
<a name="ln911">  }</a>
<a name="ln912"> </a>
<a name="ln913">  ptrdiff_t input_len = 0;</a>
<a name="ln914">  char *input = save_tv_as_string(&amp;argvars[1], &amp;input_len, false);</a>
<a name="ln915">  if (!input) {</a>
<a name="ln916">    // Either the error has been handled by save_tv_as_string(),</a>
<a name="ln917">    // or there is no input to send.</a>
<a name="ln918">    return;</a>
<a name="ln919">  }</a>
<a name="ln920">  uint64_t id = argvars[0].vval.v_number;</a>
<a name="ln921">  const char *error = NULL;</a>
<a name="ln922">  rettv-&gt;vval.v_number = channel_send(id, input, input_len, true, &amp;error);</a>
<a name="ln923">  if (error) {</a>
<a name="ln924">    EMSG(error);</a>
<a name="ln925">  }</a>
<a name="ln926">}</a>
<a name="ln927"> </a>
<a name="ln928">/*</a>
<a name="ln929"> * &quot;char2nr(string)&quot; function</a>
<a name="ln930"> */</a>
<a name="ln931">static void f_char2nr(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln932">{</a>
<a name="ln933">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln934">    if (!tv_check_num(&amp;argvars[1])) {</a>
<a name="ln935">      return;</a>
<a name="ln936">    }</a>
<a name="ln937">  }</a>
<a name="ln938"> </a>
<a name="ln939">  rettv-&gt;vval.v_number = utf_ptr2char(</a>
<a name="ln940">      (const char_u *)tv_get_string(&amp;argvars[0]));</a>
<a name="ln941">}</a>
<a name="ln942"> </a>
<a name="ln943">// &quot;charidx()&quot; function</a>
<a name="ln944">static void f_charidx(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln945">{</a>
<a name="ln946">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln947"> </a>
<a name="ln948">  if (argvars[0].v_type != VAR_STRING</a>
<a name="ln949">      || argvars[1].v_type != VAR_NUMBER</a>
<a name="ln950">      || (argvars[2].v_type != VAR_UNKNOWN</a>
<a name="ln951">          &amp;&amp; argvars[2].v_type != VAR_NUMBER)) {</a>
<a name="ln952">    EMSG(_(e_invarg));</a>
<a name="ln953">    return;</a>
<a name="ln954">  }</a>
<a name="ln955"> </a>
<a name="ln956">  const char *str = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln957">  varnumber_T idx = tv_get_number_chk(&amp;argvars[1], NULL);</a>
<a name="ln958">  if (str == NULL || idx &lt; 0) {</a>
<a name="ln959">    return;</a>
<a name="ln960">  }</a>
<a name="ln961">  int countcc = 0;</a>
<a name="ln962">  if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln963">    countcc = (int)tv_get_number(&amp;argvars[2]);</a>
<a name="ln964">  }</a>
<a name="ln965">  if (countcc &lt; 0 || countcc &gt; 1) {</a>
<a name="ln966">    EMSG(_(e_invarg));</a>
<a name="ln967">    return;</a>
<a name="ln968">  }</a>
<a name="ln969"> </a>
<a name="ln970">  int (*ptr2len)(const char_u *);</a>
<a name="ln971">  if (countcc) {</a>
<a name="ln972">    ptr2len = utf_ptr2len;</a>
<a name="ln973">  } else {</a>
<a name="ln974">    ptr2len = utfc_ptr2len;</a>
<a name="ln975">  }</a>
<a name="ln976"> </a>
<a name="ln977">  const char *p;</a>
<a name="ln978">  int len;</a>
<a name="ln979">  for (p = str, len = 0; p &lt;= str + idx; len++) {</a>
<a name="ln980">    if (*p == NUL) {</a>
<a name="ln981">      return;</a>
<a name="ln982">    }</a>
<a name="ln983">    p += ptr2len((const char_u *)p);</a>
<a name="ln984">  }</a>
<a name="ln985"> </a>
<a name="ln986">  rettv-&gt;vval.v_number = len &gt; 0 ? len - 1 : 0;</a>
<a name="ln987">}</a>
<a name="ln988"> </a>
<a name="ln989">/*</a>
<a name="ln990"> * &quot;cindent(lnum)&quot; function</a>
<a name="ln991"> */</a>
<a name="ln992">static void f_cindent(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln993">{</a>
<a name="ln994">  pos_T pos;</a>
<a name="ln995">  linenr_T lnum;</a>
<a name="ln996"> </a>
<a name="ln997">  pos = curwin-&gt;w_cursor;</a>
<a name="ln998">  lnum = tv_get_lnum(argvars);</a>
<a name="ln999">  if (lnum &gt;= 1 &amp;&amp; lnum &lt;= curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln1000">    curwin-&gt;w_cursor.lnum = lnum;</a>
<a name="ln1001">    rettv-&gt;vval.v_number = get_c_indent();</a>
<a name="ln1002">    curwin-&gt;w_cursor = pos;</a>
<a name="ln1003">  } else</a>
<a name="ln1004">    rettv-&gt;vval.v_number = -1;</a>
<a name="ln1005">}</a>
<a name="ln1006"> </a>
<a name="ln1007">static win_T * get_optional_window(typval_T *argvars, int idx)</a>
<a name="ln1008">{</a>
<a name="ln1009">  win_T *win = curwin;</a>
<a name="ln1010"> </a>
<a name="ln1011">  if (argvars[idx].v_type != VAR_UNKNOWN) {</a>
<a name="ln1012">    win = find_win_by_nr_or_id(&amp;argvars[idx]);</a>
<a name="ln1013">    if (win == NULL) {</a>
<a name="ln1014">      EMSG(_(e_invalwindow));</a>
<a name="ln1015">      return NULL;</a>
<a name="ln1016">    }</a>
<a name="ln1017">  }</a>
<a name="ln1018">  return win;</a>
<a name="ln1019">}</a>
<a name="ln1020"> </a>
<a name="ln1021">/*</a>
<a name="ln1022"> * &quot;clearmatches()&quot; function</a>
<a name="ln1023"> */</a>
<a name="ln1024">static void f_clearmatches(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1025">{</a>
<a name="ln1026">  win_T *win = get_optional_window(argvars, 0);</a>
<a name="ln1027"> </a>
<a name="ln1028">  if (win != NULL) {</a>
<a name="ln1029">    clear_matches(win);</a>
<a name="ln1030">  }</a>
<a name="ln1031">}</a>
<a name="ln1032"> </a>
<a name="ln1033">/*</a>
<a name="ln1034"> * &quot;col(string)&quot; function</a>
<a name="ln1035"> */</a>
<a name="ln1036">static void f_col(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1037">{</a>
<a name="ln1038">  colnr_T col = 0;</a>
<a name="ln1039">  pos_T       *fp;</a>
<a name="ln1040">  int fnum = curbuf-&gt;b_fnum;</a>
<a name="ln1041"> </a>
<a name="ln1042">  fp = var2fpos(&amp;argvars[0], FALSE, &amp;fnum);</a>
<a name="ln1043">  if (fp != NULL &amp;&amp; fnum == curbuf-&gt;b_fnum) {</a>
<a name="ln1044">    if (fp-&gt;col == MAXCOL) {</a>
<a name="ln1045">      // '&gt; can be MAXCOL, get the length of the line then</a>
<a name="ln1046">      if (fp-&gt;lnum &lt;= curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln1047">        col = (colnr_T)STRLEN(ml_get(fp-&gt;lnum)) + 1;</a>
<a name="ln1048">      } else {</a>
<a name="ln1049">        col = MAXCOL;</a>
<a name="ln1050">      }</a>
<a name="ln1051">    } else {</a>
<a name="ln1052">      col = fp-&gt;col + 1;</a>
<a name="ln1053">      // col(&quot;.&quot;) when the cursor is on the NUL at the end of the line</a>
<a name="ln1054">      // because of &quot;coladd&quot; can be seen as an extra column.</a>
<a name="ln1055">      if (virtual_active() &amp;&amp; fp == &amp;curwin-&gt;w_cursor) {</a>
<a name="ln1056">        char_u  *p = get_cursor_pos_ptr();</a>
<a name="ln1057"> </a>
<a name="ln1058">        if (curwin-&gt;w_cursor.coladd &gt;= (colnr_T)chartabsize(p,</a>
<a name="ln1059">                curwin-&gt;w_virtcol - curwin-&gt;w_cursor.coladd)) {</a>
<a name="ln1060">          int l;</a>
<a name="ln1061"> </a>
<a name="ln1062">          if (*p != NUL &amp;&amp; p[(l = (*mb_ptr2len)(p))] == NUL)</a>
<a name="ln1063">            col += l;</a>
<a name="ln1064">        }</a>
<a name="ln1065">      }</a>
<a name="ln1066">    }</a>
<a name="ln1067">  }</a>
<a name="ln1068">  rettv-&gt;vval.v_number = col;</a>
<a name="ln1069">}</a>
<a name="ln1070"> </a>
<a name="ln1071">/*</a>
<a name="ln1072"> * &quot;complete()&quot; function</a>
<a name="ln1073"> */</a>
<a name="ln1074">static void f_complete(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1075">{</a>
<a name="ln1076">  if ((State &amp; INSERT) == 0) {</a>
<a name="ln1077">    EMSG(_(&quot;E785: complete() can only be used in Insert mode&quot;));</a>
<a name="ln1078">    return;</a>
<a name="ln1079">  }</a>
<a name="ln1080"> </a>
<a name="ln1081">  // Check for undo allowed here, because if something was already inserted</a>
<a name="ln1082">  // the line was already saved for undo and this check isn't done.</a>
<a name="ln1083">  if (!undo_allowed(curbuf)) {</a>
<a name="ln1084">    return;</a>
<a name="ln1085">  }</a>
<a name="ln1086"> </a>
<a name="ln1087">  if (argvars[1].v_type != VAR_LIST) {</a>
<a name="ln1088">    EMSG(_(e_invarg));</a>
<a name="ln1089">    return;</a>
<a name="ln1090">  }</a>
<a name="ln1091"> </a>
<a name="ln1092">  const colnr_T startcol = tv_get_number_chk(&amp;argvars[0], NULL);</a>
<a name="ln1093">  if (startcol &lt;= 0) {</a>
<a name="ln1094">    return;</a>
<a name="ln1095">  }</a>
<a name="ln1096"> </a>
<a name="ln1097">  set_completion(startcol - 1, argvars[1].vval.v_list);</a>
<a name="ln1098">}</a>
<a name="ln1099"> </a>
<a name="ln1100">/*</a>
<a name="ln1101"> * &quot;complete_add()&quot; function</a>
<a name="ln1102"> */</a>
<a name="ln1103">static void f_complete_add(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1104">{</a>
<a name="ln1105">  rettv-&gt;vval.v_number = ins_compl_add_tv(&amp;argvars[0], 0, false);</a>
<a name="ln1106">}</a>
<a name="ln1107"> </a>
<a name="ln1108">/*</a>
<a name="ln1109"> * &quot;complete_check()&quot; function</a>
<a name="ln1110"> */</a>
<a name="ln1111">static void f_complete_check(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1112">{</a>
<a name="ln1113">  int saved = RedrawingDisabled;</a>
<a name="ln1114"> </a>
<a name="ln1115">  RedrawingDisabled = 0;</a>
<a name="ln1116">  ins_compl_check_keys(0, true);</a>
<a name="ln1117">  rettv-&gt;vval.v_number = compl_interrupted;</a>
<a name="ln1118">  RedrawingDisabled = saved;</a>
<a name="ln1119">}</a>
<a name="ln1120"> </a>
<a name="ln1121">// &quot;complete_info()&quot; function</a>
<a name="ln1122">static void f_complete_info(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1123">{</a>
<a name="ln1124">  tv_dict_alloc_ret(rettv);</a>
<a name="ln1125"> </a>
<a name="ln1126">  list_T *what_list = NULL;</a>
<a name="ln1127"> </a>
<a name="ln1128">  if (argvars[0].v_type != VAR_UNKNOWN) {</a>
<a name="ln1129">    if (argvars[0].v_type != VAR_LIST) {</a>
<a name="ln1130">      EMSG(_(e_listreq));</a>
<a name="ln1131">      return;</a>
<a name="ln1132">    }</a>
<a name="ln1133">    what_list = argvars[0].vval.v_list;</a>
<a name="ln1134">  }</a>
<a name="ln1135">  get_complete_info(what_list, rettv-&gt;vval.v_dict);</a>
<a name="ln1136">}</a>
<a name="ln1137"> </a>
<a name="ln1138">/*</a>
<a name="ln1139"> * &quot;confirm(message, buttons[, default [, type]])&quot; function</a>
<a name="ln1140"> */</a>
<a name="ln1141">static void f_confirm(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1142">{</a>
<a name="ln1143">  char buf[NUMBUFLEN];</a>
<a name="ln1144">  char buf2[NUMBUFLEN];</a>
<a name="ln1145">  const char *message;</a>
<a name="ln1146">  const char *buttons = NULL;</a>
<a name="ln1147">  int def = 1;</a>
<a name="ln1148">  int type = VIM_GENERIC;</a>
<a name="ln1149">  const char *typestr;</a>
<a name="ln1150">  bool error = false;</a>
<a name="ln1151"> </a>
<a name="ln1152">  message = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln1153">  if (message == NULL) {</a>
<a name="ln1154">    error = true;</a>
<a name="ln1155">  }</a>
<a name="ln1156">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln1157">    buttons = tv_get_string_buf_chk(&amp;argvars[1], buf);</a>
<a name="ln1158">    if (buttons == NULL) {</a>
<a name="ln1159">      error = true;</a>
<a name="ln1160">    }</a>
<a name="ln1161">    if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln1162">      def = tv_get_number_chk(&amp;argvars[2], &amp;error);</a>
<a name="ln1163">      if (argvars[3].v_type != VAR_UNKNOWN) {</a>
<a name="ln1164">        typestr = tv_get_string_buf_chk(&amp;argvars[3], buf2);</a>
<a name="ln1165">        if (typestr == NULL) {</a>
<a name="ln1166">          error = true;</a>
<a name="ln1167">        } else {</a>
<a name="ln1168">          switch (TOUPPER_ASC(*typestr)) {</a>
<a name="ln1169">            case 'E': type = VIM_ERROR; break;</a>
<a name="ln1170">            case 'Q': type = VIM_QUESTION; break;</a>
<a name="ln1171">            case 'I': type = VIM_INFO; break;</a>
<a name="ln1172">            case 'W': type = VIM_WARNING; break;</a>
<a name="ln1173">            case 'G': type = VIM_GENERIC; break;</a>
<a name="ln1174">          }</a>
<a name="ln1175">        }</a>
<a name="ln1176">      }</a>
<a name="ln1177">    }</a>
<a name="ln1178">  }</a>
<a name="ln1179"> </a>
<a name="ln1180">  if (buttons == NULL || *buttons == NUL) {</a>
<a name="ln1181">    buttons = _(&quot;&amp;Ok&quot;);</a>
<a name="ln1182">  }</a>
<a name="ln1183"> </a>
<a name="ln1184">  if (!error) {</a>
<a name="ln1185">    rettv-&gt;vval.v_number = do_dialog(</a>
<a name="ln1186">        type, NULL, (char_u *)message, (char_u *)buttons, def, NULL, false);</a>
<a name="ln1187">  }</a>
<a name="ln1188">}</a>
<a name="ln1189"> </a>
<a name="ln1190">/*</a>
<a name="ln1191"> * &quot;copy()&quot; function</a>
<a name="ln1192"> */</a>
<a name="ln1193">static void f_copy(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1194">{</a>
<a name="ln1195">  var_item_copy(NULL, &amp;argvars[0], rettv, false, 0);</a>
<a name="ln1196">}</a>
<a name="ln1197"> </a>
<a name="ln1198">/*</a>
<a name="ln1199"> * &quot;count()&quot; function</a>
<a name="ln1200"> */</a>
<a name="ln1201">static void f_count(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1202">{</a>
<a name="ln1203">  long n = 0;</a>
<a name="ln1204">  int ic = 0;</a>
<a name="ln1205">  bool error = false;</a>
<a name="ln1206"> </a>
<a name="ln1207">  if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln1208">    ic = tv_get_number_chk(&amp;argvars[2], &amp;error);</a>
<a name="ln1209">  }</a>
<a name="ln1210"> </a>
<a name="ln1211">  if (argvars[0].v_type == VAR_STRING) {</a>
<a name="ln1212">    const char_u *expr = (char_u *)tv_get_string_chk(&amp;argvars[1]);</a>
<a name="ln1213">    const char_u *p = argvars[0].vval.v_string;</a>
<a name="ln1214"> </a>
<a name="ln1215">    if (!error &amp;&amp; expr != NULL &amp;&amp; *expr != NUL &amp;&amp; p != NULL) {</a>
<a name="ln1216">      if (ic) {</a>
<a name="ln1217">        const size_t len = STRLEN(expr);</a>
<a name="ln1218"> </a>
<a name="ln1219">        while (*p != NUL) {</a>
<a name="ln1220">          if (mb_strnicmp(p, expr, len) == 0) {</a>
<a name="ln1221">            n++;</a>
<a name="ln1222">            p += len;</a>
<a name="ln1223">          } else {</a>
<a name="ln1224">            MB_PTR_ADV(p);</a>
<a name="ln1225">          }</a>
<a name="ln1226">        }</a>
<a name="ln1227">      } else {</a>
<a name="ln1228">        char_u *next;</a>
<a name="ln1229">        while ((next = (char_u *)strstr((char *)p, (char *)expr)) != NULL) {</a>
<a name="ln1230">          n++;</a>
<a name="ln1231">          p = next + STRLEN(expr);</a>
<a name="ln1232">        }</a>
<a name="ln1233">      }</a>
<a name="ln1234">    }</a>
<a name="ln1235">  } else if (argvars[0].v_type == VAR_LIST) {</a>
<a name="ln1236">    listitem_T      *li;</a>
<a name="ln1237">    list_T          *l;</a>
<a name="ln1238">    long idx;</a>
<a name="ln1239"> </a>
<a name="ln1240">    if ((l = argvars[0].vval.v_list) != NULL) {</a>
<a name="ln1241">      li = tv_list_first(l);</a>
<a name="ln1242">      if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln1243">        if (argvars[3].v_type != VAR_UNKNOWN) {</a>
<a name="ln1244">          idx = tv_get_number_chk(&amp;argvars[3], &amp;error);</a>
<a name="ln1245">          if (!error) {</a>
<a name="ln1246">            li = tv_list_find(l, idx);</a>
<a name="ln1247">            if (li == NULL) {</a>
<a name="ln1248">              EMSGN(_(e_listidx), idx);</a>
<a name="ln1249">            }</a>
<a name="ln1250">          }</a>
<a name="ln1251">        }</a>
<a name="ln1252">        if (error)</a>
<a name="ln1253">          li = NULL;</a>
<a name="ln1254">      }</a>
<a name="ln1255"> </a>
<a name="ln1256">      for (; li != NULL; li = TV_LIST_ITEM_NEXT(l, li)) {</a>
<a name="ln1257">        if (tv_equal(TV_LIST_ITEM_TV(li), &amp;argvars[1], ic, false)) {</a>
<a name="ln1258">          n++;</a>
<a name="ln1259">        }</a>
<a name="ln1260">      }</a>
<a name="ln1261">    }</a>
<a name="ln1262">  } else if (argvars[0].v_type == VAR_DICT) {</a>
<a name="ln1263">    int todo;</a>
<a name="ln1264">    dict_T          *d;</a>
<a name="ln1265">    hashitem_T      *hi;</a>
<a name="ln1266"> </a>
<a name="ln1267">    if ((d = argvars[0].vval.v_dict) != NULL) {</a>
<a name="ln1268">      if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln1269">        if (argvars[3].v_type != VAR_UNKNOWN) {</a>
<a name="ln1270">          EMSG(_(e_invarg));</a>
<a name="ln1271">        }</a>
<a name="ln1272">      }</a>
<a name="ln1273"> </a>
<a name="ln1274">      todo = error ? 0 : (int)d-&gt;dv_hashtab.ht_used;</a>
<a name="ln1275">      for (hi = d-&gt;dv_hashtab.ht_array; todo &gt; 0; ++hi) {</a>
<a name="ln1276">        if (!HASHITEM_EMPTY(hi)) {</a>
<a name="ln1277">          todo--;</a>
<a name="ln1278">          if (tv_equal(&amp;TV_DICT_HI2DI(hi)-&gt;di_tv, &amp;argvars[1], ic, false)) {</a>
<a name="ln1279">            n++;</a>
<a name="ln1280">          }</a>
<a name="ln1281">        }</a>
<a name="ln1282">      }</a>
<a name="ln1283">    }</a>
<a name="ln1284">  } else {</a>
<a name="ln1285">    EMSG2(_(e_listdictarg), &quot;count()&quot;);</a>
<a name="ln1286">  }</a>
<a name="ln1287">  rettv-&gt;vval.v_number = n;</a>
<a name="ln1288">}</a>
<a name="ln1289"> </a>
<a name="ln1290">/*</a>
<a name="ln1291"> * &quot;cscope_connection([{num} , {dbpath} [, {prepend}]])&quot; function</a>
<a name="ln1292"> *</a>
<a name="ln1293"> * Checks the existence of a cscope connection.</a>
<a name="ln1294"> */</a>
<a name="ln1295">static void f_cscope_connection(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1296">{</a>
<a name="ln1297">  int num = 0;</a>
<a name="ln1298">  const char *dbpath = NULL;</a>
<a name="ln1299">  const char *prepend = NULL;</a>
<a name="ln1300">  char buf[NUMBUFLEN];</a>
<a name="ln1301"> </a>
<a name="ln1302">  if (argvars[0].v_type != VAR_UNKNOWN</a>
<a name="ln1303">      &amp;&amp; argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln1304">    num = (int)tv_get_number(&amp;argvars[0]);</a>
<a name="ln1305">    dbpath = tv_get_string(&amp;argvars[1]);</a>
<a name="ln1306">    if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln1307">      prepend = tv_get_string_buf(&amp;argvars[2], buf);</a>
<a name="ln1308">    }</a>
<a name="ln1309">  }</a>
<a name="ln1310"> </a>
<a name="ln1311">  rettv-&gt;vval.v_number = cs_connection(num, (char_u *)dbpath,</a>
<a name="ln1312">                                       (char_u *)prepend);</a>
<a name="ln1313">}</a>
<a name="ln1314"> </a>
<a name="ln1315">/// &quot;ctxget([{index}])&quot; function</a>
<a name="ln1316">static void f_ctxget(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1317">{</a>
<a name="ln1318">  size_t index = 0;</a>
<a name="ln1319">  if (argvars[0].v_type == VAR_NUMBER) {</a>
<a name="ln1320">    index = argvars[0].vval.v_number;</a>
<a name="ln1321">  } else if (argvars[0].v_type != VAR_UNKNOWN) {</a>
<a name="ln1322">    EMSG2(_(e_invarg2), &quot;expected nothing or a Number as an argument&quot;);</a>
<a name="ln1323">    return;</a>
<a name="ln1324">  }</a>
<a name="ln1325"> </a>
<a name="ln1326">  Context *ctx = ctx_get(index);</a>
<a name="ln1327">  if (ctx == NULL) {</a>
<a name="ln1328">    EMSG3(_(e_invargNval), &quot;index&quot;, &quot;out of bounds&quot;);</a>
<a name="ln1329">    return;</a>
<a name="ln1330">  }</a>
<a name="ln1331"> </a>
<a name="ln1332">  Dictionary ctx_dict = ctx_to_dict(ctx);</a>
<a name="ln1333">  Error err = ERROR_INIT;</a>
<a name="ln1334">  object_to_vim(DICTIONARY_OBJ(ctx_dict), rettv, &amp;err);</a>
<a name="ln1335">  api_free_dictionary(ctx_dict);</a>
<a name="ln1336">  api_clear_error(&amp;err);</a>
<a name="ln1337">}</a>
<a name="ln1338"> </a>
<a name="ln1339">/// &quot;ctxpop()&quot; function</a>
<a name="ln1340">static void f_ctxpop(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1341">{</a>
<a name="ln1342">  if (!ctx_restore(NULL, kCtxAll)) {</a>
<a name="ln1343">    EMSG(_(&quot;Context stack is empty&quot;));</a>
<a name="ln1344">  }</a>
<a name="ln1345">}</a>
<a name="ln1346"> </a>
<a name="ln1347">/// &quot;ctxpush([{types}])&quot; function</a>
<a name="ln1348">static void f_ctxpush(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1349">{</a>
<a name="ln1350">  int types = kCtxAll;</a>
<a name="ln1351">  if (argvars[0].v_type == VAR_LIST) {</a>
<a name="ln1352">    types = 0;</a>
<a name="ln1353">    TV_LIST_ITER(argvars[0].vval.v_list, li, {</a>
<a name="ln1354">      typval_T *tv_li = TV_LIST_ITEM_TV(li);</a>
<a name="ln1355">      if (tv_li-&gt;v_type == VAR_STRING) {</a>
<a name="ln1356">        if (strequal((char *)tv_li-&gt;vval.v_string, &quot;regs&quot;)) {</a>
<a name="ln1357">          types |= kCtxRegs;</a>
<a name="ln1358">        } else if (strequal((char *)tv_li-&gt;vval.v_string, &quot;jumps&quot;)) {</a>
<a name="ln1359">          types |= kCtxJumps;</a>
<a name="ln1360">        } else if (strequal((char *)tv_li-&gt;vval.v_string, &quot;bufs&quot;)) {</a>
<a name="ln1361">          types |= kCtxBufs;</a>
<a name="ln1362">        } else if (strequal((char *)tv_li-&gt;vval.v_string, &quot;gvars&quot;)) {</a>
<a name="ln1363">          types |= kCtxGVars;</a>
<a name="ln1364">        } else if (strequal((char *)tv_li-&gt;vval.v_string, &quot;sfuncs&quot;)) {</a>
<a name="ln1365">          types |= kCtxSFuncs;</a>
<a name="ln1366">        } else if (strequal((char *)tv_li-&gt;vval.v_string, &quot;funcs&quot;)) {</a>
<a name="ln1367">          types |= kCtxFuncs;</a>
<a name="ln1368">        }</a>
<a name="ln1369">      }</a>
<a name="ln1370">    });</a>
<a name="ln1371">  } else if (argvars[0].v_type != VAR_UNKNOWN) {</a>
<a name="ln1372">    EMSG2(_(e_invarg2), &quot;expected nothing or a List as an argument&quot;);</a>
<a name="ln1373">    return;</a>
<a name="ln1374">  }</a>
<a name="ln1375">  ctx_save(NULL, types);</a>
<a name="ln1376">}</a>
<a name="ln1377"> </a>
<a name="ln1378">/// &quot;ctxset({context}[, {index}])&quot; function</a>
<a name="ln1379">static void f_ctxset(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1380">{</a>
<a name="ln1381">  if (argvars[0].v_type != VAR_DICT) {</a>
<a name="ln1382">    EMSG2(_(e_invarg2), &quot;expected dictionary as first argument&quot;);</a>
<a name="ln1383">    return;</a>
<a name="ln1384">  }</a>
<a name="ln1385"> </a>
<a name="ln1386">  size_t index = 0;</a>
<a name="ln1387">  if (argvars[1].v_type == VAR_NUMBER) {</a>
<a name="ln1388">    index = argvars[1].vval.v_number;</a>
<a name="ln1389">  } else if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln1390">    EMSG2(_(e_invarg2), &quot;expected nothing or a Number as second argument&quot;);</a>
<a name="ln1391">    return;</a>
<a name="ln1392">  }</a>
<a name="ln1393"> </a>
<a name="ln1394">  Context *ctx = ctx_get(index);</a>
<a name="ln1395">  if (ctx == NULL) {</a>
<a name="ln1396">    EMSG3(_(e_invargNval), &quot;index&quot;, &quot;out of bounds&quot;);</a>
<a name="ln1397">    return;</a>
<a name="ln1398">  }</a>
<a name="ln1399"> </a>
<a name="ln1400">  int save_did_emsg = did_emsg;</a>
<a name="ln1401">  did_emsg = false;</a>
<a name="ln1402"> </a>
<a name="ln1403">  Dictionary dict = vim_to_object(&amp;argvars[0]).data.dictionary;</a>
<a name="ln1404">  Context tmp = CONTEXT_INIT;</a>
<a name="ln1405">  ctx_from_dict(dict, &amp;tmp);</a>
<a name="ln1406"> </a>
<a name="ln1407">  if (did_emsg) {</a>
<a name="ln1408">    ctx_free(&amp;tmp);</a>
<a name="ln1409">  } else {</a>
<a name="ln1410">    ctx_free(ctx);</a>
<a name="ln1411">    *ctx = tmp;</a>
<a name="ln1412">  }</a>
<a name="ln1413"> </a>
<a name="ln1414">  api_free_dictionary(dict);</a>
<a name="ln1415">  did_emsg = save_did_emsg;</a>
<a name="ln1416">}</a>
<a name="ln1417"> </a>
<a name="ln1418">/// &quot;ctxsize()&quot; function</a>
<a name="ln1419">static void f_ctxsize(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1420">{</a>
<a name="ln1421">  rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln1422">  rettv-&gt;vval.v_number = ctx_size();</a>
<a name="ln1423">}</a>
<a name="ln1424"> </a>
<a name="ln1425">/// &quot;cursor(lnum, col)&quot; function, or</a>
<a name="ln1426">/// &quot;cursor(list)&quot;</a>
<a name="ln1427">///</a>
<a name="ln1428">/// Moves the cursor to the specified line and column.</a>
<a name="ln1429">///</a>
<a name="ln1430">/// @returns 0 when the position could be set, -1 otherwise.</a>
<a name="ln1431">static void f_cursor(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1432">{</a>
<a name="ln1433">  long line, col;</a>
<a name="ln1434">  long coladd = 0;</a>
<a name="ln1435">  bool set_curswant = true;</a>
<a name="ln1436"> </a>
<a name="ln1437">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln1438">  if (argvars[1].v_type == VAR_UNKNOWN) {</a>
<a name="ln1439">    pos_T pos;</a>
<a name="ln1440">    colnr_T curswant = -1;</a>
<a name="ln1441"> </a>
<a name="ln1442">    if (list2fpos(argvars, &amp;pos, NULL, &amp;curswant) == FAIL) {</a>
<a name="ln1443">      EMSG(_(e_invarg));</a>
<a name="ln1444">      return;</a>
<a name="ln1445">    }</a>
<a name="ln1446"> </a>
<a name="ln1447">    line = pos.lnum;</a>
<a name="ln1448">    col = pos.col;</a>
<a name="ln1449">    coladd = pos.coladd;</a>
<a name="ln1450">    if (curswant &gt;= 0) {</a>
<a name="ln1451">      curwin-&gt;w_curswant = curswant - 1;</a>
<a name="ln1452">      set_curswant = false;</a>
<a name="ln1453">    }</a>
<a name="ln1454">  } else {</a>
<a name="ln1455">    line = tv_get_lnum(argvars);</a>
<a name="ln1456">    col = (long)tv_get_number_chk(&amp;argvars[1], NULL);</a>
<a name="ln1457">    if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln1458">      coladd = (long)tv_get_number_chk(&amp;argvars[2], NULL);</a>
<a name="ln1459">    }</a>
<a name="ln1460">  }</a>
<a name="ln1461">  if (line &lt; 0 || col &lt; 0</a>
<a name="ln1462">      || coladd &lt; 0) {</a>
<a name="ln1463">    return;             // type error; errmsg already given</a>
<a name="ln1464">  }</a>
<a name="ln1465">  if (line &gt; 0) {</a>
<a name="ln1466">    curwin-&gt;w_cursor.lnum = line;</a>
<a name="ln1467">  }</a>
<a name="ln1468">  if (col &gt; 0) {</a>
<a name="ln1469">    curwin-&gt;w_cursor.col = col - 1;</a>
<a name="ln1470">  }</a>
<a name="ln1471">  curwin-&gt;w_cursor.coladd = coladd;</a>
<a name="ln1472"> </a>
<a name="ln1473">  // Make sure the cursor is in a valid position.</a>
<a name="ln1474">  check_cursor();</a>
<a name="ln1475">  // Correct cursor for multi-byte character.</a>
<a name="ln1476">  mb_adjust_cursor();</a>
<a name="ln1477"> </a>
<a name="ln1478">  curwin-&gt;w_set_curswant = set_curswant;</a>
<a name="ln1479">  rettv-&gt;vval.v_number = 0;</a>
<a name="ln1480">}</a>
<a name="ln1481"> </a>
<a name="ln1482">// &quot;debugbreak()&quot; function</a>
<a name="ln1483">static void f_debugbreak(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1484">{</a>
<a name="ln1485">  int pid;</a>
<a name="ln1486"> </a>
<a name="ln1487">  rettv-&gt;vval.v_number = FAIL;</a>
<a name="ln1488">  pid = (int)tv_get_number(&amp;argvars[0]);</a>
<a name="ln1489">  if (pid == 0) {</a>
<a name="ln1490">    EMSG(_(e_invarg));</a>
<a name="ln1491">  } else {</a>
<a name="ln1492">#ifdef WIN32</a>
<a name="ln1493">    HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, 0, pid);</a>
<a name="ln1494"> </a>
<a name="ln1495">    if (hProcess != NULL) {</a>
<a name="ln1496">      DebugBreakProcess(hProcess);</a>
<a name="ln1497">      CloseHandle(hProcess);</a>
<a name="ln1498">      rettv-&gt;vval.v_number = OK;</a>
<a name="ln1499">    }</a>
<a name="ln1500">#else</a>
<a name="ln1501">    uv_kill(pid, SIGINT);</a>
<a name="ln1502">#endif</a>
<a name="ln1503">  }</a>
<a name="ln1504">}</a>
<a name="ln1505"> </a>
<a name="ln1506">// &quot;deepcopy()&quot; function</a>
<a name="ln1507">static void f_deepcopy(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1508">{</a>
<a name="ln1509">  int noref = 0;</a>
<a name="ln1510"> </a>
<a name="ln1511">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln1512">    noref = tv_get_number_chk(&amp;argvars[1], NULL);</a>
<a name="ln1513">  }</a>
<a name="ln1514">  if (noref &lt; 0 || noref &gt; 1) {</a>
<a name="ln1515">    EMSG(_(e_invarg));</a>
<a name="ln1516">  } else {</a>
<a name="ln1517">    var_item_copy(NULL, &amp;argvars[0], rettv, true, (noref == 0</a>
<a name="ln1518">                                                   ? get_copyID()</a>
<a name="ln1519">                                                   : 0));</a>
<a name="ln1520">  }</a>
<a name="ln1521">}</a>
<a name="ln1522"> </a>
<a name="ln1523">// &quot;delete()&quot; function</a>
<a name="ln1524">static void f_delete(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1525">{</a>
<a name="ln1526">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln1527">  if (check_secure()) {</a>
<a name="ln1528">    return;</a>
<a name="ln1529">  }</a>
<a name="ln1530"> </a>
<a name="ln1531">  const char *const name = tv_get_string(&amp;argvars[0]);</a>
<a name="ln1532">  if (*name == NUL) {</a>
<a name="ln1533">    EMSG(_(e_invarg));</a>
<a name="ln1534">    return;</a>
<a name="ln1535">  }</a>
<a name="ln1536"> </a>
<a name="ln1537">  char nbuf[NUMBUFLEN];</a>
<a name="ln1538">  const char *flags;</a>
<a name="ln1539">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln1540">    flags = tv_get_string_buf(&amp;argvars[1], nbuf);</a>
<a name="ln1541">  } else {</a>
<a name="ln1542">    flags = &quot;&quot;;</a>
<a name="ln1543">  }</a>
<a name="ln1544"> </a>
<a name="ln1545">  if (*flags == NUL) {</a>
<a name="ln1546">    // delete a file</a>
<a name="ln1547">    rettv-&gt;vval.v_number = os_remove(name) == 0 ? 0 : -1;</a>
<a name="ln1548">  } else if (strcmp(flags, &quot;d&quot;) == 0) {</a>
<a name="ln1549">    // delete an empty directory</a>
<a name="ln1550">    rettv-&gt;vval.v_number = os_rmdir(name) == 0 ? 0 : -1;</a>
<a name="ln1551">  } else if (strcmp(flags, &quot;rf&quot;) == 0) {</a>
<a name="ln1552">    // delete a directory recursively</a>
<a name="ln1553">    rettv-&gt;vval.v_number = delete_recursive(name);</a>
<a name="ln1554">  } else {</a>
<a name="ln1555">    emsgf(_(e_invexpr2), flags);</a>
<a name="ln1556">  }</a>
<a name="ln1557">}</a>
<a name="ln1558"> </a>
<a name="ln1559">// dictwatcheradd(dict, key, funcref) function</a>
<a name="ln1560">static void f_dictwatcheradd(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1561">{</a>
<a name="ln1562">  if (check_secure()) {</a>
<a name="ln1563">    return;</a>
<a name="ln1564">  }</a>
<a name="ln1565"> </a>
<a name="ln1566">  if (argvars[0].v_type != VAR_DICT) {</a>
<a name="ln1567">    emsgf(_(e_invarg2), &quot;dict&quot;);</a>
<a name="ln1568">    return;</a>
<a name="ln1569">  } else if (argvars[0].vval.v_dict == NULL) {</a>
<a name="ln1570">    const char *const arg_errmsg = _(&quot;dictwatcheradd() argument&quot;);</a>
<a name="ln1571">    const size_t arg_errmsg_len = strlen(arg_errmsg);</a>
<a name="ln1572">    emsgf(_(e_readonlyvar), (int)arg_errmsg_len, arg_errmsg);</a>
<a name="ln1573">    return;</a>
<a name="ln1574">  }</a>
<a name="ln1575"> </a>
<a name="ln1576">  if (argvars[1].v_type != VAR_STRING &amp;&amp; argvars[1].v_type != VAR_NUMBER) {</a>
<a name="ln1577">    emsgf(_(e_invarg2), &quot;key&quot;);</a>
<a name="ln1578">    return;</a>
<a name="ln1579">  }</a>
<a name="ln1580"> </a>
<a name="ln1581">  const char *const key_pattern = tv_get_string_chk(argvars + 1);</a>
<a name="ln1582">  if (key_pattern == NULL) {</a>
<a name="ln1583">    return;</a>
<a name="ln1584">  }</a>
<a name="ln1585">  const size_t key_pattern_len = strlen(key_pattern);</a>
<a name="ln1586"> </a>
<a name="ln1587">  Callback callback;</a>
<a name="ln1588">  if (!callback_from_typval(&amp;callback, &amp;argvars[2])) {</a>
<a name="ln1589">    emsgf(_(e_invarg2), &quot;funcref&quot;);</a>
<a name="ln1590">    return;</a>
<a name="ln1591">  }</a>
<a name="ln1592"> </a>
<a name="ln1593">  tv_dict_watcher_add(argvars[0].vval.v_dict, key_pattern, key_pattern_len,</a>
<a name="ln1594">                      callback);</a>
<a name="ln1595">}</a>
<a name="ln1596"> </a>
<a name="ln1597">// dictwatcherdel(dict, key, funcref) function</a>
<a name="ln1598">static void f_dictwatcherdel(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1599">{</a>
<a name="ln1600">  if (check_secure()) {</a>
<a name="ln1601">    return;</a>
<a name="ln1602">  }</a>
<a name="ln1603"> </a>
<a name="ln1604">  if (argvars[0].v_type != VAR_DICT) {</a>
<a name="ln1605">    emsgf(_(e_invarg2), &quot;dict&quot;);</a>
<a name="ln1606">    return;</a>
<a name="ln1607">  }</a>
<a name="ln1608"> </a>
<a name="ln1609">  if (argvars[2].v_type != VAR_FUNC &amp;&amp; argvars[2].v_type != VAR_STRING) {</a>
<a name="ln1610">    emsgf(_(e_invarg2), &quot;funcref&quot;);</a>
<a name="ln1611">    return;</a>
<a name="ln1612">  }</a>
<a name="ln1613"> </a>
<a name="ln1614">  const char *const key_pattern = tv_get_string_chk(argvars + 1);</a>
<a name="ln1615">  if (key_pattern == NULL) {</a>
<a name="ln1616">    return;</a>
<a name="ln1617">  }</a>
<a name="ln1618"> </a>
<a name="ln1619">  Callback callback;</a>
<a name="ln1620">  if (!callback_from_typval(&amp;callback, &amp;argvars[2])) {</a>
<a name="ln1621">    return;</a>
<a name="ln1622">  }</a>
<a name="ln1623"> </a>
<a name="ln1624">  if (!tv_dict_watcher_remove(argvars[0].vval.v_dict, key_pattern,</a>
<a name="ln1625">                              strlen(key_pattern), callback)) {</a>
<a name="ln1626">    EMSG(&quot;Couldn't find a watcher matching key and callback&quot;);</a>
<a name="ln1627">  }</a>
<a name="ln1628"> </a>
<a name="ln1629">  callback_free(&amp;callback);</a>
<a name="ln1630">}</a>
<a name="ln1631"> </a>
<a name="ln1632">/// &quot;deletebufline()&quot; function</a>
<a name="ln1633">static void f_deletebufline(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1634">{</a>
<a name="ln1635">  linenr_T last;</a>
<a name="ln1636">  buf_T *curbuf_save = NULL;</a>
<a name="ln1637">  win_T *curwin_save = NULL;</a>
<a name="ln1638"> </a>
<a name="ln1639">  buf_T *const buf = tv_get_buf(&amp;argvars[0], false);</a>
<a name="ln1640">  if (buf == NULL) {</a>
<a name="ln1641">    rettv-&gt;vval.v_number = 1;  // FAIL</a>
<a name="ln1642">    return;</a>
<a name="ln1643">  }</a>
<a name="ln1644">  const bool is_curbuf = buf == curbuf;</a>
<a name="ln1645"> </a>
<a name="ln1646">  const linenr_T first = tv_get_lnum_buf(&amp;argvars[1], buf);</a>
<a name="ln1647">  if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln1648">    last = tv_get_lnum_buf(&amp;argvars[2], buf);</a>
<a name="ln1649">  } else {</a>
<a name="ln1650">    last = first;</a>
<a name="ln1651">  }</a>
<a name="ln1652"> </a>
<a name="ln1653">  if (buf-&gt;b_ml.ml_mfp == NULL || first &lt; 1</a>
<a name="ln1654">      || first &gt; buf-&gt;b_ml.ml_line_count || last &lt; first) {</a>
<a name="ln1655">    rettv-&gt;vval.v_number = 1;  // FAIL</a>
<a name="ln1656">    return;</a>
<a name="ln1657">  }</a>
<a name="ln1658"> </a>
<a name="ln1659">  if (!is_curbuf) {</a>
<a name="ln1660">    curbuf_save = curbuf;</a>
<a name="ln1661">    curwin_save = curwin;</a>
<a name="ln1662">    curbuf = buf;</a>
<a name="ln1663">    find_win_for_curbuf();</a>
<a name="ln1664">  }</a>
<a name="ln1665">  if (last &gt; curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln1666">    last = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln1667">  }</a>
<a name="ln1668">  const long count = last - first + 1;</a>
<a name="ln1669"> </a>
<a name="ln1670">  // When coming here from Insert mode, sync undo, so that this can be</a>
<a name="ln1671">  // undone separately from what was previously inserted.</a>
<a name="ln1672">  if (u_sync_once == 2) {</a>
<a name="ln1673">    u_sync_once = 1;  // notify that u_sync() was called</a>
<a name="ln1674">    u_sync(true);</a>
<a name="ln1675">  }</a>
<a name="ln1676"> </a>
<a name="ln1677">  if (u_save(first - 1, last + 1) == FAIL) {</a>
<a name="ln1678">    rettv-&gt;vval.v_number = 1;  // FAIL</a>
<a name="ln1679">  } else {</a>
<a name="ln1680">    for (linenr_T lnum = first; lnum &lt;= last; lnum++) {</a>
<a name="ln1681">      ml_delete(first, true);</a>
<a name="ln1682">    }</a>
<a name="ln1683"> </a>
<a name="ln1684">    FOR_ALL_TAB_WINDOWS(tp, wp) {</a>
<a name="ln1685">      if (wp-&gt;w_buffer == buf) {</a>
<a name="ln1686">        if (wp-&gt;w_cursor.lnum &gt; last) {</a>
<a name="ln1687">          wp-&gt;w_cursor.lnum -= count;</a>
<a name="ln1688">        } else if (wp-&gt;w_cursor.lnum&gt; first) {</a>
<a name="ln1689">          wp-&gt;w_cursor.lnum = first;</a>
<a name="ln1690">        }</a>
<a name="ln1691">        if (wp-&gt;w_cursor.lnum &gt; wp-&gt;w_buffer-&gt;b_ml.ml_line_count) {</a>
<a name="ln1692">          wp-&gt;w_cursor.lnum = wp-&gt;w_buffer-&gt;b_ml.ml_line_count;</a>
<a name="ln1693">        }</a>
<a name="ln1694">      }</a>
<a name="ln1695">    }</a>
<a name="ln1696">    check_cursor_col();</a>
<a name="ln1697">    deleted_lines_mark(first, count);</a>
<a name="ln1698">  }</a>
<a name="ln1699"> </a>
<a name="ln1700">  if (!is_curbuf) {</a>
<a name="ln1701">    curbuf = curbuf_save;</a>
<a name="ln1702">    curwin = curwin_save;</a>
<a name="ln1703">  }</a>
<a name="ln1704">}</a>
<a name="ln1705"> </a>
<a name="ln1706">/*</a>
<a name="ln1707"> * &quot;did_filetype()&quot; function</a>
<a name="ln1708"> */</a>
<a name="ln1709">static void f_did_filetype(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1710">{</a>
<a name="ln1711">  rettv-&gt;vval.v_number = did_filetype;</a>
<a name="ln1712">}</a>
<a name="ln1713"> </a>
<a name="ln1714">/*</a>
<a name="ln1715"> * &quot;diff_filler()&quot; function</a>
<a name="ln1716"> */</a>
<a name="ln1717">static void f_diff_filler(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1718">{</a>
<a name="ln1719">  rettv-&gt;vval.v_number = diff_check_fill(curwin, tv_get_lnum(argvars));</a>
<a name="ln1720">}</a>
<a name="ln1721"> </a>
<a name="ln1722">/*</a>
<a name="ln1723"> * &quot;diff_hlID()&quot; function</a>
<a name="ln1724"> */</a>
<a name="ln1725">static void f_diff_hlID(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1726">{</a>
<a name="ln1727">  linenr_T lnum = tv_get_lnum(argvars);</a>
<a name="ln1728">  static linenr_T prev_lnum = 0;</a>
<a name="ln1729">  static int changedtick = 0;</a>
<a name="ln1730">  static int fnum = 0;</a>
<a name="ln1731">  static int change_start = 0;</a>
<a name="ln1732">  static int change_end = 0;</a>
<a name="ln1733">  static hlf_T hlID = (hlf_T)0;</a>
<a name="ln1734">  int filler_lines;</a>
<a name="ln1735">  int col;</a>
<a name="ln1736"> </a>
<a name="ln1737">  if (lnum &lt; 0) {       // ignore type error in {lnum} arg</a>
<a name="ln1738">    lnum = 0;</a>
<a name="ln1739">  }</a>
<a name="ln1740">  if (lnum != prev_lnum</a>
<a name="ln1741">      || changedtick != buf_get_changedtick(curbuf)</a>
<a name="ln1742">      || fnum != curbuf-&gt;b_fnum) {</a>
<a name="ln1743">    // New line, buffer, change: need to get the values.</a>
<a name="ln1744">    filler_lines = diff_check(curwin, lnum);</a>
<a name="ln1745">    if (filler_lines &lt; 0) {</a>
<a name="ln1746">      if (filler_lines == -1) {</a>
<a name="ln1747">        change_start = MAXCOL;</a>
<a name="ln1748">        change_end = -1;</a>
<a name="ln1749">        if (diff_find_change(curwin, lnum, &amp;change_start, &amp;change_end)) {</a>
<a name="ln1750">          hlID = HLF_ADD;               // added line</a>
<a name="ln1751">        } else {</a>
<a name="ln1752">          hlID = HLF_CHD;               // changed line</a>
<a name="ln1753">        }</a>
<a name="ln1754">      } else {</a>
<a name="ln1755">        hlID = HLF_ADD;         // added line</a>
<a name="ln1756">      }</a>
<a name="ln1757">    } else {</a>
<a name="ln1758">      hlID = (hlf_T)0;</a>
<a name="ln1759">    }</a>
<a name="ln1760">    prev_lnum = lnum;</a>
<a name="ln1761">    changedtick = buf_get_changedtick(curbuf);</a>
<a name="ln1762">    fnum = curbuf-&gt;b_fnum;</a>
<a name="ln1763">  }</a>
<a name="ln1764"> </a>
<a name="ln1765">  if (hlID == HLF_CHD || hlID == HLF_TXD) {</a>
<a name="ln1766">    col = tv_get_number(&amp;argvars[1]) - 1;  // Ignore type error in {col}.</a>
<a name="ln1767">    if (col &gt;= change_start &amp;&amp; col &lt;= change_end) {</a>
<a name="ln1768">      hlID = HLF_TXD;  // Changed text.</a>
<a name="ln1769">    } else {</a>
<a name="ln1770">      hlID = HLF_CHD;  // Changed line.</a>
<a name="ln1771">    }</a>
<a name="ln1772">  }</a>
<a name="ln1773">  rettv-&gt;vval.v_number = hlID == (hlf_T)0 ? 0 : (int)(hlID + 1);</a>
<a name="ln1774">}</a>
<a name="ln1775"> </a>
<a name="ln1776">/*</a>
<a name="ln1777"> * &quot;empty({expr})&quot; function</a>
<a name="ln1778"> */</a>
<a name="ln1779">static void f_empty(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1780">{</a>
<a name="ln1781">  bool n = true;</a>
<a name="ln1782"> </a>
<a name="ln1783">  switch (argvars[0].v_type) {</a>
<a name="ln1784">    case VAR_STRING:</a>
<a name="ln1785">    case VAR_FUNC: {</a>
<a name="ln1786">      n = argvars[0].vval.v_string == NULL</a>
<a name="ln1787">          || *argvars[0].vval.v_string == NUL;</a>
<a name="ln1788">      break;</a>
<a name="ln1789">    }</a>
<a name="ln1790">    case VAR_PARTIAL: {</a>
<a name="ln1791">      n = false;</a>
<a name="ln1792">      break;</a>
<a name="ln1793">    }</a>
<a name="ln1794">    case VAR_NUMBER: {</a>
<a name="ln1795">      n = argvars[0].vval.v_number == 0;</a>
<a name="ln1796">      break;</a>
<a name="ln1797">    }</a>
<a name="ln1798">    case VAR_FLOAT: {</a>
<a name="ln1799">      n = argvars[0].vval.v_float == 0.0;</a>
<a name="ln1800">      break;</a>
<a name="ln1801">    }</a>
<a name="ln1802">    case VAR_LIST: {</a>
<a name="ln1803">      n = (tv_list_len(argvars[0].vval.v_list) == 0);</a>
<a name="ln1804">      break;</a>
<a name="ln1805">    }</a>
<a name="ln1806">    case VAR_DICT: {</a>
<a name="ln1807">      n = (tv_dict_len(argvars[0].vval.v_dict) == 0);</a>
<a name="ln1808">      break;</a>
<a name="ln1809">    }</a>
<a name="ln1810">    case VAR_BOOL: {</a>
<a name="ln1811">      switch (argvars[0].vval.v_bool) {</a>
<a name="ln1812">        case kBoolVarTrue: {</a>
<a name="ln1813">          n = false;</a>
<a name="ln1814">          break;</a>
<a name="ln1815">        }</a>
<a name="ln1816">        case kBoolVarFalse: {</a>
<a name="ln1817">          n = true;</a>
<a name="ln1818">          break;</a>
<a name="ln1819">        }</a>
<a name="ln1820">      }</a>
<a name="ln1821">      break;</a>
<a name="ln1822">    }</a>
<a name="ln1823">    case VAR_SPECIAL: {</a>
<a name="ln1824">      n = argvars[0].vval.v_special == kSpecialVarNull;</a>
<a name="ln1825">      break;</a>
<a name="ln1826">    }</a>
<a name="ln1827">    case VAR_UNKNOWN: {</a>
<a name="ln1828">      internal_error(&quot;f_empty(UNKNOWN)&quot;);</a>
<a name="ln1829">      break;</a>
<a name="ln1830">    }</a>
<a name="ln1831">  }</a>
<a name="ln1832"> </a>
<a name="ln1833">  rettv-&gt;vval.v_number = n;</a>
<a name="ln1834">}</a>
<a name="ln1835"> </a>
<a name="ln1836">/// &quot;environ()&quot; function</a>
<a name="ln1837">static void f_environ(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1838">{</a>
<a name="ln1839">  tv_dict_alloc_ret(rettv);</a>
<a name="ln1840"> </a>
<a name="ln1841">  size_t env_size = os_get_fullenv_size();</a>
<a name="ln1842">  char **env = xmalloc(sizeof(*env) * (env_size + 1));</a>
<a name="ln1843">  env[env_size] = NULL;</a>
<a name="ln1844"> </a>
<a name="ln1845">  os_copy_fullenv(env, env_size);</a>
<a name="ln1846"> </a>
<a name="ln1847">  for (ssize_t i = env_size - 1; i &gt;= 0; i--) {</a>
<a name="ln1848">    const char * str = env[i];</a>
<a name="ln1849">    const char * const end = strchr(str + (str[0] == '=' ? 1 : 0),</a>
<a name="ln1850">                                    '=');</a>
<a name="ln1851">    assert(end != NULL);</a>
<a name="ln1852">    ptrdiff_t len = end - str;</a>
<a name="ln1853">    assert(len &gt; 0);</a>
<a name="ln1854">    const char * value = str + len + 1;</a>
<a name="ln1855"> </a>
<a name="ln1856">    char c = env[i][len];</a>
<a name="ln1857">    env[i][len] = NUL;</a>
<a name="ln1858"> </a>
<a name="ln1859">#ifdef WIN32</a>
<a name="ln1860">    // Upper-case all the keys for Windows so we can detect duplicates</a>
<a name="ln1861">    char *const key = strcase_save(str, true);</a>
<a name="ln1862">#else</a>
<a name="ln1863">    char *const key = xstrdup(str);</a>
<a name="ln1864">#endif</a>
<a name="ln1865"> </a>
<a name="ln1866">    env[i][len] = c;</a>
<a name="ln1867"> </a>
<a name="ln1868">    if (tv_dict_find(rettv-&gt;vval.v_dict, key, len) != NULL) {</a>
<a name="ln1869">      // Since we're traversing from the end of the env block to the front, any</a>
<a name="ln1870">      // duplicate names encountered should be ignored.  This preserves the</a>
<a name="ln1871">      // semantics of env vars defined later in the env block taking precedence.</a>
<a name="ln1872">      xfree(key);</a>
<a name="ln1873">      continue;</a>
<a name="ln1874">    }</a>
<a name="ln1875">    tv_dict_add_str(rettv-&gt;vval.v_dict,</a>
<a name="ln1876">                    key, len,</a>
<a name="ln1877">                    value);</a>
<a name="ln1878">    xfree(key);</a>
<a name="ln1879">  }</a>
<a name="ln1880">  os_free_fullenv(env);</a>
<a name="ln1881">}</a>
<a name="ln1882"> </a>
<a name="ln1883">/*</a>
<a name="ln1884"> * &quot;escape({string}, {chars})&quot; function</a>
<a name="ln1885"> */</a>
<a name="ln1886">static void f_escape(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1887">{</a>
<a name="ln1888">  char buf[NUMBUFLEN];</a>
<a name="ln1889"> </a>
<a name="ln1890">  rettv-&gt;vval.v_string = vim_strsave_escaped(</a>
<a name="ln1891">      (const char_u *)tv_get_string(&amp;argvars[0]),</a>
<a name="ln1892">      (const char_u *)tv_get_string_buf(&amp;argvars[1], buf));</a>
<a name="ln1893">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln1894">}</a>
<a name="ln1895"> </a>
<a name="ln1896">/// &quot;getenv()&quot; function</a>
<a name="ln1897">static void f_getenv(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1898">{</a>
<a name="ln1899">  char_u *p = (char_u *)vim_getenv(tv_get_string(&amp;argvars[0]));</a>
<a name="ln1900"> </a>
<a name="ln1901">  if (p == NULL) {</a>
<a name="ln1902">    rettv-&gt;v_type = VAR_SPECIAL;</a>
<a name="ln1903">    rettv-&gt;vval.v_special = kSpecialVarNull;</a>
<a name="ln1904">    return;</a>
<a name="ln1905">  }</a>
<a name="ln1906">  rettv-&gt;vval.v_string = p;</a>
<a name="ln1907">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln1908">}</a>
<a name="ln1909"> </a>
<a name="ln1910">/*</a>
<a name="ln1911"> * &quot;eval()&quot; function</a>
<a name="ln1912"> */</a>
<a name="ln1913">static void f_eval(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1914">{</a>
<a name="ln1915">  const char *s = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln1916">  if (s != NULL) {</a>
<a name="ln1917">    s = (const char *)skipwhite((const char_u *)s);</a>
<a name="ln1918">  }</a>
<a name="ln1919"> </a>
<a name="ln1920">  const char *const expr_start = s;</a>
<a name="ln1921">  if (s == NULL || eval1((char_u **)&amp;s, rettv, true) == FAIL) {</a>
<a name="ln1922">    if (expr_start != NULL &amp;&amp; !aborting()) {</a>
<a name="ln1923">      EMSG2(_(e_invexpr2), expr_start);</a>
<a name="ln1924">    }</a>
<a name="ln1925">    need_clr_eos = FALSE;</a>
<a name="ln1926">    rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln1927">    rettv-&gt;vval.v_number = 0;</a>
<a name="ln1928">  } else if (*s != NUL) {</a>
<a name="ln1929">    EMSG(_(e_trailing));</a>
<a name="ln1930">  }</a>
<a name="ln1931">}</a>
<a name="ln1932"> </a>
<a name="ln1933">/*</a>
<a name="ln1934"> * &quot;eventhandler()&quot; function</a>
<a name="ln1935"> */</a>
<a name="ln1936">static void f_eventhandler(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1937">{</a>
<a name="ln1938">  rettv-&gt;vval.v_number = vgetc_busy;</a>
<a name="ln1939">}</a>
<a name="ln1940"> </a>
<a name="ln1941">/*</a>
<a name="ln1942"> * &quot;executable()&quot; function</a>
<a name="ln1943"> */</a>
<a name="ln1944">static void f_executable(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1945">{</a>
<a name="ln1946">  if (tv_check_for_string(&amp;argvars[0]) == FAIL) {</a>
<a name="ln1947">    return;</a>
<a name="ln1948">  }</a>
<a name="ln1949"> </a>
<a name="ln1950">  // Check in $PATH and also check directly if there is a directory name</a>
<a name="ln1951">  rettv-&gt;vval.v_number = os_can_exe(tv_get_string(&amp;argvars[0]), NULL, true);</a>
<a name="ln1952">}</a>
<a name="ln1953"> </a>
<a name="ln1954">typedef struct {</a>
<a name="ln1955">  const list_T *const l;</a>
<a name="ln1956">  const listitem_T *li;</a>
<a name="ln1957">} GetListLineCookie;</a>
<a name="ln1958"> </a>
<a name="ln1959">static char_u *get_list_line(int c, void *cookie, int indent, bool do_concat)</a>
<a name="ln1960">{</a>
<a name="ln1961">  GetListLineCookie *const p = (GetListLineCookie *)cookie;</a>
<a name="ln1962"> </a>
<a name="ln1963">  const listitem_T *const item = p-&gt;li;</a>
<a name="ln1964">  if (item == NULL) {</a>
<a name="ln1965">    return NULL;</a>
<a name="ln1966">  }</a>
<a name="ln1967">  char buf[NUMBUFLEN];</a>
<a name="ln1968">  const char *const s = tv_get_string_buf_chk(TV_LIST_ITEM_TV(item), buf);</a>
<a name="ln1969">  p-&gt;li = TV_LIST_ITEM_NEXT(p-&gt;l, item);</a>
<a name="ln1970">  return (char_u *)(s == NULL ? NULL : xstrdup(s));</a>
<a name="ln1971">}</a>
<a name="ln1972"> </a>
<a name="ln1973">static void execute_common(typval_T *argvars, typval_T *rettv, FunPtr fptr,</a>
<a name="ln1974">                           int arg_off)</a>
<a name="ln1975">{</a>
<a name="ln1976">  const int save_msg_silent = msg_silent;</a>
<a name="ln1977">  const int save_emsg_silent = emsg_silent;</a>
<a name="ln1978">  const bool save_emsg_noredir = emsg_noredir;</a>
<a name="ln1979">  const bool save_redir_off = redir_off;</a>
<a name="ln1980">  garray_T *const save_capture_ga = capture_ga;</a>
<a name="ln1981">  const int save_msg_col = msg_col;</a>
<a name="ln1982">  bool echo_output = false;</a>
<a name="ln1983"> </a>
<a name="ln1984">  if (check_secure()) {</a>
<a name="ln1985">    return;</a>
<a name="ln1986">  }</a>
<a name="ln1987"> </a>
<a name="ln1988">  if (argvars[arg_off + 1].v_type != VAR_UNKNOWN) {</a>
<a name="ln1989">    char buf[NUMBUFLEN];</a>
<a name="ln1990">    const char *const s = tv_get_string_buf_chk(&amp;argvars[arg_off + 1], buf);</a>
<a name="ln1991"> </a>
<a name="ln1992">    if (s == NULL) {</a>
<a name="ln1993">      return;</a>
<a name="ln1994">    }</a>
<a name="ln1995">    if (*s == NUL) {</a>
<a name="ln1996">      echo_output = true;</a>
<a name="ln1997">    }</a>
<a name="ln1998">    if (strncmp(s, &quot;silent&quot;, 6) == 0) {</a>
<a name="ln1999">      msg_silent++;</a>
<a name="ln2000">    }</a>
<a name="ln2001">    if (strcmp(s, &quot;silent!&quot;) == 0) {</a>
<a name="ln2002">      emsg_silent = true;</a>
<a name="ln2003">      emsg_noredir = true;</a>
<a name="ln2004">    }</a>
<a name="ln2005">  } else {</a>
<a name="ln2006">    msg_silent++;</a>
<a name="ln2007">  }</a>
<a name="ln2008"> </a>
<a name="ln2009">  garray_T capture_local;</a>
<a name="ln2010">  ga_init(&amp;capture_local, (int)sizeof(char), 80);</a>
<a name="ln2011">  capture_ga = &amp;capture_local;</a>
<a name="ln2012">  redir_off = false;</a>
<a name="ln2013">  if (!echo_output) {</a>
<a name="ln2014">    msg_col = 0;  // prevent leading spaces</a>
<a name="ln2015">  }</a>
<a name="ln2016"> </a>
<a name="ln2017">  if (argvars[arg_off].v_type != VAR_LIST) {</a>
<a name="ln2018">    do_cmdline_cmd(tv_get_string(&amp;argvars[arg_off]));</a>
<a name="ln2019">  } else if (argvars[arg_off].vval.v_list != NULL) {</a>
<a name="ln2020">    list_T *const list = argvars[arg_off].vval.v_list;</a>
<a name="ln2021">    tv_list_ref(list);</a>
<a name="ln2022">    GetListLineCookie cookie = {</a>
<a name="ln2023">      .l = list,</a>
<a name="ln2024">      .li = tv_list_first(list),</a>
<a name="ln2025">    };</a>
<a name="ln2026">    do_cmdline(NULL, get_list_line, (void *)&amp;cookie,</a>
<a name="ln2027">               DOCMD_NOWAIT|DOCMD_VERBOSE|DOCMD_REPEAT|DOCMD_KEYTYPED);</a>
<a name="ln2028">    tv_list_unref(list);</a>
<a name="ln2029">  }</a>
<a name="ln2030">  msg_silent = save_msg_silent;</a>
<a name="ln2031">  emsg_silent = save_emsg_silent;</a>
<a name="ln2032">  emsg_noredir = save_emsg_noredir;</a>
<a name="ln2033">  redir_off = save_redir_off;</a>
<a name="ln2034">  // &quot;silent reg&quot; or &quot;silent echo x&quot; leaves msg_col somewhere in the line.</a>
<a name="ln2035">  if (echo_output) {</a>
<a name="ln2036">    // When not working silently: put it in column zero.  A following</a>
<a name="ln2037">    // &quot;echon&quot; will overwrite the message, unavoidably.</a>
<a name="ln2038">    msg_col = 0;</a>
<a name="ln2039">  } else {</a>
<a name="ln2040">    // When working silently: Put it back where it was, since nothing</a>
<a name="ln2041">    // should have been written.</a>
<a name="ln2042">    msg_col = save_msg_col;</a>
<a name="ln2043">  }</a>
<a name="ln2044"> </a>
<a name="ln2045">  ga_append(capture_ga, NUL);</a>
<a name="ln2046">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln2047">  rettv-&gt;vval.v_string = capture_ga-&gt;ga_data;</a>
<a name="ln2048"> </a>
<a name="ln2049">  capture_ga = save_capture_ga;</a>
<a name="ln2050">}</a>
<a name="ln2051"> </a>
<a name="ln2052">// &quot;execute(command)&quot; function</a>
<a name="ln2053">static void f_execute(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2054">{</a>
<a name="ln2055">  execute_common(argvars, rettv, fptr, 0);</a>
<a name="ln2056">}</a>
<a name="ln2057"> </a>
<a name="ln2058">// &quot;win_execute(win_id, command)&quot; function</a>
<a name="ln2059">static void f_win_execute(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2060">{</a>
<a name="ln2061">  tabpage_T *tp;</a>
<a name="ln2062">  win_T *wp = win_id2wp_tp(argvars, &amp;tp);</a>
<a name="ln2063">  win_T *save_curwin;</a>
<a name="ln2064">  tabpage_T *save_curtab;</a>
<a name="ln2065">  // Return an empty string if something fails.</a>
<a name="ln2066">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln2067">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln2068"> </a>
<a name="ln2069">  if (wp != NULL &amp;&amp; tp != NULL) {</a>
<a name="ln2070">    pos_T curpos = wp-&gt;w_cursor;</a>
<a name="ln2071">    if (switch_win_noblock(&amp;save_curwin, &amp;save_curtab, wp, tp, true) ==</a>
<a name="ln2072">        OK) {</a>
<a name="ln2073">      check_cursor();</a>
<a name="ln2074">      execute_common(argvars, rettv, fptr, 1);</a>
<a name="ln2075">    }</a>
<a name="ln2076">    restore_win_noblock(save_curwin, save_curtab, true);</a>
<a name="ln2077"> </a>
<a name="ln2078">    // Update the status line if the cursor moved.</a>
<a name="ln2079">    if (win_valid(wp) &amp;&amp; !equalpos(curpos, wp-&gt;w_cursor)) {</a>
<a name="ln2080">        wp-&gt;w_redr_status = true;</a>
<a name="ln2081">    }</a>
<a name="ln2082">  }</a>
<a name="ln2083">}</a>
<a name="ln2084"> </a>
<a name="ln2085">/// &quot;exepath()&quot; function</a>
<a name="ln2086">static void f_exepath(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2087">{</a>
<a name="ln2088">  if (tv_check_for_string(&amp;argvars[0]) == FAIL) {</a>
<a name="ln2089">    return;</a>
<a name="ln2090">  }</a>
<a name="ln2091"> </a>
<a name="ln2092">  char *path = NULL;</a>
<a name="ln2093"> </a>
<a name="ln2094">  (void)os_can_exe(tv_get_string(&amp;argvars[0]), &amp;path, true);</a>
<a name="ln2095"> </a>
<a name="ln2096">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln2097">  rettv-&gt;vval.v_string = (char_u *)path;</a>
<a name="ln2098">}</a>
<a name="ln2099"> </a>
<a name="ln2100">/*</a>
<a name="ln2101"> * &quot;exists()&quot; function</a>
<a name="ln2102"> */</a>
<a name="ln2103">static void f_exists(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2104">{</a>
<a name="ln2105">  int n = false;</a>
<a name="ln2106"> </a>
<a name="ln2107">  const char *p = tv_get_string(&amp;argvars[0]);</a>
<a name="ln2108">  if (*p == '$') {  // Environment variable.</a>
<a name="ln2109">    // First try &quot;normal&quot; environment variables (fast).</a>
<a name="ln2110">    if (os_env_exists(p + 1)) {</a>
<a name="ln2111">      n = true;</a>
<a name="ln2112">    } else {</a>
<a name="ln2113">      // Try expanding things like $VIM and ${HOME}.</a>
<a name="ln2114">      char_u *const exp = expand_env_save((char_u *)p);</a>
<a name="ln2115">      if (exp != NULL &amp;&amp; *exp != '$') {</a>
<a name="ln2116">        n = true;</a>
<a name="ln2117">      }</a>
<a name="ln2118">      xfree(exp);</a>
<a name="ln2119">    }</a>
<a name="ln2120">  } else if (*p == '&amp;' || *p == '+') {  // Option.</a>
<a name="ln2121">    n = (get_option_tv(&amp;p, NULL, true) == OK);</a>
<a name="ln2122">    if (*skipwhite((const char_u *)p) != NUL) {</a>
<a name="ln2123">      n = false;  // Trailing garbage.</a>
<a name="ln2124">    }</a>
<a name="ln2125">  } else if (*p == '*') {  // Internal or user defined function.</a>
<a name="ln2126">    n = function_exists(p + 1, false);</a>
<a name="ln2127">  } else if (*p == ':') {</a>
<a name="ln2128">    n = cmd_exists(p + 1);</a>
<a name="ln2129">  } else if (*p == '#') {</a>
<a name="ln2130">    if (p[1] == '#') {</a>
<a name="ln2131">      n = autocmd_supported(p + 2);</a>
<a name="ln2132">    } else {</a>
<a name="ln2133">      n = au_exists(p + 1);</a>
<a name="ln2134">    }</a>
<a name="ln2135">  } else {  // Internal variable.</a>
<a name="ln2136">    n = var_exists(p);</a>
<a name="ln2137">  }</a>
<a name="ln2138"> </a>
<a name="ln2139">  rettv-&gt;vval.v_number = n;</a>
<a name="ln2140">}</a>
<a name="ln2141"> </a>
<a name="ln2142">/*</a>
<a name="ln2143"> * &quot;expand()&quot; function</a>
<a name="ln2144"> */</a>
<a name="ln2145">static void f_expand(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2146">{</a>
<a name="ln2147">  size_t len;</a>
<a name="ln2148">  char_u      *errormsg;</a>
<a name="ln2149">  int options = WILD_SILENT|WILD_USE_NL|WILD_LIST_NOTFOUND;</a>
<a name="ln2150">  expand_T xpc;</a>
<a name="ln2151">  bool error = false;</a>
<a name="ln2152">  char_u *result;</a>
<a name="ln2153">#ifdef BACKSLASH_IN_FILENAME</a>
<a name="ln2154">  char_u *p_csl_save = p_csl;</a>
<a name="ln2155"> </a>
<a name="ln2156">  // avoid using 'completeslash' here</a>
<a name="ln2157">  p_csl = empty_option;</a>
<a name="ln2158">#endif</a>
<a name="ln2159"> </a>
<a name="ln2160">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln2161">  if (argvars[1].v_type != VAR_UNKNOWN</a>
<a name="ln2162">      &amp;&amp; argvars[2].v_type != VAR_UNKNOWN</a>
<a name="ln2163">      &amp;&amp; tv_get_number_chk(&amp;argvars[2], &amp;error)</a>
<a name="ln2164">      &amp;&amp; !error) {</a>
<a name="ln2165">    tv_list_set_ret(rettv, NULL);</a>
<a name="ln2166">  }</a>
<a name="ln2167"> </a>
<a name="ln2168">  const char *s = tv_get_string(&amp;argvars[0]);</a>
<a name="ln2169">  if (*s == '%' || *s == '#' || *s == '&lt;') {</a>
<a name="ln2170">    emsg_off++;</a>
<a name="ln2171">    result = eval_vars((char_u *)s, (char_u *)s, &amp;len, NULL, &amp;errormsg, NULL);</a>
<a name="ln2172">    emsg_off--;</a>
<a name="ln2173">    if (rettv-&gt;v_type == VAR_LIST) {</a>
<a name="ln2174">      tv_list_alloc_ret(rettv, (result != NULL));</a>
<a name="ln2175">      if (result != NULL) {</a>
<a name="ln2176">        tv_list_append_string(rettv-&gt;vval.v_list, (const char *)result, -1);</a>
<a name="ln2177">      }</a>
<a name="ln2178">      XFREE_CLEAR(result);</a>
<a name="ln2179">    } else {</a>
<a name="ln2180">      rettv-&gt;vval.v_string = result;</a>
<a name="ln2181">    }</a>
<a name="ln2182">  } else {</a>
<a name="ln2183">    // When the optional second argument is non-zero, don't remove matches</a>
<a name="ln2184">    // for 'wildignore' and don't put matches for 'suffixes' at the end.</a>
<a name="ln2185">    if (argvars[1].v_type != VAR_UNKNOWN</a>
<a name="ln2186">        &amp;&amp; tv_get_number_chk(&amp;argvars[1], &amp;error)) {</a>
<a name="ln2187">      options |= WILD_KEEP_ALL;</a>
<a name="ln2188">    }</a>
<a name="ln2189">    if (!error) {</a>
<a name="ln2190">      ExpandInit(&amp;xpc);</a>
<a name="ln2191">      xpc.xp_context = EXPAND_FILES;</a>
<a name="ln2192">      if (p_wic) {</a>
<a name="ln2193">        options += WILD_ICASE;</a>
<a name="ln2194">      }</a>
<a name="ln2195">      if (rettv-&gt;v_type == VAR_STRING) {</a>
<a name="ln2196">        rettv-&gt;vval.v_string = ExpandOne(&amp;xpc, (char_u *)s, NULL, options,</a>
<a name="ln2197">                                         WILD_ALL);</a>
<a name="ln2198">      } else {</a>
<a name="ln2199">        ExpandOne(&amp;xpc, (char_u *)s, NULL, options, WILD_ALL_KEEP);</a>
<a name="ln2200">        tv_list_alloc_ret(rettv, xpc.xp_numfiles);</a>
<a name="ln2201">        for (int i = 0; i &lt; xpc.xp_numfiles; i++) {</a>
<a name="ln2202">          tv_list_append_string(rettv-&gt;vval.v_list,</a>
<a name="ln2203">                                (const char *)xpc.xp_files[i], -1);</a>
<a name="ln2204">        }</a>
<a name="ln2205">        ExpandCleanup(&amp;xpc);</a>
<a name="ln2206">      }</a>
<a name="ln2207">    } else {</a>
<a name="ln2208">      rettv-&gt;vval.v_string = NULL;</a>
<a name="ln2209">    }</a>
<a name="ln2210">  }</a>
<a name="ln2211">#ifdef BACKSLASH_IN_FILENAME</a>
<a name="ln2212">  p_csl = p_csl_save;</a>
<a name="ln2213">#endif</a>
<a name="ln2214">}</a>
<a name="ln2215"> </a>
<a name="ln2216"> </a>
<a name="ln2217">/// &quot;menu_get(path [, modes])&quot; function</a>
<a name="ln2218">static void f_menu_get(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2219">{</a>
<a name="ln2220">  tv_list_alloc_ret(rettv, kListLenMayKnow);</a>
<a name="ln2221">  int modes = MENU_ALL_MODES;</a>
<a name="ln2222">  if (argvars[1].v_type == VAR_STRING) {</a>
<a name="ln2223">    const char *const strmodes = tv_get_string(&amp;argvars[1]);</a>
<a name="ln2224">    modes = get_menu_cmd_modes(strmodes, false, NULL, NULL);</a>
<a name="ln2225">  }</a>
<a name="ln2226">  menu_get((char_u *)tv_get_string(&amp;argvars[0]), modes, rettv-&gt;vval.v_list);</a>
<a name="ln2227">}</a>
<a name="ln2228"> </a>
<a name="ln2229">// &quot;expandcmd()&quot; function</a>
<a name="ln2230">// Expand all the special characters in a command string.</a>
<a name="ln2231">static void f_expandcmd(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2232">{</a>
<a name="ln2233">  char_u *errormsg = NULL;</a>
<a name="ln2234"> </a>
<a name="ln2235">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln2236">  char_u *cmdstr = (char_u *)xstrdup(tv_get_string(&amp;argvars[0]));</a>
<a name="ln2237"> </a>
<a name="ln2238">  exarg_T eap = {</a>
<a name="ln2239">    .cmd = cmdstr,</a>
<a name="ln2240">    .arg = cmdstr,</a>
<a name="ln2241">    .usefilter = false,</a>
<a name="ln2242">    .nextcmd = NULL,</a>
<a name="ln2243">    .cmdidx = CMD_USER,</a>
<a name="ln2244">  };</a>
<a name="ln2245">  eap.argt |= EX_NOSPC;</a>
<a name="ln2246"> </a>
<a name="ln2247">  expand_filename(&amp;eap, &amp;cmdstr, &amp;errormsg);</a>
<a name="ln2248">  if (errormsg != NULL &amp;&amp; *errormsg != NUL) {</a>
<a name="ln2249">    EMSG(errormsg);</a>
<a name="ln2250">  }</a>
<a name="ln2251">  rettv-&gt;vval.v_string = cmdstr;</a>
<a name="ln2252">}</a>
<a name="ln2253"> </a>
<a name="ln2254"> </a>
<a name="ln2255">/// &quot;flatten(list[, {maxdepth}])&quot; function</a>
<a name="ln2256">static void f_flatten(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2257">{</a>
<a name="ln2258">  list_T *list;</a>
<a name="ln2259">  long maxdepth;</a>
<a name="ln2260">  bool error = false;</a>
<a name="ln2261"> </a>
<a name="ln2262">  if (argvars[0].v_type != VAR_LIST) {</a>
<a name="ln2263">    EMSG2(_(e_listarg), &quot;flatten()&quot;);</a>
<a name="ln2264">    return;</a>
<a name="ln2265">  }</a>
<a name="ln2266"> </a>
<a name="ln2267">  if (argvars[1].v_type == VAR_UNKNOWN) {</a>
<a name="ln2268">    maxdepth = 999999;</a>
<a name="ln2269">  } else {</a>
<a name="ln2270">    maxdepth = (long)tv_get_number_chk(&amp;argvars[1], &amp;error);</a>
<a name="ln2271">    if (error) {</a>
<a name="ln2272">      return;</a>
<a name="ln2273">    }</a>
<a name="ln2274">    if (maxdepth &lt; 0) {</a>
<a name="ln2275">      EMSG(_(&quot;E900: maxdepth must be non-negative number&quot;));</a>
<a name="ln2276">      return;</a>
<a name="ln2277">    }</a>
<a name="ln2278">  }</a>
<a name="ln2279"> </a>
<a name="ln2280">  list = argvars[0].vval.v_list;</a>
<a name="ln2281">  if (list != NULL</a>
<a name="ln2282">      &amp;&amp; !var_check_lock(tv_list_locked(list),</a>
<a name="ln2283">                         N_(&quot;flatten() argument&quot;),</a>
<a name="ln2284">                         TV_TRANSLATE)</a>
<a name="ln2285">      &amp;&amp; tv_list_flatten(list, maxdepth) == OK) {</a>
<a name="ln2286">    tv_copy(&amp;argvars[0], rettv);</a>
<a name="ln2287">  }</a>
<a name="ln2288">}</a>
<a name="ln2289"> </a>
<a name="ln2290">/*</a>
<a name="ln2291"> * &quot;extend(list, list [, idx])&quot; function</a>
<a name="ln2292"> * &quot;extend(dict, dict [, action])&quot; function</a>
<a name="ln2293"> */</a>
<a name="ln2294">static void f_extend(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2295">{</a>
<a name="ln2296">  const char *const arg_errmsg = N_(&quot;extend() argument&quot;);</a>
<a name="ln2297"> </a>
<a name="ln2298">  if (argvars[0].v_type == VAR_LIST &amp;&amp; argvars[1].v_type == VAR_LIST) {</a>
<a name="ln2299">    long before;</a>
<a name="ln2300">    bool error = false;</a>
<a name="ln2301"> </a>
<a name="ln2302">    list_T *const l1 = argvars[0].vval.v_list;</a>
<a name="ln2303">    list_T *const l2 = argvars[1].vval.v_list;</a>
<a name="ln2304">    if (!var_check_lock(tv_list_locked(l1), arg_errmsg, TV_TRANSLATE)) {</a>
<a name="ln2305">      listitem_T *item;</a>
<a name="ln2306">      if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln2307">        before = (long)tv_get_number_chk(&amp;argvars[2], &amp;error);</a>
<a name="ln2308">        if (error) {</a>
<a name="ln2309">          return;  // Type error; errmsg already given.</a>
<a name="ln2310">        }</a>
<a name="ln2311"> </a>
<a name="ln2312">        if (before == tv_list_len(l1)) {</a>
<a name="ln2313">          item = NULL;</a>
<a name="ln2314">        } else {</a>
<a name="ln2315">          item = tv_list_find(l1, before);</a>
<a name="ln2316">          if (item == NULL) {</a>
<a name="ln2317">            EMSGN(_(e_listidx), before);</a>
<a name="ln2318">            return;</a>
<a name="ln2319">          }</a>
<a name="ln2320">        }</a>
<a name="ln2321">      } else {</a>
<a name="ln2322">        item = NULL;</a>
<a name="ln2323">      }</a>
<a name="ln2324">      tv_list_extend(l1, l2, item);</a>
<a name="ln2325"> </a>
<a name="ln2326">      tv_copy(&amp;argvars[0], rettv);</a>
<a name="ln2327">    }</a>
<a name="ln2328">  } else if (argvars[0].v_type == VAR_DICT &amp;&amp; argvars[1].v_type ==</a>
<a name="ln2329">             VAR_DICT) {</a>
<a name="ln2330">    dict_T *const d1 = argvars[0].vval.v_dict;</a>
<a name="ln2331">    dict_T *const d2 = argvars[1].vval.v_dict;</a>
<a name="ln2332">    if (d1 == NULL) {</a>
<a name="ln2333">      const bool locked = var_check_lock(VAR_FIXED, arg_errmsg, TV_TRANSLATE);</a>
<a name="ln2334">      (void)locked;</a>
<a name="ln2335">      assert(locked == true);</a>
<a name="ln2336">    } else if (d2 == NULL) {</a>
<a name="ln2337">      // Do nothing</a>
<a name="ln2338">      tv_copy(&amp;argvars[0], rettv);</a>
<a name="ln2339">    } else if (!var_check_lock(d1-&gt;dv_lock, arg_errmsg, TV_TRANSLATE)) {</a>
<a name="ln2340">      const char *action = &quot;force&quot;;</a>
<a name="ln2341">      // Check the third argument.</a>
<a name="ln2342">      if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln2343">        const char *const av[] = { &quot;keep&quot;, &quot;force&quot;, &quot;error&quot; };</a>
<a name="ln2344"> </a>
<a name="ln2345">        action = tv_get_string_chk(&amp;argvars[2]);</a>
<a name="ln2346">        if (action == NULL) {</a>
<a name="ln2347">          return;  // Type error; error message already given.</a>
<a name="ln2348">        }</a>
<a name="ln2349">        size_t i;</a>
<a name="ln2350">        for (i = 0; i &lt; ARRAY_SIZE(av); i++) {</a>
<a name="ln2351">          if (strcmp(action, av[i]) == 0) {</a>
<a name="ln2352">            break;</a>
<a name="ln2353">          }</a>
<a name="ln2354">        }</a>
<a name="ln2355">        if (i == 3) {</a>
<a name="ln2356">          EMSG2(_(e_invarg2), action);</a>
<a name="ln2357">          return;</a>
<a name="ln2358">        }</a>
<a name="ln2359">      }</a>
<a name="ln2360"> </a>
<a name="ln2361">      tv_dict_extend(d1, d2, action);</a>
<a name="ln2362"> </a>
<a name="ln2363">      tv_copy(&amp;argvars[0], rettv);</a>
<a name="ln2364">    }</a>
<a name="ln2365">  } else {</a>
<a name="ln2366">    EMSG2(_(e_listdictarg), &quot;extend()&quot;);</a>
<a name="ln2367">  }</a>
<a name="ln2368">}</a>
<a name="ln2369"> </a>
<a name="ln2370">/*</a>
<a name="ln2371"> * &quot;feedkeys()&quot; function</a>
<a name="ln2372"> */</a>
<a name="ln2373">static void f_feedkeys(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2374">{</a>
<a name="ln2375">  // This is not allowed in the sandbox.  If the commands would still be</a>
<a name="ln2376">  // executed in the sandbox it would be OK, but it probably happens later,</a>
<a name="ln2377">  // when &quot;sandbox&quot; is no longer set.</a>
<a name="ln2378">  if (check_secure()) {</a>
<a name="ln2379">    return;</a>
<a name="ln2380">  }</a>
<a name="ln2381"> </a>
<a name="ln2382">  const char *const keys = tv_get_string(&amp;argvars[0]);</a>
<a name="ln2383">  char nbuf[NUMBUFLEN];</a>
<a name="ln2384">  const char *flags = NULL;</a>
<a name="ln2385">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln2386">    flags = tv_get_string_buf(&amp;argvars[1], nbuf);</a>
<a name="ln2387">  }</a>
<a name="ln2388"> </a>
<a name="ln2389">  nvim_feedkeys(cstr_as_string((char *)keys),</a>
<a name="ln2390">                cstr_as_string((char *)flags), true);</a>
<a name="ln2391">}</a>
<a name="ln2392"> </a>
<a name="ln2393">/// &quot;filereadable()&quot; function</a>
<a name="ln2394">static void f_filereadable(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2395">{</a>
<a name="ln2396">  const char *const p = tv_get_string(&amp;argvars[0]);</a>
<a name="ln2397">  rettv-&gt;vval.v_number =</a>
<a name="ln2398">    (*p &amp;&amp; !os_isdir((const char_u *)p) &amp;&amp; os_file_is_readable(p));</a>
<a name="ln2399">}</a>
<a name="ln2400"> </a>
<a name="ln2401">/*</a>
<a name="ln2402"> * Return 0 for not writable, 1 for writable file, 2 for a dir which we have</a>
<a name="ln2403"> * rights to write into.</a>
<a name="ln2404"> */</a>
<a name="ln2405">static void f_filewritable(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2406">{</a>
<a name="ln2407">  const char *filename = tv_get_string(&amp;argvars[0]);</a>
<a name="ln2408">  rettv-&gt;vval.v_number = os_file_is_writable(filename);</a>
<a name="ln2409">}</a>
<a name="ln2410"> </a>
<a name="ln2411"> </a>
<a name="ln2412">static void findfilendir(typval_T *argvars, typval_T *rettv, int find_what)</a>
<a name="ln2413">{</a>
<a name="ln2414">  char_u *fresult = NULL;</a>
<a name="ln2415">  char_u *path = *curbuf-&gt;b_p_path == NUL ? p_path : curbuf-&gt;b_p_path;</a>
<a name="ln2416">  int count = 1;</a>
<a name="ln2417">  bool first = true;</a>
<a name="ln2418">  bool error = false;</a>
<a name="ln2419"> </a>
<a name="ln2420">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln2421">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln2422"> </a>
<a name="ln2423">  const char *fname = tv_get_string(&amp;argvars[0]);</a>
<a name="ln2424"> </a>
<a name="ln2425">  char pathbuf[NUMBUFLEN];</a>
<a name="ln2426">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln2427">    const char *p = tv_get_string_buf_chk(&amp;argvars[1], pathbuf);</a>
<a name="ln2428">    if (p == NULL) {</a>
<a name="ln2429">      error = true;</a>
<a name="ln2430">    } else {</a>
<a name="ln2431">      if (*p != NUL) {</a>
<a name="ln2432">        path = (char_u *)p;</a>
<a name="ln2433">      }</a>
<a name="ln2434"> </a>
<a name="ln2435">      if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln2436">        count = tv_get_number_chk(&amp;argvars[2], &amp;error);</a>
<a name="ln2437">      }</a>
<a name="ln2438">    }</a>
<a name="ln2439">  }</a>
<a name="ln2440"> </a>
<a name="ln2441">  if (count &lt; 0) {</a>
<a name="ln2442">    tv_list_alloc_ret(rettv, kListLenUnknown);</a>
<a name="ln2443">  }</a>
<a name="ln2444"> </a>
<a name="ln2445">  if (*fname != NUL &amp;&amp; !error) {</a>
<a name="ln2446">    do {</a>
<a name="ln2447">      if (rettv-&gt;v_type == VAR_STRING || rettv-&gt;v_type == VAR_LIST)</a>
<a name="ln2448">        xfree(fresult);</a>
<a name="ln2449">      fresult = find_file_in_path_option(first ? (char_u *)fname : NULL,</a>
<a name="ln2450">                                         first ? strlen(fname) : 0,</a>
<a name="ln2451">                                         0, first, path,</a>
<a name="ln2452">                                         find_what, curbuf-&gt;b_ffname,</a>
<a name="ln2453">                                         (find_what == FINDFILE_DIR</a>
<a name="ln2454">                                          ? (char_u *)&quot;&quot;</a>
<a name="ln2455">                                          : curbuf-&gt;b_p_sua));</a>
<a name="ln2456">      first = false;</a>
<a name="ln2457"> </a>
<a name="ln2458">      if (fresult != NULL &amp;&amp; rettv-&gt;v_type == VAR_LIST) {</a>
<a name="ln2459">        tv_list_append_string(rettv-&gt;vval.v_list, (const char *)fresult, -1);</a>
<a name="ln2460">      }</a>
<a name="ln2461">    } while ((rettv-&gt;v_type == VAR_LIST || --count &gt; 0) &amp;&amp; fresult != NULL);</a>
<a name="ln2462">  }</a>
<a name="ln2463"> </a>
<a name="ln2464">  if (rettv-&gt;v_type == VAR_STRING)</a>
<a name="ln2465">    rettv-&gt;vval.v_string = fresult;</a>
<a name="ln2466">}</a>
<a name="ln2467"> </a>
<a name="ln2468"> </a>
<a name="ln2469">/*</a>
<a name="ln2470"> * &quot;filter()&quot; function</a>
<a name="ln2471"> */</a>
<a name="ln2472">static void f_filter(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2473">{</a>
<a name="ln2474">  filter_map(argvars, rettv, FALSE);</a>
<a name="ln2475">}</a>
<a name="ln2476"> </a>
<a name="ln2477">/*</a>
<a name="ln2478"> * &quot;finddir({fname}[, {path}[, {count}]])&quot; function</a>
<a name="ln2479"> */</a>
<a name="ln2480">static void f_finddir(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2481">{</a>
<a name="ln2482">  findfilendir(argvars, rettv, FINDFILE_DIR);</a>
<a name="ln2483">}</a>
<a name="ln2484"> </a>
<a name="ln2485">/*</a>
<a name="ln2486"> * &quot;findfile({fname}[, {path}[, {count}]])&quot; function</a>
<a name="ln2487"> */</a>
<a name="ln2488">static void f_findfile(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2489">{</a>
<a name="ln2490">  findfilendir(argvars, rettv, FINDFILE_FILE);</a>
<a name="ln2491">}</a>
<a name="ln2492"> </a>
<a name="ln2493">/*</a>
<a name="ln2494"> * &quot;float2nr({float})&quot; function</a>
<a name="ln2495"> */</a>
<a name="ln2496">static void f_float2nr(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2497">{</a>
<a name="ln2498">  float_T f;</a>
<a name="ln2499"> </a>
<a name="ln2500">  if (tv_get_float_chk(argvars, &amp;f)) {</a>
<a name="ln2501">    if (f &lt;= (float_T)-VARNUMBER_MAX + DBL_EPSILON) {</a>
<a name="ln2502">      rettv-&gt;vval.v_number = -VARNUMBER_MAX;</a>
<a name="ln2503">    } else if (f &gt;= (float_T)VARNUMBER_MAX - DBL_EPSILON) {</a>
<a name="ln2504">      rettv-&gt;vval.v_number = VARNUMBER_MAX;</a>
<a name="ln2505">    } else {</a>
<a name="ln2506">      rettv-&gt;vval.v_number = (varnumber_T)f;</a>
<a name="ln2507">    }</a>
<a name="ln2508">  }</a>
<a name="ln2509">}</a>
<a name="ln2510"> </a>
<a name="ln2511">/*</a>
<a name="ln2512"> * &quot;fmod()&quot; function</a>
<a name="ln2513"> */</a>
<a name="ln2514">static void f_fmod(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2515">{</a>
<a name="ln2516">  float_T fx;</a>
<a name="ln2517">  float_T fy;</a>
<a name="ln2518"> </a>
<a name="ln2519">  rettv-&gt;v_type = VAR_FLOAT;</a>
<a name="ln2520">  if (tv_get_float_chk(argvars, &amp;fx) &amp;&amp; tv_get_float_chk(&amp;argvars[1], &amp;fy)) {</a>
<a name="ln2521">    rettv-&gt;vval.v_float = fmod(fx, fy);</a>
<a name="ln2522">  } else {</a>
<a name="ln2523">    rettv-&gt;vval.v_float = 0.0;</a>
<a name="ln2524">  }</a>
<a name="ln2525">}</a>
<a name="ln2526"> </a>
<a name="ln2527">/*</a>
<a name="ln2528"> * &quot;fnameescape({string})&quot; function</a>
<a name="ln2529"> */</a>
<a name="ln2530">static void f_fnameescape(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2531">{</a>
<a name="ln2532">  rettv-&gt;vval.v_string = (char_u *)vim_strsave_fnameescape(</a>
<a name="ln2533">      tv_get_string(&amp;argvars[0]), false);</a>
<a name="ln2534">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln2535">}</a>
<a name="ln2536"> </a>
<a name="ln2537">/*</a>
<a name="ln2538"> * &quot;fnamemodify({fname}, {mods})&quot; function</a>
<a name="ln2539"> */</a>
<a name="ln2540">static void f_fnamemodify(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2541">{</a>
<a name="ln2542">  char_u *fbuf = NULL;</a>
<a name="ln2543">  size_t len = 0;</a>
<a name="ln2544">  char buf[NUMBUFLEN];</a>
<a name="ln2545">  const char *fname = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln2546">  const char *const mods = tv_get_string_buf_chk(&amp;argvars[1], buf);</a>
<a name="ln2547">  if (fname == NULL || mods == NULL) {</a>
<a name="ln2548">    fname = NULL;</a>
<a name="ln2549">  } else {</a>
<a name="ln2550">    len = strlen(fname);</a>
<a name="ln2551">    size_t usedlen = 0;</a>
<a name="ln2552">    if (*mods != NUL) {</a>
<a name="ln2553">      (void)modify_fname((char_u *)mods, false, &amp;usedlen,</a>
<a name="ln2554">                         (char_u **)&amp;fname, &amp;fbuf, &amp;len);</a>
<a name="ln2555">    }</a>
<a name="ln2556">  }</a>
<a name="ln2557"> </a>
<a name="ln2558">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln2559">  if (fname == NULL) {</a>
<a name="ln2560">    rettv-&gt;vval.v_string = NULL;</a>
<a name="ln2561">  } else {</a>
<a name="ln2562">    rettv-&gt;vval.v_string = (char_u *)xmemdupz(fname, len);</a>
<a name="ln2563">  }</a>
<a name="ln2564">  xfree(fbuf);</a>
<a name="ln2565">}</a>
<a name="ln2566"> </a>
<a name="ln2567"> </a>
<a name="ln2568">/*</a>
<a name="ln2569"> * &quot;foldclosed()&quot; function</a>
<a name="ln2570"> */</a>
<a name="ln2571">static void foldclosed_both(typval_T *argvars, typval_T *rettv, int end)</a>
<a name="ln2572">{</a>
<a name="ln2573">  const linenr_T lnum = tv_get_lnum(argvars);</a>
<a name="ln2574">  if (lnum &gt;= 1 &amp;&amp; lnum &lt;= curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln2575">    linenr_T first;</a>
<a name="ln2576">    linenr_T last;</a>
<a name="ln2577">    if (hasFoldingWin(curwin, lnum, &amp;first, &amp;last, false, NULL)) {</a>
<a name="ln2578">      if (end) {</a>
<a name="ln2579">        rettv-&gt;vval.v_number = (varnumber_T)last;</a>
<a name="ln2580">      } else {</a>
<a name="ln2581">        rettv-&gt;vval.v_number = (varnumber_T)first;</a>
<a name="ln2582">      }</a>
<a name="ln2583">      return;</a>
<a name="ln2584">    }</a>
<a name="ln2585">  }</a>
<a name="ln2586">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln2587">}</a>
<a name="ln2588"> </a>
<a name="ln2589">/*</a>
<a name="ln2590"> * &quot;foldclosed()&quot; function</a>
<a name="ln2591"> */</a>
<a name="ln2592">static void f_foldclosed(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2593">{</a>
<a name="ln2594">  foldclosed_both(argvars, rettv, FALSE);</a>
<a name="ln2595">}</a>
<a name="ln2596"> </a>
<a name="ln2597">/*</a>
<a name="ln2598"> * &quot;foldclosedend()&quot; function</a>
<a name="ln2599"> */</a>
<a name="ln2600">static void f_foldclosedend(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2601">{</a>
<a name="ln2602">  foldclosed_both(argvars, rettv, TRUE);</a>
<a name="ln2603">}</a>
<a name="ln2604"> </a>
<a name="ln2605">/*</a>
<a name="ln2606"> * &quot;foldlevel()&quot; function</a>
<a name="ln2607"> */</a>
<a name="ln2608">static void f_foldlevel(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2609">{</a>
<a name="ln2610">  const linenr_T lnum = tv_get_lnum(argvars);</a>
<a name="ln2611">  if (lnum &gt;= 1 &amp;&amp; lnum &lt;= curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln2612">    rettv-&gt;vval.v_number = foldLevel(lnum);</a>
<a name="ln2613">  }</a>
<a name="ln2614">}</a>
<a name="ln2615"> </a>
<a name="ln2616">/*</a>
<a name="ln2617"> * &quot;foldtext()&quot; function</a>
<a name="ln2618"> */</a>
<a name="ln2619">static void f_foldtext(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2620">{</a>
<a name="ln2621">  linenr_T    foldstart;</a>
<a name="ln2622">  linenr_T    foldend;</a>
<a name="ln2623">  char_u      *dashes;</a>
<a name="ln2624">  linenr_T    lnum;</a>
<a name="ln2625">  char_u      *s;</a>
<a name="ln2626">  char_u      *r;</a>
<a name="ln2627">  int         len;</a>
<a name="ln2628">  char        *txt;</a>
<a name="ln2629"> </a>
<a name="ln2630">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln2631">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln2632"> </a>
<a name="ln2633">  foldstart = (linenr_T)get_vim_var_nr(VV_FOLDSTART);</a>
<a name="ln2634">  foldend = (linenr_T)get_vim_var_nr(VV_FOLDEND);</a>
<a name="ln2635">  dashes = get_vim_var_str(VV_FOLDDASHES);</a>
<a name="ln2636">  if (foldstart &gt; 0 &amp;&amp; foldend &lt;= curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln2637">    // Find first non-empty line in the fold.</a>
<a name="ln2638">    for (lnum = foldstart; lnum &lt; foldend; lnum++) {</a>
<a name="ln2639">      if (!linewhite(lnum)) {</a>
<a name="ln2640">        break;</a>
<a name="ln2641">      }</a>
<a name="ln2642">    }</a>
<a name="ln2643"> </a>
<a name="ln2644">    // Find interesting text in this line.</a>
<a name="ln2645">    s = skipwhite(ml_get(lnum));</a>
<a name="ln2646">    // skip C comment-start</a>
<a name="ln2647">    if (s[0] == '/' &amp;&amp; (s[1] == '*' || s[1] == '/')) {</a>
<a name="ln2648">      s = skipwhite(s + 2);</a>
<a name="ln2649">      if (*skipwhite(s) == NUL &amp;&amp; lnum + 1 &lt; foldend) {</a>
<a name="ln2650">        s = skipwhite(ml_get(lnum + 1));</a>
<a name="ln2651">        if (*s == '*')</a>
<a name="ln2652">          s = skipwhite(s + 1);</a>
<a name="ln2653">      }</a>
<a name="ln2654">    }</a>
<a name="ln2655">    unsigned long count = (unsigned long)(foldend - foldstart + 1);</a>
<a name="ln2656">    txt = NGETTEXT(&quot;+-%s%3ld line: &quot;, &quot;+-%s%3ld lines: &quot;, count);</a>
<a name="ln2657">    r = xmalloc(STRLEN(txt)</a>
<a name="ln2658">                + STRLEN(dashes)  // for %s</a>
<a name="ln2659">                + 20              // for %3ld</a>
<a name="ln2660">                + STRLEN(s));     // concatenated</a>
<a name="ln2661">    sprintf((char *)r, txt, dashes, count);</a>
<a name="ln2662">    len = (int)STRLEN(r);</a>
<a name="ln2663">    STRCAT(r, s);</a>
<a name="ln2664">    // remove 'foldmarker' and 'commentstring'</a>
<a name="ln2665">    foldtext_cleanup(r + len);</a>
<a name="ln2666">    rettv-&gt;vval.v_string = r;</a>
<a name="ln2667">  }</a>
<a name="ln2668">}</a>
<a name="ln2669"> </a>
<a name="ln2670">/*</a>
<a name="ln2671"> * &quot;foldtextresult(lnum)&quot; function</a>
<a name="ln2672"> */</a>
<a name="ln2673">static void f_foldtextresult(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2674">{</a>
<a name="ln2675">  char_u      *text;</a>
<a name="ln2676">  char_u buf[FOLD_TEXT_LEN];</a>
<a name="ln2677">  static bool entered = false;</a>
<a name="ln2678"> </a>
<a name="ln2679">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln2680">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln2681">  if (entered) {</a>
<a name="ln2682">    return;  // reject recursive use</a>
<a name="ln2683">  }</a>
<a name="ln2684">  entered = true;</a>
<a name="ln2685">  linenr_T lnum = tv_get_lnum(argvars);</a>
<a name="ln2686">  // Treat illegal types and illegal string values for {lnum} the same.</a>
<a name="ln2687">  if (lnum &lt; 0) {</a>
<a name="ln2688">    lnum = 0;</a>
<a name="ln2689">  }</a>
<a name="ln2690"> </a>
<a name="ln2691">  foldinfo_T info = fold_info(curwin, lnum);</a>
<a name="ln2692">  if (info.fi_lines &gt; 0) {</a>
<a name="ln2693">    text = get_foldtext(curwin, lnum, lnum + info.fi_lines - 1, info, buf);</a>
<a name="ln2694">    if (text == buf) {</a>
<a name="ln2695">      text = vim_strsave(text);</a>
<a name="ln2696">    }</a>
<a name="ln2697">    rettv-&gt;vval.v_string = text;</a>
<a name="ln2698">  }</a>
<a name="ln2699"> </a>
<a name="ln2700">  entered = false;</a>
<a name="ln2701">}</a>
<a name="ln2702"> </a>
<a name="ln2703">/*</a>
<a name="ln2704"> * &quot;foreground()&quot; function</a>
<a name="ln2705"> */</a>
<a name="ln2706">static void f_foreground(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2707">{</a>
<a name="ln2708">}</a>
<a name="ln2709"> </a>
<a name="ln2710">static void f_funcref(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2711">{</a>
<a name="ln2712">  common_function(argvars, rettv, true, fptr);</a>
<a name="ln2713">}</a>
<a name="ln2714"> </a>
<a name="ln2715">static void f_function(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2716">{</a>
<a name="ln2717">  common_function(argvars, rettv, false, fptr);</a>
<a name="ln2718">}</a>
<a name="ln2719"> </a>
<a name="ln2720">/// &quot;garbagecollect()&quot; function</a>
<a name="ln2721">static void f_garbagecollect(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2722">{</a>
<a name="ln2723">  // This is postponed until we are back at the toplevel, because we may be</a>
<a name="ln2724">  // using Lists and Dicts internally.  E.g.: &quot;:echo [garbagecollect()]&quot;.</a>
<a name="ln2725">  want_garbage_collect = true;</a>
<a name="ln2726"> </a>
<a name="ln2727">  if (argvars[0].v_type != VAR_UNKNOWN &amp;&amp; tv_get_number(&amp;argvars[0]) == 1) {</a>
<a name="ln2728">    garbage_collect_at_exit = true;</a>
<a name="ln2729">  }</a>
<a name="ln2730">}</a>
<a name="ln2731"> </a>
<a name="ln2732">/*</a>
<a name="ln2733"> * &quot;get()&quot; function</a>
<a name="ln2734"> */</a>
<a name="ln2735">static void f_get(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2736">{</a>
<a name="ln2737">  listitem_T  *li;</a>
<a name="ln2738">  list_T      *l;</a>
<a name="ln2739">  dictitem_T  *di;</a>
<a name="ln2740">  dict_T      *d;</a>
<a name="ln2741">  typval_T    *tv = NULL;</a>
<a name="ln2742">  bool what_is_dict = false;</a>
<a name="ln2743"> </a>
<a name="ln2744">  if (argvars[0].v_type == VAR_LIST) {</a>
<a name="ln2745">    if ((l = argvars[0].vval.v_list) != NULL) {</a>
<a name="ln2746">      bool error = false;</a>
<a name="ln2747"> </a>
<a name="ln2748">      li = tv_list_find(l, tv_get_number_chk(&amp;argvars[1], &amp;error));</a>
<a name="ln2749">      if (!error &amp;&amp; li != NULL) {</a>
<a name="ln2750">        tv = TV_LIST_ITEM_TV(li);</a>
<a name="ln2751">      }</a>
<a name="ln2752">    }</a>
<a name="ln2753">  } else if (argvars[0].v_type == VAR_DICT) {</a>
<a name="ln2754">    if ((d = argvars[0].vval.v_dict) != NULL) {</a>
<a name="ln2755">      di = tv_dict_find(d, tv_get_string(&amp;argvars[1]), -1);</a>
<a name="ln2756">      if (di != NULL) {</a>
<a name="ln2757">        tv = &amp;di-&gt;di_tv;</a>
<a name="ln2758">      }</a>
<a name="ln2759">    }</a>
<a name="ln2760">  } else if (tv_is_func(argvars[0])) {</a>
<a name="ln2761">    partial_T *pt;</a>
<a name="ln2762">    partial_T fref_pt;</a>
<a name="ln2763"> </a>
<a name="ln2764">    if (argvars[0].v_type == VAR_PARTIAL) {</a>
<a name="ln2765">      pt = argvars[0].vval.v_partial;</a>
<a name="ln2766">    } else {</a>
<a name="ln2767">      memset(&amp;fref_pt, 0, sizeof(fref_pt));</a>
<a name="ln2768">      fref_pt.pt_name = argvars[0].vval.v_string;</a>
<a name="ln2769">      pt = &amp;fref_pt;</a>
<a name="ln2770">    }</a>
<a name="ln2771"> </a>
<a name="ln2772">    if (pt != NULL) {</a>
<a name="ln2773">      const char *const what = tv_get_string(&amp;argvars[1]);</a>
<a name="ln2774"> </a>
<a name="ln2775">      if (strcmp(what, &quot;func&quot;) == 0 || strcmp(what, &quot;name&quot;) == 0) {</a>
<a name="ln2776">        rettv-&gt;v_type = (*what == 'f' ? VAR_FUNC : VAR_STRING);</a>
<a name="ln2777">        const char *const n = (const char *)partial_name(pt);</a>
<a name="ln2778">        assert(n != NULL);</a>
<a name="ln2779">        rettv-&gt;vval.v_string = (char_u *)xstrdup(n);</a>
<a name="ln2780">        if (rettv-&gt;v_type == VAR_FUNC) {</a>
<a name="ln2781">          func_ref(rettv-&gt;vval.v_string);</a>
<a name="ln2782">        }</a>
<a name="ln2783">      } else if (strcmp(what, &quot;dict&quot;) == 0) {</a>
<a name="ln2784">        what_is_dict = true;</a>
<a name="ln2785">        if (pt-&gt;pt_dict != NULL) {</a>
<a name="ln2786">          tv_dict_set_ret(rettv, pt-&gt;pt_dict);</a>
<a name="ln2787">        }</a>
<a name="ln2788">      } else if (strcmp(what, &quot;args&quot;) == 0) {</a>
<a name="ln2789">        rettv-&gt;v_type = VAR_LIST;</a>
<a name="ln2790">        tv_list_alloc_ret(rettv, pt-&gt;pt_argc);</a>
<a name="ln2791">        for (int i = 0; i &lt; pt-&gt;pt_argc; i++) {</a>
<a name="ln2792">          tv_list_append_tv(rettv-&gt;vval.v_list, &amp;pt-&gt;pt_argv[i]);</a>
<a name="ln2793">        }</a>
<a name="ln2794">      } else {</a>
<a name="ln2795">        EMSG2(_(e_invarg2), what);</a>
<a name="ln2796">      }</a>
<a name="ln2797"> </a>
<a name="ln2798">      // When {what} == &quot;dict&quot; and pt-&gt;pt_dict == NULL, evaluate the</a>
<a name="ln2799">      // third argument</a>
<a name="ln2800">      if (!what_is_dict) {</a>
<a name="ln2801">        return;</a>
<a name="ln2802">      }</a>
<a name="ln2803">    }</a>
<a name="ln2804">  } else {</a>
<a name="ln2805">    EMSG2(_(e_listdictarg), &quot;get()&quot;);</a>
<a name="ln2806">  }</a>
<a name="ln2807"> </a>
<a name="ln2808">  if (tv == NULL) {</a>
<a name="ln2809">    if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln2810">      tv_copy(&amp;argvars[2], rettv);</a>
<a name="ln2811">    }</a>
<a name="ln2812">  } else {</a>
<a name="ln2813">    tv_copy(tv, rettv);</a>
<a name="ln2814">  }</a>
<a name="ln2815">}</a>
<a name="ln2816"> </a>
<a name="ln2817">/// &quot;getbufinfo()&quot; function</a>
<a name="ln2818">static void f_getbufinfo(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2819">{</a>
<a name="ln2820">  buf_T *argbuf = NULL;</a>
<a name="ln2821">  bool filtered = false;</a>
<a name="ln2822">  bool sel_buflisted = false;</a>
<a name="ln2823">  bool sel_bufloaded = false;</a>
<a name="ln2824">  bool sel_bufmodified = false;</a>
<a name="ln2825"> </a>
<a name="ln2826">  tv_list_alloc_ret(rettv, kListLenMayKnow);</a>
<a name="ln2827"> </a>
<a name="ln2828">  // List of all the buffers or selected buffers</a>
<a name="ln2829">  if (argvars[0].v_type == VAR_DICT) {</a>
<a name="ln2830">    dict_T *sel_d = argvars[0].vval.v_dict;</a>
<a name="ln2831"> </a>
<a name="ln2832">    if (sel_d != NULL) {</a>
<a name="ln2833">      dictitem_T *di;</a>
<a name="ln2834"> </a>
<a name="ln2835">      filtered = true;</a>
<a name="ln2836"> </a>
<a name="ln2837">      di = tv_dict_find(sel_d, S_LEN(&quot;buflisted&quot;));</a>
<a name="ln2838">      if (di != NULL &amp;&amp; tv_get_number(&amp;di-&gt;di_tv)) {</a>
<a name="ln2839">        sel_buflisted = true;</a>
<a name="ln2840">      }</a>
<a name="ln2841"> </a>
<a name="ln2842">      di = tv_dict_find(sel_d, S_LEN(&quot;bufloaded&quot;));</a>
<a name="ln2843">      if (di != NULL &amp;&amp; tv_get_number(&amp;di-&gt;di_tv)) {</a>
<a name="ln2844">        sel_bufloaded = true;</a>
<a name="ln2845">      }</a>
<a name="ln2846">      di = tv_dict_find(sel_d, S_LEN(&quot;bufmodified&quot;));</a>
<a name="ln2847">      if (di != NULL &amp;&amp; tv_get_number(&amp;di-&gt;di_tv)) {</a>
<a name="ln2848">        sel_bufmodified = true;</a>
<a name="ln2849">      }</a>
<a name="ln2850">    }</a>
<a name="ln2851">  } else if (argvars[0].v_type != VAR_UNKNOWN) {</a>
<a name="ln2852">    // Information about one buffer.  Argument specifies the buffer</a>
<a name="ln2853">    argbuf = tv_get_buf_from_arg(&amp;argvars[0]);</a>
<a name="ln2854">    if (argbuf == NULL) {</a>
<a name="ln2855">      return;</a>
<a name="ln2856">    }</a>
<a name="ln2857">  }</a>
<a name="ln2858"> </a>
<a name="ln2859">  // Return information about all the buffers or a specified buffer</a>
<a name="ln2860">  FOR_ALL_BUFFERS(buf) {</a>
<a name="ln2861">    if (argbuf != NULL &amp;&amp; argbuf != buf) {</a>
<a name="ln2862">      continue;</a>
<a name="ln2863">    }</a>
<a name="ln2864">    if (filtered &amp;&amp; ((sel_bufloaded &amp;&amp; buf-&gt;b_ml.ml_mfp == NULL)</a>
<a name="ln2865">                     || (sel_buflisted &amp;&amp; !buf-&gt;b_p_bl)</a>
<a name="ln2866">                     || (sel_bufmodified &amp;&amp; !buf-&gt;b_changed))) {</a>
<a name="ln2867">      continue;</a>
<a name="ln2868">    }</a>
<a name="ln2869"> </a>
<a name="ln2870">    dict_T *const d = get_buffer_info(buf);</a>
<a name="ln2871">    tv_list_append_dict(rettv-&gt;vval.v_list, d);</a>
<a name="ln2872">    if (argbuf != NULL) {</a>
<a name="ln2873">      return;</a>
<a name="ln2874">    }</a>
<a name="ln2875">  }</a>
<a name="ln2876">}</a>
<a name="ln2877"> </a>
<a name="ln2878">/*</a>
<a name="ln2879"> * Get line or list of lines from buffer &quot;buf&quot; into &quot;rettv&quot;.</a>
<a name="ln2880"> * Return a range (from start to end) of lines in rettv from the specified</a>
<a name="ln2881"> * buffer.</a>
<a name="ln2882"> * If 'retlist' is TRUE, then the lines are returned as a Vim List.</a>
<a name="ln2883"> */</a>
<a name="ln2884">static void get_buffer_lines(buf_T *buf,</a>
<a name="ln2885">                             linenr_T start,</a>
<a name="ln2886">                             linenr_T end,</a>
<a name="ln2887">                             int retlist,</a>
<a name="ln2888">                             typval_T *rettv)</a>
<a name="ln2889">{</a>
<a name="ln2890">  rettv-&gt;v_type = (retlist ? VAR_LIST : VAR_STRING);</a>
<a name="ln2891">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln2892"> </a>
<a name="ln2893">  if (buf == NULL || buf-&gt;b_ml.ml_mfp == NULL || start &lt; 0 || end &lt; start) {</a>
<a name="ln2894">    if (retlist) {</a>
<a name="ln2895">      tv_list_alloc_ret(rettv, 0);</a>
<a name="ln2896">    }</a>
<a name="ln2897">    return;</a>
<a name="ln2898">  }</a>
<a name="ln2899"> </a>
<a name="ln2900">  if (retlist) {</a>
<a name="ln2901">    if (start &lt; 1) {</a>
<a name="ln2902">      start = 1;</a>
<a name="ln2903">    }</a>
<a name="ln2904">    if (end &gt; buf-&gt;b_ml.ml_line_count) {</a>
<a name="ln2905">      end = buf-&gt;b_ml.ml_line_count;</a>
<a name="ln2906">    }</a>
<a name="ln2907">    tv_list_alloc_ret(rettv, end - start + 1);</a>
<a name="ln2908">    while (start &lt;= end) {</a>
<a name="ln2909">      tv_list_append_string(rettv-&gt;vval.v_list,</a>
<a name="ln2910">                            (const char *)ml_get_buf(buf, start++, false), -1);</a>
<a name="ln2911">    }</a>
<a name="ln2912">  } else {</a>
<a name="ln2913">    rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln2914">    rettv-&gt;vval.v_string = ((start &gt;= 1 &amp;&amp; start &lt;= buf-&gt;b_ml.ml_line_count)</a>
<a name="ln2915">                            ? vim_strsave(ml_get_buf(buf, start, false))</a>
<a name="ln2916">                            : NULL);</a>
<a name="ln2917">  }</a>
<a name="ln2918">}</a>
<a name="ln2919"> </a>
<a name="ln2920">/*</a>
<a name="ln2921"> * &quot;getbufline()&quot; function</a>
<a name="ln2922"> */</a>
<a name="ln2923">static void f_getbufline(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2924">{</a>
<a name="ln2925">  buf_T *const buf = tv_get_buf_from_arg(&amp;argvars[0]);</a>
<a name="ln2926"> </a>
<a name="ln2927">  const linenr_T lnum = tv_get_lnum_buf(&amp;argvars[1], buf);</a>
<a name="ln2928">  const linenr_T end = (argvars[2].v_type == VAR_UNKNOWN</a>
<a name="ln2929">                        ? lnum</a>
<a name="ln2930">                        : tv_get_lnum_buf(&amp;argvars[2], buf));</a>
<a name="ln2931"> </a>
<a name="ln2932">  get_buffer_lines(buf, lnum, end, true, rettv);</a>
<a name="ln2933">}</a>
<a name="ln2934"> </a>
<a name="ln2935">/*</a>
<a name="ln2936"> * &quot;getbufvar()&quot; function</a>
<a name="ln2937"> */</a>
<a name="ln2938">static void f_getbufvar(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2939">{</a>
<a name="ln2940">  bool done = false;</a>
<a name="ln2941"> </a>
<a name="ln2942">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln2943">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln2944"> </a>
<a name="ln2945">  if (!tv_check_str_or_nr(&amp;argvars[0])) {</a>
<a name="ln2946">    goto f_getbufvar_end;</a>
<a name="ln2947">  }</a>
<a name="ln2948"> </a>
<a name="ln2949">  const char *varname = tv_get_string_chk(&amp;argvars[1]);</a>
<a name="ln2950">  emsg_off++;</a>
<a name="ln2951">  buf_T *const buf = tv_get_buf(&amp;argvars[0], false);</a>
<a name="ln2952"> </a>
<a name="ln2953">  if (buf != NULL &amp;&amp; varname != NULL) {</a>
<a name="ln2954">    if (*varname == '&amp;') {  // buffer-local-option</a>
<a name="ln2955">      buf_T *const save_curbuf = curbuf;</a>
<a name="ln2956"> </a>
<a name="ln2957">      // set curbuf to be our buf, temporarily</a>
<a name="ln2958">      curbuf = buf;</a>
<a name="ln2959"> </a>
<a name="ln2960">      if (varname[1] == NUL) {</a>
<a name="ln2961">        // get all buffer-local options in a dict</a>
<a name="ln2962">        dict_T *opts = get_winbuf_options(true);</a>
<a name="ln2963"> </a>
<a name="ln2964">        if (opts != NULL) {</a>
<a name="ln2965">          tv_dict_set_ret(rettv, opts);</a>
<a name="ln2966">          done = true;</a>
<a name="ln2967">        }</a>
<a name="ln2968">      } else if (get_option_tv(&amp;varname, rettv, true) == OK) {</a>
<a name="ln2969">        // buffer-local-option</a>
<a name="ln2970">        done = true;</a>
<a name="ln2971">      }</a>
<a name="ln2972"> </a>
<a name="ln2973">      // restore previous notion of curbuf</a>
<a name="ln2974">      curbuf = save_curbuf;</a>
<a name="ln2975">    } else {</a>
<a name="ln2976">      // Look up the variable.</a>
<a name="ln2977">      // Let getbufvar({nr}, &quot;&quot;) return the &quot;b:&quot; dictionary.</a>
<a name="ln2978">      dictitem_T *const v = *varname == NUL</a>
<a name="ln2979">        ? (dictitem_T *)&amp;buf-&gt;b_bufvar</a>
<a name="ln2980">        : find_var_in_ht(&amp;buf-&gt;b_vars-&gt;dv_hashtab, 'b',</a>
<a name="ln2981">                         varname, strlen(varname), false);</a>
<a name="ln2982">      if (v != NULL) {</a>
<a name="ln2983">        tv_copy(&amp;v-&gt;di_tv, rettv);</a>
<a name="ln2984">        done = true;</a>
<a name="ln2985">      }</a>
<a name="ln2986">    }</a>
<a name="ln2987">  }</a>
<a name="ln2988">  emsg_off--;</a>
<a name="ln2989"> </a>
<a name="ln2990">f_getbufvar_end:</a>
<a name="ln2991">  if (!done &amp;&amp; argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln2992">    // use the default value</a>
<a name="ln2993">    tv_copy(&amp;argvars[2], rettv);</a>
<a name="ln2994">  }</a>
<a name="ln2995">}</a>
<a name="ln2996"> </a>
<a name="ln2997">// &quot;getchangelist()&quot; function</a>
<a name="ln2998">static void f_getchangelist(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2999">{</a>
<a name="ln3000">  tv_list_alloc_ret(rettv, 2);</a>
<a name="ln3001">  vim_ignored = tv_get_number(&amp;argvars[0]);  // issue errmsg if type error</a>
<a name="ln3002">  emsg_off++;</a>
<a name="ln3003">  const buf_T *const buf = tv_get_buf(&amp;argvars[0], false);</a>
<a name="ln3004">  emsg_off--;</a>
<a name="ln3005">  if (buf == NULL) {</a>
<a name="ln3006">    return;</a>
<a name="ln3007">  }</a>
<a name="ln3008"> </a>
<a name="ln3009">  list_T *const l = tv_list_alloc(buf-&gt;b_changelistlen);</a>
<a name="ln3010">  tv_list_append_list(rettv-&gt;vval.v_list, l);</a>
<a name="ln3011">  // The current window change list index tracks only the position in the</a>
<a name="ln3012">  // current buffer change list. For other buffers, use the change list</a>
<a name="ln3013">  // length as the current index.</a>
<a name="ln3014">  tv_list_append_number(rettv-&gt;vval.v_list,</a>
<a name="ln3015">                        (buf == curwin-&gt;w_buffer)</a>
<a name="ln3016">                        ? curwin-&gt;w_changelistidx</a>
<a name="ln3017">                        : buf-&gt;b_changelistlen);</a>
<a name="ln3018"> </a>
<a name="ln3019">  for (int i = 0; i &lt; buf-&gt;b_changelistlen; i++) {</a>
<a name="ln3020">    if (buf-&gt;b_changelist[i].mark.lnum == 0) {</a>
<a name="ln3021">      continue;</a>
<a name="ln3022">    }</a>
<a name="ln3023">    dict_T *const d = tv_dict_alloc();</a>
<a name="ln3024">    tv_list_append_dict(l, d);</a>
<a name="ln3025">    tv_dict_add_nr(d, S_LEN(&quot;lnum&quot;), buf-&gt;b_changelist[i].mark.lnum);</a>
<a name="ln3026">    tv_dict_add_nr(d, S_LEN(&quot;col&quot;), buf-&gt;b_changelist[i].mark.col);</a>
<a name="ln3027">    tv_dict_add_nr(d, S_LEN(&quot;coladd&quot;), buf-&gt;b_changelist[i].mark.coladd);</a>
<a name="ln3028">  }</a>
<a name="ln3029">}</a>
<a name="ln3030"> </a>
<a name="ln3031">/*</a>
<a name="ln3032"> * &quot;getchar()&quot; function</a>
<a name="ln3033"> */</a>
<a name="ln3034">static void f_getchar(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3035">{</a>
<a name="ln3036">  varnumber_T n;</a>
<a name="ln3037">  bool error = false;</a>
<a name="ln3038"> </a>
<a name="ln3039">  no_mapping++;</a>
<a name="ln3040">  for (;; ) {</a>
<a name="ln3041">    // Position the cursor.  Needed after a message that ends in a space,</a>
<a name="ln3042">    // or if event processing caused a redraw.</a>
<a name="ln3043">    ui_cursor_goto(msg_row, msg_col);</a>
<a name="ln3044"> </a>
<a name="ln3045">    if (argvars[0].v_type == VAR_UNKNOWN) {</a>
<a name="ln3046">      // getchar(): blocking wait.</a>
<a name="ln3047">      // TODO(bfredl): deduplicate shared logic with state_enter ?</a>
<a name="ln3048">      if (!(char_avail() || using_script() || input_available())) {</a>
<a name="ln3049">        (void)os_inchar(NULL, 0, -1, 0, main_loop.events);</a>
<a name="ln3050">        if (!multiqueue_empty(main_loop.events)) {</a>
<a name="ln3051">          state_handle_k_event();</a>
<a name="ln3052">          continue;</a>
<a name="ln3053">        }</a>
<a name="ln3054">      }</a>
<a name="ln3055">      n = safe_vgetc();</a>
<a name="ln3056">    } else if (tv_get_number_chk(&amp;argvars[0], &amp;error) == 1) {</a>
<a name="ln3057">      // getchar(1): only check if char avail</a>
<a name="ln3058">      n = vpeekc_any();</a>
<a name="ln3059">    } else if (error || vpeekc_any() == NUL) {</a>
<a name="ln3060">      // illegal argument or getchar(0) and no char avail: return zero</a>
<a name="ln3061">      n = 0;</a>
<a name="ln3062">    } else {</a>
<a name="ln3063">      // getchar(0) and char avail() != NUL: get a character.</a>
<a name="ln3064">      // Note that vpeekc_any() returns K_SPECIAL for K_IGNORE.</a>
<a name="ln3065">      n = safe_vgetc();</a>
<a name="ln3066">    }</a>
<a name="ln3067"> </a>
<a name="ln3068">    if (n == K_IGNORE</a>
<a name="ln3069">        || n == K_MOUSEMOVE</a>
<a name="ln3070">        || n == K_VER_SCROLLBAR</a>
<a name="ln3071">        || n == K_HOR_SCROLLBAR) {</a>
<a name="ln3072">      continue;</a>
<a name="ln3073">    }</a>
<a name="ln3074">    break;</a>
<a name="ln3075">  }</a>
<a name="ln3076">  no_mapping--;</a>
<a name="ln3077"> </a>
<a name="ln3078">  set_vim_var_nr(VV_MOUSE_WIN, 0);</a>
<a name="ln3079">  set_vim_var_nr(VV_MOUSE_WINID, 0);</a>
<a name="ln3080">  set_vim_var_nr(VV_MOUSE_LNUM, 0);</a>
<a name="ln3081">  set_vim_var_nr(VV_MOUSE_COL, 0);</a>
<a name="ln3082"> </a>
<a name="ln3083">  rettv-&gt;vval.v_number = n;</a>
<a name="ln3084">  if (IS_SPECIAL(n) || mod_mask != 0) {</a>
<a name="ln3085">    char_u temp[10];                // modifier: 3, mbyte-char: 6, NUL: 1</a>
<a name="ln3086">    int i = 0;</a>
<a name="ln3087"> </a>
<a name="ln3088">    // Turn a special key into three bytes, plus modifier.</a>
<a name="ln3089">    if (mod_mask != 0) {</a>
<a name="ln3090">      temp[i++] = K_SPECIAL;</a>
<a name="ln3091">      temp[i++] = KS_MODIFIER;</a>
<a name="ln3092">      temp[i++] = mod_mask;</a>
<a name="ln3093">    }</a>
<a name="ln3094">    if (IS_SPECIAL(n)) {</a>
<a name="ln3095">      temp[i++] = K_SPECIAL;</a>
<a name="ln3096">      temp[i++] = K_SECOND(n);</a>
<a name="ln3097">      temp[i++] = K_THIRD(n);</a>
<a name="ln3098">    } else {</a>
<a name="ln3099">      i += utf_char2bytes(n, temp + i);</a>
<a name="ln3100">    }</a>
<a name="ln3101">    temp[i++] = NUL;</a>
<a name="ln3102">    rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln3103">    rettv-&gt;vval.v_string = vim_strsave(temp);</a>
<a name="ln3104"> </a>
<a name="ln3105">    if (is_mouse_key(n)) {</a>
<a name="ln3106">      int row = mouse_row;</a>
<a name="ln3107">      int col = mouse_col;</a>
<a name="ln3108">      int grid = mouse_grid;</a>
<a name="ln3109">      win_T       *win;</a>
<a name="ln3110">      linenr_T lnum;</a>
<a name="ln3111">      win_T       *wp;</a>
<a name="ln3112">      int winnr = 1;</a>
<a name="ln3113"> </a>
<a name="ln3114">      if (row &gt;= 0 &amp;&amp; col &gt;= 0) {</a>
<a name="ln3115">        /* Find the window at the mouse coordinates and compute the</a>
<a name="ln3116">         * text position. */</a>
<a name="ln3117">        win = mouse_find_win(&amp;grid, &amp;row, &amp;col);</a>
<a name="ln3118">        if (win == NULL) {</a>
<a name="ln3119">          return;</a>
<a name="ln3120">        }</a>
<a name="ln3121">        (void)mouse_comp_pos(win, &amp;row, &amp;col, &amp;lnum);</a>
<a name="ln3122">        for (wp = firstwin; wp != win; wp = wp-&gt;w_next)</a>
<a name="ln3123">          ++winnr;</a>
<a name="ln3124">        set_vim_var_nr(VV_MOUSE_WIN, winnr);</a>
<a name="ln3125">        set_vim_var_nr(VV_MOUSE_WINID, wp-&gt;handle);</a>
<a name="ln3126">        set_vim_var_nr(VV_MOUSE_LNUM, lnum);</a>
<a name="ln3127">        set_vim_var_nr(VV_MOUSE_COL, col + 1);</a>
<a name="ln3128">      }</a>
<a name="ln3129">    }</a>
<a name="ln3130">  }</a>
<a name="ln3131">}</a>
<a name="ln3132"> </a>
<a name="ln3133">/*</a>
<a name="ln3134"> * &quot;getcharmod()&quot; function</a>
<a name="ln3135"> */</a>
<a name="ln3136">static void f_getcharmod(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3137">{</a>
<a name="ln3138">  rettv-&gt;vval.v_number = mod_mask;</a>
<a name="ln3139">}</a>
<a name="ln3140"> </a>
<a name="ln3141">/*</a>
<a name="ln3142"> * &quot;getcharsearch()&quot; function</a>
<a name="ln3143"> */</a>
<a name="ln3144">static void f_getcharsearch(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3145">{</a>
<a name="ln3146">  tv_dict_alloc_ret(rettv);</a>
<a name="ln3147"> </a>
<a name="ln3148">  dict_T *dict = rettv-&gt;vval.v_dict;</a>
<a name="ln3149"> </a>
<a name="ln3150">  tv_dict_add_str(dict, S_LEN(&quot;char&quot;), last_csearch());</a>
<a name="ln3151">  tv_dict_add_nr(dict, S_LEN(&quot;forward&quot;), last_csearch_forward());</a>
<a name="ln3152">  tv_dict_add_nr(dict, S_LEN(&quot;until&quot;), last_csearch_until());</a>
<a name="ln3153">}</a>
<a name="ln3154"> </a>
<a name="ln3155">/*</a>
<a name="ln3156"> * &quot;getcmdline()&quot; function</a>
<a name="ln3157"> */</a>
<a name="ln3158">static void f_getcmdline(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3159">{</a>
<a name="ln3160">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln3161">  rettv-&gt;vval.v_string = get_cmdline_str();</a>
<a name="ln3162">}</a>
<a name="ln3163"> </a>
<a name="ln3164">/*</a>
<a name="ln3165"> * &quot;getcmdpos()&quot; function</a>
<a name="ln3166"> */</a>
<a name="ln3167">static void f_getcmdpos(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3168">{</a>
<a name="ln3169">  rettv-&gt;vval.v_number = get_cmdline_pos() + 1;</a>
<a name="ln3170">}</a>
<a name="ln3171"> </a>
<a name="ln3172">/*</a>
<a name="ln3173"> * &quot;getcmdtype()&quot; function</a>
<a name="ln3174"> */</a>
<a name="ln3175">static void f_getcmdtype(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3176">{</a>
<a name="ln3177">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln3178">  rettv-&gt;vval.v_string = xmallocz(1);</a>
<a name="ln3179">  rettv-&gt;vval.v_string[0] = get_cmdline_type();</a>
<a name="ln3180">}</a>
<a name="ln3181"> </a>
<a name="ln3182">/*</a>
<a name="ln3183"> * &quot;getcmdwintype()&quot; function</a>
<a name="ln3184"> */</a>
<a name="ln3185">static void f_getcmdwintype(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3186">{</a>
<a name="ln3187">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln3188">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln3189">  rettv-&gt;vval.v_string = xmallocz(1);</a>
<a name="ln3190">  rettv-&gt;vval.v_string[0] = cmdwin_type;</a>
<a name="ln3191">}</a>
<a name="ln3192"> </a>
<a name="ln3193">// &quot;getcompletion()&quot; function</a>
<a name="ln3194">static void f_getcompletion(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3195">{</a>
<a name="ln3196">  char_u        *pat;</a>
<a name="ln3197">  expand_T      xpc;</a>
<a name="ln3198">  bool          filtered = false;</a>
<a name="ln3199">  int           options = WILD_SILENT | WILD_USE_NL | WILD_ADD_SLASH</a>
<a name="ln3200">          | WILD_NO_BEEP;</a>
<a name="ln3201"> </a>
<a name="ln3202">  if (argvars[1].v_type != VAR_STRING) {</a>
<a name="ln3203">    EMSG2(_(e_invarg2), &quot;type must be a string&quot;);</a>
<a name="ln3204">    return;</a>
<a name="ln3205">  }</a>
<a name="ln3206">  const char *const type = tv_get_string(&amp;argvars[1]);</a>
<a name="ln3207"> </a>
<a name="ln3208">  if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln3209">    filtered = (bool)tv_get_number_chk(&amp;argvars[2], NULL);</a>
<a name="ln3210">  }</a>
<a name="ln3211"> </a>
<a name="ln3212">  if (p_wic) {</a>
<a name="ln3213">    options |= WILD_ICASE;</a>
<a name="ln3214">  }</a>
<a name="ln3215"> </a>
<a name="ln3216">  // For filtered results, 'wildignore' is used</a>
<a name="ln3217">  if (!filtered) {</a>
<a name="ln3218">    options |= WILD_KEEP_ALL;</a>
<a name="ln3219">  }</a>
<a name="ln3220"> </a>
<a name="ln3221">  if (argvars[0].v_type != VAR_STRING) {</a>
<a name="ln3222">    EMSG(_(e_invarg));</a>
<a name="ln3223">    return;</a>
<a name="ln3224">  }</a>
<a name="ln3225"> </a>
<a name="ln3226">  if (strcmp(type, &quot;cmdline&quot;) == 0) {</a>
<a name="ln3227">    set_one_cmd_context(&amp;xpc, tv_get_string(&amp;argvars[0]));</a>
<a name="ln3228">    xpc.xp_pattern_len = STRLEN(xpc.xp_pattern);</a>
<a name="ln3229">    goto theend;</a>
<a name="ln3230">  }</a>
<a name="ln3231"> </a>
<a name="ln3232">  ExpandInit(&amp;xpc);</a>
<a name="ln3233">  xpc.xp_pattern = (char_u *)tv_get_string(&amp;argvars[0]);</a>
<a name="ln3234">  xpc.xp_pattern_len = STRLEN(xpc.xp_pattern);</a>
<a name="ln3235">  xpc.xp_context = cmdcomplete_str_to_type(type);</a>
<a name="ln3236">  if (xpc.xp_context == EXPAND_NOTHING) {</a>
<a name="ln3237">    EMSG2(_(e_invarg2), type);</a>
<a name="ln3238">    return;</a>
<a name="ln3239">  }</a>
<a name="ln3240"> </a>
<a name="ln3241">  if (xpc.xp_context == EXPAND_MENUS) {</a>
<a name="ln3242">    set_context_in_menu_cmd(&amp;xpc, &quot;menu&quot;, xpc.xp_pattern, false);</a>
<a name="ln3243">    xpc.xp_pattern_len = STRLEN(xpc.xp_pattern);</a>
<a name="ln3244">  }</a>
<a name="ln3245"> </a>
<a name="ln3246">  if (xpc.xp_context == EXPAND_CSCOPE) {</a>
<a name="ln3247">    set_context_in_cscope_cmd(&amp;xpc, (const char *)xpc.xp_pattern, CMD_cscope);</a>
<a name="ln3248">    xpc.xp_pattern_len = STRLEN(xpc.xp_pattern);</a>
<a name="ln3249">  }</a>
<a name="ln3250"> </a>
<a name="ln3251">  if (xpc.xp_context == EXPAND_SIGN) {</a>
<a name="ln3252">    set_context_in_sign_cmd(&amp;xpc, xpc.xp_pattern);</a>
<a name="ln3253">    xpc.xp_pattern_len = STRLEN(xpc.xp_pattern);</a>
<a name="ln3254">  }</a>
<a name="ln3255"> </a>
<a name="ln3256">theend:</a>
<a name="ln3257">  pat = addstar(xpc.xp_pattern, xpc.xp_pattern_len, xpc.xp_context);</a>
<a name="ln3258">  ExpandOne(&amp;xpc, pat, NULL, options, WILD_ALL_KEEP);</a>
<a name="ln3259">  tv_list_alloc_ret(rettv, xpc.xp_numfiles);</a>
<a name="ln3260"> </a>
<a name="ln3261">  for (int i = 0; i &lt; xpc.xp_numfiles; i++) {</a>
<a name="ln3262">    tv_list_append_string(rettv-&gt;vval.v_list, (const char *)xpc.xp_files[i],</a>
<a name="ln3263">                          -1);</a>
<a name="ln3264">  }</a>
<a name="ln3265">  xfree(pat);</a>
<a name="ln3266">  ExpandCleanup(&amp;xpc);</a>
<a name="ln3267">}</a>
<a name="ln3268"> </a>
<a name="ln3269">/// `getcwd([{win}[, {tab}]])` function</a>
<a name="ln3270">///</a>
<a name="ln3271">/// Every scope not specified implies the currently selected scope object.</a>
<a name="ln3272">///</a>
<a name="ln3273">/// @pre  The arguments must be of type number.</a>
<a name="ln3274">/// @pre  There may not be more than two arguments.</a>
<a name="ln3275">/// @pre  An argument may not be -1 if preceding arguments are not all -1.</a>
<a name="ln3276">///</a>
<a name="ln3277">/// @post  The return value will be a string.</a>
<a name="ln3278">static void f_getcwd(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3279">{</a>
<a name="ln3280">  // Possible scope of working directory to return.</a>
<a name="ln3281">  CdScope scope = kCdScopeInvalid;</a>
<a name="ln3282"> </a>
<a name="ln3283">  // Numbers of the scope objects (window, tab) we want the working directory</a>
<a name="ln3284">  // of. A `-1` means to skip this scope, a `0` means the current object.</a>
<a name="ln3285">  int scope_number[] = {</a>
<a name="ln3286">    [kCdScopeWindow] = 0,  // Number of window to look at.</a>
<a name="ln3287">    [kCdScopeTab   ] = 0,  // Number of tab to look at.</a>
<a name="ln3288">  };</a>
<a name="ln3289"> </a>
<a name="ln3290">  char_u *cwd  = NULL;  // Current working directory to print</a>
<a name="ln3291">  char_u *from = NULL;  // The original string to copy</a>
<a name="ln3292"> </a>
<a name="ln3293">  tabpage_T *tp  = curtab;  // The tabpage to look at.</a>
<a name="ln3294">  win_T     *win = curwin;  // The window to look at.</a>
<a name="ln3295"> </a>
<a name="ln3296">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln3297">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln3298"> </a>
<a name="ln3299">  // Pre-conditions and scope extraction together</a>
<a name="ln3300">  for (int i = MIN_CD_SCOPE; i &lt; MAX_CD_SCOPE; i++) {</a>
<a name="ln3301">    // If there is no argument there are no more scopes after it, break out.</a>
<a name="ln3302">    if (argvars[i].v_type == VAR_UNKNOWN) {</a>
<a name="ln3303">      break;</a>
<a name="ln3304">    }</a>
<a name="ln3305">    if (argvars[i].v_type != VAR_NUMBER) {</a>
<a name="ln3306">      EMSG(_(e_invarg));</a>
<a name="ln3307">      return;</a>
<a name="ln3308">    }</a>
<a name="ln3309">    scope_number[i] = argvars[i].vval.v_number;</a>
<a name="ln3310">    // It is an error for the scope number to be less than `-1`.</a>
<a name="ln3311">    if (scope_number[i] &lt; -1) {</a>
<a name="ln3312">      EMSG(_(e_invarg));</a>
<a name="ln3313">      return;</a>
<a name="ln3314">    }</a>
<a name="ln3315">    // Use the narrowest scope the user requested</a>
<a name="ln3316">    if (scope_number[i] &gt;= 0 &amp;&amp; scope == kCdScopeInvalid) {</a>
<a name="ln3317">      // The scope is the current iteration step.</a>
<a name="ln3318">      scope = i;</a>
<a name="ln3319">    } else if (scope_number[i] &lt; 0) {</a>
<a name="ln3320">      scope = i + 1;</a>
<a name="ln3321">    }</a>
<a name="ln3322">  }</a>
<a name="ln3323"> </a>
<a name="ln3324">  // If the user didn't specify anything, default to window scope</a>
<a name="ln3325">  if (scope == kCdScopeInvalid) {</a>
<a name="ln3326">    scope = MIN_CD_SCOPE;</a>
<a name="ln3327">  }</a>
<a name="ln3328"> </a>
<a name="ln3329">  // Find the tabpage by number</a>
<a name="ln3330">  if (scope_number[kCdScopeTab] &gt; 0) {</a>
<a name="ln3331">    tp = find_tabpage(scope_number[kCdScopeTab]);</a>
<a name="ln3332">    if (!tp) {</a>
<a name="ln3333">      EMSG(_(&quot;E5000: Cannot find tab number.&quot;));</a>
<a name="ln3334">      return;</a>
<a name="ln3335">    }</a>
<a name="ln3336">  }</a>
<a name="ln3337"> </a>
<a name="ln3338">  // Find the window in `tp` by number, `NULL` if none.</a>
<a name="ln3339">  if (scope_number[kCdScopeWindow] &gt;= 0) {</a>
<a name="ln3340">    if (scope_number[kCdScopeTab] &lt; 0) {</a>
<a name="ln3341">      EMSG(_(&quot;E5001: Higher scope cannot be -1 if lower scope is &gt;= 0.&quot;));</a>
<a name="ln3342">      return;</a>
<a name="ln3343">    }</a>
<a name="ln3344"> </a>
<a name="ln3345">    if (scope_number[kCdScopeWindow] &gt; 0) {</a>
<a name="ln3346">      win = find_win_by_nr(&amp;argvars[0], tp);</a>
<a name="ln3347">      if (!win) {</a>
<a name="ln3348">        EMSG(_(&quot;E5002: Cannot find window number.&quot;));</a>
<a name="ln3349">        return;</a>
<a name="ln3350">      }</a>
<a name="ln3351">    }</a>
<a name="ln3352">  }</a>
<a name="ln3353"> </a>
<a name="ln3354">  cwd = xmalloc(MAXPATHL);</a>
<a name="ln3355"> </a>
<a name="ln3356">  switch (scope) {</a>
<a name="ln3357">    case kCdScopeWindow:</a>
<a name="ln3358">      assert(win);</a>
<a name="ln3359">      from = win-&gt;w_localdir;</a>
<a name="ln3360">      if (from) {</a>
<a name="ln3361">        break;</a>
<a name="ln3362">      }</a>
<a name="ln3363">      FALLTHROUGH;</a>
<a name="ln3364">    case kCdScopeTab:</a>
<a name="ln3365">      assert(tp);</a>
<a name="ln3366">      from = tp-&gt;tp_localdir;</a>
<a name="ln3367">      if (from) {</a>
<a name="ln3368">        break;</a>
<a name="ln3369">      }</a>
<a name="ln3370">      FALLTHROUGH;</a>
<a name="ln3371">    case kCdScopeGlobal:</a>
<a name="ln3372">      if (globaldir) {        // `globaldir` is not always set.</a>
<a name="ln3373">        from = globaldir;</a>
<a name="ln3374">      } else if (os_dirname(cwd, MAXPATHL) == FAIL) {  // Get the OS CWD.</a>
<a name="ln3375">        from = (char_u *)&quot;&quot;;  // Return empty string on failure.</a>
<a name="ln3376">      }</a>
<a name="ln3377">      break;</a>
<a name="ln3378">    case kCdScopeInvalid:     // We should never get here</a>
<a name="ln3379">      abort();</a>
<a name="ln3380">  }</a>
<a name="ln3381"> </a>
<a name="ln3382">  if (from) {</a>
<a name="ln3383">    xstrlcpy((char *)cwd, (char *)from, MAXPATHL);</a>
<a name="ln3384">  }</a>
<a name="ln3385"> </a>
<a name="ln3386">  rettv-&gt;vval.v_string = vim_strsave(cwd);</a>
<a name="ln3387">#ifdef BACKSLASH_IN_FILENAME</a>
<a name="ln3388">  slash_adjust(rettv-&gt;vval.v_string);</a>
<a name="ln3389">#endif</a>
<a name="ln3390"> </a>
<a name="ln3391">  xfree(cwd);</a>
<a name="ln3392">}</a>
<a name="ln3393"> </a>
<a name="ln3394">/*</a>
<a name="ln3395"> * &quot;getfontname()&quot; function</a>
<a name="ln3396"> */</a>
<a name="ln3397">static void f_getfontname(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3398">{</a>
<a name="ln3399">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln3400">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln3401">}</a>
<a name="ln3402"> </a>
<a name="ln3403">/*</a>
<a name="ln3404"> * &quot;getfperm({fname})&quot; function</a>
<a name="ln3405"> */</a>
<a name="ln3406">static void f_getfperm(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3407">{</a>
<a name="ln3408">  char *perm = NULL;</a>
<a name="ln3409">  char_u flags[] = &quot;rwx&quot;;</a>
<a name="ln3410"> </a>
<a name="ln3411">  const char *filename = tv_get_string(&amp;argvars[0]);</a>
<a name="ln3412">  int32_t file_perm = os_getperm(filename);</a>
<a name="ln3413">  if (file_perm &gt;= 0) {</a>
<a name="ln3414">    perm = xstrdup(&quot;---------&quot;);</a>
<a name="ln3415">    for (int i = 0; i &lt; 9; i++) {</a>
<a name="ln3416">      if (file_perm &amp; (1 &lt;&lt; (8 - i))) {</a>
<a name="ln3417">        perm[i] = flags[i % 3];</a>
<a name="ln3418">      }</a>
<a name="ln3419">    }</a>
<a name="ln3420">  }</a>
<a name="ln3421">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln3422">  rettv-&gt;vval.v_string = (char_u *)perm;</a>
<a name="ln3423">}</a>
<a name="ln3424"> </a>
<a name="ln3425">/*</a>
<a name="ln3426"> * &quot;getfsize({fname})&quot; function</a>
<a name="ln3427"> */</a>
<a name="ln3428">static void f_getfsize(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3429">{</a>
<a name="ln3430">  const char *fname = tv_get_string(&amp;argvars[0]);</a>
<a name="ln3431"> </a>
<a name="ln3432">  rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln3433"> </a>
<a name="ln3434">  FileInfo file_info;</a>
<a name="ln3435">  if (os_fileinfo(fname, &amp;file_info)) {</a>
<a name="ln3436">    uint64_t filesize = os_fileinfo_size(&amp;file_info);</a>
<a name="ln3437">    if (os_isdir((const char_u *)fname)) {</a>
<a name="ln3438">      rettv-&gt;vval.v_number = 0;</a>
<a name="ln3439">    } else {</a>
<a name="ln3440">      rettv-&gt;vval.v_number = (varnumber_T)filesize;</a>
<a name="ln3441"> </a>
<a name="ln3442">      // non-perfect check for overflow</a>
<a name="ln3443">      if ((uint64_t)rettv-&gt;vval.v_number != filesize) {</a>
<a name="ln3444">        rettv-&gt;vval.v_number = -2;</a>
<a name="ln3445">      }</a>
<a name="ln3446">    }</a>
<a name="ln3447">  } else {</a>
<a name="ln3448">    rettv-&gt;vval.v_number = -1;</a>
<a name="ln3449">  }</a>
<a name="ln3450">}</a>
<a name="ln3451"> </a>
<a name="ln3452">/*</a>
<a name="ln3453"> * &quot;getftime({fname})&quot; function</a>
<a name="ln3454"> */</a>
<a name="ln3455">static void f_getftime(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3456">{</a>
<a name="ln3457">  const char *fname = tv_get_string(&amp;argvars[0]);</a>
<a name="ln3458"> </a>
<a name="ln3459">  FileInfo file_info;</a>
<a name="ln3460">  if (os_fileinfo(fname, &amp;file_info)) {</a>
<a name="ln3461">    rettv-&gt;vval.v_number = (varnumber_T)file_info.stat.st_mtim.tv_sec;</a>
<a name="ln3462">  } else {</a>
<a name="ln3463">    rettv-&gt;vval.v_number = -1;</a>
<a name="ln3464">  }</a>
<a name="ln3465">}</a>
<a name="ln3466"> </a>
<a name="ln3467">/*</a>
<a name="ln3468"> * &quot;getftype({fname})&quot; function</a>
<a name="ln3469"> */</a>
<a name="ln3470">static void f_getftype(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3471">{</a>
<a name="ln3472">  char_u      *type = NULL;</a>
<a name="ln3473">  char        *t;</a>
<a name="ln3474"> </a>
<a name="ln3475">  const char *fname = tv_get_string(&amp;argvars[0]);</a>
<a name="ln3476"> </a>
<a name="ln3477">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln3478">  FileInfo file_info;</a>
<a name="ln3479">  if (os_fileinfo_link(fname, &amp;file_info)) {</a>
<a name="ln3480">    uint64_t mode = file_info.stat.st_mode;</a>
<a name="ln3481">    if (S_ISREG(mode)) {</a>
<a name="ln3482">      t = &quot;file&quot;;</a>
<a name="ln3483">    } else if (S_ISDIR(mode)) {</a>
<a name="ln3484">      t = &quot;dir&quot;;</a>
<a name="ln3485">    } else if (S_ISLNK(mode)) {</a>
<a name="ln3486">      t = &quot;link&quot;;</a>
<a name="ln3487">    } else if (S_ISBLK(mode)) {</a>
<a name="ln3488">      t = &quot;bdev&quot;;</a>
<a name="ln3489">    } else if (S_ISCHR(mode)) {</a>
<a name="ln3490">      t = &quot;cdev&quot;;</a>
<a name="ln3491">    } else if (S_ISFIFO(mode)) {</a>
<a name="ln3492">      t = &quot;fifo&quot;;</a>
<a name="ln3493">    } else if (S_ISSOCK(mode)) {</a>
<a name="ln3494">      t = &quot;socket&quot;;</a>
<a name="ln3495">    } else {</a>
<a name="ln3496">      t = &quot;other&quot;;</a>
<a name="ln3497">    }</a>
<a name="ln3498">    type = vim_strsave((char_u *)t);</a>
<a name="ln3499">  }</a>
<a name="ln3500">  rettv-&gt;vval.v_string = type;</a>
<a name="ln3501">}</a>
<a name="ln3502"> </a>
<a name="ln3503">// &quot;getjumplist()&quot; function</a>
<a name="ln3504">static void f_getjumplist(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3505">{</a>
<a name="ln3506">  tv_list_alloc_ret(rettv, kListLenMayKnow);</a>
<a name="ln3507">  win_T *const wp = find_tabwin(&amp;argvars[0], &amp;argvars[1]);</a>
<a name="ln3508">  if (wp == NULL) {</a>
<a name="ln3509">    return;</a>
<a name="ln3510">  }</a>
<a name="ln3511"> </a>
<a name="ln3512">  cleanup_jumplist(wp, true);</a>
<a name="ln3513"> </a>
<a name="ln3514">  list_T *const l = tv_list_alloc(wp-&gt;w_jumplistlen);</a>
<a name="ln3515">  tv_list_append_list(rettv-&gt;vval.v_list, l);</a>
<a name="ln3516">  tv_list_append_number(rettv-&gt;vval.v_list, wp-&gt;w_jumplistidx);</a>
<a name="ln3517"> </a>
<a name="ln3518">  for (int i = 0; i &lt; wp-&gt;w_jumplistlen; i++) {</a>
<a name="ln3519">    if (wp-&gt;w_jumplist[i].fmark.mark.lnum == 0) {</a>
<a name="ln3520">      continue;</a>
<a name="ln3521">    }</a>
<a name="ln3522">    dict_T *const d = tv_dict_alloc();</a>
<a name="ln3523">    tv_list_append_dict(l, d);</a>
<a name="ln3524">    tv_dict_add_nr(d, S_LEN(&quot;lnum&quot;), wp-&gt;w_jumplist[i].fmark.mark.lnum);</a>
<a name="ln3525">    tv_dict_add_nr(d, S_LEN(&quot;col&quot;), wp-&gt;w_jumplist[i].fmark.mark.col);</a>
<a name="ln3526">    tv_dict_add_nr(d, S_LEN(&quot;coladd&quot;), wp-&gt;w_jumplist[i].fmark.mark.coladd);</a>
<a name="ln3527">    tv_dict_add_nr(d, S_LEN(&quot;bufnr&quot;), wp-&gt;w_jumplist[i].fmark.fnum);</a>
<a name="ln3528">    if (wp-&gt;w_jumplist[i].fname != NULL) {</a>
<a name="ln3529">      tv_dict_add_str(d, S_LEN(&quot;filename&quot;), (char *)wp-&gt;w_jumplist[i].fname);</a>
<a name="ln3530">    }</a>
<a name="ln3531">  }</a>
<a name="ln3532">}</a>
<a name="ln3533"> </a>
<a name="ln3534">/*</a>
<a name="ln3535"> * &quot;getline(lnum, [end])&quot; function</a>
<a name="ln3536"> */</a>
<a name="ln3537">static void f_getline(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3538">{</a>
<a name="ln3539">  linenr_T end;</a>
<a name="ln3540">  bool retlist;</a>
<a name="ln3541"> </a>
<a name="ln3542">  const linenr_T lnum = tv_get_lnum(argvars);</a>
<a name="ln3543">  if (argvars[1].v_type == VAR_UNKNOWN) {</a>
<a name="ln3544">    end = lnum;</a>
<a name="ln3545">    retlist = false;</a>
<a name="ln3546">  } else {</a>
<a name="ln3547">    end = tv_get_lnum(&amp;argvars[1]);</a>
<a name="ln3548">    retlist = true;</a>
<a name="ln3549">  }</a>
<a name="ln3550"> </a>
<a name="ln3551">  get_buffer_lines(curbuf, lnum, end, retlist, rettv);</a>
<a name="ln3552">}</a>
<a name="ln3553"> </a>
<a name="ln3554">/// &quot;getloclist()&quot; function</a>
<a name="ln3555">static void f_getloclist(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3556">{</a>
<a name="ln3557">  win_T *wp = find_win_by_nr_or_id(&amp;argvars[0]);</a>
<a name="ln3558">  get_qf_loc_list(false, wp, &amp;argvars[1], rettv);</a>
<a name="ln3559">}</a>
<a name="ln3560"> </a>
<a name="ln3561"> </a>
<a name="ln3562">/// &quot;getmarklist()&quot; function</a>
<a name="ln3563">static void f_getmarklist(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3564">{</a>
<a name="ln3565">  tv_list_alloc_ret(rettv, kListLenMayKnow);</a>
<a name="ln3566"> </a>
<a name="ln3567">  if (argvars[0].v_type == VAR_UNKNOWN) {</a>
<a name="ln3568">    get_global_marks(rettv-&gt;vval.v_list);</a>
<a name="ln3569">    return;</a>
<a name="ln3570">  }</a>
<a name="ln3571"> </a>
<a name="ln3572">  buf_T *buf = tv_get_buf(&amp;argvars[0], false);</a>
<a name="ln3573">  if (buf == NULL) {</a>
<a name="ln3574">    return;</a>
<a name="ln3575">  }</a>
<a name="ln3576"> </a>
<a name="ln3577">  get_buf_local_marks(buf, rettv-&gt;vval.v_list);</a>
<a name="ln3578">}</a>
<a name="ln3579"> </a>
<a name="ln3580">/*</a>
<a name="ln3581"> * &quot;getmatches()&quot; function</a>
<a name="ln3582"> */</a>
<a name="ln3583">static void f_getmatches(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3584">{</a>
<a name="ln3585">  matchitem_T *cur;</a>
<a name="ln3586">  int i;</a>
<a name="ln3587">  win_T *win = get_optional_window(argvars, 0);</a>
<a name="ln3588"> </a>
<a name="ln3589">  if (win == NULL) {</a>
<a name="ln3590">    return;</a>
<a name="ln3591">  }</a>
<a name="ln3592"> </a>
<a name="ln3593">  tv_list_alloc_ret(rettv, kListLenMayKnow);</a>
<a name="ln3594">  cur = win-&gt;w_match_head;</a>
<a name="ln3595">  while (cur != NULL) {</a>
<a name="ln3596">    dict_T *dict = tv_dict_alloc();</a>
<a name="ln3597">    if (cur-&gt;match.regprog == NULL) {</a>
<a name="ln3598">      // match added with matchaddpos()</a>
<a name="ln3599">      for (i = 0; i &lt; MAXPOSMATCH; i++) {</a>
<a name="ln3600">        llpos_T   *llpos;</a>
<a name="ln3601">        char buf[30];  // use 30 to avoid compiler warning</a>
<a name="ln3602"> </a>
<a name="ln3603">        llpos = &amp;cur-&gt;pos.pos[i];</a>
<a name="ln3604">        if (llpos-&gt;lnum == 0) {</a>
<a name="ln3605">          break;</a>
<a name="ln3606">        }</a>
<a name="ln3607">        list_T *const l = tv_list_alloc(1 + (llpos-&gt;col &gt; 0 ? 2 : 0));</a>
<a name="ln3608">        tv_list_append_number(l, (varnumber_T)llpos-&gt;lnum);</a>
<a name="ln3609">        if (llpos-&gt;col &gt; 0) {</a>
<a name="ln3610">          tv_list_append_number(l, (varnumber_T)llpos-&gt;col);</a>
<a name="ln3611">          tv_list_append_number(l, (varnumber_T)llpos-&gt;len);</a>
<a name="ln3612">        }</a>
<a name="ln3613">        int len = snprintf(buf, sizeof(buf), &quot;pos%d&quot;, i + 1);</a>
<a name="ln3614">        assert((size_t)len &lt; sizeof(buf));</a>
<a name="ln3615">        tv_dict_add_list(dict, buf, (size_t)len, l);</a>
<a name="ln3616">      }</a>
<a name="ln3617">    } else {</a>
<a name="ln3618">      tv_dict_add_str(dict, S_LEN(&quot;pattern&quot;), (const char *)cur-&gt;pattern);</a>
<a name="ln3619">    }</a>
<a name="ln3620">    tv_dict_add_str(dict, S_LEN(&quot;group&quot;),</a>
<a name="ln3621">                    (const char *)syn_id2name(cur-&gt;hlg_id));</a>
<a name="ln3622">    tv_dict_add_nr(dict, S_LEN(&quot;priority&quot;), (varnumber_T)cur-&gt;priority);</a>
<a name="ln3623">    tv_dict_add_nr(dict, S_LEN(&quot;id&quot;), (varnumber_T)cur-&gt;id);</a>
<a name="ln3624"> </a>
<a name="ln3625">    if (cur-&gt;conceal_char) {</a>
<a name="ln3626">      char buf[MB_MAXBYTES + 1];</a>
<a name="ln3627"> </a>
<a name="ln3628">      buf[utf_char2bytes((int)cur-&gt;conceal_char, (char_u *)buf)] = NUL;</a>
<a name="ln3629">      tv_dict_add_str(dict, S_LEN(&quot;conceal&quot;), buf);</a>
<a name="ln3630">    }</a>
<a name="ln3631"> </a>
<a name="ln3632">    tv_list_append_dict(rettv-&gt;vval.v_list, dict);</a>
<a name="ln3633">    cur = cur-&gt;next;</a>
<a name="ln3634">  }</a>
<a name="ln3635">}</a>
<a name="ln3636"> </a>
<a name="ln3637">/*</a>
<a name="ln3638"> * &quot;getpid()&quot; function</a>
<a name="ln3639"> */</a>
<a name="ln3640">static void f_getpid(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3641">{</a>
<a name="ln3642">  rettv-&gt;vval.v_number = os_get_pid();</a>
<a name="ln3643">}</a>
<a name="ln3644"> </a>
<a name="ln3645">static void getpos_both(typval_T *argvars, typval_T *rettv, bool getcurpos)</a>
<a name="ln3646">{</a>
<a name="ln3647">  pos_T *fp;</a>
<a name="ln3648">  int fnum = -1;</a>
<a name="ln3649"> </a>
<a name="ln3650">  if (getcurpos) {</a>
<a name="ln3651">    fp = &amp;curwin-&gt;w_cursor;</a>
<a name="ln3652">  } else {</a>
<a name="ln3653">    fp = var2fpos(&amp;argvars[0], true, &amp;fnum);</a>
<a name="ln3654">  }</a>
<a name="ln3655"> </a>
<a name="ln3656">  list_T *const l = tv_list_alloc_ret(rettv, 4 + (!!getcurpos));</a>
<a name="ln3657">  tv_list_append_number(l, (fnum != -1) ? (varnumber_T)fnum : (varnumber_T)0);</a>
<a name="ln3658">  tv_list_append_number(l, ((fp != NULL)</a>
<a name="ln3659">                            ? (varnumber_T)fp-&gt;lnum</a>
<a name="ln3660">                            : (varnumber_T)0));</a>
<a name="ln3661">  tv_list_append_number(</a>
<a name="ln3662">      l, ((fp != NULL)</a>
<a name="ln3663">          ? (varnumber_T)(fp-&gt;col == MAXCOL ? MAXCOL : fp-&gt;col + 1)</a>
<a name="ln3664">          : (varnumber_T)0));</a>
<a name="ln3665">  tv_list_append_number(</a>
<a name="ln3666">      l, (fp != NULL) ? (varnumber_T)fp-&gt;coladd : (varnumber_T)0);</a>
<a name="ln3667">  if (getcurpos) {</a>
<a name="ln3668">    const int save_set_curswant = curwin-&gt;w_set_curswant;</a>
<a name="ln3669">    const colnr_T save_curswant = curwin-&gt;w_curswant;</a>
<a name="ln3670">    const colnr_T save_virtcol = curwin-&gt;w_virtcol;</a>
<a name="ln3671"> </a>
<a name="ln3672">    update_curswant();</a>
<a name="ln3673">    tv_list_append_number(l, (curwin-&gt;w_curswant == MAXCOL</a>
<a name="ln3674">                              ? (varnumber_T)MAXCOL</a>
<a name="ln3675">                              : (varnumber_T)curwin-&gt;w_curswant + 1));</a>
<a name="ln3676"> </a>
<a name="ln3677">    // Do not change &quot;curswant&quot;, as it is unexpected that a get</a>
<a name="ln3678">    // function has a side effect.</a>
<a name="ln3679">    if (save_set_curswant) {</a>
<a name="ln3680">      curwin-&gt;w_set_curswant = save_set_curswant;</a>
<a name="ln3681">      curwin-&gt;w_curswant = save_curswant;</a>
<a name="ln3682">      curwin-&gt;w_virtcol = save_virtcol;</a>
<a name="ln3683">      curwin-&gt;w_valid &amp;= ~VALID_VIRTCOL;</a>
<a name="ln3684">    }</a>
<a name="ln3685">  }</a>
<a name="ln3686">}</a>
<a name="ln3687"> </a>
<a name="ln3688">/*</a>
<a name="ln3689"> * &quot;getcurpos(string)&quot; function</a>
<a name="ln3690"> */</a>
<a name="ln3691">static void f_getcurpos(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3692">{</a>
<a name="ln3693">  getpos_both(argvars, rettv, true);</a>
<a name="ln3694">}</a>
<a name="ln3695"> </a>
<a name="ln3696">/*</a>
<a name="ln3697"> * &quot;getpos(string)&quot; function</a>
<a name="ln3698"> */</a>
<a name="ln3699">static void f_getpos(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3700">{</a>
<a name="ln3701">  getpos_both(argvars, rettv, false);</a>
<a name="ln3702">}</a>
<a name="ln3703"> </a>
<a name="ln3704">/// &quot;getqflist()&quot; functions</a>
<a name="ln3705">static void f_getqflist(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3706">{</a>
<a name="ln3707">  get_qf_loc_list(true, NULL, &amp;argvars[0], rettv);</a>
<a name="ln3708">}</a>
<a name="ln3709"> </a>
<a name="ln3710">/// &quot;getreg()&quot; function</a>
<a name="ln3711">static void f_getreg(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3712">{</a>
<a name="ln3713">  const char *strregname;</a>
<a name="ln3714">  int arg2 = false;</a>
<a name="ln3715">  bool return_list = false;</a>
<a name="ln3716">  bool error = false;</a>
<a name="ln3717"> </a>
<a name="ln3718">  if (argvars[0].v_type != VAR_UNKNOWN) {</a>
<a name="ln3719">    strregname = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln3720">    error = strregname == NULL;</a>
<a name="ln3721">    if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln3722">      arg2 = tv_get_number_chk(&amp;argvars[1], &amp;error);</a>
<a name="ln3723">      if (!error &amp;&amp; argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln3724">        return_list = tv_get_number_chk(&amp;argvars[2], &amp;error);</a>
<a name="ln3725">      }</a>
<a name="ln3726">    }</a>
<a name="ln3727">  } else {</a>
<a name="ln3728">    strregname = _(get_vim_var_str(VV_REG));</a>
<a name="ln3729">  }</a>
<a name="ln3730"> </a>
<a name="ln3731">  if (error) {</a>
<a name="ln3732">    return;</a>
<a name="ln3733">  }</a>
<a name="ln3734"> </a>
<a name="ln3735">  int regname = (uint8_t)(strregname == NULL ? '&quot;' : *strregname);</a>
<a name="ln3736">  if (regname == 0) {</a>
<a name="ln3737">    regname = '&quot;';</a>
<a name="ln3738">  }</a>
<a name="ln3739"> </a>
<a name="ln3740">  if (return_list) {</a>
<a name="ln3741">    rettv-&gt;v_type = VAR_LIST;</a>
<a name="ln3742">    rettv-&gt;vval.v_list =</a>
<a name="ln3743">      get_reg_contents(regname, (arg2 ? kGRegExprSrc : 0) | kGRegList);</a>
<a name="ln3744">    if (rettv-&gt;vval.v_list == NULL) {</a>
<a name="ln3745">      rettv-&gt;vval.v_list = tv_list_alloc(0);</a>
<a name="ln3746">    }</a>
<a name="ln3747">    tv_list_ref(rettv-&gt;vval.v_list);</a>
<a name="ln3748">  } else {</a>
<a name="ln3749">    rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln3750">    rettv-&gt;vval.v_string = get_reg_contents(regname, arg2 ? kGRegExprSrc : 0);</a>
<a name="ln3751">  }</a>
<a name="ln3752">}</a>
<a name="ln3753"> </a>
<a name="ln3754">/*</a>
<a name="ln3755"> * &quot;getregtype()&quot; function</a>
<a name="ln3756"> */</a>
<a name="ln3757">static void f_getregtype(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3758">{</a>
<a name="ln3759">  const char *strregname;</a>
<a name="ln3760"> </a>
<a name="ln3761">  if (argvars[0].v_type != VAR_UNKNOWN) {</a>
<a name="ln3762">    strregname = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln3763">    if (strregname == NULL) {  // Type error; errmsg already given.</a>
<a name="ln3764">      rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln3765">      rettv-&gt;vval.v_string = NULL;</a>
<a name="ln3766">      return;</a>
<a name="ln3767">    }</a>
<a name="ln3768">  } else {</a>
<a name="ln3769">    // Default to v:register.</a>
<a name="ln3770">    strregname = _(get_vim_var_str(VV_REG));</a>
<a name="ln3771">  }</a>
<a name="ln3772"> </a>
<a name="ln3773">  int regname = (uint8_t)(strregname == NULL ? '&quot;' : *strregname);</a>
<a name="ln3774">  if (regname == 0) {</a>
<a name="ln3775">    regname = '&quot;';</a>
<a name="ln3776">  }</a>
<a name="ln3777"> </a>
<a name="ln3778">  colnr_T reglen = 0;</a>
<a name="ln3779">  char buf[NUMBUFLEN + 2];</a>
<a name="ln3780">  MotionType reg_type = get_reg_type(regname, &amp;reglen);</a>
<a name="ln3781">  format_reg_type(reg_type, reglen, buf, ARRAY_SIZE(buf));</a>
<a name="ln3782"> </a>
<a name="ln3783">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln3784">  rettv-&gt;vval.v_string = (char_u *)xstrdup(buf);</a>
<a name="ln3785">}</a>
<a name="ln3786"> </a>
<a name="ln3787">/// &quot;gettabinfo()&quot; function</a>
<a name="ln3788">static void f_gettabinfo(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3789">{</a>
<a name="ln3790">  tabpage_T *tparg = NULL;</a>
<a name="ln3791"> </a>
<a name="ln3792">  tv_list_alloc_ret(rettv, (argvars[0].v_type == VAR_UNKNOWN</a>
<a name="ln3793">                            ? 1</a>
<a name="ln3794">                            : kListLenMayKnow));</a>
<a name="ln3795"> </a>
<a name="ln3796">  if (argvars[0].v_type != VAR_UNKNOWN) {</a>
<a name="ln3797">    // Information about one tab page</a>
<a name="ln3798">    tparg = find_tabpage((int)tv_get_number_chk(&amp;argvars[0], NULL));</a>
<a name="ln3799">    if (tparg == NULL) {</a>
<a name="ln3800">      return;</a>
<a name="ln3801">    }</a>
<a name="ln3802">  }</a>
<a name="ln3803"> </a>
<a name="ln3804">  // Get information about a specific tab page or all tab pages</a>
<a name="ln3805">  int tpnr = 0;</a>
<a name="ln3806">  FOR_ALL_TABS(tp) {</a>
<a name="ln3807">    tpnr++;</a>
<a name="ln3808">    if (tparg != NULL &amp;&amp; tp != tparg) {</a>
<a name="ln3809">      continue;</a>
<a name="ln3810">    }</a>
<a name="ln3811">    dict_T *const d = get_tabpage_info(tp, tpnr);</a>
<a name="ln3812">    tv_list_append_dict(rettv-&gt;vval.v_list, d);</a>
<a name="ln3813">    if (tparg != NULL) {</a>
<a name="ln3814">      return;</a>
<a name="ln3815">    }</a>
<a name="ln3816">  }</a>
<a name="ln3817">}</a>
<a name="ln3818"> </a>
<a name="ln3819">/*</a>
<a name="ln3820"> * &quot;gettabvar()&quot; function</a>
<a name="ln3821"> */</a>
<a name="ln3822">static void f_gettabvar(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3823">{</a>
<a name="ln3824">  win_T *oldcurwin;</a>
<a name="ln3825">  tabpage_T *oldtabpage;</a>
<a name="ln3826">  bool done = false;</a>
<a name="ln3827"> </a>
<a name="ln3828">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln3829">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln3830"> </a>
<a name="ln3831">  const char *const varname = tv_get_string_chk(&amp;argvars[1]);</a>
<a name="ln3832">  tabpage_T *const tp = find_tabpage((int)tv_get_number_chk(&amp;argvars[0], NULL));</a>
<a name="ln3833">  if (tp != NULL &amp;&amp; varname != NULL) {</a>
<a name="ln3834">    // Set tp to be our tabpage, temporarily.  Also set the window to the</a>
<a name="ln3835">    // first window in the tabpage, otherwise the window is not valid.</a>
<a name="ln3836">    win_T *const window = tp == curtab || tp-&gt;tp_firstwin == NULL</a>
<a name="ln3837">        ? firstwin</a>
<a name="ln3838">        : tp-&gt;tp_firstwin;</a>
<a name="ln3839">    if (switch_win(&amp;oldcurwin, &amp;oldtabpage, window, tp, true) == OK) {</a>
<a name="ln3840">      // look up the variable</a>
<a name="ln3841">      // Let gettabvar({nr}, &quot;&quot;) return the &quot;t:&quot; dictionary.</a>
<a name="ln3842">      const dictitem_T *const v = find_var_in_ht(&amp;tp-&gt;tp_vars-&gt;dv_hashtab, 't',</a>
<a name="ln3843">                                                 varname, strlen(varname),</a>
<a name="ln3844">                                                 false);</a>
<a name="ln3845">      if (v != NULL) {</a>
<a name="ln3846">        tv_copy(&amp;v-&gt;di_tv, rettv);</a>
<a name="ln3847">        done = true;</a>
<a name="ln3848">      }</a>
<a name="ln3849">    }</a>
<a name="ln3850"> </a>
<a name="ln3851">    // restore previous notion of curwin</a>
<a name="ln3852">    restore_win(oldcurwin, oldtabpage, true);</a>
<a name="ln3853">  }</a>
<a name="ln3854"> </a>
<a name="ln3855">  if (!done &amp;&amp; argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln3856">    tv_copy(&amp;argvars[2], rettv);</a>
<a name="ln3857">  }</a>
<a name="ln3858">}</a>
<a name="ln3859"> </a>
<a name="ln3860">/*</a>
<a name="ln3861"> * &quot;gettabwinvar()&quot; function</a>
<a name="ln3862"> */</a>
<a name="ln3863">static void f_gettabwinvar(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3864">{</a>
<a name="ln3865">  getwinvar(argvars, rettv, 1);</a>
<a name="ln3866">}</a>
<a name="ln3867"> </a>
<a name="ln3868">// &quot;gettagstack()&quot; function</a>
<a name="ln3869">static void f_gettagstack(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3870">{</a>
<a name="ln3871">    win_T        *wp = curwin;                  // default is current window</a>
<a name="ln3872"> </a>
<a name="ln3873">    tv_dict_alloc_ret(rettv);</a>
<a name="ln3874"> </a>
<a name="ln3875">    if (argvars[0].v_type != VAR_UNKNOWN) {</a>
<a name="ln3876">        wp = find_win_by_nr_or_id(&amp;argvars[0]);</a>
<a name="ln3877">        if (wp == NULL) {</a>
<a name="ln3878">          return;</a>
<a name="ln3879">        }</a>
<a name="ln3880">    }</a>
<a name="ln3881"> </a>
<a name="ln3882">    get_tagstack(wp, rettv-&gt;vval.v_dict);</a>
<a name="ln3883">}</a>
<a name="ln3884"> </a>
<a name="ln3885">/// &quot;getwininfo()&quot; function</a>
<a name="ln3886">static void f_getwininfo(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3887">{</a>
<a name="ln3888">  win_T *wparg = NULL;</a>
<a name="ln3889"> </a>
<a name="ln3890">  tv_list_alloc_ret(rettv, kListLenMayKnow);</a>
<a name="ln3891"> </a>
<a name="ln3892">  if (argvars[0].v_type != VAR_UNKNOWN) {</a>
<a name="ln3893">    wparg = win_id2wp(argvars);</a>
<a name="ln3894">    if (wparg == NULL) {</a>
<a name="ln3895">      return;</a>
<a name="ln3896">    }</a>
<a name="ln3897">  }</a>
<a name="ln3898"> </a>
<a name="ln3899">  // Collect information about either all the windows across all the tab</a>
<a name="ln3900">  // pages or one particular window.</a>
<a name="ln3901">  int16_t tabnr = 0;</a>
<a name="ln3902">  FOR_ALL_TABS(tp) {</a>
<a name="ln3903">    tabnr++;</a>
<a name="ln3904">    int16_t winnr = 0;</a>
<a name="ln3905">    FOR_ALL_WINDOWS_IN_TAB(wp, tp) {</a>
<a name="ln3906">      winnr++;</a>
<a name="ln3907">      if (wparg != NULL &amp;&amp; wp != wparg) {</a>
<a name="ln3908">        continue;</a>
<a name="ln3909">      }</a>
<a name="ln3910">      dict_T *const d = get_win_info(wp, tabnr, winnr);</a>
<a name="ln3911">      tv_list_append_dict(rettv-&gt;vval.v_list, d);</a>
<a name="ln3912">      if (wparg != NULL) {</a>
<a name="ln3913">        // found information about a specific window</a>
<a name="ln3914">        return;</a>
<a name="ln3915">      }</a>
<a name="ln3916">    }</a>
<a name="ln3917">  }</a>
<a name="ln3918">}</a>
<a name="ln3919"> </a>
<a name="ln3920">// Dummy timer callback. Used by f_wait().</a>
<a name="ln3921">static void dummy_timer_due_cb(TimeWatcher *tw, void *data)</a>
<a name="ln3922">{</a>
<a name="ln3923">}</a>
<a name="ln3924"> </a>
<a name="ln3925">// Dummy timer close callback. Used by f_wait().</a>
<a name="ln3926">static void dummy_timer_close_cb(TimeWatcher *tw, void *data)</a>
<a name="ln3927">{</a>
<a name="ln3928">  xfree(tw);</a>
<a name="ln3929">}</a>
<a name="ln3930"> </a>
<a name="ln3931">/// &quot;wait(timeout, condition[, interval])&quot; function</a>
<a name="ln3932">static void f_wait(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3933">{</a>
<a name="ln3934">  rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln3935">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln3936"> </a>
<a name="ln3937">  if (argvars[0].v_type != VAR_NUMBER) {</a>
<a name="ln3938">    EMSG2(_(e_invargval), &quot;1&quot;);</a>
<a name="ln3939">    return;</a>
<a name="ln3940">  }</a>
<a name="ln3941">  if ((argvars[2].v_type != VAR_NUMBER &amp;&amp; argvars[2].v_type != VAR_UNKNOWN)</a>
<a name="ln3942">      || (argvars[2].v_type == VAR_NUMBER &amp;&amp; argvars[2].vval.v_number &lt;= 0)) {</a>
<a name="ln3943">    EMSG2(_(e_invargval), &quot;3&quot;);</a>
<a name="ln3944">    return;</a>
<a name="ln3945">  }</a>
<a name="ln3946"> </a>
<a name="ln3947">  int timeout = argvars[0].vval.v_number;</a>
<a name="ln3948">  typval_T expr = argvars[1];</a>
<a name="ln3949">  int interval = argvars[2].v_type == VAR_NUMBER</a>
<a name="ln3950">    ? argvars[2].vval.v_number</a>
<a name="ln3951">    : 200;  // Default.</a>
<a name="ln3952">  TimeWatcher *tw = xmalloc(sizeof(TimeWatcher));</a>
<a name="ln3953"> </a>
<a name="ln3954">  // Start dummy timer.</a>
<a name="ln3955">  time_watcher_init(&amp;main_loop, tw, NULL);</a>
<a name="ln3956">  tw-&gt;events = main_loop.events;</a>
<a name="ln3957">  tw-&gt;blockable = true;</a>
<a name="ln3958">  time_watcher_start(tw, dummy_timer_due_cb, interval, interval);</a>
<a name="ln3959"> </a>
<a name="ln3960">  typval_T argv = TV_INITIAL_VALUE;</a>
<a name="ln3961">  typval_T exprval = TV_INITIAL_VALUE;</a>
<a name="ln3962">  bool error = false;</a>
<a name="ln3963">  int save_called_emsg = called_emsg;</a>
<a name="ln3964">  called_emsg = false;</a>
<a name="ln3965"> </a>
<a name="ln3966">  LOOP_PROCESS_EVENTS_UNTIL(&amp;main_loop, main_loop.events, timeout,</a>
<a name="ln3967">                            eval_expr_typval(&amp;expr, &amp;argv, 0, &amp;exprval) != OK</a>
<a name="ln3968">                            || tv_get_number_chk(&amp;exprval, &amp;error)</a>
<a name="ln3969">                            || called_emsg || error || got_int);</a>
<a name="ln3970"> </a>
<a name="ln3971">  if (called_emsg || error) {</a>
<a name="ln3972">    rettv-&gt;vval.v_number = -3;</a>
<a name="ln3973">  } else if (got_int) {</a>
<a name="ln3974">    got_int = false;</a>
<a name="ln3975">    vgetc();</a>
<a name="ln3976">    rettv-&gt;vval.v_number = -2;</a>
<a name="ln3977">  } else if (tv_get_number_chk(&amp;exprval, &amp;error)) {</a>
<a name="ln3978">    rettv-&gt;vval.v_number = 0;</a>
<a name="ln3979">  }</a>
<a name="ln3980"> </a>
<a name="ln3981">  called_emsg = save_called_emsg;</a>
<a name="ln3982"> </a>
<a name="ln3983">  // Stop dummy timer</a>
<a name="ln3984">  time_watcher_stop(tw);</a>
<a name="ln3985">  time_watcher_close(tw, dummy_timer_close_cb);</a>
<a name="ln3986">}</a>
<a name="ln3987"> </a>
<a name="ln3988">// &quot;win_screenpos()&quot; function</a>
<a name="ln3989">static void f_win_screenpos(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3990">{</a>
<a name="ln3991">  tv_list_alloc_ret(rettv, 2);</a>
<a name="ln3992">  const win_T *const wp = find_win_by_nr_or_id(&amp;argvars[0]);</a>
<a name="ln3993">  tv_list_append_number(rettv-&gt;vval.v_list, wp == NULL ? 0 : wp-&gt;w_winrow + 1);</a>
<a name="ln3994">  tv_list_append_number(rettv-&gt;vval.v_list, wp == NULL ? 0 : wp-&gt;w_wincol + 1);</a>
<a name="ln3995">}</a>
<a name="ln3996"> </a>
<a name="ln3997">//</a>
<a name="ln3998">// Move the window wp into a new split of targetwin in a given direction</a>
<a name="ln3999">//</a>
<a name="ln4000">static void win_move_into_split(win_T *wp, win_T *targetwin,</a>
<a name="ln4001">                                int size, int flags)</a>
<a name="ln4002">{</a>
<a name="ln4003">  int     dir;</a>
<a name="ln4004">  int     height = wp-&gt;w_height;</a>
<a name="ln4005">  win_T   *oldwin = curwin;</a>
<a name="ln4006"> </a>
<a name="ln4007">  if (wp == targetwin) {</a>
<a name="ln4008">    return;</a>
<a name="ln4009">  }</a>
<a name="ln4010"> </a>
<a name="ln4011">  // Jump to the target window</a>
<a name="ln4012">  if (curwin != targetwin) {</a>
<a name="ln4013">    win_goto(targetwin);</a>
<a name="ln4014">  }</a>
<a name="ln4015"> </a>
<a name="ln4016">  // Remove the old window and frame from the tree of frames</a>
<a name="ln4017">  (void)winframe_remove(wp, &amp;dir, NULL);</a>
<a name="ln4018">  win_remove(wp, NULL);</a>
<a name="ln4019">  last_status(false);     // may need to remove last status line</a>
<a name="ln4020">  (void)win_comp_pos();   // recompute window positions</a>
<a name="ln4021"> </a>
<a name="ln4022">  // Split a window on the desired side and put the old window there</a>
<a name="ln4023">  (void)win_split_ins(size, flags, wp, dir);</a>
<a name="ln4024"> </a>
<a name="ln4025">  // If splitting horizontally, try to preserve height</a>
<a name="ln4026">  if (size == 0 &amp;&amp; !(flags &amp; WSP_VERT)) {</a>
<a name="ln4027">    win_setheight_win(height, wp);</a>
<a name="ln4028">    if (p_ea) {</a>
<a name="ln4029">      win_equal(wp, true, 'v');</a>
<a name="ln4030">    }</a>
<a name="ln4031">  }</a>
<a name="ln4032"> </a>
<a name="ln4033">  if (oldwin != curwin) {</a>
<a name="ln4034">    win_goto(oldwin);</a>
<a name="ln4035">  }</a>
<a name="ln4036">}</a>
<a name="ln4037"> </a>
<a name="ln4038">// &quot;win_splitmove()&quot; function</a>
<a name="ln4039">static void f_win_splitmove(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4040">{</a>
<a name="ln4041">  win_T   *wp;</a>
<a name="ln4042">  win_T   *targetwin;</a>
<a name="ln4043">  int     flags = 0, size = 0;</a>
<a name="ln4044"> </a>
<a name="ln4045">  wp = find_win_by_nr_or_id(&amp;argvars[0]);</a>
<a name="ln4046">  targetwin = find_win_by_nr_or_id(&amp;argvars[1]);</a>
<a name="ln4047"> </a>
<a name="ln4048">  if (wp == NULL || targetwin == NULL || wp == targetwin</a>
<a name="ln4049">      || !win_valid(wp) || !win_valid(targetwin)</a>
<a name="ln4050">      || win_valid_floating(wp) || win_valid_floating(targetwin)) {</a>
<a name="ln4051">    EMSG(_(e_invalwindow));</a>
<a name="ln4052">    rettv-&gt;vval.v_number = -1;</a>
<a name="ln4053">    return;</a>
<a name="ln4054">  }</a>
<a name="ln4055"> </a>
<a name="ln4056">  if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln4057">    dict_T      *d;</a>
<a name="ln4058">    dictitem_T  *di;</a>
<a name="ln4059"> </a>
<a name="ln4060">    if (argvars[2].v_type != VAR_DICT || argvars[2].vval.v_dict == NULL) {</a>
<a name="ln4061">      EMSG(_(e_invarg));</a>
<a name="ln4062">      return;</a>
<a name="ln4063">    }</a>
<a name="ln4064"> </a>
<a name="ln4065">    d = argvars[2].vval.v_dict;</a>
<a name="ln4066">    if (tv_dict_get_number(d, &quot;vertical&quot;)) {</a>
<a name="ln4067">      flags |= WSP_VERT;</a>
<a name="ln4068">    }</a>
<a name="ln4069">    if ((di = tv_dict_find(d, &quot;rightbelow&quot;, -1)) != NULL) {</a>
<a name="ln4070">      flags |= tv_get_number(&amp;di-&gt;di_tv) ? WSP_BELOW : WSP_ABOVE;</a>
<a name="ln4071">    }</a>
<a name="ln4072">    size = tv_dict_get_number(d, &quot;size&quot;);</a>
<a name="ln4073">  }</a>
<a name="ln4074"> </a>
<a name="ln4075">  win_move_into_split(wp, targetwin, size, flags);</a>
<a name="ln4076">}</a>
<a name="ln4077"> </a>
<a name="ln4078">// &quot;getwinpos({timeout})&quot; function</a>
<a name="ln4079">static void f_getwinpos(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4080">{</a>
<a name="ln4081">  tv_list_alloc_ret(rettv, 2);</a>
<a name="ln4082">  tv_list_append_number(rettv-&gt;vval.v_list, -1);</a>
<a name="ln4083">  tv_list_append_number(rettv-&gt;vval.v_list, -1);</a>
<a name="ln4084">}</a>
<a name="ln4085"> </a>
<a name="ln4086">/*</a>
<a name="ln4087"> * &quot;getwinposx()&quot; function</a>
<a name="ln4088"> */</a>
<a name="ln4089">static void f_getwinposx(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4090">{</a>
<a name="ln4091">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln4092">}</a>
<a name="ln4093"> </a>
<a name="ln4094">/*</a>
<a name="ln4095"> * &quot;getwinposy()&quot; function</a>
<a name="ln4096"> */</a>
<a name="ln4097">static void f_getwinposy(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4098">{</a>
<a name="ln4099">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln4100">}</a>
<a name="ln4101"> </a>
<a name="ln4102">/// &quot;getwinvar()&quot; function</a>
<a name="ln4103">static void f_getwinvar(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4104">{</a>
<a name="ln4105">  getwinvar(argvars, rettv, 0);</a>
<a name="ln4106">}</a>
<a name="ln4107"> </a>
<a name="ln4108">/*</a>
<a name="ln4109"> * &quot;glob()&quot; function</a>
<a name="ln4110"> */</a>
<a name="ln4111">static void f_glob(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4112">{</a>
<a name="ln4113">  int options = WILD_SILENT|WILD_USE_NL;</a>
<a name="ln4114">  expand_T xpc;</a>
<a name="ln4115">  bool error = false;</a>
<a name="ln4116"> </a>
<a name="ln4117">  /* When the optional second argument is non-zero, don't remove matches</a>
<a name="ln4118">  * for 'wildignore' and don't put matches for 'suffixes' at the end. */</a>
<a name="ln4119">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln4120">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln4121">    if (tv_get_number_chk(&amp;argvars[1], &amp;error)) {</a>
<a name="ln4122">      options |= WILD_KEEP_ALL;</a>
<a name="ln4123">    }</a>
<a name="ln4124">    if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln4125">      if (tv_get_number_chk(&amp;argvars[2], &amp;error)) {</a>
<a name="ln4126">        tv_list_set_ret(rettv, NULL);</a>
<a name="ln4127">      }</a>
<a name="ln4128">      if (argvars[3].v_type != VAR_UNKNOWN</a>
<a name="ln4129">          &amp;&amp; tv_get_number_chk(&amp;argvars[3], &amp;error)) {</a>
<a name="ln4130">        options |= WILD_ALLLINKS;</a>
<a name="ln4131">      }</a>
<a name="ln4132">    }</a>
<a name="ln4133">  }</a>
<a name="ln4134">  if (!error) {</a>
<a name="ln4135">    ExpandInit(&amp;xpc);</a>
<a name="ln4136">    xpc.xp_context = EXPAND_FILES;</a>
<a name="ln4137">    if (p_wic)</a>
<a name="ln4138">      options += WILD_ICASE;</a>
<a name="ln4139">    if (rettv-&gt;v_type == VAR_STRING) {</a>
<a name="ln4140">      rettv-&gt;vval.v_string = ExpandOne(</a>
<a name="ln4141">          &amp;xpc, (char_u *)tv_get_string(&amp;argvars[0]), NULL, options, WILD_ALL);</a>
<a name="ln4142">    } else {</a>
<a name="ln4143">      ExpandOne(&amp;xpc, (char_u *)tv_get_string(&amp;argvars[0]), NULL, options,</a>
<a name="ln4144">                WILD_ALL_KEEP);</a>
<a name="ln4145">      tv_list_alloc_ret(rettv, xpc.xp_numfiles);</a>
<a name="ln4146">      for (int i = 0; i &lt; xpc.xp_numfiles; i++) {</a>
<a name="ln4147">        tv_list_append_string(rettv-&gt;vval.v_list, (const char *)xpc.xp_files[i],</a>
<a name="ln4148">                              -1);</a>
<a name="ln4149">      }</a>
<a name="ln4150">      ExpandCleanup(&amp;xpc);</a>
<a name="ln4151">    }</a>
<a name="ln4152">  } else</a>
<a name="ln4153">    rettv-&gt;vval.v_string = NULL;</a>
<a name="ln4154">}</a>
<a name="ln4155"> </a>
<a name="ln4156">/// &quot;globpath()&quot; function</a>
<a name="ln4157">static void f_globpath(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4158">{</a>
<a name="ln4159">  int flags = WILD_IGNORE_COMPLETESLASH;  // Flags for globpath.</a>
<a name="ln4160">  bool error = false;</a>
<a name="ln4161"> </a>
<a name="ln4162">  // Return a string, or a list if the optional third argument is non-zero.</a>
<a name="ln4163">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln4164"> </a>
<a name="ln4165">  if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln4166">    // When the optional second argument is non-zero, don't remove matches</a>
<a name="ln4167">    // for 'wildignore' and don't put matches for 'suffixes' at the end.</a>
<a name="ln4168">    if (tv_get_number_chk(&amp;argvars[2], &amp;error)) {</a>
<a name="ln4169">      flags |= WILD_KEEP_ALL;</a>
<a name="ln4170">    }</a>
<a name="ln4171"> </a>
<a name="ln4172">    if (argvars[3].v_type != VAR_UNKNOWN) {</a>
<a name="ln4173">      if (tv_get_number_chk(&amp;argvars[3], &amp;error)) {</a>
<a name="ln4174">        tv_list_set_ret(rettv, NULL);</a>
<a name="ln4175">      }</a>
<a name="ln4176">      if (argvars[4].v_type != VAR_UNKNOWN</a>
<a name="ln4177">          &amp;&amp; tv_get_number_chk(&amp;argvars[4], &amp;error)) {</a>
<a name="ln4178">        flags |= WILD_ALLLINKS;</a>
<a name="ln4179">      }</a>
<a name="ln4180">    }</a>
<a name="ln4181">  }</a>
<a name="ln4182"> </a>
<a name="ln4183">  char buf1[NUMBUFLEN];</a>
<a name="ln4184">  const char *const file = tv_get_string_buf_chk(&amp;argvars[1], buf1);</a>
<a name="ln4185">  if (file != NULL &amp;&amp; !error) {</a>
<a name="ln4186">    garray_T ga;</a>
<a name="ln4187">    ga_init(&amp;ga, (int)sizeof(char_u *), 10);</a>
<a name="ln4188">    globpath((char_u *)tv_get_string(&amp;argvars[0]), (char_u *)file, &amp;ga, flags);</a>
<a name="ln4189"> </a>
<a name="ln4190">    if (rettv-&gt;v_type == VAR_STRING) {</a>
<a name="ln4191">      rettv-&gt;vval.v_string = ga_concat_strings_sep(&amp;ga, &quot;\n&quot;);</a>
<a name="ln4192">    } else {</a>
<a name="ln4193">      tv_list_alloc_ret(rettv, ga.ga_len);</a>
<a name="ln4194">      for (int i = 0; i &lt; ga.ga_len; i++) {</a>
<a name="ln4195">        tv_list_append_string(rettv-&gt;vval.v_list,</a>
<a name="ln4196">                              ((const char **)(ga.ga_data))[i], -1);</a>
<a name="ln4197">      }</a>
<a name="ln4198">    }</a>
<a name="ln4199"> </a>
<a name="ln4200">    ga_clear_strings(&amp;ga);</a>
<a name="ln4201">  } else {</a>
<a name="ln4202">    rettv-&gt;vval.v_string = NULL;</a>
<a name="ln4203">  }</a>
<a name="ln4204">}</a>
<a name="ln4205"> </a>
<a name="ln4206">// &quot;glob2regpat()&quot; function</a>
<a name="ln4207">static void f_glob2regpat(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4208">{</a>
<a name="ln4209">  const char *const pat = tv_get_string_chk(&amp;argvars[0]);  // NULL on type error</a>
<a name="ln4210"> </a>
<a name="ln4211">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln4212">  rettv-&gt;vval.v_string = ((pat == NULL)</a>
<a name="ln4213">                          ? NULL</a>
<a name="ln4214">                          : file_pat_to_reg_pat((char_u *)pat, NULL, NULL,</a>
<a name="ln4215">                                                false));</a>
<a name="ln4216">}</a>
<a name="ln4217"> </a>
<a name="ln4218">/// &quot;has()&quot; function</a>
<a name="ln4219">static void f_has(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4220">{</a>
<a name="ln4221">  static const char *const has_list[] = {</a>
<a name="ln4222">#if defined(BSD) &amp;&amp; !defined(__APPLE__)</a>
<a name="ln4223">    &quot;bsd&quot;,</a>
<a name="ln4224">#endif</a>
<a name="ln4225">#ifdef UNIX</a>
<a name="ln4226">    &quot;unix&quot;,</a>
<a name="ln4227">#endif</a>
<a name="ln4228">#if defined(WIN32)</a>
<a name="ln4229">    &quot;win32&quot;,</a>
<a name="ln4230">#endif</a>
<a name="ln4231">#ifdef _WIN64</a>
<a name="ln4232">    &quot;win64&quot;,</a>
<a name="ln4233">#endif</a>
<a name="ln4234">#ifndef CASE_INSENSITIVE_FILENAME</a>
<a name="ln4235">    &quot;fname_case&quot;,</a>
<a name="ln4236">#endif</a>
<a name="ln4237">#ifdef HAVE_ACL</a>
<a name="ln4238">    &quot;acl&quot;,</a>
<a name="ln4239">#endif</a>
<a name="ln4240">    &quot;autochdir&quot;,</a>
<a name="ln4241">    &quot;arabic&quot;,</a>
<a name="ln4242">    &quot;autocmd&quot;,</a>
<a name="ln4243">    &quot;browsefilter&quot;,</a>
<a name="ln4244">    &quot;byte_offset&quot;,</a>
<a name="ln4245">    &quot;cindent&quot;,</a>
<a name="ln4246">    &quot;cmdline_compl&quot;,</a>
<a name="ln4247">    &quot;cmdline_hist&quot;,</a>
<a name="ln4248">    &quot;comments&quot;,</a>
<a name="ln4249">    &quot;conceal&quot;,</a>
<a name="ln4250">    &quot;cscope&quot;,</a>
<a name="ln4251">    &quot;cursorbind&quot;,</a>
<a name="ln4252">    &quot;cursorshape&quot;,</a>
<a name="ln4253">#ifdef DEBUG</a>
<a name="ln4254">    &quot;debug&quot;,</a>
<a name="ln4255">#endif</a>
<a name="ln4256">    &quot;dialog_con&quot;,</a>
<a name="ln4257">    &quot;diff&quot;,</a>
<a name="ln4258">    &quot;digraphs&quot;,</a>
<a name="ln4259">    &quot;eval&quot;,         // always present, of course!</a>
<a name="ln4260">    &quot;ex_extra&quot;,</a>
<a name="ln4261">    &quot;extra_search&quot;,</a>
<a name="ln4262">    &quot;file_in_path&quot;,</a>
<a name="ln4263">    &quot;filterpipe&quot;,</a>
<a name="ln4264">    &quot;find_in_path&quot;,</a>
<a name="ln4265">    &quot;float&quot;,</a>
<a name="ln4266">    &quot;folding&quot;,</a>
<a name="ln4267">#if defined(UNIX)</a>
<a name="ln4268">    &quot;fork&quot;,</a>
<a name="ln4269">#endif</a>
<a name="ln4270">    &quot;gettext&quot;,</a>
<a name="ln4271">#if defined(HAVE_ICONV)</a>
<a name="ln4272">    &quot;iconv&quot;,</a>
<a name="ln4273">#endif</a>
<a name="ln4274">    &quot;insert_expand&quot;,</a>
<a name="ln4275">    &quot;jumplist&quot;,</a>
<a name="ln4276">    &quot;keymap&quot;,</a>
<a name="ln4277">    &quot;lambda&quot;,</a>
<a name="ln4278">    &quot;langmap&quot;,</a>
<a name="ln4279">    &quot;libcall&quot;,</a>
<a name="ln4280">    &quot;linebreak&quot;,</a>
<a name="ln4281">    &quot;lispindent&quot;,</a>
<a name="ln4282">    &quot;listcmds&quot;,</a>
<a name="ln4283">    &quot;localmap&quot;,</a>
<a name="ln4284">#ifdef __APPLE__</a>
<a name="ln4285">    &quot;mac&quot;,</a>
<a name="ln4286">    &quot;macunix&quot;,</a>
<a name="ln4287">    &quot;osx&quot;,</a>
<a name="ln4288">    &quot;osxdarwin&quot;,</a>
<a name="ln4289">#endif</a>
<a name="ln4290">    &quot;menu&quot;,</a>
<a name="ln4291">    &quot;mksession&quot;,</a>
<a name="ln4292">    &quot;modify_fname&quot;,</a>
<a name="ln4293">    &quot;mouse&quot;,</a>
<a name="ln4294">    &quot;multi_byte&quot;,</a>
<a name="ln4295">    &quot;multi_lang&quot;,</a>
<a name="ln4296">    &quot;num64&quot;,</a>
<a name="ln4297">    &quot;packages&quot;,</a>
<a name="ln4298">    &quot;path_extra&quot;,</a>
<a name="ln4299">    &quot;persistent_undo&quot;,</a>
<a name="ln4300">    &quot;postscript&quot;,</a>
<a name="ln4301">    &quot;printer&quot;,</a>
<a name="ln4302">    &quot;profile&quot;,</a>
<a name="ln4303">    &quot;pythonx&quot;,</a>
<a name="ln4304">    &quot;reltime&quot;,</a>
<a name="ln4305">    &quot;quickfix&quot;,</a>
<a name="ln4306">    &quot;rightleft&quot;,</a>
<a name="ln4307">    &quot;scrollbind&quot;,</a>
<a name="ln4308">    &quot;showcmd&quot;,</a>
<a name="ln4309">    &quot;cmdline_info&quot;,</a>
<a name="ln4310">    &quot;shada&quot;,</a>
<a name="ln4311">    &quot;signs&quot;,</a>
<a name="ln4312">    &quot;smartindent&quot;,</a>
<a name="ln4313">    &quot;startuptime&quot;,</a>
<a name="ln4314">    &quot;statusline&quot;,</a>
<a name="ln4315">    &quot;spell&quot;,</a>
<a name="ln4316">    &quot;syntax&quot;,</a>
<a name="ln4317">#if !defined(UNIX)</a>
<a name="ln4318">    &quot;system&quot;,  // TODO(SplinterOfChaos): This IS defined for UNIX!</a>
<a name="ln4319">#endif</a>
<a name="ln4320">    &quot;tablineat&quot;,</a>
<a name="ln4321">    &quot;tag_binary&quot;,</a>
<a name="ln4322">    &quot;termguicolors&quot;,</a>
<a name="ln4323">    &quot;termresponse&quot;,</a>
<a name="ln4324">    &quot;textobjects&quot;,</a>
<a name="ln4325">    &quot;timers&quot;,</a>
<a name="ln4326">    &quot;title&quot;,</a>
<a name="ln4327">    &quot;user-commands&quot;,        // was accidentally included in 5.4</a>
<a name="ln4328">    &quot;user_commands&quot;,</a>
<a name="ln4329">    &quot;vartabs&quot;,</a>
<a name="ln4330">    &quot;vertsplit&quot;,</a>
<a name="ln4331">    &quot;virtualedit&quot;,</a>
<a name="ln4332">    &quot;visual&quot;,</a>
<a name="ln4333">    &quot;visualextra&quot;,</a>
<a name="ln4334">    &quot;vreplace&quot;,</a>
<a name="ln4335">    &quot;wildignore&quot;,</a>
<a name="ln4336">    &quot;wildmenu&quot;,</a>
<a name="ln4337">    &quot;windows&quot;,</a>
<a name="ln4338">    &quot;winaltkeys&quot;,</a>
<a name="ln4339">    &quot;writebackup&quot;,</a>
<a name="ln4340">#if defined(HAVE_WSL)</a>
<a name="ln4341">    &quot;wsl&quot;,</a>
<a name="ln4342">#endif</a>
<a name="ln4343">    &quot;nvim&quot;,</a>
<a name="ln4344">  };</a>
<a name="ln4345"> </a>
<a name="ln4346">  bool n = false;</a>
<a name="ln4347">  const char *const name = tv_get_string(&amp;argvars[0]);</a>
<a name="ln4348">  for (size_t i = 0; i &lt; ARRAY_SIZE(has_list); i++) {</a>
<a name="ln4349">    if (STRICMP(name, has_list[i]) == 0) {</a>
<a name="ln4350">      n = true;</a>
<a name="ln4351">      break;</a>
<a name="ln4352">    }</a>
<a name="ln4353">  }</a>
<a name="ln4354"> </a>
<a name="ln4355">  if (!n) {</a>
<a name="ln4356">    if (STRNICMP(name, &quot;patch&quot;, 5) == 0) {</a>
<a name="ln4357">      if (name[5] == '-'</a>
<a name="ln4358">          &amp;&amp; strlen(name) &gt;= 11</a>
<a name="ln4359">          &amp;&amp; ascii_isdigit(name[6])</a>
<a name="ln4360">          &amp;&amp; ascii_isdigit(name[8])</a>
<a name="ln4361">          &amp;&amp; ascii_isdigit(name[10])) {</a>
<a name="ln4362">        int major = atoi(name + 6);</a>
<a name="ln4363">        int minor = atoi(name + 8);</a>
<a name="ln4364"> </a>
<a name="ln4365">        // Expect &quot;patch-9.9.01234&quot;.</a>
<a name="ln4366">        n = (major &lt; VIM_VERSION_MAJOR</a>
<a name="ln4367">             || (major == VIM_VERSION_MAJOR</a>
<a name="ln4368">                 &amp;&amp; (minor &lt; VIM_VERSION_MINOR</a>
<a name="ln4369">                     || (minor == VIM_VERSION_MINOR</a>
<a name="ln4370">                         &amp;&amp; has_vim_patch(atoi(name + 10))))));</a>
<a name="ln4371">      } else {</a>
<a name="ln4372">        n = has_vim_patch(atoi(name + 5));</a>
<a name="ln4373">      }</a>
<a name="ln4374">    } else if (STRNICMP(name, &quot;nvim-&quot;, 5) == 0) {</a>
<a name="ln4375">      // Expect &quot;nvim-x.y.z&quot;</a>
<a name="ln4376">      n = has_nvim_version(name + 5);</a>
<a name="ln4377">    } else if (STRICMP(name, &quot;vim_starting&quot;) == 0) {</a>
<a name="ln4378">      n = (starting != 0);</a>
<a name="ln4379">    } else if (STRICMP(name, &quot;ttyin&quot;) == 0) {</a>
<a name="ln4380">      n = stdin_isatty;</a>
<a name="ln4381">    } else if (STRICMP(name, &quot;ttyout&quot;) == 0) {</a>
<a name="ln4382">      n = stdout_isatty;</a>
<a name="ln4383">    } else if (STRICMP(name, &quot;multi_byte_encoding&quot;) == 0) {</a>
<a name="ln4384">      n = true;</a>
<a name="ln4385">    } else if (STRICMP(name, &quot;syntax_items&quot;) == 0) {</a>
<a name="ln4386">      n = syntax_present(curwin);</a>
<a name="ln4387">    } else if (STRICMP(name, &quot;clipboard_working&quot;) == 0) {</a>
<a name="ln4388">      n = eval_has_provider(&quot;clipboard&quot;);</a>
<a name="ln4389">#ifdef UNIX</a>
<a name="ln4390">    } else if (STRICMP(name, &quot;unnamedplus&quot;) == 0) {</a>
<a name="ln4391">      n = eval_has_provider(&quot;clipboard&quot;);</a>
<a name="ln4392">#endif</a>
<a name="ln4393">    }</a>
<a name="ln4394">  }</a>
<a name="ln4395"> </a>
<a name="ln4396">  if (!n &amp;&amp; eval_has_provider(name)) {</a>
<a name="ln4397">    n = true;</a>
<a name="ln4398">  }</a>
<a name="ln4399"> </a>
<a name="ln4400">  rettv-&gt;vval.v_number = n;</a>
<a name="ln4401">}</a>
<a name="ln4402"> </a>
<a name="ln4403">/*</a>
<a name="ln4404"> * &quot;has_key()&quot; function</a>
<a name="ln4405"> */</a>
<a name="ln4406">static void f_has_key(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4407">{</a>
<a name="ln4408">  if (argvars[0].v_type != VAR_DICT) {</a>
<a name="ln4409">    EMSG(_(e_dictreq));</a>
<a name="ln4410">    return;</a>
<a name="ln4411">  }</a>
<a name="ln4412">  if (argvars[0].vval.v_dict == NULL)</a>
<a name="ln4413">    return;</a>
<a name="ln4414"> </a>
<a name="ln4415">  rettv-&gt;vval.v_number = tv_dict_find(argvars[0].vval.v_dict,</a>
<a name="ln4416">                                      tv_get_string(&amp;argvars[1]),</a>
<a name="ln4417">                                      -1) != NULL;</a>
<a name="ln4418">}</a>
<a name="ln4419"> </a>
<a name="ln4420">/// `haslocaldir([{win}[, {tab}]])` function</a>
<a name="ln4421">///</a>
<a name="ln4422">/// Returns `1` if the scope object has a local directory, `0` otherwise. If a</a>
<a name="ln4423">/// scope object is not specified the current one is implied. This function</a>
<a name="ln4424">/// share a lot of code with `f_getcwd`.</a>
<a name="ln4425">///</a>
<a name="ln4426">/// @pre  The arguments must be of type number.</a>
<a name="ln4427">/// @pre  There may not be more than two arguments.</a>
<a name="ln4428">/// @pre  An argument may not be -1 if preceding arguments are not all -1.</a>
<a name="ln4429">///</a>
<a name="ln4430">/// @post  The return value will be either the number `1` or `0`.</a>
<a name="ln4431">static void f_haslocaldir(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4432">{</a>
<a name="ln4433">  // Possible scope of working directory to return.</a>
<a name="ln4434">  CdScope scope = kCdScopeInvalid;</a>
<a name="ln4435"> </a>
<a name="ln4436">  // Numbers of the scope objects (window, tab) we want the working directory</a>
<a name="ln4437">  // of. A `-1` means to skip this scope, a `0` means the current object.</a>
<a name="ln4438">  int scope_number[] = {</a>
<a name="ln4439">    [kCdScopeWindow] = 0,  // Number of window to look at.</a>
<a name="ln4440">    [kCdScopeTab   ] = 0,  // Number of tab to look at.</a>
<a name="ln4441">  };</a>
<a name="ln4442"> </a>
<a name="ln4443">  tabpage_T *tp  = curtab;  // The tabpage to look at.</a>
<a name="ln4444">  win_T     *win = curwin;  // The window to look at.</a>
<a name="ln4445"> </a>
<a name="ln4446">  rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln4447">  rettv-&gt;vval.v_number = 0;</a>
<a name="ln4448"> </a>
<a name="ln4449">  // Pre-conditions and scope extraction together</a>
<a name="ln4450">  for (int i = MIN_CD_SCOPE; i &lt; MAX_CD_SCOPE; i++) {</a>
<a name="ln4451">    if (argvars[i].v_type == VAR_UNKNOWN) {</a>
<a name="ln4452">      break;</a>
<a name="ln4453">    }</a>
<a name="ln4454">    if (argvars[i].v_type != VAR_NUMBER) {</a>
<a name="ln4455">      EMSG(_(e_invarg));</a>
<a name="ln4456">      return;</a>
<a name="ln4457">    }</a>
<a name="ln4458">    scope_number[i] = argvars[i].vval.v_number;</a>
<a name="ln4459">    if (scope_number[i] &lt; -1) {</a>
<a name="ln4460">      EMSG(_(e_invarg));</a>
<a name="ln4461">      return;</a>
<a name="ln4462">    }</a>
<a name="ln4463">    // Use the narrowest scope the user requested</a>
<a name="ln4464">    if (scope_number[i] &gt;= 0 &amp;&amp; scope == kCdScopeInvalid) {</a>
<a name="ln4465">      // The scope is the current iteration step.</a>
<a name="ln4466">      scope = i;</a>
<a name="ln4467">    } else if (scope_number[i] &lt; 0) {</a>
<a name="ln4468">      scope = i + 1;</a>
<a name="ln4469">    }</a>
<a name="ln4470">  }</a>
<a name="ln4471"> </a>
<a name="ln4472">  // If the user didn't specify anything, default to window scope</a>
<a name="ln4473">  if (scope == kCdScopeInvalid) {</a>
<a name="ln4474">    scope = MIN_CD_SCOPE;</a>
<a name="ln4475">  }</a>
<a name="ln4476"> </a>
<a name="ln4477">  // Find the tabpage by number</a>
<a name="ln4478">  if (scope_number[kCdScopeTab] &gt; 0) {</a>
<a name="ln4479">    tp = find_tabpage(scope_number[kCdScopeTab]);</a>
<a name="ln4480">    if (!tp) {</a>
<a name="ln4481">      EMSG(_(&quot;E5000: Cannot find tab number.&quot;));</a>
<a name="ln4482">      return;</a>
<a name="ln4483">    }</a>
<a name="ln4484">  }</a>
<a name="ln4485"> </a>
<a name="ln4486">  // Find the window in `tp` by number, `NULL` if none.</a>
<a name="ln4487">  if (scope_number[kCdScopeWindow] &gt;= 0) {</a>
<a name="ln4488">    if (scope_number[kCdScopeTab] &lt; 0) {</a>
<a name="ln4489">      EMSG(_(&quot;E5001: Higher scope cannot be -1 if lower scope is &gt;= 0.&quot;));</a>
<a name="ln4490">      return;</a>
<a name="ln4491">    }</a>
<a name="ln4492"> </a>
<a name="ln4493">    if (scope_number[kCdScopeWindow] &gt; 0) {</a>
<a name="ln4494">      win = find_win_by_nr(&amp;argvars[0], tp);</a>
<a name="ln4495">      if (!win) {</a>
<a name="ln4496">        EMSG(_(&quot;E5002: Cannot find window number.&quot;));</a>
<a name="ln4497">        return;</a>
<a name="ln4498">      }</a>
<a name="ln4499">    }</a>
<a name="ln4500">  }</a>
<a name="ln4501"> </a>
<a name="ln4502">  switch (scope) {</a>
<a name="ln4503">    case kCdScopeWindow:</a>
<a name="ln4504">      assert(win);</a>
<a name="ln4505">      rettv-&gt;vval.v_number = win-&gt;w_localdir ? 1 : 0;</a>
<a name="ln4506">      break;</a>
<a name="ln4507">    case kCdScopeTab:</a>
<a name="ln4508">      assert(tp);</a>
<a name="ln4509">      rettv-&gt;vval.v_number = tp-&gt;tp_localdir ? 1 : 0;</a>
<a name="ln4510">      break;</a>
<a name="ln4511">    case kCdScopeGlobal:</a>
<a name="ln4512">      // The global scope never has a local directory</a>
<a name="ln4513">      break;</a>
<a name="ln4514">    case kCdScopeInvalid:</a>
<a name="ln4515">      // We should never get here</a>
<a name="ln4516">      abort();</a>
<a name="ln4517">  }</a>
<a name="ln4518">}</a>
<a name="ln4519"> </a>
<a name="ln4520">/*</a>
<a name="ln4521"> * &quot;hasmapto()&quot; function</a>
<a name="ln4522"> */</a>
<a name="ln4523">static void f_hasmapto(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4524">{</a>
<a name="ln4525">  const char *mode;</a>
<a name="ln4526">  const char *const name = tv_get_string(&amp;argvars[0]);</a>
<a name="ln4527">  bool abbr = false;</a>
<a name="ln4528">  char buf[NUMBUFLEN];</a>
<a name="ln4529">  if (argvars[1].v_type == VAR_UNKNOWN) {</a>
<a name="ln4530">    mode = &quot;nvo&quot;;</a>
<a name="ln4531">  } else {</a>
<a name="ln4532">    mode = tv_get_string_buf(&amp;argvars[1], buf);</a>
<a name="ln4533">    if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln4534">      abbr = tv_get_number(&amp;argvars[2]);</a>
<a name="ln4535">    }</a>
<a name="ln4536">  }</a>
<a name="ln4537"> </a>
<a name="ln4538">  if (map_to_exists(name, mode, abbr)) {</a>
<a name="ln4539">    rettv-&gt;vval.v_number = true;</a>
<a name="ln4540">  } else {</a>
<a name="ln4541">    rettv-&gt;vval.v_number = false;</a>
<a name="ln4542">  }</a>
<a name="ln4543">}</a>
<a name="ln4544"> </a>
<a name="ln4545">/*</a>
<a name="ln4546"> * &quot;histadd()&quot; function</a>
<a name="ln4547"> */</a>
<a name="ln4548">static void f_histadd(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4549">{</a>
<a name="ln4550">  HistoryType histype;</a>
<a name="ln4551"> </a>
<a name="ln4552">  rettv-&gt;vval.v_number = false;</a>
<a name="ln4553">  if (check_secure()) {</a>
<a name="ln4554">    return;</a>
<a name="ln4555">  }</a>
<a name="ln4556">  const char *str = tv_get_string_chk(&amp;argvars[0]);  // NULL on type error</a>
<a name="ln4557">  histype = str != NULL ? get_histtype(str, strlen(str), false) : HIST_INVALID;</a>
<a name="ln4558">  if (histype != HIST_INVALID) {</a>
<a name="ln4559">    char buf[NUMBUFLEN];</a>
<a name="ln4560">    str = tv_get_string_buf(&amp;argvars[1], buf);</a>
<a name="ln4561">    if (*str != NUL) {</a>
<a name="ln4562">      init_history();</a>
<a name="ln4563">      add_to_history(histype, (char_u *)str, false, NUL);</a>
<a name="ln4564">      rettv-&gt;vval.v_number = true;</a>
<a name="ln4565">      return;</a>
<a name="ln4566">    }</a>
<a name="ln4567">  }</a>
<a name="ln4568">}</a>
<a name="ln4569"> </a>
<a name="ln4570">/*</a>
<a name="ln4571"> * &quot;histdel()&quot; function</a>
<a name="ln4572"> */</a>
<a name="ln4573">static void f_histdel(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4574">{</a>
<a name="ln4575">  int n;</a>
<a name="ln4576">  const char *const str = tv_get_string_chk(&amp;argvars[0]);  // NULL on type error</a>
<a name="ln4577">  if (str == NULL) {</a>
<a name="ln4578">    n = 0;</a>
<a name="ln4579">  } else if (argvars[1].v_type == VAR_UNKNOWN) {</a>
<a name="ln4580">    // only one argument: clear entire history</a>
<a name="ln4581">    n = clr_history(get_histtype(str, strlen(str), false));</a>
<a name="ln4582">  } else if (argvars[1].v_type == VAR_NUMBER) {</a>
<a name="ln4583">    // index given: remove that entry</a>
<a name="ln4584">    n = del_history_idx(get_histtype(str, strlen(str), false),</a>
<a name="ln4585">                        (int)tv_get_number(&amp;argvars[1]));</a>
<a name="ln4586">  } else {</a>
<a name="ln4587">    // string given: remove all matching entries</a>
<a name="ln4588">    char buf[NUMBUFLEN];</a>
<a name="ln4589">    n = del_history_entry(get_histtype(str, strlen(str), false),</a>
<a name="ln4590">                          (char_u *)tv_get_string_buf(&amp;argvars[1], buf));</a>
<a name="ln4591">  }</a>
<a name="ln4592">  rettv-&gt;vval.v_number = n;</a>
<a name="ln4593">}</a>
<a name="ln4594"> </a>
<a name="ln4595">/*</a>
<a name="ln4596"> * &quot;histget()&quot; function</a>
<a name="ln4597"> */</a>
<a name="ln4598">static void f_histget(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4599">{</a>
<a name="ln4600">  HistoryType type;</a>
<a name="ln4601">  int idx;</a>
<a name="ln4602"> </a>
<a name="ln4603">  const char *const str = tv_get_string_chk(&amp;argvars[0]);  // NULL on type error</a>
<a name="ln4604">  if (str == NULL) {</a>
<a name="ln4605">    rettv-&gt;vval.v_string = NULL;</a>
<a name="ln4606">  } else {</a>
<a name="ln4607">    type = get_histtype(str, strlen(str), false);</a>
<a name="ln4608">    if (argvars[1].v_type == VAR_UNKNOWN) {</a>
<a name="ln4609">      idx = get_history_idx(type);</a>
<a name="ln4610">    } else {</a>
<a name="ln4611">      idx = (int)tv_get_number_chk(&amp;argvars[1], NULL);</a>
<a name="ln4612">    }</a>
<a name="ln4613">    // -1 on type error</a>
<a name="ln4614">    rettv-&gt;vval.v_string = vim_strsave(get_history_entry(type, idx));</a>
<a name="ln4615">  }</a>
<a name="ln4616">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln4617">}</a>
<a name="ln4618"> </a>
<a name="ln4619">/*</a>
<a name="ln4620"> * &quot;histnr()&quot; function</a>
<a name="ln4621"> */</a>
<a name="ln4622">static void f_histnr(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4623">{</a>
<a name="ln4624">  const char *const history = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln4625">  HistoryType i = history == NULL</a>
<a name="ln4626">    ? HIST_INVALID</a>
<a name="ln4627">    : get_histtype(history, strlen(history), false);</a>
<a name="ln4628">  if (i != HIST_INVALID) {</a>
<a name="ln4629">    i = get_history_idx(i);</a>
<a name="ln4630">  }</a>
<a name="ln4631">  rettv-&gt;vval.v_number = i;</a>
<a name="ln4632">}</a>
<a name="ln4633"> </a>
<a name="ln4634">/*</a>
<a name="ln4635"> * &quot;highlightID(name)&quot; function</a>
<a name="ln4636"> */</a>
<a name="ln4637">static void f_hlID(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4638">{</a>
<a name="ln4639">  rettv-&gt;vval.v_number = syn_name2id(</a>
<a name="ln4640">      (const char_u *)tv_get_string(&amp;argvars[0]));</a>
<a name="ln4641">}</a>
<a name="ln4642"> </a>
<a name="ln4643">/*</a>
<a name="ln4644"> * &quot;highlight_exists()&quot; function</a>
<a name="ln4645"> */</a>
<a name="ln4646">static void f_hlexists(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4647">{</a>
<a name="ln4648">  rettv-&gt;vval.v_number = highlight_exists(</a>
<a name="ln4649">      (const char_u *)tv_get_string(&amp;argvars[0]));</a>
<a name="ln4650">}</a>
<a name="ln4651"> </a>
<a name="ln4652">/*</a>
<a name="ln4653"> * &quot;hostname()&quot; function</a>
<a name="ln4654"> */</a>
<a name="ln4655">static void f_hostname(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4656">{</a>
<a name="ln4657">  char hostname[256];</a>
<a name="ln4658"> </a>
<a name="ln4659">  os_get_hostname(hostname, 256);</a>
<a name="ln4660">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln4661">  rettv-&gt;vval.v_string = vim_strsave((char_u *)hostname);</a>
<a name="ln4662">}</a>
<a name="ln4663"> </a>
<a name="ln4664">/*</a>
<a name="ln4665"> * iconv() function</a>
<a name="ln4666"> */</a>
<a name="ln4667">static void f_iconv(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4668">{</a>
<a name="ln4669">  vimconv_T vimconv;</a>
<a name="ln4670"> </a>
<a name="ln4671">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln4672">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln4673"> </a>
<a name="ln4674">  const char *const str = tv_get_string(&amp;argvars[0]);</a>
<a name="ln4675">  char buf1[NUMBUFLEN];</a>
<a name="ln4676">  char_u *const from = enc_canonize(enc_skip(</a>
<a name="ln4677">      (char_u *)tv_get_string_buf(&amp;argvars[1], buf1)));</a>
<a name="ln4678">  char buf2[NUMBUFLEN];</a>
<a name="ln4679">  char_u *const to = enc_canonize(enc_skip(</a>
<a name="ln4680">      (char_u *)tv_get_string_buf(&amp;argvars[2], buf2)));</a>
<a name="ln4681">  vimconv.vc_type = CONV_NONE;</a>
<a name="ln4682">  convert_setup(&amp;vimconv, from, to);</a>
<a name="ln4683"> </a>
<a name="ln4684">  // If the encodings are equal, no conversion needed.</a>
<a name="ln4685">  if (vimconv.vc_type == CONV_NONE) {</a>
<a name="ln4686">    rettv-&gt;vval.v_string = (char_u *)xstrdup(str);</a>
<a name="ln4687">  } else {</a>
<a name="ln4688">    rettv-&gt;vval.v_string = string_convert(&amp;vimconv, (char_u *)str, NULL);</a>
<a name="ln4689">  }</a>
<a name="ln4690"> </a>
<a name="ln4691">  convert_setup(&amp;vimconv, NULL, NULL);</a>
<a name="ln4692">  xfree(from);</a>
<a name="ln4693">  xfree(to);</a>
<a name="ln4694">}</a>
<a name="ln4695"> </a>
<a name="ln4696">/*</a>
<a name="ln4697"> * &quot;indent()&quot; function</a>
<a name="ln4698"> */</a>
<a name="ln4699">static void f_indent(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4700">{</a>
<a name="ln4701">  const linenr_T lnum = tv_get_lnum(argvars);</a>
<a name="ln4702">  if (lnum &gt;= 1 &amp;&amp; lnum &lt;= curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln4703">    rettv-&gt;vval.v_number = get_indent_lnum(lnum);</a>
<a name="ln4704">  } else {</a>
<a name="ln4705">    rettv-&gt;vval.v_number = -1;</a>
<a name="ln4706">  }</a>
<a name="ln4707">}</a>
<a name="ln4708"> </a>
<a name="ln4709">/*</a>
<a name="ln4710"> * &quot;index()&quot; function</a>
<a name="ln4711"> */</a>
<a name="ln4712">static void f_index(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4713">{</a>
<a name="ln4714">  long idx = 0;</a>
<a name="ln4715">  bool ic = false;</a>
<a name="ln4716"> </a>
<a name="ln4717">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln4718">  if (argvars[0].v_type != VAR_LIST) {</a>
<a name="ln4719">    EMSG(_(e_listreq));</a>
<a name="ln4720">    return;</a>
<a name="ln4721">  }</a>
<a name="ln4722">  list_T *const l = argvars[0].vval.v_list;</a>
<a name="ln4723">  if (l != NULL) {</a>
<a name="ln4724">    listitem_T *item = tv_list_first(l);</a>
<a name="ln4725">    if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln4726">      bool error = false;</a>
<a name="ln4727"> </a>
<a name="ln4728">      // Start at specified item.</a>
<a name="ln4729">      idx = tv_list_uidx(l, tv_get_number_chk(&amp;argvars[2], &amp;error));</a>
<a name="ln4730">      if (error || idx == -1) {</a>
<a name="ln4731">        item = NULL;</a>
<a name="ln4732">      } else {</a>
<a name="ln4733">        item = tv_list_find(l, idx);</a>
<a name="ln4734">        assert(item != NULL);</a>
<a name="ln4735">      }</a>
<a name="ln4736">      if (argvars[3].v_type != VAR_UNKNOWN) {</a>
<a name="ln4737">        ic = !!tv_get_number_chk(&amp;argvars[3], &amp;error);</a>
<a name="ln4738">        if (error) {</a>
<a name="ln4739">          item = NULL;</a>
<a name="ln4740">        }</a>
<a name="ln4741">      }</a>
<a name="ln4742">    }</a>
<a name="ln4743"> </a>
<a name="ln4744">    for (; item != NULL; item = TV_LIST_ITEM_NEXT(l, item), idx++) {</a>
<a name="ln4745">      if (tv_equal(TV_LIST_ITEM_TV(item), &amp;argvars[1], ic, false)) {</a>
<a name="ln4746">        rettv-&gt;vval.v_number = idx;</a>
<a name="ln4747">        break;</a>
<a name="ln4748">      }</a>
<a name="ln4749">    }</a>
<a name="ln4750">  }</a>
<a name="ln4751">}</a>
<a name="ln4752"> </a>
<a name="ln4753">static bool inputsecret_flag = false;</a>
<a name="ln4754"> </a>
<a name="ln4755">/*</a>
<a name="ln4756"> * &quot;input()&quot; function</a>
<a name="ln4757"> *     Also handles inputsecret() when inputsecret is set.</a>
<a name="ln4758"> */</a>
<a name="ln4759">static void f_input(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4760">{</a>
<a name="ln4761">  get_user_input(argvars, rettv, FALSE, inputsecret_flag);</a>
<a name="ln4762">}</a>
<a name="ln4763"> </a>
<a name="ln4764">/*</a>
<a name="ln4765"> * &quot;inputdialog()&quot; function</a>
<a name="ln4766"> */</a>
<a name="ln4767">static void f_inputdialog(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4768">{</a>
<a name="ln4769">  get_user_input(argvars, rettv, TRUE, inputsecret_flag);</a>
<a name="ln4770">}</a>
<a name="ln4771"> </a>
<a name="ln4772">/*</a>
<a name="ln4773"> * &quot;inputlist()&quot; function</a>
<a name="ln4774"> */</a>
<a name="ln4775">static void f_inputlist(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4776">{</a>
<a name="ln4777">  int selected;</a>
<a name="ln4778">  int mouse_used;</a>
<a name="ln4779"> </a>
<a name="ln4780">  if (argvars[0].v_type != VAR_LIST) {</a>
<a name="ln4781">    EMSG2(_(e_listarg), &quot;inputlist()&quot;);</a>
<a name="ln4782">    return;</a>
<a name="ln4783">  }</a>
<a name="ln4784"> </a>
<a name="ln4785">  msg_start();</a>
<a name="ln4786">  msg_row = Rows - 1;   // for when 'cmdheight' &gt; 1</a>
<a name="ln4787">  lines_left = Rows;    // avoid more prompt</a>
<a name="ln4788">  msg_scroll = true;</a>
<a name="ln4789">  msg_clr_eos();</a>
<a name="ln4790"> </a>
<a name="ln4791">  TV_LIST_ITER_CONST(argvars[0].vval.v_list, li, {</a>
<a name="ln4792">    msg_puts(tv_get_string(TV_LIST_ITEM_TV(li)));</a>
<a name="ln4793">    msg_putchar('\n');</a>
<a name="ln4794">  });</a>
<a name="ln4795"> </a>
<a name="ln4796">  // Ask for choice.</a>
<a name="ln4797">  selected = prompt_for_number(&amp;mouse_used);</a>
<a name="ln4798">  if (mouse_used) {</a>
<a name="ln4799">    selected -= lines_left;</a>
<a name="ln4800">  }</a>
<a name="ln4801"> </a>
<a name="ln4802">  rettv-&gt;vval.v_number = selected;</a>
<a name="ln4803">}</a>
<a name="ln4804"> </a>
<a name="ln4805"> </a>
<a name="ln4806">static garray_T ga_userinput = { 0, 0, sizeof(tasave_T), 4, NULL };</a>
<a name="ln4807"> </a>
<a name="ln4808">/// &quot;inputrestore()&quot; function</a>
<a name="ln4809">static void f_inputrestore(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4810">{</a>
<a name="ln4811">  if (!GA_EMPTY(&amp;ga_userinput)) {</a>
<a name="ln4812">    ga_userinput.ga_len--;</a>
<a name="ln4813">    restore_typeahead((tasave_T *)(ga_userinput.ga_data)</a>
<a name="ln4814">                      + ga_userinput.ga_len);</a>
<a name="ln4815">    // default return is zero == OK</a>
<a name="ln4816">  } else if (p_verbose &gt; 1) {</a>
<a name="ln4817">    verb_msg(_(&quot;called inputrestore() more often than inputsave()&quot;));</a>
<a name="ln4818">    rettv-&gt;vval.v_number = 1;  // Failed</a>
<a name="ln4819">  }</a>
<a name="ln4820">}</a>
<a name="ln4821"> </a>
<a name="ln4822">/// &quot;inputsave()&quot; function</a>
<a name="ln4823">static void f_inputsave(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4824">{</a>
<a name="ln4825">  // Add an entry to the stack of typeahead storage.</a>
<a name="ln4826">  tasave_T *p = GA_APPEND_VIA_PTR(tasave_T, &amp;ga_userinput);</a>
<a name="ln4827">  save_typeahead(p);</a>
<a name="ln4828">}</a>
<a name="ln4829"> </a>
<a name="ln4830">/// &quot;inputsecret()&quot; function</a>
<a name="ln4831">static void f_inputsecret(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4832">{</a>
<a name="ln4833">  cmdline_star++;</a>
<a name="ln4834">  inputsecret_flag = true;</a>
<a name="ln4835">  f_input(argvars, rettv, NULL);</a>
<a name="ln4836">  cmdline_star--;</a>
<a name="ln4837">  inputsecret_flag = false;</a>
<a name="ln4838">}</a>
<a name="ln4839"> </a>
<a name="ln4840">/*</a>
<a name="ln4841"> * &quot;insert()&quot; function</a>
<a name="ln4842"> */</a>
<a name="ln4843">static void f_insert(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4844">{</a>
<a name="ln4845">  list_T *l;</a>
<a name="ln4846">  bool error = false;</a>
<a name="ln4847"> </a>
<a name="ln4848">  if (argvars[0].v_type != VAR_LIST) {</a>
<a name="ln4849">    EMSG2(_(e_listarg), &quot;insert()&quot;);</a>
<a name="ln4850">  } else if (!var_check_lock(tv_list_locked((l = argvars[0].vval.v_list)),</a>
<a name="ln4851">                             N_(&quot;insert() argument&quot;), TV_TRANSLATE)) {</a>
<a name="ln4852">    long before = 0;</a>
<a name="ln4853">    if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln4854">      before = tv_get_number_chk(&amp;argvars[2], &amp;error);</a>
<a name="ln4855">    }</a>
<a name="ln4856">    if (error) {</a>
<a name="ln4857">      // type error; errmsg already given</a>
<a name="ln4858">      return;</a>
<a name="ln4859">    }</a>
<a name="ln4860"> </a>
<a name="ln4861">    listitem_T *item = NULL;</a>
<a name="ln4862">    if (before != tv_list_len(l)) {</a>
<a name="ln4863">      item = tv_list_find(l, before);</a>
<a name="ln4864">      if (item == NULL) {</a>
<a name="ln4865">        EMSGN(_(e_listidx), before);</a>
<a name="ln4866">        l = NULL;</a>
<a name="ln4867">      }</a>
<a name="ln4868">    }</a>
<a name="ln4869">    if (l != NULL) {</a>
<a name="ln4870">      tv_list_insert_tv(l, &amp;argvars[1], item);</a>
<a name="ln4871">      tv_copy(&amp;argvars[0], rettv);</a>
<a name="ln4872">    }</a>
<a name="ln4873">  }</a>
<a name="ln4874">}</a>
<a name="ln4875"> </a>
<a name="ln4876">// &quot;interrupt()&quot; function</a>
<a name="ln4877">static void f_interrupt(typval_T *argvars FUNC_ATTR_UNUSED,</a>
<a name="ln4878">                        typval_T *rettv FUNC_ATTR_UNUSED,</a>
<a name="ln4879">                        FunPtr fptr FUNC_ATTR_UNUSED)</a>
<a name="ln4880">{</a>
<a name="ln4881">  got_int = true;</a>
<a name="ln4882">}</a>
<a name="ln4883"> </a>
<a name="ln4884">/*</a>
<a name="ln4885"> * &quot;invert(expr)&quot; function</a>
<a name="ln4886"> */</a>
<a name="ln4887">static void f_invert(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4888">{</a>
<a name="ln4889">  rettv-&gt;vval.v_number = ~tv_get_number_chk(&amp;argvars[0], NULL);</a>
<a name="ln4890">}</a>
<a name="ln4891"> </a>
<a name="ln4892">/*</a>
<a name="ln4893"> * &quot;isdirectory()&quot; function</a>
<a name="ln4894"> */</a>
<a name="ln4895">static void f_isdirectory(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4896">{</a>
<a name="ln4897">  rettv-&gt;vval.v_number = os_isdir((const char_u *)tv_get_string(&amp;argvars[0]));</a>
<a name="ln4898">}</a>
<a name="ln4899"> </a>
<a name="ln4900">/*</a>
<a name="ln4901"> * &quot;islocked()&quot; function</a>
<a name="ln4902"> */</a>
<a name="ln4903">static void f_islocked(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4904">{</a>
<a name="ln4905">  lval_T lv;</a>
<a name="ln4906">  dictitem_T  *di;</a>
<a name="ln4907"> </a>
<a name="ln4908">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln4909">  const char_u *const end = get_lval((char_u *)tv_get_string(&amp;argvars[0]),</a>
<a name="ln4910">                                     NULL,</a>
<a name="ln4911">                                     &amp;lv, false, false,</a>
<a name="ln4912">                                     GLV_NO_AUTOLOAD|GLV_READ_ONLY,</a>
<a name="ln4913">                                     FNE_CHECK_START);</a>
<a name="ln4914">  if (end != NULL &amp;&amp; lv.ll_name != NULL) {</a>
<a name="ln4915">    if (*end != NUL) {</a>
<a name="ln4916">      EMSG(_(e_trailing));</a>
<a name="ln4917">    } else {</a>
<a name="ln4918">      if (lv.ll_tv == NULL) {</a>
<a name="ln4919">        di = find_var((const char *)lv.ll_name, lv.ll_name_len, NULL, true);</a>
<a name="ln4920">        if (di != NULL) {</a>
<a name="ln4921">          // Consider a variable locked when:</a>
<a name="ln4922">          // 1. the variable itself is locked</a>
<a name="ln4923">          // 2. the value of the variable is locked.</a>
<a name="ln4924">          // 3. the List or Dict value is locked.</a>
<a name="ln4925">          rettv-&gt;vval.v_number = ((di-&gt;di_flags &amp; DI_FLAGS_LOCK)</a>
<a name="ln4926">                                  || tv_islocked(&amp;di-&gt;di_tv));</a>
<a name="ln4927">        }</a>
<a name="ln4928">      } else if (lv.ll_range) {</a>
<a name="ln4929">        EMSG(_(&quot;E786: Range not allowed&quot;));</a>
<a name="ln4930">      } else if (lv.ll_newkey != NULL) {</a>
<a name="ln4931">        EMSG2(_(e_dictkey), lv.ll_newkey);</a>
<a name="ln4932">      } else if (lv.ll_list != NULL) {</a>
<a name="ln4933">        // List item.</a>
<a name="ln4934">        rettv-&gt;vval.v_number = tv_islocked(TV_LIST_ITEM_TV(lv.ll_li));</a>
<a name="ln4935">      } else {</a>
<a name="ln4936">        // Dictionary item.</a>
<a name="ln4937">        rettv-&gt;vval.v_number = tv_islocked(&amp;lv.ll_di-&gt;di_tv);</a>
<a name="ln4938">      }</a>
<a name="ln4939">    }</a>
<a name="ln4940">  }</a>
<a name="ln4941"> </a>
<a name="ln4942">  clear_lval(&amp;lv);</a>
<a name="ln4943">}</a>
<a name="ln4944"> </a>
<a name="ln4945">// &quot;isinf()&quot; function</a>
<a name="ln4946">static void f_isinf(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4947">{</a>
<a name="ln4948">  if (argvars[0].v_type == VAR_FLOAT</a>
<a name="ln4949">      &amp;&amp; xisinf(argvars[0].vval.v_float)) {</a>
<a name="ln4950">    rettv-&gt;vval.v_number = argvars[0].vval.v_float &gt; 0.0 ? 1 : -1;</a>
<a name="ln4951">  }</a>
<a name="ln4952">}</a>
<a name="ln4953"> </a>
<a name="ln4954">// &quot;isnan()&quot; function</a>
<a name="ln4955">static void f_isnan(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4956">{</a>
<a name="ln4957">  rettv-&gt;vval.v_number = argvars[0].v_type == VAR_FLOAT</a>
<a name="ln4958">    &amp;&amp; xisnan(argvars[0].vval.v_float);</a>
<a name="ln4959">}</a>
<a name="ln4960"> </a>
<a name="ln4961">/// &quot;id()&quot; function</a>
<a name="ln4962">static void f_id(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4963">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln4964">{</a>
<a name="ln4965">  const int len = vim_vsnprintf_typval(NULL, 0, &quot;%p&quot;, dummy_ap, argvars);</a>
<a name="ln4966">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln4967">  rettv-&gt;vval.v_string = xmalloc(len + 1);</a>
<a name="ln4968">  vim_vsnprintf_typval((char *)rettv-&gt;vval.v_string, len + 1, &quot;%p&quot;,</a>
<a name="ln4969">                       dummy_ap, argvars);</a>
<a name="ln4970">}</a>
<a name="ln4971"> </a>
<a name="ln4972">/*</a>
<a name="ln4973"> * &quot;items(dict)&quot; function</a>
<a name="ln4974"> */</a>
<a name="ln4975">static void f_items(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4976">{</a>
<a name="ln4977">  dict_list(argvars, rettv, 2);</a>
<a name="ln4978">}</a>
<a name="ln4979"> </a>
<a name="ln4980">// &quot;jobpid(id)&quot; function</a>
<a name="ln4981">static void f_jobpid(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4982">{</a>
<a name="ln4983">  rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln4984">  rettv-&gt;vval.v_number = 0;</a>
<a name="ln4985"> </a>
<a name="ln4986">  if (check_secure()) {</a>
<a name="ln4987">    return;</a>
<a name="ln4988">  }</a>
<a name="ln4989"> </a>
<a name="ln4990">  if (argvars[0].v_type != VAR_NUMBER) {</a>
<a name="ln4991">    EMSG(_(e_invarg));</a>
<a name="ln4992">    return;</a>
<a name="ln4993">  }</a>
<a name="ln4994"> </a>
<a name="ln4995">  Channel *data = find_job(argvars[0].vval.v_number, true);</a>
<a name="ln4996">  if (!data) {</a>
<a name="ln4997">    return;</a>
<a name="ln4998">  }</a>
<a name="ln4999"> </a>
<a name="ln5000">  Process *proc = (Process *)&amp;data-&gt;stream.proc;</a>
<a name="ln5001">  rettv-&gt;vval.v_number = proc-&gt;pid;</a>
<a name="ln5002">}</a>
<a name="ln5003"> </a>
<a name="ln5004">// &quot;jobresize(job, width, height)&quot; function</a>
<a name="ln5005">static void f_jobresize(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5006">{</a>
<a name="ln5007">  rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln5008">  rettv-&gt;vval.v_number = 0;</a>
<a name="ln5009"> </a>
<a name="ln5010">  if (check_secure()) {</a>
<a name="ln5011">    return;</a>
<a name="ln5012">  }</a>
<a name="ln5013"> </a>
<a name="ln5014">  if (argvars[0].v_type != VAR_NUMBER || argvars[1].v_type != VAR_NUMBER</a>
<a name="ln5015">      || argvars[2].v_type != VAR_NUMBER) {</a>
<a name="ln5016">    // job id, width, height</a>
<a name="ln5017">    EMSG(_(e_invarg));</a>
<a name="ln5018">    return;</a>
<a name="ln5019">  }</a>
<a name="ln5020"> </a>
<a name="ln5021"> </a>
<a name="ln5022">  Channel *data = find_job(argvars[0].vval.v_number, true);</a>
<a name="ln5023">  if (!data) {</a>
<a name="ln5024">    return;</a>
<a name="ln5025">  }</a>
<a name="ln5026"> </a>
<a name="ln5027">  if (data-&gt;stream.proc.type != kProcessTypePty) {</a>
<a name="ln5028">    EMSG(_(e_channotpty));</a>
<a name="ln5029">    return;</a>
<a name="ln5030">  }</a>
<a name="ln5031"> </a>
<a name="ln5032">  pty_process_resize(&amp;data-&gt;stream.pty, argvars[1].vval.v_number,</a>
<a name="ln5033">                     argvars[2].vval.v_number);</a>
<a name="ln5034">  rettv-&gt;vval.v_number = 1;</a>
<a name="ln5035">}</a>
<a name="ln5036"> </a>
<a name="ln5037">static const char *ignored_env_vars[] = {</a>
<a name="ln5038">#ifndef WIN32</a>
<a name="ln5039">  &quot;COLUMNS&quot;,</a>
<a name="ln5040">  &quot;LINES&quot;,</a>
<a name="ln5041">  &quot;TERMCAP&quot;,</a>
<a name="ln5042">  &quot;COLORFGBG&quot;,</a>
<a name="ln5043">#endif</a>
<a name="ln5044">  NULL</a>
<a name="ln5045">};</a>
<a name="ln5046"> </a>
<a name="ln5047">/// According to comments in src/win/process.c of libuv, Windows has a few</a>
<a name="ln5048">/// &quot;essential&quot; environment variables.</a>
<a name="ln5049">static const char *required_env_vars[] = {</a>
<a name="ln5050">#ifdef WIN32</a>
<a name="ln5051">  &quot;HOMEDRIVE&quot;,</a>
<a name="ln5052">  &quot;HOMEPATH&quot;,</a>
<a name="ln5053">  &quot;LOGONSERVER&quot;,</a>
<a name="ln5054">  &quot;PATH&quot;,</a>
<a name="ln5055">  &quot;SYSTEMDRIVE&quot;,</a>
<a name="ln5056">  &quot;SYSTEMROOT&quot;,</a>
<a name="ln5057">  &quot;TEMP&quot;,</a>
<a name="ln5058">  &quot;USERDOMAIN&quot;,</a>
<a name="ln5059">  &quot;USERNAME&quot;,</a>
<a name="ln5060">  &quot;USERPROFILE&quot;,</a>
<a name="ln5061">  &quot;WINDIR&quot;,</a>
<a name="ln5062">#endif</a>
<a name="ln5063">  NULL</a>
<a name="ln5064">};</a>
<a name="ln5065"> </a>
<a name="ln5066">static dict_T *create_environment(const dictitem_T *job_env,</a>
<a name="ln5067">                                  const bool clear_env,</a>
<a name="ln5068">                                  const bool pty,</a>
<a name="ln5069">                                  const char * const pty_term_name)</a>
<a name="ln5070">{</a>
<a name="ln5071">  dict_T * env = tv_dict_alloc();</a>
<a name="ln5072"> </a>
<a name="ln5073">  if (!clear_env) {</a>
<a name="ln5074">    typval_T temp_env = TV_INITIAL_VALUE;</a>
<a name="ln5075">    f_environ(NULL, &amp;temp_env, NULL);</a>
<a name="ln5076">    tv_dict_extend(env, temp_env.vval.v_dict, &quot;force&quot;);</a>
<a name="ln5077">    tv_dict_free(temp_env.vval.v_dict);</a>
<a name="ln5078"> </a>
<a name="ln5079">    if (pty) {</a>
<a name="ln5080">      // These environment variables generally shouldn't be propagated to the</a>
<a name="ln5081">      // child process.  We're removing them here so the user can still decide</a>
<a name="ln5082">      // they want to explicitly set them.</a>
<a name="ln5083">      for (size_t i = 0;</a>
<a name="ln5084">           i &lt; ARRAY_SIZE(ignored_env_vars) &amp;&amp; ignored_env_vars[i];</a>
<a name="ln5085">           i++) {</a>
<a name="ln5086">        dictitem_T *dv = tv_dict_find(env, ignored_env_vars[i], -1);</a>
<a name="ln5087">        if (dv) {</a>
<a name="ln5088">          tv_dict_item_remove(env, dv);</a>
<a name="ln5089">        }</a>
<a name="ln5090">      }</a>
<a name="ln5091">#ifndef WIN32</a>
<a name="ln5092">      // Set COLORTERM to &quot;truecolor&quot; if termguicolors is set and 256</a>
<a name="ln5093">      // otherwise, but only if it was set in the parent terminal at all</a>
<a name="ln5094">      dictitem_T *dv = tv_dict_find(env, S_LEN(&quot;COLORTERM&quot;));</a>
<a name="ln5095">      if (dv) {</a>
<a name="ln5096">        tv_dict_item_remove(env, dv);</a>
<a name="ln5097">        tv_dict_add_str(env, S_LEN(&quot;COLORTERM&quot;), p_tgc ? &quot;truecolor&quot; : &quot;256&quot;);</a>
<a name="ln5098">      }</a>
<a name="ln5099">#endif</a>
<a name="ln5100">    }</a>
<a name="ln5101">  }</a>
<a name="ln5102"> </a>
<a name="ln5103">  // For a pty, we need a sane $TERM set.  We can't rely on nvim's environment,</a>
<a name="ln5104">  // because the child process is going to be communicating with nvim, not the</a>
<a name="ln5105">  // parent terminal.  Set a sane default, but let the user override it in the</a>
<a name="ln5106">  // job's environment if they want.</a>
<a name="ln5107">  if (pty) {</a>
<a name="ln5108">    dictitem_T *dv = tv_dict_find(env, S_LEN(&quot;TERM&quot;));</a>
<a name="ln5109">    if (dv) {</a>
<a name="ln5110">      tv_dict_item_remove(env, dv);</a>
<a name="ln5111">    }</a>
<a name="ln5112">    tv_dict_add_str(env, S_LEN(&quot;TERM&quot;), pty_term_name);</a>
<a name="ln5113">  }</a>
<a name="ln5114"> </a>
<a name="ln5115">  if (job_env) {</a>
<a name="ln5116">#ifdef WIN32</a>
<a name="ln5117">    TV_DICT_ITER(job_env-&gt;di_tv.vval.v_dict, var, {</a>
<a name="ln5118">      // Always use upper-case keys for Windows so we detect duplicate keys</a>
<a name="ln5119">      char *const key = strcase_save((const char *)var-&gt;di_key, true);</a>
<a name="ln5120">      size_t len = strlen(key);</a>
<a name="ln5121">      dictitem_T *dv = tv_dict_find(env, key, len);</a>
<a name="ln5122">      if (dv) {</a>
<a name="ln5123">        tv_dict_item_remove(env, dv);</a>
<a name="ln5124">      }</a>
<a name="ln5125">      tv_dict_add_str(env, key, len, tv_get_string(&amp;var-&gt;di_tv));</a>
<a name="ln5126">      xfree(key);</a>
<a name="ln5127">    });</a>
<a name="ln5128">#else</a>
<a name="ln5129">    tv_dict_extend(env, job_env-&gt;di_tv.vval.v_dict, &quot;force&quot;);</a>
<a name="ln5130">#endif</a>
<a name="ln5131">  }</a>
<a name="ln5132"> </a>
<a name="ln5133">  if (pty) {</a>
<a name="ln5134">    // Now that the custom environment is configured, we need to ensure certain</a>
<a name="ln5135">    // environment variables are present.</a>
<a name="ln5136">    for (size_t i = 0;</a>
<a name="ln5137">         i &lt; ARRAY_SIZE(required_env_vars) &amp;&amp; required_env_vars[i];</a>
<a name="ln5138">         i++) {</a>
<a name="ln5139">      size_t len = strlen(required_env_vars[i]);</a>
<a name="ln5140">      dictitem_T *dv = tv_dict_find(env, required_env_vars[i], len);</a>
<a name="ln5141">      if (!dv) {</a>
<a name="ln5142">        const char *env_var = os_getenv(required_env_vars[i]);</a>
<a name="ln5143">        if (env_var) {</a>
<a name="ln5144">          tv_dict_add_str(env, required_env_vars[i], len, env_var);</a>
<a name="ln5145">        }</a>
<a name="ln5146">      }</a>
<a name="ln5147">    }</a>
<a name="ln5148">  }</a>
<a name="ln5149"> </a>
<a name="ln5150">  return env;</a>
<a name="ln5151">}</a>
<a name="ln5152"> </a>
<a name="ln5153">// &quot;jobstart()&quot; function</a>
<a name="ln5154">static void f_jobstart(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5155">{</a>
<a name="ln5156">  rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln5157">  rettv-&gt;vval.v_number = 0;</a>
<a name="ln5158"> </a>
<a name="ln5159">  if (check_secure()) {</a>
<a name="ln5160">    return;</a>
<a name="ln5161">  }</a>
<a name="ln5162"> </a>
<a name="ln5163">  bool executable = true;</a>
<a name="ln5164">  char **argv = tv_to_argv(&amp;argvars[0], NULL, &amp;executable);</a>
<a name="ln5165">  dict_T *env = NULL;</a>
<a name="ln5166">  if (!argv) {</a>
<a name="ln5167">    rettv-&gt;vval.v_number = executable ? 0 : -1;</a>
<a name="ln5168">    return;  // Did error message in tv_to_argv.</a>
<a name="ln5169">  }</a>
<a name="ln5170"> </a>
<a name="ln5171">  if (argvars[1].v_type != VAR_DICT &amp;&amp; argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln5172">    // Wrong argument types</a>
<a name="ln5173">    EMSG2(_(e_invarg2), &quot;expected dictionary&quot;);</a>
<a name="ln5174">    shell_free_argv(argv);</a>
<a name="ln5175">    return;</a>
<a name="ln5176">  }</a>
<a name="ln5177"> </a>
<a name="ln5178"> </a>
<a name="ln5179">  dict_T *job_opts = NULL;</a>
<a name="ln5180">  bool detach = false;</a>
<a name="ln5181">  bool rpc = false;</a>
<a name="ln5182">  bool pty = false;</a>
<a name="ln5183">  bool clear_env = false;</a>
<a name="ln5184">  bool overlapped = false;</a>
<a name="ln5185">  CallbackReader on_stdout = CALLBACK_READER_INIT,</a>
<a name="ln5186">                 on_stderr = CALLBACK_READER_INIT;</a>
<a name="ln5187">  Callback on_exit = CALLBACK_NONE;</a>
<a name="ln5188">  char *cwd = NULL;</a>
<a name="ln5189">  dictitem_T *job_env = NULL;</a>
<a name="ln5190">  if (argvars[1].v_type == VAR_DICT) {</a>
<a name="ln5191">    job_opts = argvars[1].vval.v_dict;</a>
<a name="ln5192"> </a>
<a name="ln5193">    detach = tv_dict_get_number(job_opts, &quot;detach&quot;) != 0;</a>
<a name="ln5194">    rpc = tv_dict_get_number(job_opts, &quot;rpc&quot;) != 0;</a>
<a name="ln5195">    pty = tv_dict_get_number(job_opts, &quot;pty&quot;) != 0;</a>
<a name="ln5196">    clear_env = tv_dict_get_number(job_opts, &quot;clear_env&quot;) != 0;</a>
<a name="ln5197">    overlapped = tv_dict_get_number(job_opts, &quot;overlapped&quot;) != 0;</a>
<a name="ln5198"> </a>
<a name="ln5199">    if (pty &amp;&amp; rpc) {</a>
<a name="ln5200">      EMSG2(_(e_invarg2), &quot;job cannot have both 'pty' and 'rpc' options set&quot;);</a>
<a name="ln5201">      shell_free_argv(argv);</a>
<a name="ln5202">      return;</a>
<a name="ln5203">    }</a>
<a name="ln5204"> </a>
<a name="ln5205">#ifdef WIN32</a>
<a name="ln5206">    if (pty &amp;&amp; overlapped) {</a>
<a name="ln5207">      EMSG2(_(e_invarg2),</a>
<a name="ln5208">            &quot;job cannot have both 'pty' and 'overlapped' options set&quot;);</a>
<a name="ln5209">      shell_free_argv(argv);</a>
<a name="ln5210">      return;</a>
<a name="ln5211">    }</a>
<a name="ln5212">#endif</a>
<a name="ln5213"> </a>
<a name="ln5214">    char *new_cwd = tv_dict_get_string(job_opts, &quot;cwd&quot;, false);</a>
<a name="ln5215">    if (new_cwd &amp;&amp; *new_cwd != NUL) {</a>
<a name="ln5216">      cwd = new_cwd;</a>
<a name="ln5217">      // The new cwd must be a directory.</a>
<a name="ln5218">      if (!os_isdir_executable((const char *)cwd)) {</a>
<a name="ln5219">        EMSG2(_(e_invarg2), &quot;expected valid directory&quot;);</a>
<a name="ln5220">        shell_free_argv(argv);</a>
<a name="ln5221">        return;</a>
<a name="ln5222">      }</a>
<a name="ln5223">    }</a>
<a name="ln5224"> </a>
<a name="ln5225">    job_env = tv_dict_find(job_opts, S_LEN(&quot;env&quot;));</a>
<a name="ln5226">    if (job_env &amp;&amp; job_env-&gt;di_tv.v_type != VAR_DICT) {</a>
<a name="ln5227">      EMSG2(_(e_invarg2), &quot;env&quot;);</a>
<a name="ln5228">      shell_free_argv(argv);</a>
<a name="ln5229">      return;</a>
<a name="ln5230">    }</a>
<a name="ln5231"> </a>
<a name="ln5232">    if (!common_job_callbacks(job_opts, &amp;on_stdout, &amp;on_stderr, &amp;on_exit)) {</a>
<a name="ln5233">      shell_free_argv(argv);</a>
<a name="ln5234">      return;</a>
<a name="ln5235">    }</a>
<a name="ln5236">  }</a>
<a name="ln5237"> </a>
<a name="ln5238">  uint16_t width = 0, height = 0;</a>
<a name="ln5239">  char *term_name = NULL;</a>
<a name="ln5240"> </a>
<a name="ln5241">  if (pty) {</a>
<a name="ln5242">    width = (uint16_t)tv_dict_get_number(job_opts, &quot;width&quot;);</a>
<a name="ln5243">    height = (uint16_t)tv_dict_get_number(job_opts, &quot;height&quot;);</a>
<a name="ln5244">    // Legacy method, before env option existed, to specify $TERM.  No longer</a>
<a name="ln5245">    // documented, but still usable to avoid breaking scripts.</a>
<a name="ln5246">    term_name = tv_dict_get_string(job_opts, &quot;TERM&quot;, false);</a>
<a name="ln5247">    if (!term_name) {</a>
<a name="ln5248">      term_name = &quot;ansi&quot;;</a>
<a name="ln5249">    }</a>
<a name="ln5250">  }</a>
<a name="ln5251"> </a>
<a name="ln5252">  env = create_environment(job_env, clear_env, pty, term_name);</a>
<a name="ln5253"> </a>
<a name="ln5254">  Channel *chan = channel_job_start(argv, on_stdout, on_stderr, on_exit, pty,</a>
<a name="ln5255">                                    rpc, overlapped, detach, cwd, width, height,</a>
<a name="ln5256">                                    env, &amp;rettv-&gt;vval.v_number);</a>
<a name="ln5257">  if (chan) {</a>
<a name="ln5258">    channel_create_event(chan, NULL);</a>
<a name="ln5259">  }</a>
<a name="ln5260">}</a>
<a name="ln5261"> </a>
<a name="ln5262">// &quot;jobstop()&quot; function</a>
<a name="ln5263">static void f_jobstop(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5264">{</a>
<a name="ln5265">  rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln5266">  rettv-&gt;vval.v_number = 0;</a>
<a name="ln5267"> </a>
<a name="ln5268">  if (check_secure()) {</a>
<a name="ln5269">    return;</a>
<a name="ln5270">  }</a>
<a name="ln5271"> </a>
<a name="ln5272">  if (argvars[0].v_type != VAR_NUMBER) {</a>
<a name="ln5273">    // Only argument is the job id</a>
<a name="ln5274">    EMSG(_(e_invarg));</a>
<a name="ln5275">    return;</a>
<a name="ln5276">  }</a>
<a name="ln5277"> </a>
<a name="ln5278">  Channel *data = find_job(argvars[0].vval.v_number, false);</a>
<a name="ln5279">  if (!data) {</a>
<a name="ln5280">    return;</a>
<a name="ln5281">  }</a>
<a name="ln5282"> </a>
<a name="ln5283">  const char *error = NULL;</a>
<a name="ln5284">  if (data-&gt;is_rpc) {</a>
<a name="ln5285">    // Ignore return code, but show error later.</a>
<a name="ln5286">    (void)channel_close(data-&gt;id, kChannelPartRpc, &amp;error);</a>
<a name="ln5287">  }</a>
<a name="ln5288">  process_stop((Process *)&amp;data-&gt;stream.proc);</a>
<a name="ln5289">  rettv-&gt;vval.v_number = 1;</a>
<a name="ln5290">  if (error) {</a>
<a name="ln5291">    EMSG(error);</a>
<a name="ln5292">  }</a>
<a name="ln5293">}</a>
<a name="ln5294"> </a>
<a name="ln5295">// &quot;jobwait(ids[, timeout])&quot; function</a>
<a name="ln5296">static void f_jobwait(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5297">{</a>
<a name="ln5298">  rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln5299">  rettv-&gt;vval.v_number = 0;</a>
<a name="ln5300"> </a>
<a name="ln5301">  if (check_secure()) {</a>
<a name="ln5302">    return;</a>
<a name="ln5303">  }</a>
<a name="ln5304">  if (argvars[0].v_type != VAR_LIST || (argvars[1].v_type != VAR_NUMBER</a>
<a name="ln5305">        &amp;&amp; argvars[1].v_type != VAR_UNKNOWN)) {</a>
<a name="ln5306">    EMSG(_(e_invarg));</a>
<a name="ln5307">    return;</a>
<a name="ln5308">  }</a>
<a name="ln5309"> </a>
<a name="ln5310">  ui_busy_start();</a>
<a name="ln5311">  list_T *args = argvars[0].vval.v_list;</a>
<a name="ln5312">  Channel **jobs = xcalloc(tv_list_len(args), sizeof(*jobs));</a>
<a name="ln5313">  MultiQueue *waiting_jobs = multiqueue_new_parent(loop_on_put, &amp;main_loop);</a>
<a name="ln5314"> </a>
<a name="ln5315">  // Validate, prepare jobs for waiting.</a>
<a name="ln5316">  int i = 0;</a>
<a name="ln5317">  TV_LIST_ITER_CONST(args, arg, {</a>
<a name="ln5318">    Channel *chan = NULL;</a>
<a name="ln5319">    if (TV_LIST_ITEM_TV(arg)-&gt;v_type != VAR_NUMBER</a>
<a name="ln5320">        || !(chan = find_job(TV_LIST_ITEM_TV(arg)-&gt;vval.v_number, false))) {</a>
<a name="ln5321">      jobs[i] = NULL;  // Invalid job.</a>
<a name="ln5322">    } else {</a>
<a name="ln5323">      jobs[i] = chan;</a>
<a name="ln5324">      channel_incref(chan);</a>
<a name="ln5325">      if (chan-&gt;stream.proc.status &lt; 0) {</a>
<a name="ln5326">        // Process any pending events on the job's queue before temporarily</a>
<a name="ln5327">        // replacing it.</a>
<a name="ln5328">        multiqueue_process_events(chan-&gt;events);</a>
<a name="ln5329">        multiqueue_replace_parent(chan-&gt;events, waiting_jobs);</a>
<a name="ln5330">      }</a>
<a name="ln5331">    }</a>
<a name="ln5332">    i++;</a>
<a name="ln5333">  });</a>
<a name="ln5334"> </a>
<a name="ln5335">  int remaining = -1;</a>
<a name="ln5336">  uint64_t before = 0;</a>
<a name="ln5337">  if (argvars[1].v_type == VAR_NUMBER &amp;&amp; argvars[1].vval.v_number &gt;= 0) {</a>
<a name="ln5338">    remaining = argvars[1].vval.v_number;</a>
<a name="ln5339">    before = os_hrtime();</a>
<a name="ln5340">  }</a>
<a name="ln5341"> </a>
<a name="ln5342">  for (i = 0; i &lt; tv_list_len(args); i++) {</a>
<a name="ln5343">    if (remaining == 0) {</a>
<a name="ln5344">      break;  // Timeout.</a>
<a name="ln5345">    }</a>
<a name="ln5346">    if (jobs[i] == NULL) {</a>
<a name="ln5347">      continue;  // Invalid job, will assign status=-3 below.</a>
<a name="ln5348">    }</a>
<a name="ln5349">    int status = process_wait(&amp;jobs[i]-&gt;stream.proc, remaining,</a>
<a name="ln5350">                              waiting_jobs);</a>
<a name="ln5351">    if (status &lt; 0) {</a>
<a name="ln5352">      break;  // Interrupted (CTRL-C) or timeout, skip remaining jobs.</a>
<a name="ln5353">    }</a>
<a name="ln5354">    if (remaining &gt; 0) {</a>
<a name="ln5355">      uint64_t now = os_hrtime();</a>
<a name="ln5356">      remaining = MIN(0, remaining - (int)((now - before) / 1000000));</a>
<a name="ln5357">      before = now;</a>
<a name="ln5358">    }</a>
<a name="ln5359">  }</a>
<a name="ln5360"> </a>
<a name="ln5361">  list_T *const rv = tv_list_alloc(tv_list_len(args));</a>
<a name="ln5362"> </a>
<a name="ln5363">  // For each job:</a>
<a name="ln5364">  //  * Restore its parent queue if the job is still alive.</a>
<a name="ln5365">  //  * Append its status to the output list, or:</a>
<a name="ln5366">  //       -3 for &quot;invalid job id&quot;</a>
<a name="ln5367">  //       -2 for &quot;interrupted&quot; (user hit CTRL-C)</a>
<a name="ln5368">  //       -1 for jobs that were skipped or timed out</a>
<a name="ln5369">  for (i = 0; i &lt; tv_list_len(args); i++) {</a>
<a name="ln5370">    if (jobs[i] == NULL) {</a>
<a name="ln5371">      tv_list_append_number(rv, -3);</a>
<a name="ln5372">      continue;</a>
<a name="ln5373">    }</a>
<a name="ln5374">    multiqueue_process_events(jobs[i]-&gt;events);</a>
<a name="ln5375">    multiqueue_replace_parent(jobs[i]-&gt;events, main_loop.events);</a>
<a name="ln5376"> </a>
<a name="ln5377">    tv_list_append_number(rv, jobs[i]-&gt;stream.proc.status);</a>
<a name="ln5378">    channel_decref(jobs[i]);</a>
<a name="ln5379">  }</a>
<a name="ln5380"> </a>
<a name="ln5381">  multiqueue_free(waiting_jobs);</a>
<a name="ln5382">  xfree(jobs);</a>
<a name="ln5383">  ui_busy_stop();</a>
<a name="ln5384">  tv_list_ref(rv);</a>
<a name="ln5385">  rettv-&gt;v_type = VAR_LIST;</a>
<a name="ln5386">  rettv-&gt;vval.v_list = rv;</a>
<a name="ln5387">}</a>
<a name="ln5388"> </a>
<a name="ln5389">/*</a>
<a name="ln5390"> * &quot;join()&quot; function</a>
<a name="ln5391"> */</a>
<a name="ln5392">static void f_join(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5393">{</a>
<a name="ln5394">  if (argvars[0].v_type != VAR_LIST) {</a>
<a name="ln5395">    EMSG(_(e_listreq));</a>
<a name="ln5396">    return;</a>
<a name="ln5397">  }</a>
<a name="ln5398">  const char *const sep = (argvars[1].v_type == VAR_UNKNOWN</a>
<a name="ln5399">                           ? &quot; &quot;</a>
<a name="ln5400">                           : tv_get_string_chk(&amp;argvars[1]));</a>
<a name="ln5401"> </a>
<a name="ln5402">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln5403"> </a>
<a name="ln5404">  if (sep != NULL) {</a>
<a name="ln5405">    garray_T ga;</a>
<a name="ln5406">    ga_init(&amp;ga, (int)sizeof(char), 80);</a>
<a name="ln5407">    tv_list_join(&amp;ga, argvars[0].vval.v_list, sep);</a>
<a name="ln5408">    ga_append(&amp;ga, NUL);</a>
<a name="ln5409">    rettv-&gt;vval.v_string = (char_u *)ga.ga_data;</a>
<a name="ln5410">  } else {</a>
<a name="ln5411">    rettv-&gt;vval.v_string = NULL;</a>
<a name="ln5412">  }</a>
<a name="ln5413">}</a>
<a name="ln5414"> </a>
<a name="ln5415">/// json_decode() function</a>
<a name="ln5416">static void f_json_decode(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5417">{</a>
<a name="ln5418">  char numbuf[NUMBUFLEN];</a>
<a name="ln5419">  const char *s = NULL;</a>
<a name="ln5420">  char *tofree = NULL;</a>
<a name="ln5421">  size_t len;</a>
<a name="ln5422">  if (argvars[0].v_type == VAR_LIST) {</a>
<a name="ln5423">    if (!encode_vim_list_to_buf(argvars[0].vval.v_list, &amp;len, &amp;tofree)) {</a>
<a name="ln5424">      EMSG(_(&quot;E474: Failed to convert list to string&quot;));</a>
<a name="ln5425">      return;</a>
<a name="ln5426">    }</a>
<a name="ln5427">    s = tofree;</a>
<a name="ln5428">    if (s == NULL) {</a>
<a name="ln5429">      assert(len == 0);</a>
<a name="ln5430">      s = &quot;&quot;;</a>
<a name="ln5431">    }</a>
<a name="ln5432">  } else {</a>
<a name="ln5433">    s = tv_get_string_buf_chk(&amp;argvars[0], numbuf);</a>
<a name="ln5434">    if (s) {</a>
<a name="ln5435">      len = strlen(s);</a>
<a name="ln5436">    } else {</a>
<a name="ln5437">      return;</a>
<a name="ln5438">    }</a>
<a name="ln5439">  }</a>
<a name="ln5440">  if (json_decode_string(s, len, rettv) == FAIL) {</a>
<a name="ln5441">    emsgf(_(&quot;E474: Failed to parse %.*s&quot;), (int)len, s);</a>
<a name="ln5442">    rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln5443">    rettv-&gt;vval.v_number = 0;</a>
<a name="ln5444">  }</a>
<a name="ln5445">  assert(rettv-&gt;v_type != VAR_UNKNOWN);</a>
<a name="ln5446">  xfree(tofree);</a>
<a name="ln5447">}</a>
<a name="ln5448"> </a>
<a name="ln5449">/// json_encode() function</a>
<a name="ln5450">static void f_json_encode(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5451">{</a>
<a name="ln5452">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln5453">  rettv-&gt;vval.v_string = (char_u *)encode_tv2json(&amp;argvars[0], NULL);</a>
<a name="ln5454">}</a>
<a name="ln5455"> </a>
<a name="ln5456">/*</a>
<a name="ln5457"> * &quot;keys()&quot; function</a>
<a name="ln5458"> */</a>
<a name="ln5459">static void f_keys(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5460">{</a>
<a name="ln5461">  dict_list(argvars, rettv, 0);</a>
<a name="ln5462">}</a>
<a name="ln5463"> </a>
<a name="ln5464">/*</a>
<a name="ln5465"> * &quot;last_buffer_nr()&quot; function.</a>
<a name="ln5466"> */</a>
<a name="ln5467">static void f_last_buffer_nr(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5468">{</a>
<a name="ln5469">  int n = 0;</a>
<a name="ln5470"> </a>
<a name="ln5471">  FOR_ALL_BUFFERS(buf) {</a>
<a name="ln5472">    if (n &lt; buf-&gt;b_fnum) {</a>
<a name="ln5473">      n = buf-&gt;b_fnum;</a>
<a name="ln5474">    }</a>
<a name="ln5475">  }</a>
<a name="ln5476"> </a>
<a name="ln5477">  rettv-&gt;vval.v_number = n;</a>
<a name="ln5478">}</a>
<a name="ln5479"> </a>
<a name="ln5480">/*</a>
<a name="ln5481"> * &quot;len()&quot; function</a>
<a name="ln5482"> */</a>
<a name="ln5483">static void f_len(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5484">{</a>
<a name="ln5485">  switch (argvars[0].v_type) {</a>
<a name="ln5486">    case VAR_STRING:</a>
<a name="ln5487">    case VAR_NUMBER: {</a>
<a name="ln5488">      rettv-&gt;vval.v_number = (varnumber_T)strlen(</a>
<a name="ln5489">          tv_get_string(&amp;argvars[0]));</a>
<a name="ln5490">      break;</a>
<a name="ln5491">    }</a>
<a name="ln5492">    case VAR_LIST: {</a>
<a name="ln5493">      rettv-&gt;vval.v_number = tv_list_len(argvars[0].vval.v_list);</a>
<a name="ln5494">      break;</a>
<a name="ln5495">    }</a>
<a name="ln5496">    case VAR_DICT: {</a>
<a name="ln5497">      rettv-&gt;vval.v_number = tv_dict_len(argvars[0].vval.v_dict);</a>
<a name="ln5498">      break;</a>
<a name="ln5499">    }</a>
<a name="ln5500">    case VAR_UNKNOWN:</a>
<a name="ln5501">    case VAR_BOOL:</a>
<a name="ln5502">    case VAR_SPECIAL:</a>
<a name="ln5503">    case VAR_FLOAT:</a>
<a name="ln5504">    case VAR_PARTIAL:</a>
<a name="ln5505">    case VAR_FUNC: {</a>
<a name="ln5506">      EMSG(_(&quot;E701: Invalid type for len()&quot;));</a>
<a name="ln5507">      break;</a>
<a name="ln5508">    }</a>
<a name="ln5509">  }</a>
<a name="ln5510">}</a>
<a name="ln5511"> </a>
<a name="ln5512">static void libcall_common(typval_T *argvars, typval_T *rettv, int out_type)</a>
<a name="ln5513">{</a>
<a name="ln5514">  rettv-&gt;v_type = out_type;</a>
<a name="ln5515">  if (out_type != VAR_NUMBER) {</a>
<a name="ln5516">    rettv-&gt;vval.v_string = NULL;</a>
<a name="ln5517">  }</a>
<a name="ln5518"> </a>
<a name="ln5519">  if (check_secure()) {</a>
<a name="ln5520">    return;</a>
<a name="ln5521">  }</a>
<a name="ln5522"> </a>
<a name="ln5523">  // The first two args (libname and funcname) must be strings</a>
<a name="ln5524">  if (argvars[0].v_type != VAR_STRING || argvars[1].v_type != VAR_STRING) {</a>
<a name="ln5525">    return;</a>
<a name="ln5526">  }</a>
<a name="ln5527"> </a>
<a name="ln5528">  const char *libname = (char *)argvars[0].vval.v_string;</a>
<a name="ln5529">  const char *funcname = (char *)argvars[1].vval.v_string;</a>
<a name="ln5530"> </a>
<a name="ln5531">  VarType in_type = argvars[2].v_type;</a>
<a name="ln5532"> </a>
<a name="ln5533">  // input variables</a>
<a name="ln5534">  char *str_in = (in_type == VAR_STRING)</a>
<a name="ln5535">      ? (char *)argvars[2].vval.v_string : NULL;</a>
<a name="ln5536">  int int_in = argvars[2].vval.v_number;</a>
<a name="ln5537"> </a>
<a name="ln5538">  // output variables</a>
<a name="ln5539">  char **str_out = (out_type == VAR_STRING)</a>
<a name="ln5540">      ? (char **)&amp;rettv-&gt;vval.v_string : NULL;</a>
<a name="ln5541">  int int_out = 0;</a>
<a name="ln5542"> </a>
<a name="ln5543">  bool success = os_libcall(libname, funcname,</a>
<a name="ln5544">                            str_in, int_in,</a>
<a name="ln5545">                            str_out, &amp;int_out);</a>
<a name="ln5546"> </a>
<a name="ln5547">  if (!success) {</a>
<a name="ln5548">    EMSG2(_(e_libcall), funcname);</a>
<a name="ln5549">    return;</a>
<a name="ln5550">  }</a>
<a name="ln5551"> </a>
<a name="ln5552">  if (out_type == VAR_NUMBER) {</a>
<a name="ln5553">     rettv-&gt;vval.v_number = (varnumber_T)int_out;</a>
<a name="ln5554">  }</a>
<a name="ln5555">}</a>
<a name="ln5556"> </a>
<a name="ln5557">/*</a>
<a name="ln5558"> * &quot;libcall()&quot; function</a>
<a name="ln5559"> */</a>
<a name="ln5560">static void f_libcall(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5561">{</a>
<a name="ln5562">  libcall_common(argvars, rettv, VAR_STRING);</a>
<a name="ln5563">}</a>
<a name="ln5564"> </a>
<a name="ln5565">/*</a>
<a name="ln5566"> * &quot;libcallnr()&quot; function</a>
<a name="ln5567"> */</a>
<a name="ln5568">static void f_libcallnr(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5569">{</a>
<a name="ln5570">  libcall_common(argvars, rettv, VAR_NUMBER);</a>
<a name="ln5571">}</a>
<a name="ln5572"> </a>
<a name="ln5573">// &quot;line(string, [winid])&quot; function</a>
<a name="ln5574">static void f_line(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5575">{</a>
<a name="ln5576">  linenr_T lnum = 0;</a>
<a name="ln5577">  pos_T *fp = NULL;</a>
<a name="ln5578">  int fnum;</a>
<a name="ln5579"> </a>
<a name="ln5580">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln5581">    tabpage_T *tp;</a>
<a name="ln5582">    win_T *save_curwin;</a>
<a name="ln5583">    tabpage_T *save_curtab;</a>
<a name="ln5584"> </a>
<a name="ln5585">    // use window specified in the second argument</a>
<a name="ln5586">    win_T *wp = win_id2wp_tp(&amp;argvars[1], &amp;tp);</a>
<a name="ln5587">    if (wp != NULL &amp;&amp; tp != NULL) {</a>
<a name="ln5588">      if (switch_win_noblock(&amp;save_curwin, &amp;save_curtab, wp, tp, true)</a>
<a name="ln5589">          == OK) {</a>
<a name="ln5590">        check_cursor();</a>
<a name="ln5591">        fp = var2fpos(&amp;argvars[0], true, &amp;fnum);</a>
<a name="ln5592">      }</a>
<a name="ln5593">      restore_win_noblock(save_curwin, save_curtab, true);</a>
<a name="ln5594">    }</a>
<a name="ln5595">  } else {</a>
<a name="ln5596">    // use current window</a>
<a name="ln5597">    fp = var2fpos(&amp;argvars[0], true, &amp;fnum);</a>
<a name="ln5598">  }</a>
<a name="ln5599"> </a>
<a name="ln5600">  if (fp != NULL) {</a>
<a name="ln5601">    lnum = fp-&gt;lnum;</a>
<a name="ln5602">  }</a>
<a name="ln5603">  rettv-&gt;vval.v_number = lnum;</a>
<a name="ln5604">}</a>
<a name="ln5605"> </a>
<a name="ln5606">/*</a>
<a name="ln5607"> * &quot;line2byte(lnum)&quot; function</a>
<a name="ln5608"> */</a>
<a name="ln5609">static void f_line2byte(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5610">{</a>
<a name="ln5611">  const linenr_T lnum = tv_get_lnum(argvars);</a>
<a name="ln5612">  if (lnum &lt; 1 || lnum &gt; curbuf-&gt;b_ml.ml_line_count + 1) {</a>
<a name="ln5613">    rettv-&gt;vval.v_number = -1;</a>
<a name="ln5614">  } else {</a>
<a name="ln5615">    rettv-&gt;vval.v_number = ml_find_line_or_offset(curbuf, lnum, NULL, false);</a>
<a name="ln5616">  }</a>
<a name="ln5617">  if (rettv-&gt;vval.v_number &gt;= 0) {</a>
<a name="ln5618">    rettv-&gt;vval.v_number++;</a>
<a name="ln5619">  }</a>
<a name="ln5620">}</a>
<a name="ln5621"> </a>
<a name="ln5622">/*</a>
<a name="ln5623"> * &quot;lispindent(lnum)&quot; function</a>
<a name="ln5624"> */</a>
<a name="ln5625">static void f_lispindent(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5626">{</a>
<a name="ln5627">  const pos_T pos = curwin-&gt;w_cursor;</a>
<a name="ln5628">  const linenr_T lnum = tv_get_lnum(argvars);</a>
<a name="ln5629">  if (lnum &gt;= 1 &amp;&amp; lnum &lt;= curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln5630">    curwin-&gt;w_cursor.lnum = lnum;</a>
<a name="ln5631">    rettv-&gt;vval.v_number = get_lisp_indent();</a>
<a name="ln5632">    curwin-&gt;w_cursor = pos;</a>
<a name="ln5633">  } else {</a>
<a name="ln5634">    rettv-&gt;vval.v_number = -1;</a>
<a name="ln5635">  }</a>
<a name="ln5636">}</a>
<a name="ln5637"> </a>
<a name="ln5638">// &quot;list2str()&quot; function</a>
<a name="ln5639">static void f_list2str(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5640">{</a>
<a name="ln5641">  garray_T ga;</a>
<a name="ln5642"> </a>
<a name="ln5643">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln5644">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln5645">  if (argvars[0].v_type != VAR_LIST) {</a>
<a name="ln5646">    EMSG(_(e_invarg));</a>
<a name="ln5647">    return;</a>
<a name="ln5648">  }</a>
<a name="ln5649"> </a>
<a name="ln5650">  list_T *const l = argvars[0].vval.v_list;</a>
<a name="ln5651">  if (l == NULL) {</a>
<a name="ln5652">    return;  // empty list results in empty string</a>
<a name="ln5653">  }</a>
<a name="ln5654"> </a>
<a name="ln5655">  ga_init(&amp;ga, 1, 80);</a>
<a name="ln5656">  char_u buf[MB_MAXBYTES + 1];</a>
<a name="ln5657"> </a>
<a name="ln5658">  TV_LIST_ITER_CONST(l, li, {</a>
<a name="ln5659">    buf[utf_char2bytes(tv_get_number(TV_LIST_ITEM_TV(li)), buf)] = NUL;</a>
<a name="ln5660">    ga_concat(&amp;ga, buf);</a>
<a name="ln5661">  });</a>
<a name="ln5662">  ga_append(&amp;ga, NUL);</a>
<a name="ln5663"> </a>
<a name="ln5664">  rettv-&gt;vval.v_string = ga.ga_data;</a>
<a name="ln5665">}</a>
<a name="ln5666"> </a>
<a name="ln5667">/*</a>
<a name="ln5668"> * &quot;localtime()&quot; function</a>
<a name="ln5669"> */</a>
<a name="ln5670">static void f_localtime(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5671">{</a>
<a name="ln5672">  rettv-&gt;vval.v_number = (varnumber_T)time(NULL);</a>
<a name="ln5673">}</a>
<a name="ln5674"> </a>
<a name="ln5675"> </a>
<a name="ln5676">static void get_maparg(typval_T *argvars, typval_T *rettv, int exact)</a>
<a name="ln5677">{</a>
<a name="ln5678">  char_u *keys_buf = NULL;</a>
<a name="ln5679">  char_u *rhs;</a>
<a name="ln5680">  int mode;</a>
<a name="ln5681">  int abbr = FALSE;</a>
<a name="ln5682">  int get_dict = FALSE;</a>
<a name="ln5683">  mapblock_T  *mp;</a>
<a name="ln5684">  int buffer_local;</a>
<a name="ln5685"> </a>
<a name="ln5686">  // Return empty string for failure.</a>
<a name="ln5687">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln5688">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln5689"> </a>
<a name="ln5690">  char_u *keys = (char_u *)tv_get_string(&amp;argvars[0]);</a>
<a name="ln5691">  if (*keys == NUL) {</a>
<a name="ln5692">    return;</a>
<a name="ln5693">  }</a>
<a name="ln5694"> </a>
<a name="ln5695">  char buf[NUMBUFLEN];</a>
<a name="ln5696">  const char *which;</a>
<a name="ln5697">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln5698">    which = tv_get_string_buf_chk(&amp;argvars[1], buf);</a>
<a name="ln5699">    if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln5700">      abbr = tv_get_number(&amp;argvars[2]);</a>
<a name="ln5701">      if (argvars[3].v_type != VAR_UNKNOWN) {</a>
<a name="ln5702">        get_dict = tv_get_number(&amp;argvars[3]);</a>
<a name="ln5703">      }</a>
<a name="ln5704">    }</a>
<a name="ln5705">  } else {</a>
<a name="ln5706">    which = &quot;&quot;;</a>
<a name="ln5707">  }</a>
<a name="ln5708">  if (which == NULL) {</a>
<a name="ln5709">    return;</a>
<a name="ln5710">  }</a>
<a name="ln5711"> </a>
<a name="ln5712">  mode = get_map_mode((char_u **)&amp;which, 0);</a>
<a name="ln5713"> </a>
<a name="ln5714">  keys = replace_termcodes(keys, STRLEN(keys), &amp;keys_buf, true, true, true,</a>
<a name="ln5715">                           CPO_TO_CPO_FLAGS);</a>
<a name="ln5716">  rhs = check_map(keys, mode, exact, false, abbr, &amp;mp, &amp;buffer_local);</a>
<a name="ln5717">  xfree(keys_buf);</a>
<a name="ln5718"> </a>
<a name="ln5719">  if (!get_dict) {</a>
<a name="ln5720">    // Return a string.</a>
<a name="ln5721">    if (rhs != NULL) {</a>
<a name="ln5722">      if (*rhs == NUL) {</a>
<a name="ln5723">        rettv-&gt;vval.v_string = vim_strsave((char_u *)&quot;&lt;Nop&gt;&quot;);</a>
<a name="ln5724">      } else {</a>
<a name="ln5725">        rettv-&gt;vval.v_string = (char_u *)str2special_save(</a>
<a name="ln5726">            (char *)rhs, false, false);</a>
<a name="ln5727">      }</a>
<a name="ln5728">    }</a>
<a name="ln5729"> </a>
<a name="ln5730">  } else {</a>
<a name="ln5731">    tv_dict_alloc_ret(rettv);</a>
<a name="ln5732">    if (rhs != NULL) {</a>
<a name="ln5733">      // Return a dictionary.</a>
<a name="ln5734">      mapblock_fill_dict(rettv-&gt;vval.v_dict, mp, buffer_local, true);</a>
<a name="ln5735">    }</a>
<a name="ln5736">  }</a>
<a name="ln5737">}</a>
<a name="ln5738"> </a>
<a name="ln5739">/// luaeval() function implementation</a>
<a name="ln5740">static void f_luaeval(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5741">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln5742">{</a>
<a name="ln5743">  const char *const str = (const char *)tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln5744">  if (str == NULL) {</a>
<a name="ln5745">    return;</a>
<a name="ln5746">  }</a>
<a name="ln5747"> </a>
<a name="ln5748">  nlua_typval_eval(cstr_as_string((char *)str), &amp;argvars[1], rettv);</a>
<a name="ln5749">}</a>
<a name="ln5750"> </a>
<a name="ln5751">/*</a>
<a name="ln5752"> * &quot;map()&quot; function</a>
<a name="ln5753"> */</a>
<a name="ln5754">static void f_map(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5755">{</a>
<a name="ln5756">  filter_map(argvars, rettv, TRUE);</a>
<a name="ln5757">}</a>
<a name="ln5758"> </a>
<a name="ln5759">/*</a>
<a name="ln5760"> * &quot;maparg()&quot; function</a>
<a name="ln5761"> */</a>
<a name="ln5762">static void f_maparg(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5763">{</a>
<a name="ln5764">  get_maparg(argvars, rettv, TRUE);</a>
<a name="ln5765">}</a>
<a name="ln5766"> </a>
<a name="ln5767">/*</a>
<a name="ln5768"> * &quot;mapcheck()&quot; function</a>
<a name="ln5769"> */</a>
<a name="ln5770">static void f_mapcheck(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5771">{</a>
<a name="ln5772">  get_maparg(argvars, rettv, FALSE);</a>
<a name="ln5773">}</a>
<a name="ln5774"> </a>
<a name="ln5775"> </a>
<a name="ln5776">static void find_some_match(typval_T *const argvars, typval_T *const rettv,</a>
<a name="ln5777">                            const SomeMatchType type)</a>
<a name="ln5778">{</a>
<a name="ln5779">  char_u      *str = NULL;</a>
<a name="ln5780">  long        len = 0;</a>
<a name="ln5781">  char_u      *expr = NULL;</a>
<a name="ln5782">  regmatch_T regmatch;</a>
<a name="ln5783">  char_u      *save_cpo;</a>
<a name="ln5784">  long start = 0;</a>
<a name="ln5785">  long nth = 1;</a>
<a name="ln5786">  colnr_T startcol = 0;</a>
<a name="ln5787">  bool match = false;</a>
<a name="ln5788">  list_T      *l = NULL;</a>
<a name="ln5789">  listitem_T  *li = NULL;</a>
<a name="ln5790">  long idx = 0;</a>
<a name="ln5791">  char_u      *tofree = NULL;</a>
<a name="ln5792"> </a>
<a name="ln5793">  // Make 'cpoptions' empty, the 'l' flag should not be used here.</a>
<a name="ln5794">  save_cpo = p_cpo;</a>
<a name="ln5795">  p_cpo = (char_u *)&quot;&quot;;</a>
<a name="ln5796"> </a>
<a name="ln5797">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln5798">  switch (type) {</a>
<a name="ln5799">    // matchlist(): return empty list when there are no matches.</a>
<a name="ln5800">    case kSomeMatchList: {</a>
<a name="ln5801">      tv_list_alloc_ret(rettv, kListLenMayKnow);</a>
<a name="ln5802">      break;</a>
<a name="ln5803">    }</a>
<a name="ln5804">    // matchstrpos(): return [&quot;&quot;, -1, -1, -1]</a>
<a name="ln5805">    case kSomeMatchStrPos: {</a>
<a name="ln5806">      tv_list_alloc_ret(rettv, 4);</a>
<a name="ln5807">      tv_list_append_string(rettv-&gt;vval.v_list, &quot;&quot;, 0);</a>
<a name="ln5808">      tv_list_append_number(rettv-&gt;vval.v_list, -1);</a>
<a name="ln5809">      tv_list_append_number(rettv-&gt;vval.v_list, -1);</a>
<a name="ln5810">      tv_list_append_number(rettv-&gt;vval.v_list, -1);</a>
<a name="ln5811">      break;</a>
<a name="ln5812">    }</a>
<a name="ln5813">    case kSomeMatchStr: {</a>
<a name="ln5814">      rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln5815">      rettv-&gt;vval.v_string = NULL;</a>
<a name="ln5816">      break;</a>
<a name="ln5817">    }</a>
<a name="ln5818">    case kSomeMatch:</a>
<a name="ln5819">    case kSomeMatchEnd: {</a>
<a name="ln5820">      // Do nothing: zero is default.</a>
<a name="ln5821">      break;</a>
<a name="ln5822">    }</a>
<a name="ln5823">  }</a>
<a name="ln5824"> </a>
<a name="ln5825">  if (argvars[0].v_type == VAR_LIST) {</a>
<a name="ln5826">    if ((l = argvars[0].vval.v_list) == NULL) {</a>
<a name="ln5827">      goto theend;</a>
<a name="ln5828">    }</a>
<a name="ln5829">    li = tv_list_first(l);</a>
<a name="ln5830">  } else {</a>
<a name="ln5831">    expr = str = (char_u *)tv_get_string(&amp;argvars[0]);</a>
<a name="ln5832">    len = (long)STRLEN(str);</a>
<a name="ln5833">  }</a>
<a name="ln5834"> </a>
<a name="ln5835">  char patbuf[NUMBUFLEN];</a>
<a name="ln5836">  const char *const pat = tv_get_string_buf_chk(&amp;argvars[1], patbuf);</a>
<a name="ln5837">  if (pat == NULL) {</a>
<a name="ln5838">    goto theend;</a>
<a name="ln5839">  }</a>
<a name="ln5840"> </a>
<a name="ln5841">  if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln5842">    bool error = false;</a>
<a name="ln5843"> </a>
<a name="ln5844">    start = tv_get_number_chk(&amp;argvars[2], &amp;error);</a>
<a name="ln5845">    if (error) {</a>
<a name="ln5846">      goto theend;</a>
<a name="ln5847">    }</a>
<a name="ln5848">    if (l != NULL) {</a>
<a name="ln5849">      idx = tv_list_uidx(l, start);</a>
<a name="ln5850">      if (idx == -1) {</a>
<a name="ln5851">        goto theend;</a>
<a name="ln5852">      }</a>
<a name="ln5853">      li = tv_list_find(l, idx);</a>
<a name="ln5854">    } else {</a>
<a name="ln5855">      if (start &lt; 0)</a>
<a name="ln5856">        start = 0;</a>
<a name="ln5857">      if (start &gt; len)</a>
<a name="ln5858">        goto theend;</a>
<a name="ln5859">      // When &quot;count&quot; argument is there ignore matches before &quot;start&quot;,</a>
<a name="ln5860">      // otherwise skip part of the string.  Differs when pattern is &quot;^&quot;</a>
<a name="ln5861">      // or &quot;\&lt;&quot;.</a>
<a name="ln5862">      if (argvars[3].v_type != VAR_UNKNOWN) {</a>
<a name="ln5863">        startcol = start;</a>
<a name="ln5864">      } else {</a>
<a name="ln5865">        str += start;</a>
<a name="ln5866">        len -= start;</a>
<a name="ln5867">      }</a>
<a name="ln5868">    }</a>
<a name="ln5869"> </a>
<a name="ln5870">    if (argvars[3].v_type != VAR_UNKNOWN) {</a>
<a name="ln5871">      nth = tv_get_number_chk(&amp;argvars[3], &amp;error);</a>
<a name="ln5872">    }</a>
<a name="ln5873">    if (error) {</a>
<a name="ln5874">      goto theend;</a>
<a name="ln5875">    }</a>
<a name="ln5876">  }</a>
<a name="ln5877"> </a>
<a name="ln5878">  regmatch.regprog = vim_regcomp((char_u *)pat, RE_MAGIC + RE_STRING);</a>
<a name="ln5879">  if (regmatch.regprog != NULL) {</a>
<a name="ln5880">    regmatch.rm_ic = p_ic;</a>
<a name="ln5881"> </a>
<a name="ln5882">    for (;; ) {</a>
<a name="ln5883">      if (l != NULL) {</a>
<a name="ln5884">        if (li == NULL) {</a>
<a name="ln5885">          match = false;</a>
<a name="ln5886">          break;</a>
<a name="ln5887">        }</a>
<a name="ln5888">        xfree(tofree);</a>
<a name="ln5889">        tofree = expr = str = (char_u *)encode_tv2echo(TV_LIST_ITEM_TV(li),</a>
<a name="ln5890">                                                       NULL);</a>
<a name="ln5891">        if (str == NULL) {</a>
<a name="ln5892">          break;</a>
<a name="ln5893">        }</a>
<a name="ln5894">      }</a>
<a name="ln5895"> </a>
<a name="ln5896">      match = vim_regexec_nl(&amp;regmatch, str, (colnr_T)startcol);</a>
<a name="ln5897"> </a>
<a name="ln5898">      if (match &amp;&amp; --nth &lt;= 0)</a>
<a name="ln5899">        break;</a>
<a name="ln5900">      if (l == NULL &amp;&amp; !match)</a>
<a name="ln5901">        break;</a>
<a name="ln5902"> </a>
<a name="ln5903">      // Advance to just after the match.</a>
<a name="ln5904">      if (l != NULL) {</a>
<a name="ln5905">        li = TV_LIST_ITEM_NEXT(l, li);</a>
<a name="ln5906">        idx++;</a>
<a name="ln5907">      } else {</a>
<a name="ln5908">        startcol = (colnr_T)(regmatch.startp[0]</a>
<a name="ln5909">                             + (*mb_ptr2len)(regmatch.startp[0]) - str);</a>
<a name="ln5910">        if (startcol &gt; (colnr_T)len || str + startcol &lt;= regmatch.startp[0]) {</a>
<a name="ln5911">            match = false;</a>
<a name="ln5912">            break;</a>
<a name="ln5913">        }</a>
<a name="ln5914">      }</a>
<a name="ln5915">    }</a>
<a name="ln5916"> </a>
<a name="ln5917">    if (match) {</a>
<a name="ln5918">      switch (type) {</a>
<a name="ln5919">        case kSomeMatchStrPos: {</a>
<a name="ln5920">          list_T *const ret_l = rettv-&gt;vval.v_list;</a>
<a name="ln5921">          listitem_T *li1 = tv_list_first(ret_l);</a>
<a name="ln5922">          listitem_T *li2 = TV_LIST_ITEM_NEXT(ret_l, li1);</a>
<a name="ln5923">          listitem_T *li3 = TV_LIST_ITEM_NEXT(ret_l, li2);</a>
<a name="ln5924">          listitem_T *li4 = TV_LIST_ITEM_NEXT(ret_l, li3);</a>
<a name="ln5925">          xfree(TV_LIST_ITEM_TV(li1)-&gt;vval.v_string);</a>
<a name="ln5926"> </a>
<a name="ln5927">          const size_t rd = (size_t)(regmatch.endp[0] - regmatch.startp[0]);</a>
<a name="ln5928">          TV_LIST_ITEM_TV(li1)-&gt;vval.v_string = xmemdupz(</a>
<a name="ln5929">              (const char *)regmatch.startp[0], rd);</a>
<a name="ln5930">          TV_LIST_ITEM_TV(li3)-&gt;vval.v_number = (varnumber_T)(</a>
<a name="ln5931">              regmatch.startp[0] - expr);</a>
<a name="ln5932">          TV_LIST_ITEM_TV(li4)-&gt;vval.v_number = (varnumber_T)(</a>
<a name="ln5933">              regmatch.endp[0] - expr);</a>
<a name="ln5934">          if (l != NULL) {</a>
<a name="ln5935">            TV_LIST_ITEM_TV(li2)-&gt;vval.v_number = (varnumber_T)idx;</a>
<a name="ln5936">          }</a>
<a name="ln5937">          break;</a>
<a name="ln5938">        }</a>
<a name="ln5939">        case kSomeMatchList: {</a>
<a name="ln5940">          // Return list with matched string and submatches.</a>
<a name="ln5941">          for (int i = 0; i &lt; NSUBEXP; i++) {</a>
<a name="ln5942">            if (regmatch.endp[i] == NULL) {</a>
<a name="ln5943">              tv_list_append_string(rettv-&gt;vval.v_list, NULL, 0);</a>
<a name="ln5944">            } else {</a>
<a name="ln5945">              tv_list_append_string(rettv-&gt;vval.v_list,</a>
<a name="ln5946">                                    (const char *)regmatch.startp[i],</a>
<a name="ln5947">                                    (regmatch.endp[i] - regmatch.startp[i]));</a>
<a name="ln5948">            }</a>
<a name="ln5949">          }</a>
<a name="ln5950">          break;</a>
<a name="ln5951">        }</a>
<a name="ln5952">        case kSomeMatchStr: {</a>
<a name="ln5953">          // Return matched string.</a>
<a name="ln5954">          if (l != NULL) {</a>
<a name="ln5955">            tv_copy(TV_LIST_ITEM_TV(li), rettv);</a>
<a name="ln5956">          } else {</a>
<a name="ln5957">            rettv-&gt;vval.v_string = (char_u *)xmemdupz(</a>
<a name="ln5958">                (const char *)regmatch.startp[0],</a>
<a name="ln5959">                (size_t)(regmatch.endp[0] - regmatch.startp[0]));</a>
<a name="ln5960">          }</a>
<a name="ln5961">          break;</a>
<a name="ln5962">        }</a>
<a name="ln5963">        case kSomeMatch:</a>
<a name="ln5964">        case kSomeMatchEnd: {</a>
<a name="ln5965">          if (l != NULL) {</a>
<a name="ln5966">            rettv-&gt;vval.v_number = idx;</a>
<a name="ln5967">          } else {</a>
<a name="ln5968">            if (type == kSomeMatch) {</a>
<a name="ln5969">              rettv-&gt;vval.v_number =</a>
<a name="ln5970">                (varnumber_T)(regmatch.startp[0] - str);</a>
<a name="ln5971">            } else {</a>
<a name="ln5972">              rettv-&gt;vval.v_number =</a>
<a name="ln5973">                (varnumber_T)(regmatch.endp[0] - str);</a>
<a name="ln5974">            }</a>
<a name="ln5975">            rettv-&gt;vval.v_number += (varnumber_T)(str - expr);</a>
<a name="ln5976">          }</a>
<a name="ln5977">          break;</a>
<a name="ln5978">        }</a>
<a name="ln5979">      }</a>
<a name="ln5980">    }</a>
<a name="ln5981">    vim_regfree(regmatch.regprog);</a>
<a name="ln5982">  }</a>
<a name="ln5983"> </a>
<a name="ln5984">theend:</a>
<a name="ln5985">  if (type == kSomeMatchStrPos &amp;&amp; l == NULL &amp;&amp; rettv-&gt;vval.v_list != NULL) {</a>
<a name="ln5986">    // matchstrpos() without a list: drop the second item</a>
<a name="ln5987">    list_T *const ret_l = rettv-&gt;vval.v_list;</a>
<a name="ln5988">    tv_list_item_remove(ret_l, TV_LIST_ITEM_NEXT(ret_l, tv_list_first(ret_l)));</a>
<a name="ln5989">  }</a>
<a name="ln5990"> </a>
<a name="ln5991">  xfree(tofree);</a>
<a name="ln5992">  p_cpo = save_cpo;</a>
<a name="ln5993">}</a>
<a name="ln5994"> </a>
<a name="ln5995">/*</a>
<a name="ln5996"> * &quot;match()&quot; function</a>
<a name="ln5997"> */</a>
<a name="ln5998">static void f_match(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5999">{</a>
<a name="ln6000">  find_some_match(argvars, rettv, kSomeMatch);</a>
<a name="ln6001">}</a>
<a name="ln6002"> </a>
<a name="ln6003">/*</a>
<a name="ln6004"> * &quot;matchadd()&quot; function</a>
<a name="ln6005"> */</a>
<a name="ln6006">static void f_matchadd(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6007">{</a>
<a name="ln6008">  char grpbuf[NUMBUFLEN];</a>
<a name="ln6009">  char patbuf[NUMBUFLEN];</a>
<a name="ln6010">  // group</a>
<a name="ln6011">  const char *const grp = tv_get_string_buf_chk(&amp;argvars[0], grpbuf);</a>
<a name="ln6012">  // pattern</a>
<a name="ln6013">  const char *const pat = tv_get_string_buf_chk(&amp;argvars[1], patbuf);</a>
<a name="ln6014">  // default priority</a>
<a name="ln6015">  int prio = 10;</a>
<a name="ln6016">  int id = -1;</a>
<a name="ln6017">  bool error = false;</a>
<a name="ln6018">  const char *conceal_char = NULL;</a>
<a name="ln6019">  win_T *win = curwin;</a>
<a name="ln6020"> </a>
<a name="ln6021">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln6022"> </a>
<a name="ln6023">  if (grp == NULL || pat == NULL) {</a>
<a name="ln6024">    return;</a>
<a name="ln6025">  }</a>
<a name="ln6026">  if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln6027">    prio = tv_get_number_chk(&amp;argvars[2], &amp;error);</a>
<a name="ln6028">    if (argvars[3].v_type != VAR_UNKNOWN) {</a>
<a name="ln6029">      id = tv_get_number_chk(&amp;argvars[3], &amp;error);</a>
<a name="ln6030">      if (argvars[4].v_type != VAR_UNKNOWN</a>
<a name="ln6031">          &amp;&amp; matchadd_dict_arg(&amp;argvars[4], &amp;conceal_char, &amp;win) == FAIL) {</a>
<a name="ln6032">        return;</a>
<a name="ln6033">      }</a>
<a name="ln6034">    }</a>
<a name="ln6035">  }</a>
<a name="ln6036">  if (error) {</a>
<a name="ln6037">    return;</a>
<a name="ln6038">  }</a>
<a name="ln6039">  if (id &gt;= 1 &amp;&amp; id &lt;= 3) {</a>
<a name="ln6040">    EMSGN(_(&quot;E798: ID is reserved for \&quot;:match\&quot;: %&quot; PRId64), id);</a>
<a name="ln6041">    return;</a>
<a name="ln6042">  }</a>
<a name="ln6043"> </a>
<a name="ln6044">  rettv-&gt;vval.v_number = match_add(win, grp, pat, prio, id, NULL, conceal_char);</a>
<a name="ln6045">}</a>
<a name="ln6046"> </a>
<a name="ln6047">static void f_matchaddpos(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6048">{</a>
<a name="ln6049">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln6050"> </a>
<a name="ln6051">  char buf[NUMBUFLEN];</a>
<a name="ln6052">  const char *const group = tv_get_string_buf_chk(&amp;argvars[0], buf);</a>
<a name="ln6053">  if (group == NULL) {</a>
<a name="ln6054">    return;</a>
<a name="ln6055">  }</a>
<a name="ln6056"> </a>
<a name="ln6057">  if (argvars[1].v_type != VAR_LIST) {</a>
<a name="ln6058">    EMSG2(_(e_listarg), &quot;matchaddpos()&quot;);</a>
<a name="ln6059">    return;</a>
<a name="ln6060">  }</a>
<a name="ln6061"> </a>
<a name="ln6062">  list_T *l;</a>
<a name="ln6063">  l = argvars[1].vval.v_list;</a>
<a name="ln6064">  if (l == NULL) {</a>
<a name="ln6065">    return;</a>
<a name="ln6066">  }</a>
<a name="ln6067"> </a>
<a name="ln6068">  bool error = false;</a>
<a name="ln6069">  int prio = 10;</a>
<a name="ln6070">  int id = -1;</a>
<a name="ln6071">  const char *conceal_char = NULL;</a>
<a name="ln6072">  win_T *win = curwin;</a>
<a name="ln6073"> </a>
<a name="ln6074">  if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln6075">    prio = tv_get_number_chk(&amp;argvars[2], &amp;error);</a>
<a name="ln6076">    if (argvars[3].v_type != VAR_UNKNOWN) {</a>
<a name="ln6077">      id = tv_get_number_chk(&amp;argvars[3], &amp;error);</a>
<a name="ln6078">      if (argvars[4].v_type != VAR_UNKNOWN</a>
<a name="ln6079">          &amp;&amp; matchadd_dict_arg(&amp;argvars[4], &amp;conceal_char, &amp;win) == FAIL) {</a>
<a name="ln6080">        return;</a>
<a name="ln6081">      }</a>
<a name="ln6082">    }</a>
<a name="ln6083">  }</a>
<a name="ln6084">  if (error == true) {</a>
<a name="ln6085">    return;</a>
<a name="ln6086">  }</a>
<a name="ln6087"> </a>
<a name="ln6088">  // id == 3 is ok because matchaddpos() is supposed to substitute :3match</a>
<a name="ln6089">  if (id == 1 || id == 2) {</a>
<a name="ln6090">    EMSGN(_(&quot;E798: ID is reserved for \&quot;match\&quot;: %&quot; PRId64), id);</a>
<a name="ln6091">    return;</a>
<a name="ln6092">  }</a>
<a name="ln6093"> </a>
<a name="ln6094">  rettv-&gt;vval.v_number = match_add(win, group, NULL, prio, id, l, conceal_char);</a>
<a name="ln6095">}</a>
<a name="ln6096"> </a>
<a name="ln6097">/*</a>
<a name="ln6098"> * &quot;matcharg()&quot; function</a>
<a name="ln6099"> */</a>
<a name="ln6100">static void f_matcharg(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6101">{</a>
<a name="ln6102">  const int id = tv_get_number(&amp;argvars[0]);</a>
<a name="ln6103"> </a>
<a name="ln6104">  tv_list_alloc_ret(rettv, (id &gt;= 1 &amp;&amp; id &lt;= 3</a>
<a name="ln6105">                            ? 2</a>
<a name="ln6106">                            : 0));</a>
<a name="ln6107"> </a>
<a name="ln6108">  if (id &gt;= 1 &amp;&amp; id &lt;= 3) {</a>
<a name="ln6109">    matchitem_T *const m = (matchitem_T *)get_match(curwin, id);</a>
<a name="ln6110"> </a>
<a name="ln6111">    if (m != NULL) {</a>
<a name="ln6112">      tv_list_append_string(rettv-&gt;vval.v_list,</a>
<a name="ln6113">                            (const char *)syn_id2name(m-&gt;hlg_id), -1);</a>
<a name="ln6114">      tv_list_append_string(rettv-&gt;vval.v_list, (const char *)m-&gt;pattern, -1);</a>
<a name="ln6115">    } else {</a>
<a name="ln6116">      tv_list_append_string(rettv-&gt;vval.v_list, NULL, 0);</a>
<a name="ln6117">      tv_list_append_string(rettv-&gt;vval.v_list, NULL, 0);</a>
<a name="ln6118">    }</a>
<a name="ln6119">  }</a>
<a name="ln6120">}</a>
<a name="ln6121"> </a>
<a name="ln6122">/*</a>
<a name="ln6123"> * &quot;matchdelete()&quot; function</a>
<a name="ln6124"> */</a>
<a name="ln6125">static void f_matchdelete(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6126">{</a>
<a name="ln6127">  win_T   *win = get_optional_window(argvars, 1);</a>
<a name="ln6128">  if (win == NULL) {</a>
<a name="ln6129">    rettv-&gt;vval.v_number = -1;</a>
<a name="ln6130">  } else {</a>
<a name="ln6131">    rettv-&gt;vval.v_number = match_delete(win,</a>
<a name="ln6132">                                        (int)tv_get_number(&amp;argvars[0]), true);</a>
<a name="ln6133">  }</a>
<a name="ln6134">}</a>
<a name="ln6135"> </a>
<a name="ln6136">/*</a>
<a name="ln6137"> * &quot;matchend()&quot; function</a>
<a name="ln6138"> */</a>
<a name="ln6139">static void f_matchend(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6140">{</a>
<a name="ln6141">  find_some_match(argvars, rettv, kSomeMatchEnd);</a>
<a name="ln6142">}</a>
<a name="ln6143"> </a>
<a name="ln6144">/*</a>
<a name="ln6145"> * &quot;matchlist()&quot; function</a>
<a name="ln6146"> */</a>
<a name="ln6147">static void f_matchlist(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6148">{</a>
<a name="ln6149">  find_some_match(argvars, rettv, kSomeMatchList);</a>
<a name="ln6150">}</a>
<a name="ln6151"> </a>
<a name="ln6152">/*</a>
<a name="ln6153"> * &quot;matchstr()&quot; function</a>
<a name="ln6154"> */</a>
<a name="ln6155">static void f_matchstr(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6156">{</a>
<a name="ln6157">  find_some_match(argvars, rettv, kSomeMatchStr);</a>
<a name="ln6158">}</a>
<a name="ln6159"> </a>
<a name="ln6160">/// &quot;matchstrpos()&quot; function</a>
<a name="ln6161">static void f_matchstrpos(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6162">{</a>
<a name="ln6163">  find_some_match(argvars, rettv, kSomeMatchStrPos);</a>
<a name="ln6164">}</a>
<a name="ln6165"> </a>
<a name="ln6166">/// Get maximal/minimal number value in a list or dictionary</a>
<a name="ln6167">///</a>
<a name="ln6168">/// @param[in]  tv  List or dictionary to work with. If it contains something</a>
<a name="ln6169">///                 that is not an integer number (or cannot be coerced to</a>
<a name="ln6170">///                 it) error is given.</a>
<a name="ln6171">/// @param[out]  rettv  Location where result will be saved. Only assigns</a>
<a name="ln6172">///                     vval.v_number, type is not touched. Returns zero for</a>
<a name="ln6173">///                     empty lists/dictionaries.</a>
<a name="ln6174">/// @param[in]  domax  Determines whether maximal or minimal value is desired.</a>
<a name="ln6175">static void max_min(const typval_T *const tv, typval_T *const rettv,</a>
<a name="ln6176">                    const bool domax)</a>
<a name="ln6177">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln6178">{</a>
<a name="ln6179">  bool error = false;</a>
<a name="ln6180"> </a>
<a name="ln6181">  rettv-&gt;vval.v_number = 0;</a>
<a name="ln6182">  varnumber_T n = (domax ? VARNUMBER_MIN : VARNUMBER_MAX);</a>
<a name="ln6183">  if (tv-&gt;v_type == VAR_LIST) {</a>
<a name="ln6184">    if (tv_list_len(tv-&gt;vval.v_list) == 0) {</a>
<a name="ln6185">      return;</a>
<a name="ln6186">    }</a>
<a name="ln6187">    TV_LIST_ITER_CONST(tv-&gt;vval.v_list, li, {</a>
<a name="ln6188">      const varnumber_T i = tv_get_number_chk(TV_LIST_ITEM_TV(li), &amp;error);</a>
<a name="ln6189">      if (error) {</a>
<a name="ln6190">        return;</a>
<a name="ln6191">      }</a>
<a name="ln6192">      if (domax ? i &gt; n : i &lt; n) {</a>
<a name="ln6193">        n = i;</a>
<a name="ln6194">      }</a>
<a name="ln6195">    });</a>
<a name="ln6196">  } else if (tv-&gt;v_type == VAR_DICT) {</a>
<a name="ln6197">    if (tv_dict_len(tv-&gt;vval.v_dict) == 0) {</a>
<a name="ln6198">      return;</a>
<a name="ln6199">    }</a>
<a name="ln6200">    TV_DICT_ITER(tv-&gt;vval.v_dict, di, {</a>
<a name="ln6201">      const varnumber_T i = tv_get_number_chk(&amp;di-&gt;di_tv, &amp;error);</a>
<a name="ln6202">      if (error) {</a>
<a name="ln6203">        return;</a>
<a name="ln6204">      }</a>
<a name="ln6205">      if (domax ? i &gt; n : i &lt; n) {</a>
<a name="ln6206">        n = i;</a>
<a name="ln6207">      }</a>
<a name="ln6208">    });</a>
<a name="ln6209">  } else {</a>
<a name="ln6210">    EMSG2(_(e_listdictarg), domax ? &quot;max()&quot; : &quot;min()&quot;);</a>
<a name="ln6211">    return;</a>
<a name="ln6212">  }</a>
<a name="ln6213">  rettv-&gt;vval.v_number = n;</a>
<a name="ln6214">}</a>
<a name="ln6215"> </a>
<a name="ln6216">/*</a>
<a name="ln6217"> * &quot;max()&quot; function</a>
<a name="ln6218"> */</a>
<a name="ln6219">static void f_max(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6220">{</a>
<a name="ln6221">  max_min(argvars, rettv, TRUE);</a>
<a name="ln6222">}</a>
<a name="ln6223"> </a>
<a name="ln6224">/*</a>
<a name="ln6225"> * &quot;min()&quot; function</a>
<a name="ln6226"> */</a>
<a name="ln6227">static void f_min(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6228">{</a>
<a name="ln6229">  max_min(argvars, rettv, FALSE);</a>
<a name="ln6230">}</a>
<a name="ln6231"> </a>
<a name="ln6232">/*</a>
<a name="ln6233"> * &quot;mkdir()&quot; function</a>
<a name="ln6234"> */</a>
<a name="ln6235">static void f_mkdir(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6236">{</a>
<a name="ln6237">  int prot = 0755;  // -V536</a>
<a name="ln6238"> </a>
<a name="ln6239">  rettv-&gt;vval.v_number = FAIL;</a>
<a name="ln6240">  if (check_secure()) {</a>
<a name="ln6241">    return;</a>
<a name="ln6242">  }</a>
<a name="ln6243"> </a>
<a name="ln6244">  char buf[NUMBUFLEN];</a>
<a name="ln6245">  const char *const dir = tv_get_string_buf(&amp;argvars[0], buf);</a>
<a name="ln6246">  if (*dir == NUL) {</a>
<a name="ln6247">    return;</a>
<a name="ln6248">  }</a>
<a name="ln6249"> </a>
<a name="ln6250">  if (*path_tail((char_u *)dir) == NUL) {</a>
<a name="ln6251">    // Remove trailing slashes.</a>
<a name="ln6252">    *path_tail_with_sep((char_u *)dir) = NUL;</a>
<a name="ln6253">  }</a>
<a name="ln6254"> </a>
<a name="ln6255">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln6256">    if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln6257">      prot = tv_get_number_chk(&amp;argvars[2], NULL);</a>
<a name="ln6258">      if (prot == -1) {</a>
<a name="ln6259">        return;</a>
<a name="ln6260">      }</a>
<a name="ln6261">    }</a>
<a name="ln6262">    if (strcmp(tv_get_string(&amp;argvars[1]), &quot;p&quot;) == 0) {</a>
<a name="ln6263">      char *failed_dir;</a>
<a name="ln6264">      int ret = os_mkdir_recurse(dir, prot, &amp;failed_dir);</a>
<a name="ln6265">      if (ret != 0) {</a>
<a name="ln6266">        EMSG3(_(e_mkdir), failed_dir, os_strerror(ret));</a>
<a name="ln6267">        xfree(failed_dir);</a>
<a name="ln6268">        rettv-&gt;vval.v_number = FAIL;</a>
<a name="ln6269">        return;</a>
<a name="ln6270">      } else {</a>
<a name="ln6271">        rettv-&gt;vval.v_number = OK;</a>
<a name="ln6272">        return;</a>
<a name="ln6273">      }</a>
<a name="ln6274">    }</a>
<a name="ln6275">  }</a>
<a name="ln6276">  rettv-&gt;vval.v_number = vim_mkdir_emsg(dir, prot);</a>
<a name="ln6277">}</a>
<a name="ln6278"> </a>
<a name="ln6279">/// &quot;mode()&quot; function</a>
<a name="ln6280">static void f_mode(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6281">{</a>
<a name="ln6282">  char *mode = get_mode();</a>
<a name="ln6283"> </a>
<a name="ln6284">  // Clear out the minor mode when the argument is not a non-zero number or</a>
<a name="ln6285">  // non-empty string.</a>
<a name="ln6286">  if (!non_zero_arg(&amp;argvars[0])) {</a>
<a name="ln6287">    mode[1] = NUL;</a>
<a name="ln6288">  }</a>
<a name="ln6289"> </a>
<a name="ln6290">  rettv-&gt;vval.v_string = (char_u *)mode;</a>
<a name="ln6291">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln6292">}</a>
<a name="ln6293"> </a>
<a name="ln6294">/// &quot;msgpackdump()&quot; function</a>
<a name="ln6295">static void f_msgpackdump(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6296">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln6297">{</a>
<a name="ln6298">  if (argvars[0].v_type != VAR_LIST) {</a>
<a name="ln6299">    EMSG2(_(e_listarg), &quot;msgpackdump()&quot;);</a>
<a name="ln6300">    return;</a>
<a name="ln6301">  }</a>
<a name="ln6302">  list_T *const ret_list = tv_list_alloc_ret(rettv, kListLenMayKnow);</a>
<a name="ln6303">  list_T *const list = argvars[0].vval.v_list;</a>
<a name="ln6304">  msgpack_packer *lpacker = msgpack_packer_new(ret_list, &amp;encode_list_write);</a>
<a name="ln6305">  const char *const msg = _(&quot;msgpackdump() argument, index %i&quot;);</a>
<a name="ln6306">  // Assume that translation will not take more then 4 times more space</a>
<a name="ln6307">  char msgbuf[sizeof(&quot;msgpackdump() argument, index &quot;) * 4 + NUMBUFLEN];</a>
<a name="ln6308">  int idx = 0;</a>
<a name="ln6309">  TV_LIST_ITER(list, li, {</a>
<a name="ln6310">    vim_snprintf(msgbuf, sizeof(msgbuf), (char *)msg, idx);</a>
<a name="ln6311">    idx++;</a>
<a name="ln6312">    if (encode_vim_to_msgpack(lpacker, TV_LIST_ITEM_TV(li), msgbuf) == FAIL) {</a>
<a name="ln6313">      break;</a>
<a name="ln6314">    }</a>
<a name="ln6315">  });</a>
<a name="ln6316">  msgpack_packer_free(lpacker);</a>
<a name="ln6317">}</a>
<a name="ln6318"> </a>
<a name="ln6319">/// &quot;msgpackparse&quot; function</a>
<a name="ln6320">static void f_msgpackparse(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6321">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln6322">{</a>
<a name="ln6323">  if (argvars[0].v_type != VAR_LIST) {</a>
<a name="ln6324">    EMSG2(_(e_listarg), &quot;msgpackparse()&quot;);</a>
<a name="ln6325">    return;</a>
<a name="ln6326">  }</a>
<a name="ln6327">  list_T *const ret_list = tv_list_alloc_ret(rettv, kListLenMayKnow);</a>
<a name="ln6328">  const list_T *const list = argvars[0].vval.v_list;</a>
<a name="ln6329">  if (tv_list_len(list) == 0) {</a>
<a name="ln6330">    return;</a>
<a name="ln6331">  }</a>
<a name="ln6332">  if (TV_LIST_ITEM_TV(tv_list_first(list))-&gt;v_type != VAR_STRING) {</a>
<a name="ln6333">    EMSG2(_(e_invarg2), &quot;List item is not a string&quot;);</a>
<a name="ln6334">    return;</a>
<a name="ln6335">  }</a>
<a name="ln6336">  ListReaderState lrstate = encode_init_lrstate(list);</a>
<a name="ln6337">  msgpack_unpacker *const unpacker = msgpack_unpacker_new(IOSIZE);</a>
<a name="ln6338">  if (unpacker == NULL) {</a>
<a name="ln6339">    EMSG(_(e_outofmem));</a>
<a name="ln6340">    return;</a>
<a name="ln6341">  }</a>
<a name="ln6342">  msgpack_unpacked unpacked;</a>
<a name="ln6343">  msgpack_unpacked_init(&amp;unpacked);</a>
<a name="ln6344">  do {</a>
<a name="ln6345">    if (!msgpack_unpacker_reserve_buffer(unpacker, IOSIZE)) {</a>
<a name="ln6346">      EMSG(_(e_outofmem));</a>
<a name="ln6347">      goto f_msgpackparse_exit;</a>
<a name="ln6348">    }</a>
<a name="ln6349">    size_t read_bytes;</a>
<a name="ln6350">    const int rlret = encode_read_from_list(</a>
<a name="ln6351">        &amp;lrstate, msgpack_unpacker_buffer(unpacker), IOSIZE, &amp;read_bytes);</a>
<a name="ln6352">    if (rlret == FAIL) {</a>
<a name="ln6353">      EMSG2(_(e_invarg2), &quot;List item is not a string&quot;);</a>
<a name="ln6354">      goto f_msgpackparse_exit;</a>
<a name="ln6355">    }</a>
<a name="ln6356">    msgpack_unpacker_buffer_consumed(unpacker, read_bytes);</a>
<a name="ln6357">    if (read_bytes == 0) {</a>
<a name="ln6358">      break;</a>
<a name="ln6359">    }</a>
<a name="ln6360">    while (unpacker-&gt;off &lt; unpacker-&gt;used) {</a>
<a name="ln6361">      const msgpack_unpack_return result = msgpack_unpacker_next(unpacker,</a>
<a name="ln6362">                                                                 &amp;unpacked);</a>
<a name="ln6363">      if (result == MSGPACK_UNPACK_PARSE_ERROR) {</a>
<a name="ln6364">        EMSG2(_(e_invarg2), &quot;Failed to parse msgpack string&quot;);</a>
<a name="ln6365">        goto f_msgpackparse_exit;</a>
<a name="ln6366">      }</a>
<a name="ln6367">      if (result == MSGPACK_UNPACK_NOMEM_ERROR) {</a>
<a name="ln6368">        EMSG(_(e_outofmem));</a>
<a name="ln6369">        goto f_msgpackparse_exit;</a>
<a name="ln6370">      }</a>
<a name="ln6371">      if (result == MSGPACK_UNPACK_SUCCESS) {</a>
<a name="ln6372">        typval_T tv = { .v_type = VAR_UNKNOWN };</a>
<a name="ln6373">        if (msgpack_to_vim(unpacked.data, &amp;tv) == FAIL) {</a>
<a name="ln6374">          EMSG2(_(e_invarg2), &quot;Failed to convert msgpack string&quot;);</a>
<a name="ln6375">          goto f_msgpackparse_exit;</a>
<a name="ln6376">        }</a>
<a name="ln6377">        tv_list_append_owned_tv(ret_list, tv);</a>
<a name="ln6378">      }</a>
<a name="ln6379">      if (result == MSGPACK_UNPACK_CONTINUE) {</a>
<a name="ln6380">        if (rlret == OK) {</a>
<a name="ln6381">          EMSG2(_(e_invarg2), &quot;Incomplete msgpack string&quot;);</a>
<a name="ln6382">        }</a>
<a name="ln6383">        break;</a>
<a name="ln6384">      }</a>
<a name="ln6385">    }</a>
<a name="ln6386">    if (rlret == OK) {</a>
<a name="ln6387">      break;</a>
<a name="ln6388">    }</a>
<a name="ln6389">  } while (true);</a>
<a name="ln6390"> </a>
<a name="ln6391">f_msgpackparse_exit:</a>
<a name="ln6392">  msgpack_unpacked_destroy(&amp;unpacked);</a>
<a name="ln6393">  msgpack_unpacker_free(unpacker);</a>
<a name="ln6394">  return;</a>
<a name="ln6395">}</a>
<a name="ln6396"> </a>
<a name="ln6397">/*</a>
<a name="ln6398"> * &quot;nextnonblank()&quot; function</a>
<a name="ln6399"> */</a>
<a name="ln6400">static void f_nextnonblank(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6401">{</a>
<a name="ln6402">  linenr_T lnum;</a>
<a name="ln6403"> </a>
<a name="ln6404">  for (lnum = tv_get_lnum(argvars);; lnum++) {</a>
<a name="ln6405">    if (lnum &lt; 0 || lnum &gt; curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln6406">      lnum = 0;</a>
<a name="ln6407">      break;</a>
<a name="ln6408">    }</a>
<a name="ln6409">    if (*skipwhite(ml_get(lnum)) != NUL) {</a>
<a name="ln6410">      break;</a>
<a name="ln6411">    }</a>
<a name="ln6412">  }</a>
<a name="ln6413">  rettv-&gt;vval.v_number = lnum;</a>
<a name="ln6414">}</a>
<a name="ln6415"> </a>
<a name="ln6416">/*</a>
<a name="ln6417"> * &quot;nr2char()&quot; function</a>
<a name="ln6418"> */</a>
<a name="ln6419">static void f_nr2char(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6420">{</a>
<a name="ln6421">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln6422">    if (!tv_check_num(&amp;argvars[1])) {</a>
<a name="ln6423">      return;</a>
<a name="ln6424">    }</a>
<a name="ln6425">  }</a>
<a name="ln6426"> </a>
<a name="ln6427">  bool error = false;</a>
<a name="ln6428">  const varnumber_T num = tv_get_number_chk(&amp;argvars[0], &amp;error);</a>
<a name="ln6429">  if (error) {</a>
<a name="ln6430">    return;</a>
<a name="ln6431">  }</a>
<a name="ln6432">  if (num &lt; 0) {</a>
<a name="ln6433">    EMSG(_(&quot;E5070: Character number must not be less than zero&quot;));</a>
<a name="ln6434">    return;</a>
<a name="ln6435">  }</a>
<a name="ln6436">  if (num &gt; INT_MAX) {</a>
<a name="ln6437">    emsgf(_(&quot;E5071: Character number must not be greater than INT_MAX (%i)&quot;),</a>
<a name="ln6438">          INT_MAX);</a>
<a name="ln6439">    return;</a>
<a name="ln6440">  }</a>
<a name="ln6441"> </a>
<a name="ln6442">  char buf[MB_MAXBYTES];</a>
<a name="ln6443">  const int len = utf_char2bytes((int)num, (char_u *)buf);</a>
<a name="ln6444"> </a>
<a name="ln6445">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln6446">  rettv-&gt;vval.v_string = xmemdupz(buf, (size_t)len);</a>
<a name="ln6447">}</a>
<a name="ln6448"> </a>
<a name="ln6449">/*</a>
<a name="ln6450"> * &quot;or(expr, expr)&quot; function</a>
<a name="ln6451"> */</a>
<a name="ln6452">static void f_or(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6453">{</a>
<a name="ln6454">  rettv-&gt;vval.v_number = tv_get_number_chk(&amp;argvars[0], NULL)</a>
<a name="ln6455">                         | tv_get_number_chk(&amp;argvars[1], NULL);</a>
<a name="ln6456">}</a>
<a name="ln6457"> </a>
<a name="ln6458">/*</a>
<a name="ln6459"> * &quot;pathshorten()&quot; function</a>
<a name="ln6460"> */</a>
<a name="ln6461">static void f_pathshorten(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6462">{</a>
<a name="ln6463">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln6464">  const char *const s = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln6465">  if (!s) {</a>
<a name="ln6466">    return;</a>
<a name="ln6467">  }</a>
<a name="ln6468">  rettv-&gt;vval.v_string = shorten_dir((char_u *)xstrdup(s));</a>
<a name="ln6469">}</a>
<a name="ln6470"> </a>
<a name="ln6471">/*</a>
<a name="ln6472"> * &quot;pow()&quot; function</a>
<a name="ln6473"> */</a>
<a name="ln6474">static void f_pow(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6475">{</a>
<a name="ln6476">  float_T fx;</a>
<a name="ln6477">  float_T fy;</a>
<a name="ln6478"> </a>
<a name="ln6479">  rettv-&gt;v_type = VAR_FLOAT;</a>
<a name="ln6480">  if (tv_get_float_chk(argvars, &amp;fx) &amp;&amp; tv_get_float_chk(&amp;argvars[1], &amp;fy)) {</a>
<a name="ln6481">    rettv-&gt;vval.v_float = pow(fx, fy);</a>
<a name="ln6482">  } else {</a>
<a name="ln6483">    rettv-&gt;vval.v_float = 0.0;</a>
<a name="ln6484">  }</a>
<a name="ln6485">}</a>
<a name="ln6486"> </a>
<a name="ln6487">/*</a>
<a name="ln6488"> * &quot;prevnonblank()&quot; function</a>
<a name="ln6489"> */</a>
<a name="ln6490">static void f_prevnonblank(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6491">{</a>
<a name="ln6492">  linenr_T lnum = tv_get_lnum(argvars);</a>
<a name="ln6493">  if (lnum &lt; 1 || lnum &gt; curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln6494">    lnum = 0;</a>
<a name="ln6495">  } else {</a>
<a name="ln6496">    while (lnum &gt;= 1 &amp;&amp; *skipwhite(ml_get(lnum)) == NUL) {</a>
<a name="ln6497">      lnum--;</a>
<a name="ln6498">    }</a>
<a name="ln6499">  }</a>
<a name="ln6500">  rettv-&gt;vval.v_number = lnum;</a>
<a name="ln6501">}</a>
<a name="ln6502"> </a>
<a name="ln6503">/*</a>
<a name="ln6504"> * &quot;printf()&quot; function</a>
<a name="ln6505"> */</a>
<a name="ln6506">static void f_printf(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6507">{</a>
<a name="ln6508">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln6509">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln6510">  {</a>
<a name="ln6511">    int len;</a>
<a name="ln6512">    int saved_did_emsg = did_emsg;</a>
<a name="ln6513"> </a>
<a name="ln6514">    // Get the required length, allocate the buffer and do it for real.</a>
<a name="ln6515">    did_emsg = false;</a>
<a name="ln6516">    char buf[NUMBUFLEN];</a>
<a name="ln6517">    const char *fmt = tv_get_string_buf(&amp;argvars[0], buf);</a>
<a name="ln6518">    len = vim_vsnprintf_typval(NULL, 0, fmt, dummy_ap, argvars + 1);</a>
<a name="ln6519">    if (!did_emsg) {</a>
<a name="ln6520">      char *s = xmalloc(len + 1);</a>
<a name="ln6521">      rettv-&gt;vval.v_string = (char_u *)s;</a>
<a name="ln6522">      (void)vim_vsnprintf_typval(s, len + 1, fmt, dummy_ap, argvars + 1);</a>
<a name="ln6523">    }</a>
<a name="ln6524">    did_emsg |= saved_did_emsg;</a>
<a name="ln6525">  }</a>
<a name="ln6526">}</a>
<a name="ln6527"> </a>
<a name="ln6528">// &quot;prompt_setcallback({buffer}, {callback})&quot; function</a>
<a name="ln6529">static void f_prompt_setcallback(typval_T *argvars,</a>
<a name="ln6530">                                 typval_T *rettv, FunPtr fptr)</a>
<a name="ln6531">{</a>
<a name="ln6532">    buf_T *buf;</a>
<a name="ln6533">    Callback prompt_callback = { .type = kCallbackNone };</a>
<a name="ln6534"> </a>
<a name="ln6535">    if (check_secure()) {</a>
<a name="ln6536">      return;</a>
<a name="ln6537">    }</a>
<a name="ln6538">    buf = tv_get_buf(&amp;argvars[0], false);</a>
<a name="ln6539">    if (buf == NULL) {</a>
<a name="ln6540">      return;</a>
<a name="ln6541">    }</a>
<a name="ln6542"> </a>
<a name="ln6543">    if (argvars[1].v_type != VAR_STRING || *argvars[1].vval.v_string != NUL) {</a>
<a name="ln6544">      if (!callback_from_typval(&amp;prompt_callback, &amp;argvars[1])) {</a>
<a name="ln6545">        return;</a>
<a name="ln6546">      }</a>
<a name="ln6547">    }</a>
<a name="ln6548"> </a>
<a name="ln6549">    callback_free(&amp;buf-&gt;b_prompt_callback);</a>
<a name="ln6550">    buf-&gt;b_prompt_callback = prompt_callback;</a>
<a name="ln6551">}</a>
<a name="ln6552"> </a>
<a name="ln6553">// &quot;prompt_setinterrupt({buffer}, {callback})&quot; function</a>
<a name="ln6554">static void f_prompt_setinterrupt(typval_T *argvars,</a>
<a name="ln6555">                                  typval_T *rettv, FunPtr fptr)</a>
<a name="ln6556">{</a>
<a name="ln6557">    buf_T *buf;</a>
<a name="ln6558">    Callback interrupt_callback = { .type = kCallbackNone };</a>
<a name="ln6559"> </a>
<a name="ln6560">    if (check_secure()) {</a>
<a name="ln6561">      return;</a>
<a name="ln6562">    }</a>
<a name="ln6563">    buf = tv_get_buf(&amp;argvars[0], false);</a>
<a name="ln6564">    if (buf == NULL) {</a>
<a name="ln6565">      return;</a>
<a name="ln6566">    }</a>
<a name="ln6567"> </a>
<a name="ln6568">    if (argvars[1].v_type != VAR_STRING || *argvars[1].vval.v_string != NUL) {</a>
<a name="ln6569">      if (!callback_from_typval(&amp;interrupt_callback, &amp;argvars[1])) {</a>
<a name="ln6570">        return;</a>
<a name="ln6571">      }</a>
<a name="ln6572">    }</a>
<a name="ln6573"> </a>
<a name="ln6574">    callback_free(&amp;buf-&gt;b_prompt_interrupt);</a>
<a name="ln6575">    buf-&gt;b_prompt_interrupt= interrupt_callback;</a>
<a name="ln6576">}</a>
<a name="ln6577"> </a>
<a name="ln6578">/// &quot;prompt_getprompt({buffer})&quot; function</a>
<a name="ln6579">void f_prompt_getprompt(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6580">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln6581">{</a>
<a name="ln6582">  // return an empty string by default, e.g. it's not a prompt buffer</a>
<a name="ln6583">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln6584">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln6585"> </a>
<a name="ln6586">  buf_T *const buf = tv_get_buf_from_arg(&amp;argvars[0]);</a>
<a name="ln6587">  if (buf == NULL) {</a>
<a name="ln6588">    return;</a>
<a name="ln6589">  }</a>
<a name="ln6590"> </a>
<a name="ln6591">  if (!bt_prompt(buf)) {</a>
<a name="ln6592">    return;</a>
<a name="ln6593">  }</a>
<a name="ln6594"> </a>
<a name="ln6595">  rettv-&gt;vval.v_string = vim_strsave(buf_prompt_text(buf));</a>
<a name="ln6596">}</a>
<a name="ln6597"> </a>
<a name="ln6598">// &quot;prompt_setprompt({buffer}, {text})&quot; function</a>
<a name="ln6599">static void f_prompt_setprompt(typval_T *argvars,</a>
<a name="ln6600">                               typval_T *rettv, FunPtr fptr)</a>
<a name="ln6601">{</a>
<a name="ln6602">    buf_T *buf;</a>
<a name="ln6603">    const char_u *text;</a>
<a name="ln6604"> </a>
<a name="ln6605">    if (check_secure()) {</a>
<a name="ln6606">      return;</a>
<a name="ln6607">    }</a>
<a name="ln6608">    buf = tv_get_buf(&amp;argvars[0], false);</a>
<a name="ln6609">    if (buf == NULL) {</a>
<a name="ln6610">      return;</a>
<a name="ln6611">    }</a>
<a name="ln6612"> </a>
<a name="ln6613">    text = (const char_u *)tv_get_string(&amp;argvars[1]);</a>
<a name="ln6614">    xfree(buf-&gt;b_prompt_text);</a>
<a name="ln6615">    buf-&gt;b_prompt_text = vim_strsave(text);</a>
<a name="ln6616">}</a>
<a name="ln6617"> </a>
<a name="ln6618">// &quot;pum_getpos()&quot; function</a>
<a name="ln6619">static void f_pum_getpos(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6620">{</a>
<a name="ln6621">  tv_dict_alloc_ret(rettv);</a>
<a name="ln6622">  pum_set_event_info(rettv-&gt;vval.v_dict);</a>
<a name="ln6623">}</a>
<a name="ln6624"> </a>
<a name="ln6625">/*</a>
<a name="ln6626"> * &quot;pumvisible()&quot; function</a>
<a name="ln6627"> */</a>
<a name="ln6628">static void f_pumvisible(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6629">{</a>
<a name="ln6630">  if (pum_visible())</a>
<a name="ln6631">    rettv-&gt;vval.v_number = 1;</a>
<a name="ln6632">}</a>
<a name="ln6633"> </a>
<a name="ln6634">/*</a>
<a name="ln6635"> * &quot;pyeval()&quot; function</a>
<a name="ln6636"> */</a>
<a name="ln6637">static void f_pyeval(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6638">{</a>
<a name="ln6639">  script_host_eval(&quot;python&quot;, argvars, rettv);</a>
<a name="ln6640">}</a>
<a name="ln6641"> </a>
<a name="ln6642">/*</a>
<a name="ln6643"> * &quot;py3eval()&quot; function</a>
<a name="ln6644"> */</a>
<a name="ln6645">static void f_py3eval(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6646">{</a>
<a name="ln6647">  script_host_eval(&quot;python3&quot;, argvars, rettv);</a>
<a name="ln6648">}</a>
<a name="ln6649"> </a>
<a name="ln6650">// &quot;pyxeval()&quot; function</a>
<a name="ln6651">static void f_pyxeval(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6652">{</a>
<a name="ln6653">  init_pyxversion();</a>
<a name="ln6654">  if (p_pyx == 2) {</a>
<a name="ln6655">    f_pyeval(argvars, rettv, NULL);</a>
<a name="ln6656">  } else {</a>
<a name="ln6657">    f_py3eval(argvars, rettv, NULL);</a>
<a name="ln6658">  }</a>
<a name="ln6659">}</a>
<a name="ln6660"> </a>
<a name="ln6661">///</a>
<a name="ln6662">/// &quot;perleval()&quot; function</a>
<a name="ln6663">///</a>
<a name="ln6664">static void f_perleval(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6665">{</a>
<a name="ln6666">  script_host_eval(&quot;perl&quot;, argvars, rettv);</a>
<a name="ln6667">}</a>
<a name="ln6668"> </a>
<a name="ln6669">// &quot;rubyeval()&quot; function</a>
<a name="ln6670">static void f_rubyeval(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6671">{</a>
<a name="ln6672">  script_host_eval(&quot;ruby&quot;, argvars, rettv);</a>
<a name="ln6673">}</a>
<a name="ln6674"> </a>
<a name="ln6675">/*</a>
<a name="ln6676"> * &quot;range()&quot; function</a>
<a name="ln6677"> */</a>
<a name="ln6678">static void f_range(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6679">{</a>
<a name="ln6680">  varnumber_T start;</a>
<a name="ln6681">  varnumber_T end;</a>
<a name="ln6682">  varnumber_T stride = 1;</a>
<a name="ln6683">  varnumber_T i;</a>
<a name="ln6684">  bool error = false;</a>
<a name="ln6685"> </a>
<a name="ln6686">  start = tv_get_number_chk(&amp;argvars[0], &amp;error);</a>
<a name="ln6687">  if (argvars[1].v_type == VAR_UNKNOWN) {</a>
<a name="ln6688">    end = start - 1;</a>
<a name="ln6689">    start = 0;</a>
<a name="ln6690">  } else {</a>
<a name="ln6691">    end = tv_get_number_chk(&amp;argvars[1], &amp;error);</a>
<a name="ln6692">    if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln6693">      stride = tv_get_number_chk(&amp;argvars[2], &amp;error);</a>
<a name="ln6694">    }</a>
<a name="ln6695">  }</a>
<a name="ln6696"> </a>
<a name="ln6697">  if (error) {</a>
<a name="ln6698">    return;  // Type error; errmsg already given.</a>
<a name="ln6699">  }</a>
<a name="ln6700">  if (stride == 0) {</a>
<a name="ln6701">    EMSG(_(&quot;E726: Stride is zero&quot;));</a>
<a name="ln6702">  } else if (stride &gt; 0 ? end + 1 &lt; start : end - 1 &gt; start) {</a>
<a name="ln6703">    EMSG(_(&quot;E727: Start past end&quot;));</a>
<a name="ln6704">  } else {</a>
<a name="ln6705">    tv_list_alloc_ret(rettv, (end - start) / stride);</a>
<a name="ln6706">    for (i = start; stride &gt; 0 ? i &lt;= end : i &gt;= end; i += stride) {</a>
<a name="ln6707">      tv_list_append_number(rettv-&gt;vval.v_list, (varnumber_T)i);</a>
<a name="ln6708">    }</a>
<a name="ln6709">  }</a>
<a name="ln6710">}</a>
<a name="ln6711"> </a>
<a name="ln6712">// Evaluate &quot;expr&quot; for readdir().</a>
<a name="ln6713">static varnumber_T readdir_checkitem(typval_T *expr, const char *name)</a>
<a name="ln6714">{</a>
<a name="ln6715">  typval_T save_val;</a>
<a name="ln6716">  typval_T rettv;</a>
<a name="ln6717">  typval_T argv[2];</a>
<a name="ln6718">  varnumber_T retval = 0;</a>
<a name="ln6719">  bool error = false;</a>
<a name="ln6720"> </a>
<a name="ln6721">  prepare_vimvar(VV_VAL, &amp;save_val);</a>
<a name="ln6722">  set_vim_var_string(VV_VAL, name, -1);</a>
<a name="ln6723">  argv[0].v_type = VAR_STRING;</a>
<a name="ln6724">  argv[0].vval.v_string = (char_u *)name;</a>
<a name="ln6725"> </a>
<a name="ln6726">  if (eval_expr_typval(expr, argv, 1, &amp;rettv) == FAIL) {</a>
<a name="ln6727">    goto theend;</a>
<a name="ln6728">  }</a>
<a name="ln6729"> </a>
<a name="ln6730">  retval = tv_get_number_chk(&amp;rettv, &amp;error);</a>
<a name="ln6731">  if (error) {</a>
<a name="ln6732">    retval = -1;</a>
<a name="ln6733">  }</a>
<a name="ln6734"> </a>
<a name="ln6735">  tv_clear(&amp;rettv);</a>
<a name="ln6736"> </a>
<a name="ln6737">theend:</a>
<a name="ln6738">  set_vim_var_string(VV_VAL, NULL, 0);</a>
<a name="ln6739">  restore_vimvar(VV_VAL, &amp;save_val);</a>
<a name="ln6740">  return retval;</a>
<a name="ln6741">}</a>
<a name="ln6742"> </a>
<a name="ln6743">// &quot;readdir()&quot; function</a>
<a name="ln6744">static void f_readdir(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6745">{</a>
<a name="ln6746">  typval_T *expr;</a>
<a name="ln6747">  const char *path;</a>
<a name="ln6748">  garray_T ga;</a>
<a name="ln6749">  Directory dir;</a>
<a name="ln6750"> </a>
<a name="ln6751">  tv_list_alloc_ret(rettv, kListLenUnknown);</a>
<a name="ln6752">  path = tv_get_string(&amp;argvars[0]);</a>
<a name="ln6753">  expr = &amp;argvars[1];</a>
<a name="ln6754">  ga_init(&amp;ga, (int)sizeof(char *), 20);</a>
<a name="ln6755"> </a>
<a name="ln6756">  if (!os_scandir(&amp;dir, path)) {</a>
<a name="ln6757">    smsg(_(e_notopen), path);</a>
<a name="ln6758">  } else {</a>
<a name="ln6759">    for (;;) {</a>
<a name="ln6760">      bool ignore;</a>
<a name="ln6761"> </a>
<a name="ln6762">      path = os_scandir_next(&amp;dir);</a>
<a name="ln6763">      if (path == NULL) {</a>
<a name="ln6764">        break;</a>
<a name="ln6765">      }</a>
<a name="ln6766"> </a>
<a name="ln6767">      ignore = (path[0] == '.'</a>
<a name="ln6768">                &amp;&amp; (path[1] == NUL || (path[1] == '.' &amp;&amp; path[2] == NUL)));</a>
<a name="ln6769">      if (!ignore &amp;&amp; expr-&gt;v_type != VAR_UNKNOWN) {</a>
<a name="ln6770">        varnumber_T r = readdir_checkitem(expr, path);</a>
<a name="ln6771"> </a>
<a name="ln6772">        if (r &lt; 0) {</a>
<a name="ln6773">          break;</a>
<a name="ln6774">        }</a>
<a name="ln6775">        if (r == 0) {</a>
<a name="ln6776">          ignore = true;</a>
<a name="ln6777">        }</a>
<a name="ln6778">      }</a>
<a name="ln6779"> </a>
<a name="ln6780">      if (!ignore) {</a>
<a name="ln6781">        ga_grow(&amp;ga, 1);</a>
<a name="ln6782">        ((char **)ga.ga_data)[ga.ga_len++] = xstrdup(path);</a>
<a name="ln6783">      }</a>
<a name="ln6784">    }</a>
<a name="ln6785"> </a>
<a name="ln6786">    os_closedir(&amp;dir);</a>
<a name="ln6787">  }</a>
<a name="ln6788"> </a>
<a name="ln6789">  if (rettv-&gt;vval.v_list != NULL &amp;&amp; ga.ga_len &gt; 0) {</a>
<a name="ln6790">    sort_strings((char_u **)ga.ga_data, ga.ga_len);</a>
<a name="ln6791">    for (int i = 0; i &lt; ga.ga_len; i++) {</a>
<a name="ln6792">      path = ((const char **)ga.ga_data)[i];</a>
<a name="ln6793">      tv_list_append_string(rettv-&gt;vval.v_list, path, -1);</a>
<a name="ln6794">    }</a>
<a name="ln6795">  }</a>
<a name="ln6796">  ga_clear_strings(&amp;ga);</a>
<a name="ln6797">}</a>
<a name="ln6798"> </a>
<a name="ln6799">/*</a>
<a name="ln6800"> * &quot;readfile()&quot; function</a>
<a name="ln6801"> */</a>
<a name="ln6802">static void f_readfile(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6803">{</a>
<a name="ln6804">  bool binary = false;</a>
<a name="ln6805">  FILE        *fd;</a>
<a name="ln6806">  char_u buf[(IOSIZE/256) * 256];       // rounded to avoid odd + 1</a>
<a name="ln6807">  int io_size = sizeof(buf);</a>
<a name="ln6808">  int readlen;                          // size of last fread()</a>
<a name="ln6809">  char_u      *prev    = NULL;          // previously read bytes, if any</a>
<a name="ln6810">  long prevlen  = 0;                    // length of data in prev</a>
<a name="ln6811">  long prevsize = 0;                    // size of prev buffer</a>
<a name="ln6812">  long maxline  = MAXLNUM;</a>
<a name="ln6813"> </a>
<a name="ln6814">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln6815">    if (strcmp(tv_get_string(&amp;argvars[1]), &quot;b&quot;) == 0) {</a>
<a name="ln6816">      binary = true;</a>
<a name="ln6817">    }</a>
<a name="ln6818">    if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln6819">      maxline = tv_get_number(&amp;argvars[2]);</a>
<a name="ln6820">    }</a>
<a name="ln6821">  }</a>
<a name="ln6822"> </a>
<a name="ln6823">  list_T *const l = tv_list_alloc_ret(rettv, kListLenUnknown);</a>
<a name="ln6824"> </a>
<a name="ln6825">  // Always open the file in binary mode, library functions have a mind of</a>
<a name="ln6826">  // their own about CR-LF conversion.</a>
<a name="ln6827">  const char *const fname = tv_get_string(&amp;argvars[0]);</a>
<a name="ln6828">  if (*fname == NUL || (fd = os_fopen(fname, READBIN)) == NULL) {</a>
<a name="ln6829">    EMSG2(_(e_notopen), *fname == NUL ? _(&quot;&lt;empty&gt;&quot;) : fname);</a>
<a name="ln6830">    return;</a>
<a name="ln6831">  }</a>
<a name="ln6832"> </a>
<a name="ln6833">  while (maxline &lt; 0 || tv_list_len(l) &lt; maxline) {</a>
<a name="ln6834">    readlen = (int)fread(buf, 1, io_size, fd);</a>
<a name="ln6835"> </a>
<a name="ln6836">    // This for loop processes what was read, but is also entered at end</a>
<a name="ln6837">    // of file so that either:</a>
<a name="ln6838">    // - an incomplete line gets written</a>
<a name="ln6839">    // - a &quot;binary&quot; file gets an empty line at the end if it ends in a</a>
<a name="ln6840">    //   newline.</a>
<a name="ln6841">    char_u *p;  // Position in buf.</a>
<a name="ln6842">    char_u *start;  // Start of current line.</a>
<a name="ln6843">    for (p = buf, start = buf;</a>
<a name="ln6844">         p &lt; buf + readlen || (readlen &lt;= 0 &amp;&amp; (prevlen &gt; 0 || binary));</a>
<a name="ln6845">         p++) {</a>
<a name="ln6846">      if (*p == '\n' || readlen &lt;= 0) {</a>
<a name="ln6847">        char_u      *s  = NULL;</a>
<a name="ln6848">        size_t len = p - start;</a>
<a name="ln6849"> </a>
<a name="ln6850">        // Finished a line.  Remove CRs before NL.</a>
<a name="ln6851">        if (readlen &gt; 0 &amp;&amp; !binary) {</a>
<a name="ln6852">          while (len &gt; 0 &amp;&amp; start[len - 1] == '\r') {</a>
<a name="ln6853">            len--;</a>
<a name="ln6854">          }</a>
<a name="ln6855">          // removal may cross back to the &quot;prev&quot; string</a>
<a name="ln6856">          if (len == 0) {</a>
<a name="ln6857">            while (prevlen &gt; 0 &amp;&amp; prev[prevlen - 1] == '\r') {</a>
<a name="ln6858">              prevlen--;</a>
<a name="ln6859">            }</a>
<a name="ln6860">          }</a>
<a name="ln6861">        }</a>
<a name="ln6862">        if (prevlen == 0) {</a>
<a name="ln6863">          assert(len &lt; INT_MAX);</a>
<a name="ln6864">          s = vim_strnsave(start, len);</a>
<a name="ln6865">        } else {</a>
<a name="ln6866">          /* Change &quot;prev&quot; buffer to be the right size.  This way</a>
<a name="ln6867">           * the bytes are only copied once, and very long lines are</a>
<a name="ln6868">           * allocated only once.  */</a>
<a name="ln6869">          s = xrealloc(prev, prevlen + len + 1);</a>
<a name="ln6870">          memcpy(s + prevlen, start, len);</a>
<a name="ln6871">          s[prevlen + len] = NUL;</a>
<a name="ln6872">          prev = NULL;             // the list will own the string</a>
<a name="ln6873">          prevlen = prevsize = 0;</a>
<a name="ln6874">        }</a>
<a name="ln6875"> </a>
<a name="ln6876">        tv_list_append_owned_tv(l, (typval_T) {</a>
<a name="ln6877">          .v_type = VAR_STRING,</a>
<a name="ln6878">          .v_lock = VAR_UNLOCKED,</a>
<a name="ln6879">          .vval.v_string = s,</a>
<a name="ln6880">        });</a>
<a name="ln6881"> </a>
<a name="ln6882">        start = p + 1;  // Step over newline.</a>
<a name="ln6883">        if (maxline &lt; 0) {</a>
<a name="ln6884">          if (tv_list_len(l) &gt; -maxline) {</a>
<a name="ln6885">            assert(tv_list_len(l) == 1 + (-maxline));</a>
<a name="ln6886">            tv_list_item_remove(l, tv_list_first(l));</a>
<a name="ln6887">          }</a>
<a name="ln6888">        } else if (tv_list_len(l) &gt;= maxline) {</a>
<a name="ln6889">          assert(tv_list_len(l) == maxline);</a>
<a name="ln6890">          break;</a>
<a name="ln6891">        }</a>
<a name="ln6892">        if (readlen &lt;= 0) {</a>
<a name="ln6893">          break;</a>
<a name="ln6894">        }</a>
<a name="ln6895">      } else if (*p == NUL) {</a>
<a name="ln6896">        *p = '\n';</a>
<a name="ln6897">      // Check for utf8 &quot;bom&quot;; U+FEFF is encoded as EF BB BF.  Do this</a>
<a name="ln6898">      // when finding the BF and check the previous two bytes.</a>
<a name="ln6899">      } else if (*p == 0xbf &amp;&amp; !binary) {</a>
<a name="ln6900">        // Find the two bytes before the 0xbf.  If p is at buf, or buf + 1,</a>
<a name="ln6901">        // these may be in the &quot;prev&quot; string.</a>
<a name="ln6902">        char_u back1 = p &gt;= buf + 1 ? p[-1]</a>
<a name="ln6903">                       : prevlen &gt;= 1 ? prev[prevlen - 1] : NUL;</a>
<a name="ln6904">        char_u back2 = p &gt;= buf + 2 ? p[-2]</a>
<a name="ln6905">                       : p == buf + 1 &amp;&amp; prevlen &gt;= 1 ? prev[prevlen - 1]</a>
<a name="ln6906">                       : prevlen &gt;= 2 ? prev[prevlen - 2] : NUL;</a>
<a name="ln6907"> </a>
<a name="ln6908">        if (back2 == 0xef &amp;&amp; back1 == 0xbb) {</a>
<a name="ln6909">          char_u *dest = p - 2;</a>
<a name="ln6910"> </a>
<a name="ln6911">          // Usually a BOM is at the beginning of a file, and so at</a>
<a name="ln6912">          // the beginning of a line; then we can just step over it.</a>
<a name="ln6913">          if (start == dest) {</a>
<a name="ln6914">            start = p + 1;</a>
<a name="ln6915">          } else {</a>
<a name="ln6916">            // have to shuffle buf to close gap</a>
<a name="ln6917">            int adjust_prevlen = 0;</a>
<a name="ln6918"> </a>
<a name="ln6919">            if (dest &lt; buf) {  // -V782</a>
<a name="ln6920">              adjust_prevlen = (int)(buf - dest);  // -V782</a>
<a name="ln6921">              // adjust_prevlen must be 1 or 2.</a>
<a name="ln6922">              dest = buf;</a>
<a name="ln6923">            }</a>
<a name="ln6924">            if (readlen &gt; p - buf + 1)</a>
<a name="ln6925">              memmove(dest, p + 1, readlen - (p - buf) - 1);</a>
<a name="ln6926">            readlen -= 3 - adjust_prevlen;</a>
<a name="ln6927">            prevlen -= adjust_prevlen;</a>
<a name="ln6928">            p = dest - 1;</a>
<a name="ln6929">          }</a>
<a name="ln6930">        }</a>
<a name="ln6931">      }</a>
<a name="ln6932">    }     // for</a>
<a name="ln6933"> </a>
<a name="ln6934">    if ((maxline &gt;= 0 &amp;&amp; tv_list_len(l) &gt;= maxline) || readlen &lt;= 0) {</a>
<a name="ln6935">      break;</a>
<a name="ln6936">    }</a>
<a name="ln6937">    if (start &lt; p) {</a>
<a name="ln6938">      // There's part of a line in buf, store it in &quot;prev&quot;.</a>
<a name="ln6939">      if (p - start + prevlen &gt;= prevsize) {</a>
<a name="ln6940">        /* A common use case is ordinary text files and &quot;prev&quot; gets a</a>
<a name="ln6941">         * fragment of a line, so the first allocation is made</a>
<a name="ln6942">         * small, to avoid repeatedly 'allocing' large and</a>
<a name="ln6943">         * 'reallocing' small. */</a>
<a name="ln6944">        if (prevsize == 0)</a>
<a name="ln6945">          prevsize = (long)(p - start);</a>
<a name="ln6946">        else {</a>
<a name="ln6947">          long grow50pc = (prevsize * 3) / 2;</a>
<a name="ln6948">          long growmin  = (long)((p - start) * 2 + prevlen);</a>
<a name="ln6949">          prevsize = grow50pc &gt; growmin ? grow50pc : growmin;</a>
<a name="ln6950">        }</a>
<a name="ln6951">        prev = xrealloc(prev, prevsize);</a>
<a name="ln6952">      }</a>
<a name="ln6953">      // Add the line part to end of &quot;prev&quot;.</a>
<a name="ln6954">      memmove(prev + prevlen, start, p - start);</a>
<a name="ln6955">      prevlen += (long)(p - start);</a>
<a name="ln6956">    }</a>
<a name="ln6957">  }   // while</a>
<a name="ln6958"> </a>
<a name="ln6959">  xfree(prev);</a>
<a name="ln6960">  fclose(fd);</a>
<a name="ln6961">}</a>
<a name="ln6962"> </a>
<a name="ln6963">// &quot;reg_executing()&quot; function</a>
<a name="ln6964">static void f_reg_executing(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6965">{</a>
<a name="ln6966">  return_register(reg_executing, rettv);</a>
<a name="ln6967">}</a>
<a name="ln6968"> </a>
<a name="ln6969">// &quot;reg_recording()&quot; function</a>
<a name="ln6970">static void f_reg_recording(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6971">{</a>
<a name="ln6972">  return_register(reg_recording, rettv);</a>
<a name="ln6973">}</a>
<a name="ln6974"> </a>
<a name="ln6975">/// list2proftime - convert a List to proftime_T</a>
<a name="ln6976">///</a>
<a name="ln6977">/// @param arg The input list, must be of type VAR_LIST and have</a>
<a name="ln6978">///            exactly 2 items</a>
<a name="ln6979">/// @param[out] tm The proftime_T representation of `arg`</a>
<a name="ln6980">/// @return OK In case of success, FAIL in case of error</a>
<a name="ln6981">static int list2proftime(typval_T *arg, proftime_T *tm) FUNC_ATTR_NONNULL_ALL</a>
<a name="ln6982">{</a>
<a name="ln6983">  if (arg-&gt;v_type != VAR_LIST || tv_list_len(arg-&gt;vval.v_list) != 2) {</a>
<a name="ln6984">    return FAIL;</a>
<a name="ln6985">  }</a>
<a name="ln6986"> </a>
<a name="ln6987">  bool error = false;</a>
<a name="ln6988">  varnumber_T n1 = tv_list_find_nr(arg-&gt;vval.v_list, 0L, &amp;error);</a>
<a name="ln6989">  varnumber_T n2 = tv_list_find_nr(arg-&gt;vval.v_list, 1L, &amp;error);</a>
<a name="ln6990">  if (error) {</a>
<a name="ln6991">    return FAIL;</a>
<a name="ln6992">  }</a>
<a name="ln6993"> </a>
<a name="ln6994">  // in f_reltime() we split up the 64-bit proftime_T into two 32-bit</a>
<a name="ln6995">  // values, now we combine them again.</a>
<a name="ln6996">  union {</a>
<a name="ln6997">    struct { int32_t low, high; } split;</a>
<a name="ln6998">    proftime_T prof;</a>
<a name="ln6999">  } u = { .split.high = n1, .split.low = n2 };</a>
<a name="ln7000"> </a>
<a name="ln7001">  *tm = u.prof;</a>
<a name="ln7002"> </a>
<a name="ln7003">  return OK;</a>
<a name="ln7004">}</a>
<a name="ln7005"> </a>
<a name="ln7006">/// f_reltime - return an item that represents a time value</a>
<a name="ln7007">///</a>
<a name="ln7008">/// @param[out] rettv Without an argument it returns the current time. With</a>
<a name="ln7009">///             one argument it returns the time passed since the argument.</a>
<a name="ln7010">///             With two arguments it returns the time passed between</a>
<a name="ln7011">///             the two arguments.</a>
<a name="ln7012">static void f_reltime(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln7013">{</a>
<a name="ln7014">  proftime_T res;</a>
<a name="ln7015">  proftime_T start;</a>
<a name="ln7016"> </a>
<a name="ln7017">  if (argvars[0].v_type == VAR_UNKNOWN) {</a>
<a name="ln7018">    // no arguments: get current time.</a>
<a name="ln7019">    res = profile_start();</a>
<a name="ln7020">  } else if (argvars[1].v_type == VAR_UNKNOWN) {</a>
<a name="ln7021">    if (list2proftime(&amp;argvars[0], &amp;res) == FAIL) {</a>
<a name="ln7022">      return;</a>
<a name="ln7023">    }</a>
<a name="ln7024">    res = profile_end(res);</a>
<a name="ln7025">  } else {</a>
<a name="ln7026">    // two arguments: compute the difference.</a>
<a name="ln7027">    if (list2proftime(&amp;argvars[0], &amp;start) == FAIL</a>
<a name="ln7028">        || list2proftime(&amp;argvars[1], &amp;res) == FAIL) {</a>
<a name="ln7029">      return;</a>
<a name="ln7030">    }</a>
<a name="ln7031">    res = profile_sub(res, start);</a>
<a name="ln7032">  }</a>
<a name="ln7033"> </a>
<a name="ln7034">  // we have to store the 64-bit proftime_T inside of a list of int's</a>
<a name="ln7035">  // (varnumber_T is defined as int). For all our supported platforms, int's</a>
<a name="ln7036">  // are at least 32-bits wide. So we'll use two 32-bit values to store it.</a>
<a name="ln7037">  union {</a>
<a name="ln7038">    struct { int32_t low, high; } split;</a>
<a name="ln7039">    proftime_T prof;</a>
<a name="ln7040">  } u = { .prof = res };</a>
<a name="ln7041"> </a>
<a name="ln7042">  // statically assert that the union type conv will provide the correct</a>
<a name="ln7043">  // results, if varnumber_T or proftime_T change, the union cast will need</a>
<a name="ln7044">  // to be revised.</a>
<a name="ln7045">  STATIC_ASSERT(sizeof(u.prof) == sizeof(u) &amp;&amp; sizeof(u.split) == sizeof(u),</a>
<a name="ln7046">      &quot;type punning will produce incorrect results on this platform&quot;);</a>
<a name="ln7047"> </a>
<a name="ln7048">  tv_list_alloc_ret(rettv, 2);</a>
<a name="ln7049">  tv_list_append_number(rettv-&gt;vval.v_list, u.split.high);</a>
<a name="ln7050">  tv_list_append_number(rettv-&gt;vval.v_list, u.split.low);</a>
<a name="ln7051">}</a>
<a name="ln7052"> </a>
<a name="ln7053">/// &quot;reltimestr()&quot; function</a>
<a name="ln7054">static void f_reltimestr(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln7055">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln7056">{</a>
<a name="ln7057">  proftime_T tm;</a>
<a name="ln7058"> </a>
<a name="ln7059">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln7060">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln7061">  if (list2proftime(&amp;argvars[0], &amp;tm) == OK) {</a>
<a name="ln7062">    rettv-&gt;vval.v_string = (char_u *)xstrdup(profile_msg(tm));</a>
<a name="ln7063">  }</a>
<a name="ln7064">}</a>
<a name="ln7065"> </a>
<a name="ln7066">/*</a>
<a name="ln7067"> * &quot;remove()&quot; function</a>
<a name="ln7068"> */</a>
<a name="ln7069">static void f_remove(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln7070">{</a>
<a name="ln7071">  list_T      *l;</a>
<a name="ln7072">  listitem_T  *item, *item2;</a>
<a name="ln7073">  listitem_T  *li;</a>
<a name="ln7074">  long idx;</a>
<a name="ln7075">  long end;</a>
<a name="ln7076">  dict_T      *d;</a>
<a name="ln7077">  dictitem_T  *di;</a>
<a name="ln7078">  const char *const arg_errmsg = N_(&quot;remove() argument&quot;);</a>
<a name="ln7079"> </a>
<a name="ln7080">  if (argvars[0].v_type == VAR_DICT) {</a>
<a name="ln7081">    if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln7082">      EMSG2(_(e_toomanyarg), &quot;remove()&quot;);</a>
<a name="ln7083">    } else if ((d = argvars[0].vval.v_dict) != NULL</a>
<a name="ln7084">               &amp;&amp; !var_check_lock(d-&gt;dv_lock, arg_errmsg, TV_TRANSLATE)) {</a>
<a name="ln7085">      const char *key = tv_get_string_chk(&amp;argvars[1]);</a>
<a name="ln7086">      if (key != NULL) {</a>
<a name="ln7087">        di = tv_dict_find(d, key, -1);</a>
<a name="ln7088">        if (di == NULL) {</a>
<a name="ln7089">          EMSG2(_(e_dictkey), key);</a>
<a name="ln7090">        } else if (!var_check_fixed(di-&gt;di_flags, arg_errmsg, TV_TRANSLATE)</a>
<a name="ln7091">                   &amp;&amp; !var_check_ro(di-&gt;di_flags, arg_errmsg, TV_TRANSLATE)) {</a>
<a name="ln7092">          *rettv = di-&gt;di_tv;</a>
<a name="ln7093">          di-&gt;di_tv = TV_INITIAL_VALUE;</a>
<a name="ln7094">          tv_dict_item_remove(d, di);</a>
<a name="ln7095">          if (tv_dict_is_watched(d)) {</a>
<a name="ln7096">            tv_dict_watcher_notify(d, key, NULL, rettv);</a>
<a name="ln7097">          }</a>
<a name="ln7098">        }</a>
<a name="ln7099">      }</a>
<a name="ln7100">    }</a>
<a name="ln7101">  } else if (argvars[0].v_type != VAR_LIST) {</a>
<a name="ln7102">    EMSG2(_(e_listdictarg), &quot;remove()&quot;);</a>
<a name="ln7103">  } else if (!var_check_lock(tv_list_locked((l = argvars[0].vval.v_list)),</a>
<a name="ln7104">                             arg_errmsg, TV_TRANSLATE)) {</a>
<a name="ln7105">    bool error = false;</a>
<a name="ln7106"> </a>
<a name="ln7107">    idx = tv_get_number_chk(&amp;argvars[1], &amp;error);</a>
<a name="ln7108">    if (error) {</a>
<a name="ln7109">      // Type error: do nothing, errmsg already given.</a>
<a name="ln7110">    } else if ((item = tv_list_find(l, idx)) == NULL) {</a>
<a name="ln7111">      EMSGN(_(e_listidx), idx);</a>
<a name="ln7112">    } else {</a>
<a name="ln7113">      if (argvars[2].v_type == VAR_UNKNOWN) {</a>
<a name="ln7114">        // Remove one item, return its value.</a>
<a name="ln7115">        tv_list_drop_items(l, item, item);</a>
<a name="ln7116">        *rettv = *TV_LIST_ITEM_TV(item);</a>
<a name="ln7117">        xfree(item);</a>
<a name="ln7118">      } else {</a>
<a name="ln7119">        // Remove range of items, return list with values.</a>
<a name="ln7120">        end = tv_get_number_chk(&amp;argvars[2], &amp;error);</a>
<a name="ln7121">        if (error) {</a>
<a name="ln7122">          // Type error: do nothing.</a>
<a name="ln7123">        } else if ((item2 = tv_list_find(l, end)) == NULL) {</a>
<a name="ln7124">          EMSGN(_(e_listidx), end);</a>
<a name="ln7125">        } else {</a>
<a name="ln7126">          int cnt = 0;</a>
<a name="ln7127"> </a>
<a name="ln7128">          for (li = item; li != NULL; li = TV_LIST_ITEM_NEXT(l, li)) {</a>
<a name="ln7129">            cnt++;</a>
<a name="ln7130">            if (li == item2) {</a>
<a name="ln7131">              break;</a>
<a name="ln7132">            }</a>
<a name="ln7133">          }</a>
<a name="ln7134">          if (li == NULL) {  // Didn't find &quot;item2&quot; after &quot;item&quot;.</a>
<a name="ln7135">            EMSG(_(e_invrange));</a>
<a name="ln7136">          } else {</a>
<a name="ln7137">            tv_list_move_items(l, item, item2, tv_list_alloc_ret(rettv, cnt),</a>
<a name="ln7138">                               cnt);</a>
<a name="ln7139">          }</a>
<a name="ln7140">        }</a>
<a name="ln7141">      }</a>
<a name="ln7142">    }</a>
<a name="ln7143">  }</a>
<a name="ln7144">}</a>
<a name="ln7145"> </a>
<a name="ln7146">/*</a>
<a name="ln7147"> * &quot;rename({from}, {to})&quot; function</a>
<a name="ln7148"> */</a>
<a name="ln7149">static void f_rename(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln7150">{</a>
<a name="ln7151">  if (check_secure()) {</a>
<a name="ln7152">    rettv-&gt;vval.v_number = -1;</a>
<a name="ln7153">  } else {</a>
<a name="ln7154">    char buf[NUMBUFLEN];</a>
<a name="ln7155">    rettv-&gt;vval.v_number = vim_rename(</a>
<a name="ln7156">        (const char_u *)tv_get_string(&amp;argvars[0]),</a>
<a name="ln7157">        (const char_u *)tv_get_string_buf(&amp;argvars[1], buf));</a>
<a name="ln7158">  }</a>
<a name="ln7159">}</a>
<a name="ln7160"> </a>
<a name="ln7161">/*</a>
<a name="ln7162"> * &quot;repeat()&quot; function</a>
<a name="ln7163"> */</a>
<a name="ln7164">static void f_repeat(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln7165">{</a>
<a name="ln7166">  varnumber_T n = tv_get_number(&amp;argvars[1]);</a>
<a name="ln7167">  if (argvars[0].v_type == VAR_LIST) {</a>
<a name="ln7168">    tv_list_alloc_ret(rettv, (n &gt; 0) * n * tv_list_len(argvars[0].vval.v_list));</a>
<a name="ln7169">    while (n-- &gt; 0) {</a>
<a name="ln7170">      tv_list_extend(rettv-&gt;vval.v_list, argvars[0].vval.v_list, NULL);</a>
<a name="ln7171">    }</a>
<a name="ln7172">  } else {</a>
<a name="ln7173">    rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln7174">    rettv-&gt;vval.v_string = NULL;</a>
<a name="ln7175">    if (n &lt;= 0) {</a>
<a name="ln7176">      return;</a>
<a name="ln7177">    }</a>
<a name="ln7178"> </a>
<a name="ln7179">    const char *const p = tv_get_string(&amp;argvars[0]);</a>
<a name="ln7180"> </a>
<a name="ln7181">    const size_t slen = strlen(p);</a>
<a name="ln7182">    if (slen == 0) {</a>
<a name="ln7183">      return;</a>
<a name="ln7184">    }</a>
<a name="ln7185">    const size_t len = slen * n;</a>
<a name="ln7186">    // Detect overflow.</a>
<a name="ln7187">    if (len / n != slen) {</a>
<a name="ln7188">      return;</a>
<a name="ln7189">    }</a>
<a name="ln7190"> </a>
<a name="ln7191">    char *const r = xmallocz(len);</a>
<a name="ln7192">    for (varnumber_T i = 0; i &lt; n; i++) {</a>
<a name="ln7193">      memmove(r + i * slen, p, slen);</a>
<a name="ln7194">    }</a>
<a name="ln7195"> </a>
<a name="ln7196">    rettv-&gt;vval.v_string = (char_u *)r;</a>
<a name="ln7197">  }</a>
<a name="ln7198">}</a>
<a name="ln7199"> </a>
<a name="ln7200">/*</a>
<a name="ln7201"> * &quot;resolve()&quot; function</a>
<a name="ln7202"> */</a>
<a name="ln7203">static void f_resolve(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln7204">{</a>
<a name="ln7205">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln7206">  const char *fname = tv_get_string(&amp;argvars[0]);</a>
<a name="ln7207">#ifdef WIN32</a>
<a name="ln7208">  char *v = os_resolve_shortcut(fname);</a>
<a name="ln7209">  if (v == NULL) {</a>
<a name="ln7210">    if (os_is_reparse_point_include(fname)) {</a>
<a name="ln7211">      v = os_realpath(fname, v);</a>
<a name="ln7212">    }</a>
<a name="ln7213">  }</a>
<a name="ln7214">  rettv-&gt;vval.v_string = (char_u *)(v == NULL ? xstrdup(fname) : v);</a>
<a name="ln7215">#else</a>
<a name="ln7216"># ifdef HAVE_READLINK</a>
<a name="ln7217">  {</a>
<a name="ln7218">    bool is_relative_to_current = false;</a>
<a name="ln7219">    bool has_trailing_pathsep = false;</a>
<a name="ln7220">    int limit = 100;</a>
<a name="ln7221"> </a>
<a name="ln7222">    char *p = xstrdup(fname);</a>
<a name="ln7223"> </a>
<a name="ln7224">    if (p[0] == '.' &amp;&amp; (vim_ispathsep(p[1])</a>
<a name="ln7225">                        || (p[1] == '.' &amp;&amp; (vim_ispathsep(p[2]))))) {</a>
<a name="ln7226">      is_relative_to_current = true;</a>
<a name="ln7227">    }</a>
<a name="ln7228"> </a>
<a name="ln7229">    ptrdiff_t len = (ptrdiff_t)strlen(p);</a>
<a name="ln7230">    if (len &gt; 1 &amp;&amp; after_pathsep(p, p + len)) {</a>
<a name="ln7231">      has_trailing_pathsep = true;</a>
<a name="ln7232">      p[len - 1] = NUL;  // The trailing slash breaks readlink().</a>
<a name="ln7233">    }</a>
<a name="ln7234"> </a>
<a name="ln7235">    char *q = (char *)path_next_component(p);</a>
<a name="ln7236">    char *remain = NULL;</a>
<a name="ln7237">    if (*q != NUL) {</a>
<a name="ln7238">      // Separate the first path component in &quot;p&quot;, and keep the</a>
<a name="ln7239">      // remainder (beginning with the path separator).</a>
<a name="ln7240">      remain = xstrdup(q - 1);</a>
<a name="ln7241">      q[-1] = NUL;</a>
<a name="ln7242">    }</a>
<a name="ln7243"> </a>
<a name="ln7244">    char *const buf = xmallocz(MAXPATHL);</a>
<a name="ln7245"> </a>
<a name="ln7246">    char *cpy;</a>
<a name="ln7247">    for (;; ) {</a>
<a name="ln7248">      for (;; ) {</a>
<a name="ln7249">        len = readlink(p, buf, MAXPATHL);</a>
<a name="ln7250">        if (len &lt;= 0) {</a>
<a name="ln7251">          break;</a>
<a name="ln7252">        }</a>
<a name="ln7253">        buf[len] = NUL;</a>
<a name="ln7254"> </a>
<a name="ln7255">        if (limit-- == 0) {</a>
<a name="ln7256">          xfree(p);</a>
<a name="ln7257">          xfree(remain);</a>
<a name="ln7258">          EMSG(_(&quot;E655: Too many symbolic links (cycle?)&quot;));</a>
<a name="ln7259">          rettv-&gt;vval.v_string = NULL;</a>
<a name="ln7260">          xfree(buf);</a>
<a name="ln7261">          return;</a>
<a name="ln7262">        }</a>
<a name="ln7263"> </a>
<a name="ln7264">        // Ensure that the result will have a trailing path separator</a>
<a name="ln7265">        // if the argument has one. */</a>
<a name="ln7266">        if (remain == NULL &amp;&amp; has_trailing_pathsep) {</a>
<a name="ln7267">          add_pathsep(buf);</a>
<a name="ln7268">        }</a>
<a name="ln7269"> </a>
<a name="ln7270">        // Separate the first path component in the link value and</a>
<a name="ln7271">        // concatenate the remainders. */</a>
<a name="ln7272">        q = (char *)path_next_component(vim_ispathsep(*buf) ? buf + 1 : buf);</a>
<a name="ln7273">        if (*q != NUL) {</a>
<a name="ln7274">          cpy = remain;</a>
<a name="ln7275">          remain = (remain</a>
<a name="ln7276">                    ? (char *)concat_str((char_u *)q - 1, (char_u *)remain)</a>
<a name="ln7277">                    : xstrdup(q - 1));</a>
<a name="ln7278">          xfree(cpy);</a>
<a name="ln7279">          q[-1] = NUL;</a>
<a name="ln7280">        }</a>
<a name="ln7281"> </a>
<a name="ln7282">        q = (char *)path_tail((char_u *)p);</a>
<a name="ln7283">        if (q &gt; p &amp;&amp; *q == NUL) {</a>
<a name="ln7284">          // Ignore trailing path separator.</a>
<a name="ln7285">          q[-1] = NUL;</a>
<a name="ln7286">          q = (char *)path_tail((char_u *)p);</a>
<a name="ln7287">        }</a>
<a name="ln7288">        if (q &gt; p &amp;&amp; !path_is_absolute((const char_u *)buf)) {</a>
<a name="ln7289">          // Symlink is relative to directory of argument. Replace the</a>
<a name="ln7290">          // symlink with the resolved name in the same directory.</a>
<a name="ln7291">          const size_t p_len = strlen(p);</a>
<a name="ln7292">          const size_t buf_len = strlen(buf);</a>
<a name="ln7293">          p = xrealloc(p, p_len + buf_len + 1);</a>
<a name="ln7294">          memcpy(path_tail((char_u *)p), buf, buf_len + 1);</a>
<a name="ln7295">        } else {</a>
<a name="ln7296">          xfree(p);</a>
<a name="ln7297">          p = xstrdup(buf);</a>
<a name="ln7298">        }</a>
<a name="ln7299">      }</a>
<a name="ln7300"> </a>
<a name="ln7301">      if (remain == NULL) {</a>
<a name="ln7302">        break;</a>
<a name="ln7303">      }</a>
<a name="ln7304"> </a>
<a name="ln7305">      // Append the first path component of &quot;remain&quot; to &quot;p&quot;.</a>
<a name="ln7306">      q = (char *)path_next_component(remain + 1);</a>
<a name="ln7307">      len = q - remain - (*q != NUL);</a>
<a name="ln7308">      const size_t p_len = strlen(p);</a>
<a name="ln7309">      cpy = xmallocz(p_len + len);</a>
<a name="ln7310">      memcpy(cpy, p, p_len + 1);</a>
<a name="ln7311">      xstrlcat(cpy + p_len, remain, len + 1);</a>
<a name="ln7312">      xfree(p);</a>
<a name="ln7313">      p = cpy;</a>
<a name="ln7314"> </a>
<a name="ln7315">      // Shorten &quot;remain&quot;.</a>
<a name="ln7316">      if (*q != NUL) {</a>
<a name="ln7317">        STRMOVE(remain, q - 1);</a>
<a name="ln7318">      } else {</a>
<a name="ln7319">        XFREE_CLEAR(remain);</a>
<a name="ln7320">      }</a>
<a name="ln7321">    }</a>
<a name="ln7322"> </a>
<a name="ln7323">    // If the result is a relative path name, make it explicitly relative to</a>
<a name="ln7324">    // the current directory if and only if the argument had this form.</a>
<a name="ln7325">    if (!vim_ispathsep(*p)) {</a>
<a name="ln7326">      if (is_relative_to_current</a>
<a name="ln7327">          &amp;&amp; *p != NUL</a>
<a name="ln7328">          &amp;&amp; !(p[0] == '.'</a>
<a name="ln7329">               &amp;&amp; (p[1] == NUL</a>
<a name="ln7330">                   || vim_ispathsep(p[1])</a>
<a name="ln7331">                   || (p[1] == '.'</a>
<a name="ln7332">                       &amp;&amp; (p[2] == NUL</a>
<a name="ln7333">                           || vim_ispathsep(p[2])))))) {</a>
<a name="ln7334">        // Prepend &quot;./&quot;.</a>
<a name="ln7335">        cpy = (char *)concat_str((const char_u *)&quot;./&quot;, (const char_u *)p);</a>
<a name="ln7336">        xfree(p);</a>
<a name="ln7337">        p = cpy;</a>
<a name="ln7338">      } else if (!is_relative_to_current) {</a>
<a name="ln7339">        // Strip leading &quot;./&quot;.</a>
<a name="ln7340">        q = p;</a>
<a name="ln7341">        while (q[0] == '.' &amp;&amp; vim_ispathsep(q[1])) {</a>
<a name="ln7342">          q += 2;</a>
<a name="ln7343">        }</a>
<a name="ln7344">        if (q &gt; p) {</a>
<a name="ln7345">          STRMOVE(p, p + 2);</a>
<a name="ln7346">        }</a>
<a name="ln7347">      }</a>
<a name="ln7348">    }</a>
<a name="ln7349"> </a>
<a name="ln7350">    // Ensure that the result will have no trailing path separator</a>
<a name="ln7351">    // if the argument had none.  But keep &quot;/&quot; or &quot;//&quot;.</a>
<a name="ln7352">    if (!has_trailing_pathsep) {</a>
<a name="ln7353">      q = p + strlen(p);</a>
<a name="ln7354">      if (after_pathsep(p, q)) {</a>
<a name="ln7355">        *path_tail_with_sep((char_u *)p) = NUL;</a>
<a name="ln7356">      }</a>
<a name="ln7357">    }</a>
<a name="ln7358"> </a>
<a name="ln7359">    rettv-&gt;vval.v_string = (char_u *)p;</a>
<a name="ln7360">    xfree(buf);</a>
<a name="ln7361">  }</a>
<a name="ln7362"># else</a>
<a name="ln7363">  char *v = os_realpath(fname, NULL);</a>
<a name="ln7364">  rettv-&gt;vval.v_string = (char_u *)(v == NULL ? xstrdup(fname) : v);</a>
<a name="ln7365"># endif</a>
<a name="ln7366">#endif</a>
<a name="ln7367"> </a>
<a name="ln7368">  simplify_filename(rettv-&gt;vval.v_string);</a>
<a name="ln7369">}</a>
<a name="ln7370"> </a>
<a name="ln7371">/*</a>
<a name="ln7372"> * &quot;reverse({list})&quot; function</a>
<a name="ln7373"> */</a>
<a name="ln7374">static void f_reverse(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln7375">{</a>
<a name="ln7376">  list_T *l;</a>
<a name="ln7377">  if (argvars[0].v_type != VAR_LIST) {</a>
<a name="ln7378">    EMSG2(_(e_listarg), &quot;reverse()&quot;);</a>
<a name="ln7379">  } else if (!var_check_lock(tv_list_locked((l = argvars[0].vval.v_list)),</a>
<a name="ln7380">                             N_(&quot;reverse() argument&quot;), TV_TRANSLATE)) {</a>
<a name="ln7381">    tv_list_reverse(l);</a>
<a name="ln7382">    tv_list_set_ret(rettv, l);</a>
<a name="ln7383">  }</a>
<a name="ln7384">}</a>
<a name="ln7385"> </a>
<a name="ln7386">#define SP_NOMOVE       0x01        ///&lt; don't move cursor</a>
<a name="ln7387">#define SP_REPEAT       0x02        ///&lt; repeat to find outer pair</a>
<a name="ln7388">#define SP_RETCOUNT     0x04        ///&lt; return matchcount</a>
<a name="ln7389">#define SP_SETPCMARK    0x08        ///&lt; set previous context mark</a>
<a name="ln7390">#define SP_START        0x10        ///&lt; accept match at start position</a>
<a name="ln7391">#define SP_SUBPAT       0x20        ///&lt; return nr of matching sub-pattern</a>
<a name="ln7392">#define SP_END          0x40        ///&lt; leave cursor at end of match</a>
<a name="ln7393">#define SP_COLUMN       0x80        ///&lt; start at cursor column</a>
<a name="ln7394"> </a>
<a name="ln7395">/*</a>
<a name="ln7396"> * Get flags for a search function.</a>
<a name="ln7397"> * Possibly sets &quot;p_ws&quot;.</a>
<a name="ln7398"> * Returns BACKWARD, FORWARD or zero (for an error).</a>
<a name="ln7399"> */</a>
<a name="ln7400">static int get_search_arg(typval_T *varp, int *flagsp)</a>
<a name="ln7401">{</a>
<a name="ln7402">  int dir = FORWARD;</a>
<a name="ln7403">  int mask;</a>
<a name="ln7404"> </a>
<a name="ln7405">  if (varp-&gt;v_type != VAR_UNKNOWN) {</a>
<a name="ln7406">    char nbuf[NUMBUFLEN];</a>
<a name="ln7407">    const char *flags = tv_get_string_buf_chk(varp, nbuf);</a>
<a name="ln7408">    if (flags == NULL) {</a>
<a name="ln7409">      return 0;  // Type error; errmsg already given.</a>
<a name="ln7410">    }</a>
<a name="ln7411">    while (*flags != NUL) {</a>
<a name="ln7412">      switch (*flags) {</a>
<a name="ln7413">        case 'b': dir = BACKWARD; break;</a>
<a name="ln7414">        case 'w': p_ws = true; break;</a>
<a name="ln7415">        case 'W': p_ws = false; break;</a>
<a name="ln7416">        default: {</a>
<a name="ln7417">          mask = 0;</a>
<a name="ln7418">          if (flagsp != NULL) {</a>
<a name="ln7419">            switch (*flags) {</a>
<a name="ln7420">              case 'c': mask = SP_START; break;</a>
<a name="ln7421">              case 'e': mask = SP_END; break;</a>
<a name="ln7422">              case 'm': mask = SP_RETCOUNT; break;</a>
<a name="ln7423">              case 'n': mask = SP_NOMOVE; break;</a>
<a name="ln7424">              case 'p': mask = SP_SUBPAT; break;</a>
<a name="ln7425">              case 'r': mask = SP_REPEAT; break;</a>
<a name="ln7426">              case 's': mask = SP_SETPCMARK; break;</a>
<a name="ln7427">              case 'z': mask = SP_COLUMN; break;</a>
<a name="ln7428">            }</a>
<a name="ln7429">          }</a>
<a name="ln7430">          if (mask == 0) {</a>
<a name="ln7431">            emsgf(_(e_invarg2), flags);</a>
<a name="ln7432">            dir = 0;</a>
<a name="ln7433">          } else {</a>
<a name="ln7434">            *flagsp |= mask;</a>
<a name="ln7435">          }</a>
<a name="ln7436">        }</a>
<a name="ln7437">      }</a>
<a name="ln7438">      if (dir == 0) {</a>
<a name="ln7439">        break;</a>
<a name="ln7440">      }</a>
<a name="ln7441">      flags++;</a>
<a name="ln7442">    }</a>
<a name="ln7443">  }</a>
<a name="ln7444">  return dir;</a>
<a name="ln7445">}</a>
<a name="ln7446"> </a>
<a name="ln7447">// Shared by search() and searchpos() functions.</a>
<a name="ln7448">static int search_cmn(typval_T *argvars, pos_T *match_pos, int *flagsp)</a>
<a name="ln7449">{</a>
<a name="ln7450">  int flags;</a>
<a name="ln7451">  pos_T pos;</a>
<a name="ln7452">  pos_T save_cursor;</a>
<a name="ln7453">  bool save_p_ws = p_ws;</a>
<a name="ln7454">  int dir;</a>
<a name="ln7455">  int retval = 0;               // default: FAIL</a>
<a name="ln7456">  long lnum_stop = 0;</a>
<a name="ln7457">  proftime_T tm;</a>
<a name="ln7458">  long time_limit = 0;</a>
<a name="ln7459">  int options = SEARCH_KEEP;</a>
<a name="ln7460">  int subpatnum;</a>
<a name="ln7461">  searchit_arg_T sia;</a>
<a name="ln7462"> </a>
<a name="ln7463">  const char *const pat = tv_get_string(&amp;argvars[0]);</a>
<a name="ln7464">  dir = get_search_arg(&amp;argvars[1], flagsp);  // May set p_ws.</a>
<a name="ln7465">  if (dir == 0) {</a>
<a name="ln7466">    goto theend;</a>
<a name="ln7467">  }</a>
<a name="ln7468">  flags = *flagsp;</a>
<a name="ln7469">  if (flags &amp; SP_START) {</a>
<a name="ln7470">    options |= SEARCH_START;</a>
<a name="ln7471">  }</a>
<a name="ln7472">  if (flags &amp; SP_END) {</a>
<a name="ln7473">    options |= SEARCH_END;</a>
<a name="ln7474">  }</a>
<a name="ln7475">  if (flags &amp; SP_COLUMN) {</a>
<a name="ln7476">    options |= SEARCH_COL;</a>
<a name="ln7477">  }</a>
<a name="ln7478"> </a>
<a name="ln7479">  // Optional arguments: line number to stop searching and timeout.</a>
<a name="ln7480">  if (argvars[1].v_type != VAR_UNKNOWN &amp;&amp; argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln7481">    lnum_stop = tv_get_number_chk(&amp;argvars[2], NULL);</a>
<a name="ln7482">    if (lnum_stop &lt; 0) {</a>
<a name="ln7483">      goto theend;</a>
<a name="ln7484">    }</a>
<a name="ln7485">    if (argvars[3].v_type != VAR_UNKNOWN) {</a>
<a name="ln7486">      time_limit = tv_get_number_chk(&amp;argvars[3], NULL);</a>
<a name="ln7487">      if (time_limit &lt; 0) {</a>
<a name="ln7488">        goto theend;</a>
<a name="ln7489">      }</a>
<a name="ln7490">    }</a>
<a name="ln7491">  }</a>
<a name="ln7492"> </a>
<a name="ln7493">  // Set the time limit, if there is one.</a>
<a name="ln7494">  tm = profile_setlimit(time_limit);</a>
<a name="ln7495"> </a>
<a name="ln7496">  /*</a>
<a name="ln7497">   * This function does not accept SP_REPEAT and SP_RETCOUNT flags.</a>
<a name="ln7498">   * Check to make sure only those flags are set.</a>
<a name="ln7499">   * Also, Only the SP_NOMOVE or the SP_SETPCMARK flag can be set. Both</a>
<a name="ln7500">   * flags cannot be set. Check for that condition also.</a>
<a name="ln7501">   */</a>
<a name="ln7502">  if (((flags &amp; (SP_REPEAT | SP_RETCOUNT)) != 0)</a>
<a name="ln7503">      || ((flags &amp; SP_NOMOVE) &amp;&amp; (flags &amp; SP_SETPCMARK))) {</a>
<a name="ln7504">    EMSG2(_(e_invarg2), tv_get_string(&amp;argvars[1]));</a>
<a name="ln7505">    goto theend;</a>
<a name="ln7506">  }</a>
<a name="ln7507"> </a>
<a name="ln7508">  pos = save_cursor = curwin-&gt;w_cursor;</a>
<a name="ln7509">  memset(&amp;sia, 0, sizeof(sia));</a>
<a name="ln7510">  sia.sa_stop_lnum = (linenr_T)lnum_stop;</a>
<a name="ln7511">  sia.sa_tm = &amp;tm;</a>
<a name="ln7512">  subpatnum = searchit(curwin, curbuf, &amp;pos, NULL, dir, (char_u *)pat, 1,</a>
<a name="ln7513">                       options, RE_SEARCH, &amp;sia);</a>
<a name="ln7514">  if (subpatnum != FAIL) {</a>
<a name="ln7515">    if (flags &amp; SP_SUBPAT)</a>
<a name="ln7516">      retval = subpatnum;</a>
<a name="ln7517">    else</a>
<a name="ln7518">      retval = pos.lnum;</a>
<a name="ln7519">    if (flags &amp; SP_SETPCMARK)</a>
<a name="ln7520">      setpcmark();</a>
<a name="ln7521">    curwin-&gt;w_cursor = pos;</a>
<a name="ln7522">    if (match_pos != NULL) {</a>
<a name="ln7523">      // Store the match cursor position</a>
<a name="ln7524">      match_pos-&gt;lnum = pos.lnum;</a>
<a name="ln7525">      match_pos-&gt;col = pos.col + 1;</a>
<a name="ln7526">    }</a>
<a name="ln7527">    // &quot;/$&quot; will put the cursor after the end of the line, may need to</a>
<a name="ln7528">    // correct that here</a>
<a name="ln7529">    check_cursor();</a>
<a name="ln7530">  }</a>
<a name="ln7531"> </a>
<a name="ln7532">  // If 'n' flag is used: restore cursor position.</a>
<a name="ln7533">  if (flags &amp; SP_NOMOVE) {</a>
<a name="ln7534">    curwin-&gt;w_cursor = save_cursor;</a>
<a name="ln7535">  } else {</a>
<a name="ln7536">    curwin-&gt;w_set_curswant = true;</a>
<a name="ln7537">  }</a>
<a name="ln7538">theend:</a>
<a name="ln7539">  p_ws = save_p_ws;</a>
<a name="ln7540"> </a>
<a name="ln7541">  return retval;</a>
<a name="ln7542">}</a>
<a name="ln7543"> </a>
<a name="ln7544">// &quot;rpcnotify()&quot; function</a>
<a name="ln7545">static void f_rpcnotify(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln7546">{</a>
<a name="ln7547">  rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln7548">  rettv-&gt;vval.v_number = 0;</a>
<a name="ln7549"> </a>
<a name="ln7550">  if (check_secure()) {</a>
<a name="ln7551">    return;</a>
<a name="ln7552">  }</a>
<a name="ln7553"> </a>
<a name="ln7554">  if (argvars[0].v_type != VAR_NUMBER || argvars[0].vval.v_number &lt; 0) {</a>
<a name="ln7555">    EMSG2(_(e_invarg2), &quot;Channel id must be a positive integer&quot;);</a>
<a name="ln7556">    return;</a>
<a name="ln7557">  }</a>
<a name="ln7558"> </a>
<a name="ln7559">  if (argvars[1].v_type != VAR_STRING) {</a>
<a name="ln7560">    EMSG2(_(e_invarg2), &quot;Event type must be a string&quot;);</a>
<a name="ln7561">    return;</a>
<a name="ln7562">  }</a>
<a name="ln7563"> </a>
<a name="ln7564">  Array args = ARRAY_DICT_INIT;</a>
<a name="ln7565"> </a>
<a name="ln7566">  for (typval_T *tv = argvars + 2; tv-&gt;v_type != VAR_UNKNOWN; tv++) {</a>
<a name="ln7567">    ADD(args, vim_to_object(tv));</a>
<a name="ln7568">  }</a>
<a name="ln7569"> </a>
<a name="ln7570">  if (!rpc_send_event((uint64_t)argvars[0].vval.v_number,</a>
<a name="ln7571">                      tv_get_string(&amp;argvars[1]), args)) {</a>
<a name="ln7572">    EMSG2(_(e_invarg2), &quot;Channel doesn't exist&quot;);</a>
<a name="ln7573">    return;</a>
<a name="ln7574">  }</a>
<a name="ln7575"> </a>
<a name="ln7576">  rettv-&gt;vval.v_number = 1;</a>
<a name="ln7577">}</a>
<a name="ln7578"> </a>
<a name="ln7579">// &quot;rpcrequest()&quot; function</a>
<a name="ln7580">static void f_rpcrequest(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln7581">{</a>
<a name="ln7582">  rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln7583">  rettv-&gt;vval.v_number = 0;</a>
<a name="ln7584">  const int l_provider_call_nesting = provider_call_nesting;</a>
<a name="ln7585"> </a>
<a name="ln7586">  if (check_secure()) {</a>
<a name="ln7587">    return;</a>
<a name="ln7588">  }</a>
<a name="ln7589"> </a>
<a name="ln7590">  if (argvars[0].v_type != VAR_NUMBER || argvars[0].vval.v_number &lt;= 0) {</a>
<a name="ln7591">    EMSG2(_(e_invarg2), &quot;Channel id must be a positive integer&quot;);</a>
<a name="ln7592">    return;</a>
<a name="ln7593">  }</a>
<a name="ln7594"> </a>
<a name="ln7595">  if (argvars[1].v_type != VAR_STRING) {</a>
<a name="ln7596">    EMSG2(_(e_invarg2), &quot;Method name must be a string&quot;);</a>
<a name="ln7597">    return;</a>
<a name="ln7598">  }</a>
<a name="ln7599"> </a>
<a name="ln7600">  Array args = ARRAY_DICT_INIT;</a>
<a name="ln7601"> </a>
<a name="ln7602">  for (typval_T *tv = argvars + 2; tv-&gt;v_type != VAR_UNKNOWN; tv++) {</a>
<a name="ln7603">    ADD(args, vim_to_object(tv));</a>
<a name="ln7604">  }</a>
<a name="ln7605"> </a>
<a name="ln7606">  sctx_T save_current_sctx;</a>
<a name="ln7607">  uint8_t *save_sourcing_name, *save_autocmd_fname, *save_autocmd_match;</a>
<a name="ln7608">  linenr_T save_sourcing_lnum;</a>
<a name="ln7609">  int save_autocmd_bufnr;</a>
<a name="ln7610">  funccal_entry_T funccal_entry;</a>
<a name="ln7611"> </a>
<a name="ln7612">  if (l_provider_call_nesting) {</a>
<a name="ln7613">    // If this is called from a provider function, restore the scope</a>
<a name="ln7614">    // information of the caller.</a>
<a name="ln7615">    save_current_sctx = current_sctx;</a>
<a name="ln7616">    save_sourcing_name = sourcing_name;</a>
<a name="ln7617">    save_sourcing_lnum = sourcing_lnum;</a>
<a name="ln7618">    save_autocmd_fname = autocmd_fname;</a>
<a name="ln7619">    save_autocmd_match = autocmd_match;</a>
<a name="ln7620">    save_autocmd_bufnr = autocmd_bufnr;</a>
<a name="ln7621">    save_funccal(&amp;funccal_entry);</a>
<a name="ln7622"> </a>
<a name="ln7623">    current_sctx = provider_caller_scope.script_ctx;</a>
<a name="ln7624">    sourcing_name = provider_caller_scope.sourcing_name;</a>
<a name="ln7625">    sourcing_lnum = provider_caller_scope.sourcing_lnum;</a>
<a name="ln7626">    autocmd_fname = provider_caller_scope.autocmd_fname;</a>
<a name="ln7627">    autocmd_match = provider_caller_scope.autocmd_match;</a>
<a name="ln7628">    autocmd_bufnr = provider_caller_scope.autocmd_bufnr;</a>
<a name="ln7629">    set_current_funccal((funccall_T *)(provider_caller_scope.funccalp));</a>
<a name="ln7630">  }</a>
<a name="ln7631"> </a>
<a name="ln7632"> </a>
<a name="ln7633">  Error err = ERROR_INIT;</a>
<a name="ln7634"> </a>
<a name="ln7635">  uint64_t chan_id = (uint64_t)argvars[0].vval.v_number;</a>
<a name="ln7636">  const char *method = tv_get_string(&amp;argvars[1]);</a>
<a name="ln7637"> </a>
<a name="ln7638">  Object result = rpc_send_call(chan_id, method, args, &amp;err);</a>
<a name="ln7639"> </a>
<a name="ln7640">  if (l_provider_call_nesting) {</a>
<a name="ln7641">    current_sctx = save_current_sctx;</a>
<a name="ln7642">    sourcing_name = save_sourcing_name;</a>
<a name="ln7643">    sourcing_lnum = save_sourcing_lnum;</a>
<a name="ln7644">    autocmd_fname = save_autocmd_fname;</a>
<a name="ln7645">    autocmd_match = save_autocmd_match;</a>
<a name="ln7646">    autocmd_bufnr = save_autocmd_bufnr;</a>
<a name="ln7647">    restore_funccal();</a>
<a name="ln7648">  }</a>
<a name="ln7649"> </a>
<a name="ln7650">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln7651">    const char *name = NULL;</a>
<a name="ln7652">    Channel *chan = find_channel(chan_id);</a>
<a name="ln7653">    if (chan) {</a>
<a name="ln7654">      name = rpc_client_name(chan);</a>
<a name="ln7655">    }</a>
<a name="ln7656">    msg_ext_set_kind(&quot;rpc_error&quot;);</a>
<a name="ln7657">    if (name) {</a>
<a name="ln7658">      emsgf_multiline(&quot;Error invoking '%s' on channel %&quot;PRIu64&quot; (%s):\n%s&quot;,</a>
<a name="ln7659">                      method, chan_id, name, err.msg);</a>
<a name="ln7660">    } else {</a>
<a name="ln7661">      emsgf_multiline(&quot;Error invoking '%s' on channel %&quot;PRIu64&quot;:\n%s&quot;,</a>
<a name="ln7662">                      method, chan_id, err.msg);</a>
<a name="ln7663">    }</a>
<a name="ln7664"> </a>
<a name="ln7665">    goto end;</a>
<a name="ln7666">  }</a>
<a name="ln7667"> </a>
<a name="ln7668">  if (!object_to_vim(result, rettv, &amp;err)) {</a>
<a name="ln7669">    EMSG2(_(&quot;Error converting the call result: %s&quot;), err.msg);</a>
<a name="ln7670">  }</a>
<a name="ln7671"> </a>
<a name="ln7672">end:</a>
<a name="ln7673">  api_free_object(result);</a>
<a name="ln7674">  api_clear_error(&amp;err);</a>
<a name="ln7675">}</a>
<a name="ln7676"> </a>
<a name="ln7677">// &quot;rpcstart()&quot; function (DEPRECATED)</a>
<a name="ln7678">static void f_rpcstart(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln7679">{</a>
<a name="ln7680">  rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln7681">  rettv-&gt;vval.v_number = 0;</a>
<a name="ln7682"> </a>
<a name="ln7683">  if (check_secure()) {</a>
<a name="ln7684">    return;</a>
<a name="ln7685">  }</a>
<a name="ln7686"> </a>
<a name="ln7687">  if (argvars[0].v_type != VAR_STRING</a>
<a name="ln7688">      || (argvars[1].v_type != VAR_LIST &amp;&amp; argvars[1].v_type != VAR_UNKNOWN)) {</a>
<a name="ln7689">    // Wrong argument types</a>
<a name="ln7690">    EMSG(_(e_invarg));</a>
<a name="ln7691">    return;</a>
<a name="ln7692">  }</a>
<a name="ln7693"> </a>
<a name="ln7694">  list_T *args = NULL;</a>
<a name="ln7695">  int argsl = 0;</a>
<a name="ln7696">  if (argvars[1].v_type == VAR_LIST) {</a>
<a name="ln7697">    args = argvars[1].vval.v_list;</a>
<a name="ln7698">    argsl = tv_list_len(args);</a>
<a name="ln7699">    // Assert that all list items are strings</a>
<a name="ln7700">    int i = 0;</a>
<a name="ln7701">    TV_LIST_ITER_CONST(args, arg, {</a>
<a name="ln7702">      if (TV_LIST_ITEM_TV(arg)-&gt;v_type != VAR_STRING) {</a>
<a name="ln7703">        emsgf(_(&quot;E5010: List item %d of the second argument is not a string&quot;),</a>
<a name="ln7704">              i);</a>
<a name="ln7705">        return;</a>
<a name="ln7706">      }</a>
<a name="ln7707">      i++;</a>
<a name="ln7708">    });</a>
<a name="ln7709">  }</a>
<a name="ln7710"> </a>
<a name="ln7711">  if (argvars[0].vval.v_string == NULL || argvars[0].vval.v_string[0] == NUL) {</a>
<a name="ln7712">    EMSG(_(e_api_spawn_failed));</a>
<a name="ln7713">    return;</a>
<a name="ln7714">  }</a>
<a name="ln7715"> </a>
<a name="ln7716">  // Allocate extra memory for the argument vector and the NULL pointer</a>
<a name="ln7717">  int argvl = argsl + 2;</a>
<a name="ln7718">  char **argv = xmalloc(sizeof(char_u *) * argvl);</a>
<a name="ln7719"> </a>
<a name="ln7720">  // Copy program name</a>
<a name="ln7721">  argv[0] = xstrdup((char *)argvars[0].vval.v_string);</a>
<a name="ln7722"> </a>
<a name="ln7723">  int i = 1;</a>
<a name="ln7724">  // Copy arguments to the vector</a>
<a name="ln7725">  if (argsl &gt; 0) {</a>
<a name="ln7726">    TV_LIST_ITER_CONST(args, arg, {</a>
<a name="ln7727">      argv[i++] = xstrdup(tv_get_string(TV_LIST_ITEM_TV(arg)));</a>
<a name="ln7728">    });</a>
<a name="ln7729">  }</a>
<a name="ln7730"> </a>
<a name="ln7731">  // The last item of argv must be NULL</a>
<a name="ln7732">  argv[i] = NULL;</a>
<a name="ln7733"> </a>
<a name="ln7734">  Channel *chan = channel_job_start(argv, CALLBACK_READER_INIT,</a>
<a name="ln7735">                                    CALLBACK_READER_INIT, CALLBACK_NONE,</a>
<a name="ln7736">                                    false, true, false, false, NULL, 0, 0,</a>
<a name="ln7737">                                    NULL, &amp;rettv-&gt;vval.v_number);</a>
<a name="ln7738">  if (chan) {</a>
<a name="ln7739">    channel_create_event(chan, NULL);</a>
<a name="ln7740">  }</a>
<a name="ln7741">}</a>
<a name="ln7742"> </a>
<a name="ln7743">// &quot;rpcstop()&quot; function</a>
<a name="ln7744">static void f_rpcstop(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln7745">{</a>
<a name="ln7746">  rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln7747">  rettv-&gt;vval.v_number = 0;</a>
<a name="ln7748"> </a>
<a name="ln7749">  if (check_secure()) {</a>
<a name="ln7750">    return;</a>
<a name="ln7751">  }</a>
<a name="ln7752"> </a>
<a name="ln7753">  if (argvars[0].v_type != VAR_NUMBER) {</a>
<a name="ln7754">    // Wrong argument types</a>
<a name="ln7755">    EMSG(_(e_invarg));</a>
<a name="ln7756">    return;</a>
<a name="ln7757">  }</a>
<a name="ln7758"> </a>
<a name="ln7759">  // if called with a job, stop it, else closes the channel</a>
<a name="ln7760">  uint64_t id = argvars[0].vval.v_number;</a>
<a name="ln7761">  if (find_job(id, false)) {</a>
<a name="ln7762">    f_jobstop(argvars, rettv, NULL);</a>
<a name="ln7763">  } else {</a>
<a name="ln7764">    const char *error;</a>
<a name="ln7765">    rettv-&gt;vval.v_number = channel_close(argvars[0].vval.v_number,</a>
<a name="ln7766">                                         kChannelPartRpc, &amp;error);</a>
<a name="ln7767">    if (!rettv-&gt;vval.v_number) {</a>
<a name="ln7768">      EMSG(error);</a>
<a name="ln7769">    }</a>
<a name="ln7770">  }</a>
<a name="ln7771">}</a>
<a name="ln7772"> </a>
<a name="ln7773">/*</a>
<a name="ln7774"> * &quot;screenattr()&quot; function</a>
<a name="ln7775"> */</a>
<a name="ln7776">static void f_screenattr(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln7777">{</a>
<a name="ln7778">  int c;</a>
<a name="ln7779"> </a>
<a name="ln7780">  int row = (int)tv_get_number_chk(&amp;argvars[0], NULL) - 1;</a>
<a name="ln7781">  int col = (int)tv_get_number_chk(&amp;argvars[1], NULL) - 1;</a>
<a name="ln7782">  if (row &lt; 0 || row &gt;= default_grid.Rows</a>
<a name="ln7783">      || col &lt; 0 || col &gt;= default_grid.Columns) {</a>
<a name="ln7784">    c = -1;</a>
<a name="ln7785">  } else {</a>
<a name="ln7786">    ScreenGrid *grid = &amp;default_grid;</a>
<a name="ln7787">    screenchar_adjust_grid(&amp;grid, &amp;row, &amp;col);</a>
<a name="ln7788">    c = grid-&gt;attrs[grid-&gt;line_offset[row] + col];</a>
<a name="ln7789">  }</a>
<a name="ln7790">  rettv-&gt;vval.v_number = c;</a>
<a name="ln7791">}</a>
<a name="ln7792"> </a>
<a name="ln7793">/*</a>
<a name="ln7794"> * &quot;screenchar()&quot; function</a>
<a name="ln7795"> */</a>
<a name="ln7796">static void f_screenchar(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln7797">{</a>
<a name="ln7798">  int c;</a>
<a name="ln7799"> </a>
<a name="ln7800">  int row = tv_get_number_chk(&amp;argvars[0], NULL) - 1;</a>
<a name="ln7801">  int col = tv_get_number_chk(&amp;argvars[1], NULL) - 1;</a>
<a name="ln7802">  if (row &lt; 0 || row &gt;= default_grid.Rows</a>
<a name="ln7803">      || col &lt; 0 || col &gt;= default_grid.Columns) {</a>
<a name="ln7804">    c = -1;</a>
<a name="ln7805">  } else {</a>
<a name="ln7806">    ScreenGrid *grid = &amp;default_grid;</a>
<a name="ln7807">    screenchar_adjust_grid(&amp;grid, &amp;row, &amp;col);</a>
<a name="ln7808">    c = utf_ptr2char(grid-&gt;chars[grid-&gt;line_offset[row] + col]);</a>
<a name="ln7809">  }</a>
<a name="ln7810">  rettv-&gt;vval.v_number = c;</a>
<a name="ln7811">}</a>
<a name="ln7812"> </a>
<a name="ln7813">/*</a>
<a name="ln7814"> * &quot;screencol()&quot; function</a>
<a name="ln7815"> *</a>
<a name="ln7816"> * First column is 1 to be consistent with virtcol().</a>
<a name="ln7817"> */</a>
<a name="ln7818">static void f_screencol(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln7819">{</a>
<a name="ln7820">  rettv-&gt;vval.v_number = ui_current_col() + 1;</a>
<a name="ln7821">}</a>
<a name="ln7822"> </a>
<a name="ln7823">/// &quot;screenpos({winid}, {lnum}, {col})&quot; function</a>
<a name="ln7824">static void f_screenpos(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln7825">{</a>
<a name="ln7826">  pos_T pos;</a>
<a name="ln7827">  int row = 0;</a>
<a name="ln7828">  int scol = 0, ccol = 0, ecol = 0;</a>
<a name="ln7829"> </a>
<a name="ln7830">  tv_dict_alloc_ret(rettv);</a>
<a name="ln7831">  dict_T *dict = rettv-&gt;vval.v_dict;</a>
<a name="ln7832"> </a>
<a name="ln7833">  win_T *wp = find_win_by_nr_or_id(&amp;argvars[0]);</a>
<a name="ln7834">  if (wp == NULL) {</a>
<a name="ln7835">    return;</a>
<a name="ln7836">  }</a>
<a name="ln7837"> </a>
<a name="ln7838">  pos.lnum = tv_get_number(&amp;argvars[1]);</a>
<a name="ln7839">  pos.col = tv_get_number(&amp;argvars[2]) - 1;</a>
<a name="ln7840">  pos.coladd = 0;</a>
<a name="ln7841">  textpos2screenpos(wp, &amp;pos, &amp;row, &amp;scol, &amp;ccol, &amp;ecol, false);</a>
<a name="ln7842"> </a>
<a name="ln7843">  tv_dict_add_nr(dict, S_LEN(&quot;row&quot;), row);</a>
<a name="ln7844">  tv_dict_add_nr(dict, S_LEN(&quot;col&quot;), scol);</a>
<a name="ln7845">  tv_dict_add_nr(dict, S_LEN(&quot;curscol&quot;), ccol);</a>
<a name="ln7846">  tv_dict_add_nr(dict, S_LEN(&quot;endcol&quot;), ecol);</a>
<a name="ln7847">}</a>
<a name="ln7848"> </a>
<a name="ln7849">/*</a>
<a name="ln7850"> * &quot;screenrow()&quot; function</a>
<a name="ln7851"> */</a>
<a name="ln7852">static void f_screenrow(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln7853">{</a>
<a name="ln7854">  rettv-&gt;vval.v_number = ui_current_row() + 1;</a>
<a name="ln7855">}</a>
<a name="ln7856"> </a>
<a name="ln7857">/*</a>
<a name="ln7858"> * &quot;search()&quot; function</a>
<a name="ln7859"> */</a>
<a name="ln7860">static void f_search(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln7861">{</a>
<a name="ln7862">  int flags = 0;</a>
<a name="ln7863"> </a>
<a name="ln7864">  rettv-&gt;vval.v_number = search_cmn(argvars, NULL, &amp;flags);</a>
<a name="ln7865">}</a>
<a name="ln7866"> </a>
<a name="ln7867">/*</a>
<a name="ln7868"> * &quot;searchdecl()&quot; function</a>
<a name="ln7869"> */</a>
<a name="ln7870">static void f_searchdecl(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln7871">{</a>
<a name="ln7872">  int locally = 1;</a>
<a name="ln7873">  int thisblock = 0;</a>
<a name="ln7874">  bool error = false;</a>
<a name="ln7875"> </a>
<a name="ln7876">  rettv-&gt;vval.v_number = 1;     // default: FAIL</a>
<a name="ln7877"> </a>
<a name="ln7878">  const char *const name = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln7879">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln7880">    locally = tv_get_number_chk(&amp;argvars[1], &amp;error) == 0;</a>
<a name="ln7881">    if (!error &amp;&amp; argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln7882">      thisblock = tv_get_number_chk(&amp;argvars[2], &amp;error) != 0;</a>
<a name="ln7883">    }</a>
<a name="ln7884">  }</a>
<a name="ln7885">  if (!error &amp;&amp; name != NULL) {</a>
<a name="ln7886">    rettv-&gt;vval.v_number = find_decl((char_u *)name, strlen(name), locally,</a>
<a name="ln7887">                                     thisblock, SEARCH_KEEP) == FAIL;</a>
<a name="ln7888">  }</a>
<a name="ln7889">}</a>
<a name="ln7890"> </a>
<a name="ln7891">/*</a>
<a name="ln7892"> * Used by searchpair() and searchpairpos()</a>
<a name="ln7893"> */</a>
<a name="ln7894">static int searchpair_cmn(typval_T *argvars, pos_T *match_pos)</a>
<a name="ln7895">{</a>
<a name="ln7896">  bool save_p_ws = p_ws;</a>
<a name="ln7897">  int dir;</a>
<a name="ln7898">  int flags = 0;</a>
<a name="ln7899">  int retval = 0;  // default: FAIL</a>
<a name="ln7900">  long lnum_stop = 0;</a>
<a name="ln7901">  long time_limit = 0;</a>
<a name="ln7902"> </a>
<a name="ln7903">  // Get the three pattern arguments: start, middle, end. Will result in an</a>
<a name="ln7904">  // error if not a valid argument.</a>
<a name="ln7905">  char nbuf1[NUMBUFLEN];</a>
<a name="ln7906">  char nbuf2[NUMBUFLEN];</a>
<a name="ln7907">  const char *spat = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln7908">  const char *mpat = tv_get_string_buf_chk(&amp;argvars[1], nbuf1);</a>
<a name="ln7909">  const char *epat = tv_get_string_buf_chk(&amp;argvars[2], nbuf2);</a>
<a name="ln7910">  if (spat == NULL || mpat == NULL || epat == NULL) {</a>
<a name="ln7911">    goto theend;  // Type error.</a>
<a name="ln7912">  }</a>
<a name="ln7913"> </a>
<a name="ln7914">  // Handle the optional fourth argument: flags.</a>
<a name="ln7915">  dir = get_search_arg(&amp;argvars[3], &amp;flags);   // may set p_ws.</a>
<a name="ln7916">  if (dir == 0) {</a>
<a name="ln7917">    goto theend;</a>
<a name="ln7918">  }</a>
<a name="ln7919"> </a>
<a name="ln7920">  // Don't accept SP_END or SP_SUBPAT.</a>
<a name="ln7921">  // Only one of the SP_NOMOVE or SP_SETPCMARK flags can be set.</a>
<a name="ln7922">  if ((flags &amp; (SP_END | SP_SUBPAT)) != 0</a>
<a name="ln7923">      || ((flags &amp; SP_NOMOVE) &amp;&amp; (flags &amp; SP_SETPCMARK))) {</a>
<a name="ln7924">    EMSG2(_(e_invarg2), tv_get_string(&amp;argvars[3]));</a>
<a name="ln7925">    goto theend;</a>
<a name="ln7926">  }</a>
<a name="ln7927"> </a>
<a name="ln7928">  // Using 'r' implies 'W', otherwise it doesn't work.</a>
<a name="ln7929">  if (flags &amp; SP_REPEAT) {</a>
<a name="ln7930">    p_ws = false;</a>
<a name="ln7931">  }</a>
<a name="ln7932"> </a>
<a name="ln7933">  // Optional fifth argument: skip expression.</a>
<a name="ln7934">  const typval_T *skip;</a>
<a name="ln7935">  if (argvars[3].v_type == VAR_UNKNOWN</a>
<a name="ln7936">      || argvars[4].v_type == VAR_UNKNOWN) {</a>
<a name="ln7937">    skip = NULL;</a>
<a name="ln7938">  } else {</a>
<a name="ln7939">    skip = &amp;argvars[4];</a>
<a name="ln7940">    if (skip-&gt;v_type != VAR_FUNC</a>
<a name="ln7941">        &amp;&amp; skip-&gt;v_type != VAR_PARTIAL</a>
<a name="ln7942">        &amp;&amp; skip-&gt;v_type != VAR_STRING) {</a>
<a name="ln7943">      emsgf(_(e_invarg2), tv_get_string(&amp;argvars[4]));</a>
<a name="ln7944">      goto theend;  // Type error.</a>
<a name="ln7945">    }</a>
<a name="ln7946">    if (argvars[5].v_type != VAR_UNKNOWN) {</a>
<a name="ln7947">      lnum_stop = tv_get_number_chk(&amp;argvars[5], NULL);</a>
<a name="ln7948">      if (lnum_stop &lt; 0) {</a>
<a name="ln7949">        emsgf(_(e_invarg2), tv_get_string(&amp;argvars[5]));</a>
<a name="ln7950">        goto theend;</a>
<a name="ln7951">      }</a>
<a name="ln7952">      if (argvars[6].v_type != VAR_UNKNOWN) {</a>
<a name="ln7953">        time_limit = tv_get_number_chk(&amp;argvars[6], NULL);</a>
<a name="ln7954">        if (time_limit &lt; 0) {</a>
<a name="ln7955">          emsgf(_(e_invarg2), tv_get_string(&amp;argvars[6]));</a>
<a name="ln7956">          goto theend;</a>
<a name="ln7957">        }</a>
<a name="ln7958">      }</a>
<a name="ln7959">    }</a>
<a name="ln7960">  }</a>
<a name="ln7961"> </a>
<a name="ln7962">  retval = do_searchpair(</a>
<a name="ln7963">      spat, mpat, epat, dir, skip,</a>
<a name="ln7964">      flags, match_pos, lnum_stop, time_limit);</a>
<a name="ln7965"> </a>
<a name="ln7966">theend:</a>
<a name="ln7967">  p_ws = save_p_ws;</a>
<a name="ln7968"> </a>
<a name="ln7969">  return retval;</a>
<a name="ln7970">}</a>
<a name="ln7971"> </a>
<a name="ln7972">/*</a>
<a name="ln7973"> * &quot;searchpair()&quot; function</a>
<a name="ln7974"> */</a>
<a name="ln7975">static void f_searchpair(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln7976">{</a>
<a name="ln7977">  rettv-&gt;vval.v_number = searchpair_cmn(argvars, NULL);</a>
<a name="ln7978">}</a>
<a name="ln7979"> </a>
<a name="ln7980">/*</a>
<a name="ln7981"> * &quot;searchpairpos()&quot; function</a>
<a name="ln7982"> */</a>
<a name="ln7983">static void f_searchpairpos(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln7984">{</a>
<a name="ln7985">  pos_T match_pos;</a>
<a name="ln7986">  int lnum = 0;</a>
<a name="ln7987">  int col = 0;</a>
<a name="ln7988"> </a>
<a name="ln7989">  tv_list_alloc_ret(rettv, 2);</a>
<a name="ln7990"> </a>
<a name="ln7991">  if (searchpair_cmn(argvars, &amp;match_pos) &gt; 0) {</a>
<a name="ln7992">    lnum = match_pos.lnum;</a>
<a name="ln7993">    col = match_pos.col;</a>
<a name="ln7994">  }</a>
<a name="ln7995"> </a>
<a name="ln7996">  tv_list_append_number(rettv-&gt;vval.v_list, (varnumber_T)lnum);</a>
<a name="ln7997">  tv_list_append_number(rettv-&gt;vval.v_list, (varnumber_T)col);</a>
<a name="ln7998">}</a>
<a name="ln7999"> </a>
<a name="ln8000">/*</a>
<a name="ln8001"> * Search for a start/middle/end thing.</a>
<a name="ln8002"> * Used by searchpair(), see its documentation for the details.</a>
<a name="ln8003"> * Returns 0 or -1 for no match,</a>
<a name="ln8004"> */</a>
<a name="ln8005">long</a>
<a name="ln8006">do_searchpair(</a>
<a name="ln8007">    const char *spat,      // start pattern</a>
<a name="ln8008">    const char *mpat,      // middle pattern</a>
<a name="ln8009">    const char *epat,      // end pattern</a>
<a name="ln8010">    int dir,               // BACKWARD or FORWARD</a>
<a name="ln8011">    const typval_T *skip,  // skip expression</a>
<a name="ln8012">    int flags,             // SP_SETPCMARK and other SP_ values</a>
<a name="ln8013">    pos_T *match_pos,</a>
<a name="ln8014">    linenr_T lnum_stop,    // stop at this line if not zero</a>
<a name="ln8015">    long time_limit        // stop after this many msec</a>
<a name="ln8016">)</a>
<a name="ln8017">  FUNC_ATTR_NONNULL_ARG(1, 2, 3)</a>
<a name="ln8018">{</a>
<a name="ln8019">  char_u      *save_cpo;</a>
<a name="ln8020">  char_u      *pat, *pat2 = NULL, *pat3 = NULL;</a>
<a name="ln8021">  long retval = 0;</a>
<a name="ln8022">  pos_T pos;</a>
<a name="ln8023">  pos_T firstpos;</a>
<a name="ln8024">  pos_T foundpos;</a>
<a name="ln8025">  pos_T save_cursor;</a>
<a name="ln8026">  pos_T save_pos;</a>
<a name="ln8027">  int n;</a>
<a name="ln8028">  int nest = 1;</a>
<a name="ln8029">  bool use_skip = false;</a>
<a name="ln8030">  int options = SEARCH_KEEP;</a>
<a name="ln8031">  proftime_T tm;</a>
<a name="ln8032"> </a>
<a name="ln8033">  // Make 'cpoptions' empty, the 'l' flag should not be used here.</a>
<a name="ln8034">  save_cpo = p_cpo;</a>
<a name="ln8035">  p_cpo = empty_option;</a>
<a name="ln8036"> </a>
<a name="ln8037">  // Set the time limit, if there is one.</a>
<a name="ln8038">  tm = profile_setlimit(time_limit);</a>
<a name="ln8039"> </a>
<a name="ln8040">  // Make two search patterns: start/end (pat2, for in nested pairs) and</a>
<a name="ln8041">  // start/middle/end (pat3, for the top pair).</a>
<a name="ln8042">  const size_t pat2_len = strlen(spat) + strlen(epat) + 17;</a>
<a name="ln8043">  pat2 = xmalloc(pat2_len);</a>
<a name="ln8044">  const size_t pat3_len = strlen(spat) + strlen(mpat) + strlen(epat) + 25;</a>
<a name="ln8045">  pat3 = xmalloc(pat3_len);</a>
<a name="ln8046">  snprintf((char *)pat2, pat2_len, &quot;\\m\\(%s\\m\\)\\|\\(%s\\m\\)&quot;, spat, epat);</a>
<a name="ln8047">  if (*mpat == NUL) {</a>
<a name="ln8048">    STRCPY(pat3, pat2);</a>
<a name="ln8049">  } else {</a>
<a name="ln8050">    snprintf((char *)pat3, pat3_len,</a>
<a name="ln8051">             &quot;\\m\\(%s\\m\\)\\|\\(%s\\m\\)\\|\\(%s\\m\\)&quot;, spat, epat, mpat);</a>
<a name="ln8052">  }</a>
<a name="ln8053">  if (flags &amp; SP_START) {</a>
<a name="ln8054">    options |= SEARCH_START;</a>
<a name="ln8055">  }</a>
<a name="ln8056"> </a>
<a name="ln8057">  if (skip != NULL) {</a>
<a name="ln8058">    // Empty string means to not use the skip expression.</a>
<a name="ln8059">    if (skip-&gt;v_type == VAR_STRING || skip-&gt;v_type == VAR_FUNC) {</a>
<a name="ln8060">      use_skip = skip-&gt;vval.v_string != NULL &amp;&amp; *skip-&gt;vval.v_string != NUL;</a>
<a name="ln8061">    }</a>
<a name="ln8062">  }</a>
<a name="ln8063"> </a>
<a name="ln8064">  save_cursor = curwin-&gt;w_cursor;</a>
<a name="ln8065">  pos = curwin-&gt;w_cursor;</a>
<a name="ln8066">  clearpos(&amp;firstpos);</a>
<a name="ln8067">  clearpos(&amp;foundpos);</a>
<a name="ln8068">  pat = pat3;</a>
<a name="ln8069">  for (;; ) {</a>
<a name="ln8070">    searchit_arg_T sia;</a>
<a name="ln8071">    memset(&amp;sia, 0, sizeof(sia));</a>
<a name="ln8072">    sia.sa_stop_lnum = lnum_stop;</a>
<a name="ln8073">    sia.sa_tm = &amp;tm;</a>
<a name="ln8074"> </a>
<a name="ln8075">    n = searchit(curwin, curbuf, &amp;pos, NULL, dir, pat, 1L,</a>
<a name="ln8076">                 options, RE_SEARCH, &amp;sia);</a>
<a name="ln8077">    if (n == FAIL || (firstpos.lnum != 0 &amp;&amp; equalpos(pos, firstpos))) {</a>
<a name="ln8078">      // didn't find it or found the first match again: FAIL</a>
<a name="ln8079">      break;</a>
<a name="ln8080">    }</a>
<a name="ln8081"> </a>
<a name="ln8082">    if (firstpos.lnum == 0)</a>
<a name="ln8083">      firstpos = pos;</a>
<a name="ln8084">    if (equalpos(pos, foundpos)) {</a>
<a name="ln8085">      // Found the same position again.  Can happen with a pattern that</a>
<a name="ln8086">      // has &quot;\zs&quot; at the end and searching backwards.  Advance one</a>
<a name="ln8087">      // character and try again.</a>
<a name="ln8088">      if (dir == BACKWARD) {</a>
<a name="ln8089">        decl(&amp;pos);</a>
<a name="ln8090">      } else {</a>
<a name="ln8091">        incl(&amp;pos);</a>
<a name="ln8092">      }</a>
<a name="ln8093">    }</a>
<a name="ln8094">    foundpos = pos;</a>
<a name="ln8095"> </a>
<a name="ln8096">    // clear the start flag to avoid getting stuck here</a>
<a name="ln8097">    options &amp;= ~SEARCH_START;</a>
<a name="ln8098"> </a>
<a name="ln8099">    // If the skip pattern matches, ignore this match.</a>
<a name="ln8100">    if (use_skip) {</a>
<a name="ln8101">      save_pos = curwin-&gt;w_cursor;</a>
<a name="ln8102">      curwin-&gt;w_cursor = pos;</a>
<a name="ln8103">      bool err = false;</a>
<a name="ln8104">      const bool r = eval_expr_to_bool(skip, &amp;err);</a>
<a name="ln8105">      curwin-&gt;w_cursor = save_pos;</a>
<a name="ln8106">      if (err) {</a>
<a name="ln8107">        // Evaluating {skip} caused an error, break here.</a>
<a name="ln8108">        curwin-&gt;w_cursor = save_cursor;</a>
<a name="ln8109">        retval = -1;</a>
<a name="ln8110">        break;</a>
<a name="ln8111">      }</a>
<a name="ln8112">      if (r)</a>
<a name="ln8113">        continue;</a>
<a name="ln8114">    }</a>
<a name="ln8115"> </a>
<a name="ln8116">    if ((dir == BACKWARD &amp;&amp; n == 3) || (dir == FORWARD &amp;&amp; n == 2)) {</a>
<a name="ln8117">      // Found end when searching backwards or start when searching</a>
<a name="ln8118">      // forward: nested pair.</a>
<a name="ln8119">      nest++;</a>
<a name="ln8120">      pat = pat2;               // nested, don't search for middle</a>
<a name="ln8121">    } else {</a>
<a name="ln8122">      // Found end when searching forward or start when searching</a>
<a name="ln8123">      // backward: end of (nested) pair; or found middle in outer pair.</a>
<a name="ln8124">      if (--nest == 1) {</a>
<a name="ln8125">        pat = pat3;             // outer level, search for middle</a>
<a name="ln8126">      }</a>
<a name="ln8127">    }</a>
<a name="ln8128"> </a>
<a name="ln8129">    if (nest == 0) {</a>
<a name="ln8130">      // Found the match: return matchcount or line number.</a>
<a name="ln8131">      if (flags &amp; SP_RETCOUNT) {</a>
<a name="ln8132">        retval++;</a>
<a name="ln8133">      } else {</a>
<a name="ln8134">        retval = pos.lnum;</a>
<a name="ln8135">      }</a>
<a name="ln8136">      if (flags &amp; SP_SETPCMARK) {</a>
<a name="ln8137">        setpcmark();</a>
<a name="ln8138">      }</a>
<a name="ln8139">      curwin-&gt;w_cursor = pos;</a>
<a name="ln8140">      if (!(flags &amp; SP_REPEAT))</a>
<a name="ln8141">        break;</a>
<a name="ln8142">      nest = 1;             // search for next unmatched</a>
<a name="ln8143">    }</a>
<a name="ln8144">  }</a>
<a name="ln8145"> </a>
<a name="ln8146">  if (match_pos != NULL) {</a>
<a name="ln8147">    // Store the match cursor position</a>
<a name="ln8148">    match_pos-&gt;lnum = curwin-&gt;w_cursor.lnum;</a>
<a name="ln8149">    match_pos-&gt;col = curwin-&gt;w_cursor.col + 1;</a>
<a name="ln8150">  }</a>
<a name="ln8151"> </a>
<a name="ln8152">  // If 'n' flag is used or search failed: restore cursor position.</a>
<a name="ln8153">  if ((flags &amp; SP_NOMOVE) || retval == 0) {</a>
<a name="ln8154">    curwin-&gt;w_cursor = save_cursor;</a>
<a name="ln8155">  }</a>
<a name="ln8156"> </a>
<a name="ln8157">  xfree(pat2);</a>
<a name="ln8158">  xfree(pat3);</a>
<a name="ln8159">  if (p_cpo == empty_option) {</a>
<a name="ln8160">    p_cpo = save_cpo;</a>
<a name="ln8161">  } else {</a>
<a name="ln8162">    // Darn, evaluating the {skip} expression changed the value.</a>
<a name="ln8163">    free_string_option(save_cpo);</a>
<a name="ln8164">  }</a>
<a name="ln8165"> </a>
<a name="ln8166">  return retval;</a>
<a name="ln8167">}</a>
<a name="ln8168"> </a>
<a name="ln8169">/*</a>
<a name="ln8170"> * &quot;searchpos()&quot; function</a>
<a name="ln8171"> */</a>
<a name="ln8172">static void f_searchpos(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8173">{</a>
<a name="ln8174">  pos_T match_pos;</a>
<a name="ln8175">  int flags = 0;</a>
<a name="ln8176"> </a>
<a name="ln8177">  const int n = search_cmn(argvars, &amp;match_pos, &amp;flags);</a>
<a name="ln8178"> </a>
<a name="ln8179">  tv_list_alloc_ret(rettv, 2 + (!!(flags &amp; SP_SUBPAT)));</a>
<a name="ln8180"> </a>
<a name="ln8181">  const int lnum = (n &gt; 0 ? match_pos.lnum : 0);</a>
<a name="ln8182">  const int col = (n &gt; 0 ? match_pos.col : 0);</a>
<a name="ln8183"> </a>
<a name="ln8184">  tv_list_append_number(rettv-&gt;vval.v_list, (varnumber_T)lnum);</a>
<a name="ln8185">  tv_list_append_number(rettv-&gt;vval.v_list, (varnumber_T)col);</a>
<a name="ln8186">  if (flags &amp; SP_SUBPAT) {</a>
<a name="ln8187">    tv_list_append_number(rettv-&gt;vval.v_list, (varnumber_T)n);</a>
<a name="ln8188">  }</a>
<a name="ln8189">}</a>
<a name="ln8190"> </a>
<a name="ln8191">/// &quot;serverlist()&quot; function</a>
<a name="ln8192">static void f_serverlist(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8193">{</a>
<a name="ln8194">  size_t n;</a>
<a name="ln8195">  char **addrs = server_address_list(&amp;n);</a>
<a name="ln8196"> </a>
<a name="ln8197">  // Copy addrs into a linked list.</a>
<a name="ln8198">  list_T *const l = tv_list_alloc_ret(rettv, n);</a>
<a name="ln8199">  for (size_t i = 0; i &lt; n; i++) {</a>
<a name="ln8200">    tv_list_append_allocated_string(l, addrs[i]);</a>
<a name="ln8201">  }</a>
<a name="ln8202">  xfree(addrs);</a>
<a name="ln8203">}</a>
<a name="ln8204"> </a>
<a name="ln8205">/// &quot;serverstart()&quot; function</a>
<a name="ln8206">static void f_serverstart(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8207">{</a>
<a name="ln8208">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln8209">  rettv-&gt;vval.v_string = NULL;  // Address of the new server</a>
<a name="ln8210"> </a>
<a name="ln8211">  if (check_secure()) {</a>
<a name="ln8212">    return;</a>
<a name="ln8213">  }</a>
<a name="ln8214"> </a>
<a name="ln8215">  char *address;</a>
<a name="ln8216">  // If the user supplied an address, use it, otherwise use a temp.</a>
<a name="ln8217">  if (argvars[0].v_type != VAR_UNKNOWN) {</a>
<a name="ln8218">    if (argvars[0].v_type != VAR_STRING) {</a>
<a name="ln8219">      EMSG(_(e_invarg));</a>
<a name="ln8220">      return;</a>
<a name="ln8221">    } else {</a>
<a name="ln8222">      address = xstrdup(tv_get_string(argvars));</a>
<a name="ln8223">    }</a>
<a name="ln8224">  } else {</a>
<a name="ln8225">    address = server_address_new();</a>
<a name="ln8226">  }</a>
<a name="ln8227"> </a>
<a name="ln8228">  int result = server_start(address);</a>
<a name="ln8229">  xfree(address);</a>
<a name="ln8230"> </a>
<a name="ln8231">  if (result != 0) {</a>
<a name="ln8232">    EMSG2(&quot;Failed to start server: %s&quot;,</a>
<a name="ln8233">          result &gt; 0 ? &quot;Unknown system error&quot; : uv_strerror(result));</a>
<a name="ln8234">    return;</a>
<a name="ln8235">  }</a>
<a name="ln8236"> </a>
<a name="ln8237">  // Since it's possible server_start adjusted the given {address} (e.g.,</a>
<a name="ln8238">  // &quot;localhost:&quot; will now have a port), return the final value to the user.</a>
<a name="ln8239">  size_t n;</a>
<a name="ln8240">  char **addrs = server_address_list(&amp;n);</a>
<a name="ln8241">  rettv-&gt;vval.v_string = (char_u *)addrs[n - 1];</a>
<a name="ln8242"> </a>
<a name="ln8243">  n--;</a>
<a name="ln8244">  for (size_t i = 0; i &lt; n; i++) {</a>
<a name="ln8245">    xfree(addrs[i]);</a>
<a name="ln8246">  }</a>
<a name="ln8247">  xfree(addrs);</a>
<a name="ln8248">}</a>
<a name="ln8249"> </a>
<a name="ln8250">/// &quot;serverstop()&quot; function</a>
<a name="ln8251">static void f_serverstop(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8252">{</a>
<a name="ln8253">  if (check_secure()) {</a>
<a name="ln8254">    return;</a>
<a name="ln8255">  }</a>
<a name="ln8256"> </a>
<a name="ln8257">  if (argvars[0].v_type != VAR_STRING) {</a>
<a name="ln8258">    EMSG(_(e_invarg));</a>
<a name="ln8259">    return;</a>
<a name="ln8260">  }</a>
<a name="ln8261"> </a>
<a name="ln8262">  rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln8263">  rettv-&gt;vval.v_number = 0;</a>
<a name="ln8264">  if (argvars[0].vval.v_string) {</a>
<a name="ln8265">    bool rv = server_stop((char *)argvars[0].vval.v_string);</a>
<a name="ln8266">    rettv-&gt;vval.v_number = (rv ? 1 : 0);</a>
<a name="ln8267">  }</a>
<a name="ln8268">}</a>
<a name="ln8269"> </a>
<a name="ln8270">/// &quot;setbufline()&quot; function</a>
<a name="ln8271">static void f_setbufline(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8272">{</a>
<a name="ln8273">    linenr_T lnum;</a>
<a name="ln8274">    buf_T    *buf;</a>
<a name="ln8275"> </a>
<a name="ln8276">    buf = tv_get_buf(&amp;argvars[0], false);</a>
<a name="ln8277">    if (buf == NULL) {</a>
<a name="ln8278">      rettv-&gt;vval.v_number = 1;  // FAIL</a>
<a name="ln8279">    } else {</a>
<a name="ln8280">      lnum = tv_get_lnum_buf(&amp;argvars[1], buf);</a>
<a name="ln8281">      set_buffer_lines(buf, lnum, false, &amp;argvars[2], rettv);</a>
<a name="ln8282">    }</a>
<a name="ln8283">}</a>
<a name="ln8284"> </a>
<a name="ln8285">/*</a>
<a name="ln8286"> * &quot;setbufvar()&quot; function</a>
<a name="ln8287"> */</a>
<a name="ln8288">static void f_setbufvar(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8289">{</a>
<a name="ln8290">  if (check_secure()</a>
<a name="ln8291">      || !tv_check_str_or_nr(&amp;argvars[0])) {</a>
<a name="ln8292">    return;</a>
<a name="ln8293">  }</a>
<a name="ln8294">  const char *varname = tv_get_string_chk(&amp;argvars[1]);</a>
<a name="ln8295">  buf_T *const buf = tv_get_buf(&amp;argvars[0], false);</a>
<a name="ln8296">  typval_T *varp = &amp;argvars[2];</a>
<a name="ln8297"> </a>
<a name="ln8298">  if (buf != NULL &amp;&amp; varname != NULL) {</a>
<a name="ln8299">    if (*varname == '&amp;') {</a>
<a name="ln8300">      long numval;</a>
<a name="ln8301">      bool error = false;</a>
<a name="ln8302">      aco_save_T aco;</a>
<a name="ln8303"> </a>
<a name="ln8304">      // set curbuf to be our buf, temporarily</a>
<a name="ln8305">      aucmd_prepbuf(&amp;aco, buf);</a>
<a name="ln8306"> </a>
<a name="ln8307">      varname++;</a>
<a name="ln8308">      numval = tv_get_number_chk(varp, &amp;error);</a>
<a name="ln8309">      char nbuf[NUMBUFLEN];</a>
<a name="ln8310">      const char *const strval = tv_get_string_buf_chk(varp, nbuf);</a>
<a name="ln8311">      if (!error &amp;&amp; strval != NULL) {</a>
<a name="ln8312">        set_option_value(varname, numval, strval, OPT_LOCAL);</a>
<a name="ln8313">      }</a>
<a name="ln8314"> </a>
<a name="ln8315">      // reset notion of buffer</a>
<a name="ln8316">      aucmd_restbuf(&amp;aco);</a>
<a name="ln8317">    } else {</a>
<a name="ln8318">      const size_t varname_len = STRLEN(varname);</a>
<a name="ln8319">      char *const bufvarname = xmalloc(varname_len + 3);</a>
<a name="ln8320">      buf_T *const save_curbuf = curbuf;</a>
<a name="ln8321">      curbuf = buf;</a>
<a name="ln8322">      memcpy(bufvarname, &quot;b:&quot;, 2);</a>
<a name="ln8323">      memcpy(bufvarname + 2, varname, varname_len + 1);</a>
<a name="ln8324">      set_var(bufvarname, varname_len + 2, varp, true);</a>
<a name="ln8325">      xfree(bufvarname);</a>
<a name="ln8326">      curbuf = save_curbuf;</a>
<a name="ln8327">    }</a>
<a name="ln8328">  }</a>
<a name="ln8329">}</a>
<a name="ln8330"> </a>
<a name="ln8331">static void f_setcharsearch(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8332">{</a>
<a name="ln8333">  dict_T        *d;</a>
<a name="ln8334">  dictitem_T        *di;</a>
<a name="ln8335"> </a>
<a name="ln8336">  if (argvars[0].v_type != VAR_DICT) {</a>
<a name="ln8337">    EMSG(_(e_dictreq));</a>
<a name="ln8338">    return;</a>
<a name="ln8339">  }</a>
<a name="ln8340"> </a>
<a name="ln8341">  if ((d = argvars[0].vval.v_dict) != NULL) {</a>
<a name="ln8342">    char_u *const csearch = (char_u *)tv_dict_get_string(d, &quot;char&quot;, false);</a>
<a name="ln8343">    if (csearch != NULL) {</a>
<a name="ln8344">      int pcc[MAX_MCO];</a>
<a name="ln8345">      const int c = utfc_ptr2char(csearch, pcc);</a>
<a name="ln8346">      set_last_csearch(c, csearch, utfc_ptr2len(csearch));</a>
<a name="ln8347">    }</a>
<a name="ln8348"> </a>
<a name="ln8349">    di = tv_dict_find(d, S_LEN(&quot;forward&quot;));</a>
<a name="ln8350">    if (di != NULL) {</a>
<a name="ln8351">      set_csearch_direction(tv_get_number(&amp;di-&gt;di_tv) ? FORWARD : BACKWARD);</a>
<a name="ln8352">    }</a>
<a name="ln8353"> </a>
<a name="ln8354">    di = tv_dict_find(d, S_LEN(&quot;until&quot;));</a>
<a name="ln8355">    if (di != NULL) {</a>
<a name="ln8356">      set_csearch_until(!!tv_get_number(&amp;di-&gt;di_tv));</a>
<a name="ln8357">    }</a>
<a name="ln8358">  }</a>
<a name="ln8359">}</a>
<a name="ln8360"> </a>
<a name="ln8361">/*</a>
<a name="ln8362"> * &quot;setcmdpos()&quot; function</a>
<a name="ln8363"> */</a>
<a name="ln8364">static void f_setcmdpos(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8365">{</a>
<a name="ln8366">  const int pos = (int)tv_get_number(&amp;argvars[0]) - 1;</a>
<a name="ln8367"> </a>
<a name="ln8368">  if (pos &gt;= 0) {</a>
<a name="ln8369">    rettv-&gt;vval.v_number = set_cmdline_pos(pos);</a>
<a name="ln8370">  }</a>
<a name="ln8371">}</a>
<a name="ln8372"> </a>
<a name="ln8373">/// &quot;setenv()&quot; function</a>
<a name="ln8374">static void f_setenv(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8375">{</a>
<a name="ln8376">  char namebuf[NUMBUFLEN];</a>
<a name="ln8377">  char valbuf[NUMBUFLEN];</a>
<a name="ln8378">  const char *name = tv_get_string_buf(&amp;argvars[0], namebuf);</a>
<a name="ln8379"> </a>
<a name="ln8380">  if (argvars[1].v_type == VAR_SPECIAL</a>
<a name="ln8381">      &amp;&amp; argvars[1].vval.v_special == kSpecialVarNull) {</a>
<a name="ln8382">    os_unsetenv(name);</a>
<a name="ln8383">  } else {</a>
<a name="ln8384">    os_setenv(name, tv_get_string_buf(&amp;argvars[1], valbuf), 1);</a>
<a name="ln8385">  }</a>
<a name="ln8386">}</a>
<a name="ln8387"> </a>
<a name="ln8388">/// &quot;setfperm({fname}, {mode})&quot; function</a>
<a name="ln8389">static void f_setfperm(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8390">{</a>
<a name="ln8391">  rettv-&gt;vval.v_number = 0;</a>
<a name="ln8392"> </a>
<a name="ln8393">  const char *const fname = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln8394">  if (fname == NULL) {</a>
<a name="ln8395">    return;</a>
<a name="ln8396">  }</a>
<a name="ln8397"> </a>
<a name="ln8398">  char modebuf[NUMBUFLEN];</a>
<a name="ln8399">  const char *const mode_str = tv_get_string_buf_chk(&amp;argvars[1], modebuf);</a>
<a name="ln8400">  if (mode_str == NULL) {</a>
<a name="ln8401">    return;</a>
<a name="ln8402">  }</a>
<a name="ln8403">  if (strlen(mode_str) != 9) {</a>
<a name="ln8404">    EMSG2(_(e_invarg2), mode_str);</a>
<a name="ln8405">    return;</a>
<a name="ln8406">  }</a>
<a name="ln8407"> </a>
<a name="ln8408">  int mask = 1;</a>
<a name="ln8409">  int mode = 0;</a>
<a name="ln8410">  for (int i = 8; i &gt;= 0; i--) {</a>
<a name="ln8411">    if (mode_str[i] != '-') {</a>
<a name="ln8412">      mode |= mask;</a>
<a name="ln8413">    }</a>
<a name="ln8414">    mask = mask &lt;&lt; 1;</a>
<a name="ln8415">  }</a>
<a name="ln8416">  rettv-&gt;vval.v_number = os_setperm(fname, mode) == OK;</a>
<a name="ln8417">}</a>
<a name="ln8418"> </a>
<a name="ln8419">/*</a>
<a name="ln8420"> * &quot;setline()&quot; function</a>
<a name="ln8421"> */</a>
<a name="ln8422">static void f_setline(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8423">{</a>
<a name="ln8424">  linenr_T lnum = tv_get_lnum(&amp;argvars[0]);</a>
<a name="ln8425">  set_buffer_lines(curbuf, lnum, false, &amp;argvars[1], rettv);</a>
<a name="ln8426">}</a>
<a name="ln8427"> </a>
<a name="ln8428">/// Create quickfix/location list from VimL values</a>
<a name="ln8429">///</a>
<a name="ln8430">/// Used by `setqflist()` and `setloclist()` functions. Accepts invalid</a>
<a name="ln8431">/// args argument in which case errors out, including VAR_UNKNOWN parameters.</a>
<a name="ln8432">///</a>
<a name="ln8433">/// @param[in,out]  wp  Window to create location list for. May be NULL in</a>
<a name="ln8434">///                     which case quickfix list will be created.</a>
<a name="ln8435">/// @param[in]  args  [list, action, what]</a>
<a name="ln8436">/// @param[in]  args[0]  Quickfix list contents.</a>
<a name="ln8437">/// @param[in]  args[1]  Optional. Action to perform:</a>
<a name="ln8438">///                      append to an existing list, replace its content,</a>
<a name="ln8439">///                      or create a new one.</a>
<a name="ln8440">/// @param[in]  args[2]  Optional. Quickfix list properties or title.</a>
<a name="ln8441">///                      Defaults to caller function name.</a>
<a name="ln8442">/// @param[out]  rettv  Return value: 0 in case of success, -1 otherwise.</a>
<a name="ln8443">static void set_qf_ll_list(win_T *wp, typval_T *args, typval_T *rettv)</a>
<a name="ln8444">  FUNC_ATTR_NONNULL_ARG(2, 3)</a>
<a name="ln8445">{</a>
<a name="ln8446">  static char *e_invact = N_(&quot;E927: Invalid action: '%s'&quot;);</a>
<a name="ln8447">  const char *title = NULL;</a>
<a name="ln8448">  int action = ' ';</a>
<a name="ln8449">  static int recursive = 0;</a>
<a name="ln8450">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln8451">  dict_T *what = NULL;</a>
<a name="ln8452"> </a>
<a name="ln8453">  typval_T *list_arg = &amp;args[0];</a>
<a name="ln8454">  if (list_arg-&gt;v_type != VAR_LIST) {</a>
<a name="ln8455">    EMSG(_(e_listreq));</a>
<a name="ln8456">    return;</a>
<a name="ln8457">  } else if (recursive != 0) {</a>
<a name="ln8458">    EMSG(_(e_au_recursive));</a>
<a name="ln8459">    return;</a>
<a name="ln8460">  }</a>
<a name="ln8461"> </a>
<a name="ln8462">  typval_T *action_arg = &amp;args[1];</a>
<a name="ln8463">  if (action_arg-&gt;v_type == VAR_UNKNOWN) {</a>
<a name="ln8464">    // Option argument was not given.</a>
<a name="ln8465">    goto skip_args;</a>
<a name="ln8466">  } else if (action_arg-&gt;v_type != VAR_STRING) {</a>
<a name="ln8467">    EMSG(_(e_stringreq));</a>
<a name="ln8468">    return;</a>
<a name="ln8469">  }</a>
<a name="ln8470">  const char *const act = tv_get_string_chk(action_arg);</a>
<a name="ln8471">  if ((*act == 'a' || *act == 'r' || *act == ' ' || *act == 'f')</a>
<a name="ln8472">      &amp;&amp; act[1] == NUL) {</a>
<a name="ln8473">    action = *act;</a>
<a name="ln8474">  } else {</a>
<a name="ln8475">    EMSG2(_(e_invact), act);</a>
<a name="ln8476">    return;</a>
<a name="ln8477">  }</a>
<a name="ln8478"> </a>
<a name="ln8479">  typval_T *const what_arg = &amp;args[2];</a>
<a name="ln8480">  if (what_arg-&gt;v_type == VAR_UNKNOWN) {</a>
<a name="ln8481">    // Option argument was not given.</a>
<a name="ln8482">    goto skip_args;</a>
<a name="ln8483">  } else if (what_arg-&gt;v_type == VAR_STRING) {</a>
<a name="ln8484">    title = tv_get_string_chk(what_arg);</a>
<a name="ln8485">    if (!title) {</a>
<a name="ln8486">      // Type error. Error already printed by tv_get_string_chk().</a>
<a name="ln8487">      return;</a>
<a name="ln8488">    }</a>
<a name="ln8489">  } else if (what_arg-&gt;v_type == VAR_DICT &amp;&amp; what_arg-&gt;vval.v_dict != NULL) {</a>
<a name="ln8490">    what = what_arg-&gt;vval.v_dict;</a>
<a name="ln8491">  } else {</a>
<a name="ln8492">    EMSG(_(e_dictreq));</a>
<a name="ln8493">    return;</a>
<a name="ln8494">  }</a>
<a name="ln8495"> </a>
<a name="ln8496">skip_args:</a>
<a name="ln8497">  if (!title) {</a>
<a name="ln8498">    title = (wp ? &quot;:setloclist()&quot; : &quot;:setqflist()&quot;);</a>
<a name="ln8499">  }</a>
<a name="ln8500"> </a>
<a name="ln8501">  recursive++;</a>
<a name="ln8502">  list_T *const l = list_arg-&gt;vval.v_list;</a>
<a name="ln8503">  if (set_errorlist(wp, l, action, (char_u *)title, what) == OK) {</a>
<a name="ln8504">    rettv-&gt;vval.v_number = 0;</a>
<a name="ln8505">  }</a>
<a name="ln8506">  recursive--;</a>
<a name="ln8507">}</a>
<a name="ln8508"> </a>
<a name="ln8509">/*</a>
<a name="ln8510"> * &quot;setloclist()&quot; function</a>
<a name="ln8511"> */</a>
<a name="ln8512">static void f_setloclist(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8513">{</a>
<a name="ln8514">  win_T       *win;</a>
<a name="ln8515"> </a>
<a name="ln8516">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln8517"> </a>
<a name="ln8518">  win = find_win_by_nr_or_id(&amp;argvars[0]);</a>
<a name="ln8519">  if (win != NULL) {</a>
<a name="ln8520">    set_qf_ll_list(win, &amp;argvars[1], rettv);</a>
<a name="ln8521">  }</a>
<a name="ln8522">}</a>
<a name="ln8523"> </a>
<a name="ln8524">/*</a>
<a name="ln8525"> * &quot;setmatches()&quot; function</a>
<a name="ln8526"> */</a>
<a name="ln8527">static void f_setmatches(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8528">{</a>
<a name="ln8529">  dict_T *d;</a>
<a name="ln8530">  list_T *s = NULL;</a>
<a name="ln8531">  win_T *win = get_optional_window(argvars, 1);</a>
<a name="ln8532"> </a>
<a name="ln8533">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln8534">  if (argvars[0].v_type != VAR_LIST) {</a>
<a name="ln8535">    EMSG(_(e_listreq));</a>
<a name="ln8536">    return;</a>
<a name="ln8537">  }</a>
<a name="ln8538">  if (win == NULL) {</a>
<a name="ln8539">    return;</a>
<a name="ln8540">  }</a>
<a name="ln8541"> </a>
<a name="ln8542">  list_T *const l = argvars[0].vval.v_list;</a>
<a name="ln8543">  // To some extent make sure that we are dealing with a list from</a>
<a name="ln8544">  // &quot;getmatches()&quot;.</a>
<a name="ln8545">  int li_idx = 0;</a>
<a name="ln8546">  TV_LIST_ITER_CONST(l, li, {</a>
<a name="ln8547">    if (TV_LIST_ITEM_TV(li)-&gt;v_type != VAR_DICT</a>
<a name="ln8548">        || (d = TV_LIST_ITEM_TV(li)-&gt;vval.v_dict) == NULL) {</a>
<a name="ln8549">      emsgf(_(&quot;E474: List item %d is either not a dictionary &quot;</a>
<a name="ln8550">              &quot;or an empty one&quot;), li_idx);</a>
<a name="ln8551">      return;</a>
<a name="ln8552">    }</a>
<a name="ln8553">    if (!(tv_dict_find(d, S_LEN(&quot;group&quot;)) != NULL</a>
<a name="ln8554">          &amp;&amp; (tv_dict_find(d, S_LEN(&quot;pattern&quot;)) != NULL</a>
<a name="ln8555">              || tv_dict_find(d, S_LEN(&quot;pos1&quot;)) != NULL)</a>
<a name="ln8556">          &amp;&amp; tv_dict_find(d, S_LEN(&quot;priority&quot;)) != NULL</a>
<a name="ln8557">          &amp;&amp; tv_dict_find(d, S_LEN(&quot;id&quot;)) != NULL)) {</a>
<a name="ln8558">      emsgf(_(&quot;E474: List item %d is missing one of the required keys&quot;),</a>
<a name="ln8559">            li_idx);</a>
<a name="ln8560">      return;</a>
<a name="ln8561">    }</a>
<a name="ln8562">    li_idx++;</a>
<a name="ln8563">  });</a>
<a name="ln8564"> </a>
<a name="ln8565">  clear_matches(win);</a>
<a name="ln8566">  bool match_add_failed = false;</a>
<a name="ln8567">  TV_LIST_ITER_CONST(l, li, {</a>
<a name="ln8568">    int i = 0;</a>
<a name="ln8569"> </a>
<a name="ln8570">    d = TV_LIST_ITEM_TV(li)-&gt;vval.v_dict;</a>
<a name="ln8571">    dictitem_T *const di = tv_dict_find(d, S_LEN(&quot;pattern&quot;));</a>
<a name="ln8572">    if (di == NULL) {</a>
<a name="ln8573">      if (s == NULL) {</a>
<a name="ln8574">        s = tv_list_alloc(9);</a>
<a name="ln8575">      }</a>
<a name="ln8576"> </a>
<a name="ln8577">      // match from matchaddpos()</a>
<a name="ln8578">      for (i = 1; i &lt; 9; i++) {</a>
<a name="ln8579">        char buf[30];  // use 30 to avoid compiler warning</a>
<a name="ln8580">        snprintf(buf, sizeof(buf), &quot;pos%d&quot;, i);</a>
<a name="ln8581">        dictitem_T *const pos_di = tv_dict_find(d, buf, -1);</a>
<a name="ln8582">        if (pos_di != NULL) {</a>
<a name="ln8583">          if (pos_di-&gt;di_tv.v_type != VAR_LIST) {</a>
<a name="ln8584">            return;</a>
<a name="ln8585">          }</a>
<a name="ln8586"> </a>
<a name="ln8587">          tv_list_append_tv(s, &amp;pos_di-&gt;di_tv);</a>
<a name="ln8588">          tv_list_ref(s);</a>
<a name="ln8589">        } else {</a>
<a name="ln8590">          break;</a>
<a name="ln8591">        }</a>
<a name="ln8592">      }</a>
<a name="ln8593">    }</a>
<a name="ln8594"> </a>
<a name="ln8595">    // Note: there are three number buffers involved:</a>
<a name="ln8596">    // - group_buf below.</a>
<a name="ln8597">    // - numbuf in tv_dict_get_string().</a>
<a name="ln8598">    // - mybuf in tv_get_string().</a>
<a name="ln8599">    //</a>
<a name="ln8600">    // If you change this code make sure that buffers will not get</a>
<a name="ln8601">    // accidentally reused.</a>
<a name="ln8602">    char group_buf[NUMBUFLEN];</a>
<a name="ln8603">    const char *const group = tv_dict_get_string_buf(d, &quot;group&quot;, group_buf);</a>
<a name="ln8604">    const int priority = (int)tv_dict_get_number(d, &quot;priority&quot;);</a>
<a name="ln8605">    const int id = (int)tv_dict_get_number(d, &quot;id&quot;);</a>
<a name="ln8606">    dictitem_T *const conceal_di = tv_dict_find(d, S_LEN(&quot;conceal&quot;));</a>
<a name="ln8607">    const char *const conceal = (conceal_di != NULL</a>
<a name="ln8608">                                 ? tv_get_string(&amp;conceal_di-&gt;di_tv)</a>
<a name="ln8609">                                 : NULL);</a>
<a name="ln8610">    if (i == 0) {</a>
<a name="ln8611">      if (match_add(win, group,</a>
<a name="ln8612">                    tv_dict_get_string(d, &quot;pattern&quot;, false),</a>
<a name="ln8613">                    priority, id, NULL, conceal) != id) {</a>
<a name="ln8614">        match_add_failed = true;</a>
<a name="ln8615">      }</a>
<a name="ln8616">    } else {</a>
<a name="ln8617">      if (match_add(win, group, NULL, priority, id, s, conceal) != id) {</a>
<a name="ln8618">        match_add_failed = true;</a>
<a name="ln8619">      }</a>
<a name="ln8620">      tv_list_unref(s);</a>
<a name="ln8621">      s = NULL;</a>
<a name="ln8622">    }</a>
<a name="ln8623">  });</a>
<a name="ln8624">  if (!match_add_failed) {</a>
<a name="ln8625">    rettv-&gt;vval.v_number = 0;</a>
<a name="ln8626">  }</a>
<a name="ln8627">}</a>
<a name="ln8628"> </a>
<a name="ln8629">/*</a>
<a name="ln8630"> * &quot;setpos()&quot; function</a>
<a name="ln8631"> */</a>
<a name="ln8632">static void f_setpos(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8633">{</a>
<a name="ln8634">  pos_T pos;</a>
<a name="ln8635">  int fnum;</a>
<a name="ln8636">  colnr_T     curswant = -1;</a>
<a name="ln8637"> </a>
<a name="ln8638">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln8639">  const char *const name = tv_get_string_chk(argvars);</a>
<a name="ln8640">  if (name != NULL) {</a>
<a name="ln8641">    if (list2fpos(&amp;argvars[1], &amp;pos, &amp;fnum, &amp;curswant) == OK) {</a>
<a name="ln8642">      if (pos.col != MAXCOL &amp;&amp; --pos.col &lt; 0) {</a>
<a name="ln8643">        pos.col = 0;</a>
<a name="ln8644">      }</a>
<a name="ln8645">      if (name[0] == '.' &amp;&amp; name[1] == NUL) {</a>
<a name="ln8646">        // set cursor; &quot;fnum&quot; is ignored</a>
<a name="ln8647">        curwin-&gt;w_cursor = pos;</a>
<a name="ln8648">        if (curswant &gt;= 0) {</a>
<a name="ln8649">          curwin-&gt;w_curswant = curswant - 1;</a>
<a name="ln8650">          curwin-&gt;w_set_curswant = false;</a>
<a name="ln8651">        }</a>
<a name="ln8652">        check_cursor();</a>
<a name="ln8653">        rettv-&gt;vval.v_number = 0;</a>
<a name="ln8654">      } else if (name[0] == '\'' &amp;&amp; name[1] != NUL &amp;&amp; name[2] == NUL)   {</a>
<a name="ln8655">        // set mark</a>
<a name="ln8656">        if (setmark_pos((uint8_t)name[1], &amp;pos, fnum) == OK) {</a>
<a name="ln8657">          rettv-&gt;vval.v_number = 0;</a>
<a name="ln8658">        }</a>
<a name="ln8659">      } else {</a>
<a name="ln8660">        EMSG(_(e_invarg));</a>
<a name="ln8661">      }</a>
<a name="ln8662">    }</a>
<a name="ln8663">  }</a>
<a name="ln8664">}</a>
<a name="ln8665"> </a>
<a name="ln8666">/*</a>
<a name="ln8667"> * &quot;setqflist()&quot; function</a>
<a name="ln8668"> */</a>
<a name="ln8669">static void f_setqflist(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8670">{</a>
<a name="ln8671">  set_qf_ll_list(NULL, argvars, rettv);</a>
<a name="ln8672">}</a>
<a name="ln8673"> </a>
<a name="ln8674">/*</a>
<a name="ln8675"> * &quot;setreg()&quot; function</a>
<a name="ln8676"> */</a>
<a name="ln8677">static void f_setreg(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8678">{</a>
<a name="ln8679">  int regname;</a>
<a name="ln8680">  bool append = false;</a>
<a name="ln8681">  MotionType yank_type;</a>
<a name="ln8682">  long block_len;</a>
<a name="ln8683"> </a>
<a name="ln8684">  block_len = -1;</a>
<a name="ln8685">  yank_type = kMTUnknown;</a>
<a name="ln8686"> </a>
<a name="ln8687">  rettv-&gt;vval.v_number = 1;  // FAIL is default.</a>
<a name="ln8688"> </a>
<a name="ln8689">  const char *const strregname = tv_get_string_chk(argvars);</a>
<a name="ln8690">  if (strregname == NULL) {</a>
<a name="ln8691">    return;  // Type error; errmsg already given.</a>
<a name="ln8692">  }</a>
<a name="ln8693">  regname = (uint8_t)(*strregname);</a>
<a name="ln8694">  if (regname == 0 || regname == '@') {</a>
<a name="ln8695">    regname = '&quot;';</a>
<a name="ln8696">  }</a>
<a name="ln8697"> </a>
<a name="ln8698">  bool set_unnamed = false;</a>
<a name="ln8699">  if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln8700">    const char *stropt = tv_get_string_chk(&amp;argvars[2]);</a>
<a name="ln8701">    if (stropt == NULL) {</a>
<a name="ln8702">      return;  // Type error.</a>
<a name="ln8703">    }</a>
<a name="ln8704">    for (; *stropt != NUL; stropt++) {</a>
<a name="ln8705">      switch (*stropt) {</a>
<a name="ln8706">        case 'a': case 'A': {  // append</a>
<a name="ln8707">          append = true;</a>
<a name="ln8708">          break;</a>
<a name="ln8709">        }</a>
<a name="ln8710">        case 'v': case 'c': {  // character-wise selection</a>
<a name="ln8711">          yank_type = kMTCharWise;</a>
<a name="ln8712">          break;</a>
<a name="ln8713">        }</a>
<a name="ln8714">        case 'V': case 'l': {  // line-wise selection</a>
<a name="ln8715">          yank_type = kMTLineWise;</a>
<a name="ln8716">          break;</a>
<a name="ln8717">        }</a>
<a name="ln8718">        case 'b': case Ctrl_V: {  // block-wise selection</a>
<a name="ln8719">          yank_type = kMTBlockWise;</a>
<a name="ln8720">          if (ascii_isdigit(stropt[1])) {</a>
<a name="ln8721">            stropt++;</a>
<a name="ln8722">            block_len = getdigits_long((char_u **)&amp;stropt, true, 0) - 1;</a>
<a name="ln8723">            stropt--;</a>
<a name="ln8724">          }</a>
<a name="ln8725">          break;</a>
<a name="ln8726">        }</a>
<a name="ln8727">        case 'u': case '&quot;': {  // unnamed register</a>
<a name="ln8728">          set_unnamed = true;</a>
<a name="ln8729">          break;</a>
<a name="ln8730">        }</a>
<a name="ln8731">      }</a>
<a name="ln8732">    }</a>
<a name="ln8733">  }</a>
<a name="ln8734"> </a>
<a name="ln8735">  if (argvars[1].v_type == VAR_LIST) {</a>
<a name="ln8736">    list_T *ll = argvars[1].vval.v_list;</a>
<a name="ln8737">    // If the list is NULL handle like an empty list.</a>
<a name="ln8738">    const int len = tv_list_len(ll);</a>
<a name="ln8739"> </a>
<a name="ln8740">    // First half: use for pointers to result lines; second half: use for</a>
<a name="ln8741">    // pointers to allocated copies.</a>
<a name="ln8742">    char **lstval = xmalloc(sizeof(char *) * ((len + 1) * 2));</a>
<a name="ln8743">    const char **curval = (const char **)lstval;</a>
<a name="ln8744">    char **allocval = lstval + len + 2;</a>
<a name="ln8745">    char **curallocval = allocval;</a>
<a name="ln8746"> </a>
<a name="ln8747">    TV_LIST_ITER_CONST(ll, li, {</a>
<a name="ln8748">      char buf[NUMBUFLEN];</a>
<a name="ln8749">      *curval = tv_get_string_buf_chk(TV_LIST_ITEM_TV(li), buf);</a>
<a name="ln8750">      if (*curval == NULL) {</a>
<a name="ln8751">        goto free_lstval;</a>
<a name="ln8752">      }</a>
<a name="ln8753">      if (*curval == buf) {</a>
<a name="ln8754">        // Need to make a copy,</a>
<a name="ln8755">        // next tv_get_string_buf_chk() will overwrite the string.</a>
<a name="ln8756">        *curallocval = xstrdup(*curval);</a>
<a name="ln8757">        *curval = *curallocval;</a>
<a name="ln8758">        curallocval++;</a>
<a name="ln8759">      }</a>
<a name="ln8760">      curval++;</a>
<a name="ln8761">    });</a>
<a name="ln8762">    *curval++ = NULL;</a>
<a name="ln8763"> </a>
<a name="ln8764">    write_reg_contents_lst(regname, (char_u **)lstval, append, yank_type,</a>
<a name="ln8765">                           block_len);</a>
<a name="ln8766"> </a>
<a name="ln8767">free_lstval:</a>
<a name="ln8768">    while (curallocval &gt; allocval) {</a>
<a name="ln8769">      xfree(*--curallocval);</a>
<a name="ln8770">    }</a>
<a name="ln8771">    xfree(lstval);</a>
<a name="ln8772">  } else {</a>
<a name="ln8773">    const char *strval = tv_get_string_chk(&amp;argvars[1]);</a>
<a name="ln8774">    if (strval == NULL) {</a>
<a name="ln8775">      return;</a>
<a name="ln8776">    }</a>
<a name="ln8777">    write_reg_contents_ex(regname, (const char_u *)strval, STRLEN(strval),</a>
<a name="ln8778">                          append, yank_type, block_len);</a>
<a name="ln8779">  }</a>
<a name="ln8780">  rettv-&gt;vval.v_number = 0;</a>
<a name="ln8781"> </a>
<a name="ln8782">  if (set_unnamed) {</a>
<a name="ln8783">    // Discard the result. We already handle the error case.</a>
<a name="ln8784">    if (op_reg_set_previous(regname)) { }</a>
<a name="ln8785">  }</a>
<a name="ln8786">}</a>
<a name="ln8787"> </a>
<a name="ln8788">/*</a>
<a name="ln8789"> * &quot;settabvar()&quot; function</a>
<a name="ln8790"> */</a>
<a name="ln8791">static void f_settabvar(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8792">{</a>
<a name="ln8793">  rettv-&gt;vval.v_number = 0;</a>
<a name="ln8794"> </a>
<a name="ln8795">  if (check_secure()) {</a>
<a name="ln8796">    return;</a>
<a name="ln8797">  }</a>
<a name="ln8798"> </a>
<a name="ln8799">  tabpage_T *const tp = find_tabpage((int)tv_get_number_chk(&amp;argvars[0], NULL));</a>
<a name="ln8800">  const char *const varname = tv_get_string_chk(&amp;argvars[1]);</a>
<a name="ln8801">  typval_T *const varp = &amp;argvars[2];</a>
<a name="ln8802"> </a>
<a name="ln8803">  if (varname != NULL &amp;&amp; tp != NULL) {</a>
<a name="ln8804">    tabpage_T *const save_curtab = curtab;</a>
<a name="ln8805">    goto_tabpage_tp(tp, false, false);</a>
<a name="ln8806"> </a>
<a name="ln8807">    const size_t varname_len = strlen(varname);</a>
<a name="ln8808">    char *const tabvarname = xmalloc(varname_len + 3);</a>
<a name="ln8809">    memcpy(tabvarname, &quot;t:&quot;, 2);</a>
<a name="ln8810">    memcpy(tabvarname + 2, varname, varname_len + 1);</a>
<a name="ln8811">    set_var(tabvarname, varname_len + 2, varp, true);</a>
<a name="ln8812">    xfree(tabvarname);</a>
<a name="ln8813"> </a>
<a name="ln8814">    // Restore current tabpage.</a>
<a name="ln8815">    if (valid_tabpage(save_curtab)) {</a>
<a name="ln8816">      goto_tabpage_tp(save_curtab, false, false);</a>
<a name="ln8817">    }</a>
<a name="ln8818">  }</a>
<a name="ln8819">}</a>
<a name="ln8820"> </a>
<a name="ln8821">/*</a>
<a name="ln8822"> * &quot;settabwinvar()&quot; function</a>
<a name="ln8823"> */</a>
<a name="ln8824">static void f_settabwinvar(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8825">{</a>
<a name="ln8826">  setwinvar(argvars, rettv, 1);</a>
<a name="ln8827">}</a>
<a name="ln8828"> </a>
<a name="ln8829">// &quot;settagstack()&quot; function</a>
<a name="ln8830">static void f_settagstack(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8831">{</a>
<a name="ln8832">    static char *e_invact2 = N_(&quot;E962: Invalid action: '%s'&quot;);</a>
<a name="ln8833">    win_T       *wp;</a>
<a name="ln8834">    dict_T      *d;</a>
<a name="ln8835">    int         action = 'r';</a>
<a name="ln8836"> </a>
<a name="ln8837">    rettv-&gt;vval.v_number = -1;</a>
<a name="ln8838"> </a>
<a name="ln8839">    // first argument: window number or id</a>
<a name="ln8840">    wp = find_win_by_nr_or_id(&amp;argvars[0]);</a>
<a name="ln8841">    if (wp == NULL) {</a>
<a name="ln8842">      return;</a>
<a name="ln8843">    }</a>
<a name="ln8844"> </a>
<a name="ln8845">    // second argument: dict with items to set in the tag stack</a>
<a name="ln8846">    if (argvars[1].v_type != VAR_DICT) {</a>
<a name="ln8847">        EMSG(_(e_dictreq));</a>
<a name="ln8848">        return;</a>
<a name="ln8849">    }</a>
<a name="ln8850">    d = argvars[1].vval.v_dict;</a>
<a name="ln8851">    if (d == NULL) {</a>
<a name="ln8852">      return;</a>
<a name="ln8853">    }</a>
<a name="ln8854"> </a>
<a name="ln8855">    // third argument: action - 'a' for append and 'r' for replace.</a>
<a name="ln8856">    // default is to replace the stack.</a>
<a name="ln8857">    if (argvars[2].v_type == VAR_UNKNOWN) {</a>
<a name="ln8858">      action = 'r';</a>
<a name="ln8859">    } else if (argvars[2].v_type == VAR_STRING) {</a>
<a name="ln8860">        const char *actstr;</a>
<a name="ln8861">        actstr = tv_get_string_chk(&amp;argvars[2]);</a>
<a name="ln8862">        if (actstr == NULL) {</a>
<a name="ln8863">          return;</a>
<a name="ln8864">        }</a>
<a name="ln8865">        if ((*actstr == 'r' || *actstr == 'a' || *actstr == 't')</a>
<a name="ln8866">            &amp;&amp; actstr[1] == NUL) {</a>
<a name="ln8867">          action = *actstr;</a>
<a name="ln8868">        } else {</a>
<a name="ln8869">            EMSG2(_(e_invact2), actstr);</a>
<a name="ln8870">            return;</a>
<a name="ln8871">        }</a>
<a name="ln8872">    } else {</a>
<a name="ln8873">        EMSG(_(e_stringreq));</a>
<a name="ln8874">        return;</a>
<a name="ln8875">    }</a>
<a name="ln8876"> </a>
<a name="ln8877">    if (set_tagstack(wp, d, action) == OK) {</a>
<a name="ln8878">      rettv-&gt;vval.v_number = 0;</a>
<a name="ln8879">    }</a>
<a name="ln8880">}</a>
<a name="ln8881"> </a>
<a name="ln8882">/*</a>
<a name="ln8883"> * &quot;setwinvar()&quot; function</a>
<a name="ln8884"> */</a>
<a name="ln8885">static void f_setwinvar(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8886">{</a>
<a name="ln8887">  setwinvar(argvars, rettv, 0);</a>
<a name="ln8888">}</a>
<a name="ln8889"> </a>
<a name="ln8890">/// f_sha256 - sha256({string}) function</a>
<a name="ln8891">static void f_sha256(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8892">{</a>
<a name="ln8893">  const char *p = tv_get_string(&amp;argvars[0]);</a>
<a name="ln8894">  const char *hash = sha256_bytes((const uint8_t *)p, strlen(p) , NULL, 0);</a>
<a name="ln8895"> </a>
<a name="ln8896">  // make a copy of the hash (sha256_bytes returns a static buffer)</a>
<a name="ln8897">  rettv-&gt;vval.v_string = (char_u *)xstrdup(hash);</a>
<a name="ln8898">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln8899">}</a>
<a name="ln8900"> </a>
<a name="ln8901">/*</a>
<a name="ln8902"> * &quot;shellescape({string})&quot; function</a>
<a name="ln8903"> */</a>
<a name="ln8904">static void f_shellescape(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8905">{</a>
<a name="ln8906">  const bool do_special = non_zero_arg(&amp;argvars[1]);</a>
<a name="ln8907"> </a>
<a name="ln8908">  rettv-&gt;vval.v_string = vim_strsave_shellescape(</a>
<a name="ln8909">      (const char_u *)tv_get_string(&amp;argvars[0]), do_special, do_special);</a>
<a name="ln8910">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln8911">}</a>
<a name="ln8912"> </a>
<a name="ln8913">/*</a>
<a name="ln8914"> * shiftwidth() function</a>
<a name="ln8915"> */</a>
<a name="ln8916">static void f_shiftwidth(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8917">{</a>
<a name="ln8918">  rettv-&gt;vval.v_number = 0;</a>
<a name="ln8919"> </a>
<a name="ln8920">  if (argvars[0].v_type != VAR_UNKNOWN) {</a>
<a name="ln8921">    long col;</a>
<a name="ln8922"> </a>
<a name="ln8923">    col = (long)tv_get_number_chk(argvars, NULL);</a>
<a name="ln8924">    if (col &lt; 0) {</a>
<a name="ln8925">      return;  // type error; errmsg already given</a>
<a name="ln8926">    }</a>
<a name="ln8927">    rettv-&gt;vval.v_number = get_sw_value_col(curbuf, col);</a>
<a name="ln8928">    return;</a>
<a name="ln8929">  }</a>
<a name="ln8930">  rettv-&gt;vval.v_number = get_sw_value(curbuf);</a>
<a name="ln8931">}</a>
<a name="ln8932"> </a>
<a name="ln8933">/// &quot;sign_define()&quot; function</a>
<a name="ln8934">static void f_sign_define(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8935">{</a>
<a name="ln8936">  const char *name;</a>
<a name="ln8937"> </a>
<a name="ln8938">  if (argvars[0].v_type == VAR_LIST &amp;&amp; argvars[1].v_type == VAR_UNKNOWN) {</a>
<a name="ln8939">    // Define multiple signs</a>
<a name="ln8940">    tv_list_alloc_ret(rettv, kListLenMayKnow);</a>
<a name="ln8941"> </a>
<a name="ln8942">    sign_define_multiple(argvars[0].vval.v_list, rettv-&gt;vval.v_list);</a>
<a name="ln8943">    return;</a>
<a name="ln8944">  }</a>
<a name="ln8945"> </a>
<a name="ln8946">  // Define a single sign</a>
<a name="ln8947">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln8948"> </a>
<a name="ln8949">  name = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln8950">  if (name == NULL) {</a>
<a name="ln8951">    return;</a>
<a name="ln8952">  }</a>
<a name="ln8953"> </a>
<a name="ln8954">  if (argvars[1].v_type != VAR_UNKNOWN &amp;&amp; argvars[1].v_type != VAR_DICT) {</a>
<a name="ln8955">    EMSG(_(e_dictreq));</a>
<a name="ln8956">    return;</a>
<a name="ln8957">  }</a>
<a name="ln8958"> </a>
<a name="ln8959">  rettv-&gt;vval.v_number = sign_define_from_dict(</a>
<a name="ln8960">      name, argvars[1].v_type == VAR_DICT ? argvars[1].vval.v_dict : NULL);</a>
<a name="ln8961">}</a>
<a name="ln8962"> </a>
<a name="ln8963">/// &quot;sign_getdefined()&quot; function</a>
<a name="ln8964">static void f_sign_getdefined(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8965">{</a>
<a name="ln8966">  const char *name = NULL;</a>
<a name="ln8967"> </a>
<a name="ln8968">  tv_list_alloc_ret(rettv, 0);</a>
<a name="ln8969"> </a>
<a name="ln8970">  if (argvars[0].v_type != VAR_UNKNOWN) {</a>
<a name="ln8971">    name = tv_get_string(&amp;argvars[0]);</a>
<a name="ln8972">  }</a>
<a name="ln8973"> </a>
<a name="ln8974">  sign_getlist((const char_u *)name, rettv-&gt;vval.v_list);</a>
<a name="ln8975">}</a>
<a name="ln8976"> </a>
<a name="ln8977">/// &quot;sign_getplaced()&quot; function</a>
<a name="ln8978">static void f_sign_getplaced(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8979">{</a>
<a name="ln8980">  buf_T *buf = NULL;</a>
<a name="ln8981">  dict_T *dict;</a>
<a name="ln8982">  dictitem_T *di;</a>
<a name="ln8983">  linenr_T lnum = 0;</a>
<a name="ln8984">  int sign_id = 0;</a>
<a name="ln8985">  const char *group = NULL;</a>
<a name="ln8986">  bool notanum = false;</a>
<a name="ln8987"> </a>
<a name="ln8988">  tv_list_alloc_ret(rettv, 0);</a>
<a name="ln8989"> </a>
<a name="ln8990">  if (argvars[0].v_type != VAR_UNKNOWN) {</a>
<a name="ln8991">    // get signs placed in the specified buffer</a>
<a name="ln8992">    buf = get_buf_arg(&amp;argvars[0]);</a>
<a name="ln8993">    if (buf == NULL) {</a>
<a name="ln8994">      return;</a>
<a name="ln8995">    }</a>
<a name="ln8996"> </a>
<a name="ln8997">    if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln8998">      if (argvars[1].v_type != VAR_DICT</a>
<a name="ln8999">          || ((dict = argvars[1].vval.v_dict) == NULL)) {</a>
<a name="ln9000">        EMSG(_(e_dictreq));</a>
<a name="ln9001">        return;</a>
<a name="ln9002">      }</a>
<a name="ln9003">      if ((di = tv_dict_find(dict, &quot;lnum&quot;, -1)) != NULL) {</a>
<a name="ln9004">        // get signs placed at this line</a>
<a name="ln9005">        lnum = (linenr_T)tv_get_number_chk(&amp;di-&gt;di_tv, &amp;notanum);</a>
<a name="ln9006">        if (notanum) {</a>
<a name="ln9007">          return;</a>
<a name="ln9008">        }</a>
<a name="ln9009">        (void)lnum;</a>
<a name="ln9010">        lnum = tv_get_lnum(&amp;di-&gt;di_tv);</a>
<a name="ln9011">      }</a>
<a name="ln9012">      if ((di = tv_dict_find(dict, &quot;id&quot;, -1)) != NULL) {</a>
<a name="ln9013">        // get sign placed with this identifier</a>
<a name="ln9014">        sign_id = (int)tv_get_number_chk(&amp;di-&gt;di_tv, &amp;notanum);</a>
<a name="ln9015">        if (notanum) {</a>
<a name="ln9016">          return;</a>
<a name="ln9017">        }</a>
<a name="ln9018">      }</a>
<a name="ln9019">      if ((di = tv_dict_find(dict, &quot;group&quot;, -1)) != NULL) {</a>
<a name="ln9020">        group = tv_get_string_chk(&amp;di-&gt;di_tv);</a>
<a name="ln9021">        if (group == NULL) {</a>
<a name="ln9022">          return;</a>
<a name="ln9023">        }</a>
<a name="ln9024">        if (*group == '\0') {  // empty string means global group</a>
<a name="ln9025">          group = NULL;</a>
<a name="ln9026">        }</a>
<a name="ln9027">      }</a>
<a name="ln9028">    }</a>
<a name="ln9029">  }</a>
<a name="ln9030"> </a>
<a name="ln9031">  sign_get_placed(buf, lnum, sign_id, (const char_u *)group,</a>
<a name="ln9032">                  rettv-&gt;vval.v_list);</a>
<a name="ln9033">}</a>
<a name="ln9034"> </a>
<a name="ln9035">/// &quot;sign_jump()&quot; function</a>
<a name="ln9036">static void f_sign_jump(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln9037">{</a>
<a name="ln9038">  int sign_id;</a>
<a name="ln9039">  char *sign_group = NULL;</a>
<a name="ln9040">  buf_T *buf;</a>
<a name="ln9041">  bool notanum = false;</a>
<a name="ln9042"> </a>
<a name="ln9043">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln9044"> </a>
<a name="ln9045">  // Sign identifier</a>
<a name="ln9046">  sign_id = (int)tv_get_number_chk(&amp;argvars[0], &amp;notanum);</a>
<a name="ln9047">  if (notanum) {</a>
<a name="ln9048">    return;</a>
<a name="ln9049">  }</a>
<a name="ln9050">  if (sign_id &lt;= 0) {</a>
<a name="ln9051">    EMSG(_(e_invarg));</a>
<a name="ln9052">    return;</a>
<a name="ln9053">  }</a>
<a name="ln9054"> </a>
<a name="ln9055">  // Sign group</a>
<a name="ln9056">  const char * sign_group_chk = tv_get_string_chk(&amp;argvars[1]);</a>
<a name="ln9057">  if (sign_group_chk == NULL) {</a>
<a name="ln9058">    return;</a>
<a name="ln9059">  }</a>
<a name="ln9060">  if (sign_group_chk[0] == '\0') {</a>
<a name="ln9061">    sign_group = NULL;  // global sign group</a>
<a name="ln9062">  } else {</a>
<a name="ln9063">    sign_group = xstrdup(sign_group_chk);</a>
<a name="ln9064">  }</a>
<a name="ln9065"> </a>
<a name="ln9066">  // Buffer to place the sign</a>
<a name="ln9067">  buf = get_buf_arg(&amp;argvars[2]);</a>
<a name="ln9068">  if (buf == NULL) {</a>
<a name="ln9069">    goto cleanup;</a>
<a name="ln9070">  }</a>
<a name="ln9071"> </a>
<a name="ln9072">  rettv-&gt;vval.v_number = sign_jump(sign_id, (char_u *)sign_group, buf);</a>
<a name="ln9073"> </a>
<a name="ln9074">cleanup:</a>
<a name="ln9075">  xfree(sign_group);</a>
<a name="ln9076">}</a>
<a name="ln9077"> </a>
<a name="ln9078">/// &quot;sign_place()&quot; function</a>
<a name="ln9079">static void f_sign_place(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln9080">{</a>
<a name="ln9081">  dict_T *dict = NULL;</a>
<a name="ln9082"> </a>
<a name="ln9083">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln9084"> </a>
<a name="ln9085">  if (argvars[4].v_type != VAR_UNKNOWN</a>
<a name="ln9086">      &amp;&amp; (argvars[4].v_type != VAR_DICT</a>
<a name="ln9087">          || ((dict = argvars[4].vval.v_dict) == NULL))) {</a>
<a name="ln9088">    EMSG(_(e_dictreq));</a>
<a name="ln9089">    return;</a>
<a name="ln9090">  }</a>
<a name="ln9091"> </a>
<a name="ln9092">  rettv-&gt;vval.v_number = sign_place_from_dict(</a>
<a name="ln9093">      &amp;argvars[0], &amp;argvars[1], &amp;argvars[2], &amp;argvars[3], dict);</a>
<a name="ln9094">}</a>
<a name="ln9095"> </a>
<a name="ln9096">/// &quot;sign_placelist()&quot; function.  Place multiple signs.</a>
<a name="ln9097">static void f_sign_placelist(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln9098">{</a>
<a name="ln9099">  int sign_id;</a>
<a name="ln9100"> </a>
<a name="ln9101">  tv_list_alloc_ret(rettv, kListLenMayKnow);</a>
<a name="ln9102"> </a>
<a name="ln9103">  if (argvars[0].v_type != VAR_LIST) {</a>
<a name="ln9104">    EMSG(_(e_listreq));</a>
<a name="ln9105">    return;</a>
<a name="ln9106">  }</a>
<a name="ln9107"> </a>
<a name="ln9108">  // Process the List of sign attributes</a>
<a name="ln9109">  TV_LIST_ITER_CONST(argvars[0].vval.v_list, li, {</a>
<a name="ln9110">    sign_id = -1;</a>
<a name="ln9111">    if (TV_LIST_ITEM_TV(li)-&gt;v_type == VAR_DICT) {</a>
<a name="ln9112">      sign_id = sign_place_from_dict(</a>
<a name="ln9113">          NULL, NULL, NULL, NULL, TV_LIST_ITEM_TV(li)-&gt;vval.v_dict);</a>
<a name="ln9114">    } else {</a>
<a name="ln9115">      EMSG(_(e_dictreq));</a>
<a name="ln9116">    }</a>
<a name="ln9117">    tv_list_append_number(rettv-&gt;vval.v_list, sign_id);</a>
<a name="ln9118">  });</a>
<a name="ln9119">}</a>
<a name="ln9120"> </a>
<a name="ln9121">/// &quot;sign_undefine()&quot; function</a>
<a name="ln9122">static void f_sign_undefine(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln9123">{</a>
<a name="ln9124">  const char *name;</a>
<a name="ln9125"> </a>
<a name="ln9126">  if (argvars[0].v_type == VAR_LIST &amp;&amp; argvars[1].v_type == VAR_UNKNOWN) {</a>
<a name="ln9127">    // Undefine multiple signs</a>
<a name="ln9128">    tv_list_alloc_ret(rettv, kListLenMayKnow);</a>
<a name="ln9129"> </a>
<a name="ln9130">    sign_undefine_multiple(argvars[0].vval.v_list, rettv-&gt;vval.v_list);</a>
<a name="ln9131">    return;</a>
<a name="ln9132">  }</a>
<a name="ln9133"> </a>
<a name="ln9134">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln9135"> </a>
<a name="ln9136">  if (argvars[0].v_type == VAR_UNKNOWN) {</a>
<a name="ln9137">    // Free all the signs</a>
<a name="ln9138">    free_signs();</a>
<a name="ln9139">    rettv-&gt;vval.v_number = 0;</a>
<a name="ln9140">  } else {</a>
<a name="ln9141">    // Free only the specified sign</a>
<a name="ln9142">    name = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln9143">    if (name == NULL) {</a>
<a name="ln9144">      return;</a>
<a name="ln9145">    }</a>
<a name="ln9146"> </a>
<a name="ln9147">    if (sign_undefine_by_name((const char_u *)name) == OK) {</a>
<a name="ln9148">      rettv-&gt;vval.v_number = 0;</a>
<a name="ln9149">    }</a>
<a name="ln9150">  }</a>
<a name="ln9151">}</a>
<a name="ln9152"> </a>
<a name="ln9153">/// &quot;sign_unplace()&quot; function</a>
<a name="ln9154">static void f_sign_unplace(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln9155">{</a>
<a name="ln9156">  dict_T *dict = NULL;</a>
<a name="ln9157"> </a>
<a name="ln9158">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln9159"> </a>
<a name="ln9160">  if (argvars[0].v_type != VAR_STRING) {</a>
<a name="ln9161">    EMSG(_(e_invarg));</a>
<a name="ln9162">    return;</a>
<a name="ln9163">  }</a>
<a name="ln9164"> </a>
<a name="ln9165">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln9166">    if (argvars[1].v_type != VAR_DICT) {</a>
<a name="ln9167">      EMSG(_(e_dictreq));</a>
<a name="ln9168">      return;</a>
<a name="ln9169">    }</a>
<a name="ln9170">    dict = argvars[1].vval.v_dict;</a>
<a name="ln9171">  }</a>
<a name="ln9172"> </a>
<a name="ln9173">  rettv-&gt;vval.v_number = sign_unplace_from_dict(&amp;argvars[0], dict);</a>
<a name="ln9174">}</a>
<a name="ln9175"> </a>
<a name="ln9176">/// &quot;sign_unplacelist()&quot; function</a>
<a name="ln9177">static void f_sign_unplacelist(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln9178">{</a>
<a name="ln9179">  int retval;</a>
<a name="ln9180"> </a>
<a name="ln9181">  tv_list_alloc_ret(rettv, kListLenMayKnow);</a>
<a name="ln9182"> </a>
<a name="ln9183">  if (argvars[0].v_type != VAR_LIST) {</a>
<a name="ln9184">    EMSG(_(e_listreq));</a>
<a name="ln9185">    return;</a>
<a name="ln9186">  }</a>
<a name="ln9187"> </a>
<a name="ln9188">  TV_LIST_ITER_CONST(argvars[0].vval.v_list, li, {</a>
<a name="ln9189">    retval = -1;</a>
<a name="ln9190">    if (TV_LIST_ITEM_TV(li)-&gt;v_type == VAR_DICT) {</a>
<a name="ln9191">      retval = sign_unplace_from_dict(NULL, TV_LIST_ITEM_TV(li)-&gt;vval.v_dict);</a>
<a name="ln9192">    } else {</a>
<a name="ln9193">      EMSG(_(e_dictreq));</a>
<a name="ln9194">    }</a>
<a name="ln9195">    tv_list_append_number(rettv-&gt;vval.v_list, retval);</a>
<a name="ln9196">  });</a>
<a name="ln9197">}</a>
<a name="ln9198"> </a>
<a name="ln9199">/*</a>
<a name="ln9200"> * &quot;simplify()&quot; function</a>
<a name="ln9201"> */</a>
<a name="ln9202">static void f_simplify(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln9203">{</a>
<a name="ln9204">  const char *const p = tv_get_string(&amp;argvars[0]);</a>
<a name="ln9205">  rettv-&gt;vval.v_string = (char_u *)xstrdup(p);</a>
<a name="ln9206">  simplify_filename(rettv-&gt;vval.v_string);  // Simplify in place.</a>
<a name="ln9207">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln9208">}</a>
<a name="ln9209"> </a>
<a name="ln9210">/// &quot;sockconnect()&quot; function</a>
<a name="ln9211">static void f_sockconnect(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln9212">{</a>
<a name="ln9213">  if (argvars[0].v_type != VAR_STRING || argvars[1].v_type != VAR_STRING) {</a>
<a name="ln9214">    EMSG(_(e_invarg));</a>
<a name="ln9215">    return;</a>
<a name="ln9216">  }</a>
<a name="ln9217">  if (argvars[2].v_type != VAR_DICT &amp;&amp; argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln9218">    // Wrong argument types</a>
<a name="ln9219">    EMSG2(_(e_invarg2), &quot;expected dictionary&quot;);</a>
<a name="ln9220">    return;</a>
<a name="ln9221">  }</a>
<a name="ln9222"> </a>
<a name="ln9223">  const char *mode = tv_get_string(&amp;argvars[0]);</a>
<a name="ln9224">  const char *address = tv_get_string(&amp;argvars[1]);</a>
<a name="ln9225"> </a>
<a name="ln9226">  bool tcp;</a>
<a name="ln9227">  if (strcmp(mode, &quot;tcp&quot;) == 0) {</a>
<a name="ln9228">    tcp = true;</a>
<a name="ln9229">  } else if (strcmp(mode, &quot;pipe&quot;) == 0) {</a>
<a name="ln9230">    tcp = false;</a>
<a name="ln9231">  } else {</a>
<a name="ln9232">    EMSG2(_(e_invarg2), &quot;invalid mode&quot;);</a>
<a name="ln9233">    return;</a>
<a name="ln9234">  }</a>
<a name="ln9235"> </a>
<a name="ln9236">  bool rpc = false;</a>
<a name="ln9237">  CallbackReader on_data = CALLBACK_READER_INIT;</a>
<a name="ln9238">  if (argvars[2].v_type == VAR_DICT) {</a>
<a name="ln9239">    dict_T *opts = argvars[2].vval.v_dict;</a>
<a name="ln9240">    rpc = tv_dict_get_number(opts, &quot;rpc&quot;) != 0;</a>
<a name="ln9241"> </a>
<a name="ln9242">    if (!tv_dict_get_callback(opts, S_LEN(&quot;on_data&quot;), &amp;on_data.cb)) {</a>
<a name="ln9243">      return;</a>
<a name="ln9244">    }</a>
<a name="ln9245">    on_data.buffered = tv_dict_get_number(opts, &quot;data_buffered&quot;);</a>
<a name="ln9246">    if (on_data.buffered &amp;&amp; on_data.cb.type == kCallbackNone) {</a>
<a name="ln9247">      on_data.self = opts;</a>
<a name="ln9248">    }</a>
<a name="ln9249">  }</a>
<a name="ln9250"> </a>
<a name="ln9251">  const char *error = NULL;</a>
<a name="ln9252">  uint64_t id = channel_connect(tcp, address, rpc, on_data, 50, &amp;error);</a>
<a name="ln9253"> </a>
<a name="ln9254">  if (error) {</a>
<a name="ln9255">    EMSG2(_(&quot;connection failed: %s&quot;), error);</a>
<a name="ln9256">  }</a>
<a name="ln9257"> </a>
<a name="ln9258">  rettv-&gt;vval.v_number = (varnumber_T)id;</a>
<a name="ln9259">  rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln9260">}</a>
<a name="ln9261"> </a>
<a name="ln9262">/// struct storing information about current sort</a>
<a name="ln9263">typedef struct {</a>
<a name="ln9264">  int item_compare_ic;</a>
<a name="ln9265">  bool item_compare_lc;</a>
<a name="ln9266">  bool item_compare_numeric;</a>
<a name="ln9267">  bool item_compare_numbers;</a>
<a name="ln9268">  bool item_compare_float;</a>
<a name="ln9269">  const char *item_compare_func;</a>
<a name="ln9270">  partial_T *item_compare_partial;</a>
<a name="ln9271">  dict_T *item_compare_selfdict;</a>
<a name="ln9272">  bool item_compare_func_err;</a>
<a name="ln9273">} sortinfo_T;</a>
<a name="ln9274">static sortinfo_T *sortinfo = NULL;</a>
<a name="ln9275"> </a>
<a name="ln9276">#define ITEM_COMPARE_FAIL 999</a>
<a name="ln9277"> </a>
<a name="ln9278">/*</a>
<a name="ln9279"> * Compare functions for f_sort() and f_uniq() below.</a>
<a name="ln9280"> */</a>
<a name="ln9281">static int item_compare(const void *s1, const void *s2, bool keep_zero)</a>
<a name="ln9282">{</a>
<a name="ln9283">  ListSortItem *const si1 = (ListSortItem *)s1;</a>
<a name="ln9284">  ListSortItem *const si2 = (ListSortItem *)s2;</a>
<a name="ln9285"> </a>
<a name="ln9286">  typval_T *const tv1 = TV_LIST_ITEM_TV(si1-&gt;item);</a>
<a name="ln9287">  typval_T *const tv2 = TV_LIST_ITEM_TV(si2-&gt;item);</a>
<a name="ln9288"> </a>
<a name="ln9289">  int res;</a>
<a name="ln9290"> </a>
<a name="ln9291">  if (sortinfo-&gt;item_compare_numbers) {</a>
<a name="ln9292">    const varnumber_T v1 = tv_get_number(tv1);</a>
<a name="ln9293">    const varnumber_T v2 = tv_get_number(tv2);</a>
<a name="ln9294"> </a>
<a name="ln9295">    res = v1 == v2 ? 0 : v1 &gt; v2 ? 1 : -1;</a>
<a name="ln9296">    goto item_compare_end;</a>
<a name="ln9297">  }</a>
<a name="ln9298"> </a>
<a name="ln9299">  if (sortinfo-&gt;item_compare_float) {</a>
<a name="ln9300">    const float_T v1 = tv_get_float(tv1);</a>
<a name="ln9301">    const float_T v2 = tv_get_float(tv2);</a>
<a name="ln9302"> </a>
<a name="ln9303">    res = v1 == v2 ? 0 : v1 &gt; v2 ? 1 : -1;</a>
<a name="ln9304">    goto item_compare_end;</a>
<a name="ln9305">  }</a>
<a name="ln9306"> </a>
<a name="ln9307">  char *tofree1 = NULL;</a>
<a name="ln9308">  char *tofree2 = NULL;</a>
<a name="ln9309">  char *p1;</a>
<a name="ln9310">  char *p2;</a>
<a name="ln9311"> </a>
<a name="ln9312">  // encode_tv2string() puts quotes around a string and allocates memory.  Don't</a>
<a name="ln9313">  // do that for string variables. Use a single quote when comparing with</a>
<a name="ln9314">  // a non-string to do what the docs promise.</a>
<a name="ln9315">  if (tv1-&gt;v_type == VAR_STRING) {</a>
<a name="ln9316">    if (tv2-&gt;v_type != VAR_STRING || sortinfo-&gt;item_compare_numeric) {</a>
<a name="ln9317">      p1 = &quot;'&quot;;</a>
<a name="ln9318">    } else {</a>
<a name="ln9319">      p1 = (char *)tv1-&gt;vval.v_string;</a>
<a name="ln9320">    }</a>
<a name="ln9321">  } else {</a>
<a name="ln9322">    tofree1 = p1 = encode_tv2string(tv1, NULL);</a>
<a name="ln9323">  }</a>
<a name="ln9324">  if (tv2-&gt;v_type == VAR_STRING) {</a>
<a name="ln9325">    if (tv1-&gt;v_type != VAR_STRING || sortinfo-&gt;item_compare_numeric) {</a>
<a name="ln9326">      p2 = &quot;'&quot;;</a>
<a name="ln9327">    } else {</a>
<a name="ln9328">      p2 = (char *)tv2-&gt;vval.v_string;</a>
<a name="ln9329">    }</a>
<a name="ln9330">  } else {</a>
<a name="ln9331">    tofree2 = p2 = encode_tv2string(tv2, NULL);</a>
<a name="ln9332">  }</a>
<a name="ln9333">  if (p1 == NULL) {</a>
<a name="ln9334">    p1 = &quot;&quot;;</a>
<a name="ln9335">  }</a>
<a name="ln9336">  if (p2 == NULL) {</a>
<a name="ln9337">    p2 = &quot;&quot;;</a>
<a name="ln9338">  }</a>
<a name="ln9339">  if (!sortinfo-&gt;item_compare_numeric) {</a>
<a name="ln9340">    if (sortinfo-&gt;item_compare_lc) {</a>
<a name="ln9341">      res = strcoll(p1, p2);</a>
<a name="ln9342">    } else {</a>
<a name="ln9343">      res = sortinfo-&gt;item_compare_ic ? STRICMP(p1, p2): STRCMP(p1, p2);</a>
<a name="ln9344">    }</a>
<a name="ln9345">  } else {</a>
<a name="ln9346">    double n1, n2;</a>
<a name="ln9347">    n1 = strtod(p1, &amp;p1);</a>
<a name="ln9348">    n2 = strtod(p2, &amp;p2);</a>
<a name="ln9349">    res = n1 == n2 ? 0 : n1 &gt; n2 ? 1 : -1;</a>
<a name="ln9350">  }</a>
<a name="ln9351"> </a>
<a name="ln9352">  xfree(tofree1);</a>
<a name="ln9353">  xfree(tofree2);</a>
<a name="ln9354"> </a>
<a name="ln9355">item_compare_end:</a>
<a name="ln9356">  // When the result would be zero, compare the item indexes.  Makes the</a>
<a name="ln9357">  // sort stable.</a>
<a name="ln9358">  if (res == 0 &amp;&amp; !keep_zero) {</a>
<a name="ln9359">    // WARNING: When using uniq si1 and si2 are actually listitem_T **, no</a>
<a name="ln9360">    // indexes are there.</a>
<a name="ln9361">    res = si1-&gt;idx &gt; si2-&gt;idx ? 1 : -1;</a>
<a name="ln9362">  }</a>
<a name="ln9363">  return res;</a>
<a name="ln9364">}</a>
<a name="ln9365"> </a>
<a name="ln9366">static int item_compare_keeping_zero(const void *s1, const void *s2)</a>
<a name="ln9367">{</a>
<a name="ln9368">  return item_compare(s1, s2, true);</a>
<a name="ln9369">}</a>
<a name="ln9370"> </a>
<a name="ln9371">static int item_compare_not_keeping_zero(const void *s1, const void *s2)</a>
<a name="ln9372">{</a>
<a name="ln9373">  return item_compare(s1, s2, false);</a>
<a name="ln9374">}</a>
<a name="ln9375"> </a>
<a name="ln9376">static int item_compare2(const void *s1, const void *s2, bool keep_zero)</a>
<a name="ln9377">{</a>
<a name="ln9378">  ListSortItem *si1, *si2;</a>
<a name="ln9379">  int res;</a>
<a name="ln9380">  typval_T rettv;</a>
<a name="ln9381">  typval_T argv[3];</a>
<a name="ln9382">  int dummy;</a>
<a name="ln9383">  const char *func_name;</a>
<a name="ln9384">  partial_T *partial = sortinfo-&gt;item_compare_partial;</a>
<a name="ln9385"> </a>
<a name="ln9386">  // shortcut after failure in previous call; compare all items equal</a>
<a name="ln9387">  if (sortinfo-&gt;item_compare_func_err) {</a>
<a name="ln9388">    return 0;</a>
<a name="ln9389">  }</a>
<a name="ln9390"> </a>
<a name="ln9391">  si1 = (ListSortItem *)s1;</a>
<a name="ln9392">  si2 = (ListSortItem *)s2;</a>
<a name="ln9393"> </a>
<a name="ln9394">  if (partial == NULL) {</a>
<a name="ln9395">    func_name = sortinfo-&gt;item_compare_func;</a>
<a name="ln9396">  } else {</a>
<a name="ln9397">    func_name = (const char *)partial_name(partial);</a>
<a name="ln9398">  }</a>
<a name="ln9399"> </a>
<a name="ln9400">  // Copy the values.  This is needed to be able to set v_lock to VAR_FIXED</a>
<a name="ln9401">  // in the copy without changing the original list items.</a>
<a name="ln9402">  tv_copy(TV_LIST_ITEM_TV(si1-&gt;item), &amp;argv[0]);</a>
<a name="ln9403">  tv_copy(TV_LIST_ITEM_TV(si2-&gt;item), &amp;argv[1]);</a>
<a name="ln9404"> </a>
<a name="ln9405">  rettv.v_type = VAR_UNKNOWN;  // tv_clear() uses this</a>
<a name="ln9406">  res = call_func((const char_u *)func_name,</a>
<a name="ln9407">                  -1,</a>
<a name="ln9408">                  &amp;rettv, 2, argv, NULL, 0L, 0L, &amp;dummy, true,</a>
<a name="ln9409">                  partial, sortinfo-&gt;item_compare_selfdict);</a>
<a name="ln9410">  tv_clear(&amp;argv[0]);</a>
<a name="ln9411">  tv_clear(&amp;argv[1]);</a>
<a name="ln9412"> </a>
<a name="ln9413">  if (res == FAIL) {</a>
<a name="ln9414">    res = ITEM_COMPARE_FAIL;</a>
<a name="ln9415">  } else {</a>
<a name="ln9416">    res = tv_get_number_chk(&amp;rettv, &amp;sortinfo-&gt;item_compare_func_err);</a>
<a name="ln9417">  }</a>
<a name="ln9418">  if (sortinfo-&gt;item_compare_func_err) {</a>
<a name="ln9419">    res = ITEM_COMPARE_FAIL;  // return value has wrong type</a>
<a name="ln9420">  }</a>
<a name="ln9421">  tv_clear(&amp;rettv);</a>
<a name="ln9422"> </a>
<a name="ln9423">  // When the result would be zero, compare the pointers themselves.  Makes</a>
<a name="ln9424">  // the sort stable.</a>
<a name="ln9425">  if (res == 0 &amp;&amp; !keep_zero) {</a>
<a name="ln9426">    // WARNING: When using uniq si1 and si2 are actually listitem_T **, no</a>
<a name="ln9427">    // indexes are there.</a>
<a name="ln9428">    res = si1-&gt;idx &gt; si2-&gt;idx ? 1 : -1;</a>
<a name="ln9429">  }</a>
<a name="ln9430"> </a>
<a name="ln9431">  return res;</a>
<a name="ln9432">}</a>
<a name="ln9433"> </a>
<a name="ln9434">static int item_compare2_keeping_zero(const void *s1, const void *s2)</a>
<a name="ln9435">{</a>
<a name="ln9436">  return item_compare2(s1, s2, true);</a>
<a name="ln9437">}</a>
<a name="ln9438"> </a>
<a name="ln9439">static int item_compare2_not_keeping_zero(const void *s1, const void *s2)</a>
<a name="ln9440">{</a>
<a name="ln9441">  return item_compare2(s1, s2, false);</a>
<a name="ln9442">}</a>
<a name="ln9443"> </a>
<a name="ln9444">/*</a>
<a name="ln9445"> * &quot;sort({list})&quot; function</a>
<a name="ln9446"> */</a>
<a name="ln9447">static void do_sort_uniq(typval_T *argvars, typval_T *rettv, bool sort)</a>
<a name="ln9448">{</a>
<a name="ln9449">  ListSortItem  *ptrs;</a>
<a name="ln9450">  long len;</a>
<a name="ln9451">  long i;</a>
<a name="ln9452"> </a>
<a name="ln9453">  // Pointer to current info struct used in compare function. Save and restore</a>
<a name="ln9454">  // the current one for nested calls.</a>
<a name="ln9455">  sortinfo_T info;</a>
<a name="ln9456">  sortinfo_T *old_sortinfo = sortinfo;</a>
<a name="ln9457">  sortinfo = &amp;info;</a>
<a name="ln9458"> </a>
<a name="ln9459">  const char *const arg_errmsg = (sort</a>
<a name="ln9460">                                  ? N_(&quot;sort() argument&quot;)</a>
<a name="ln9461">                                  : N_(&quot;uniq() argument&quot;));</a>
<a name="ln9462"> </a>
<a name="ln9463">  if (argvars[0].v_type != VAR_LIST) {</a>
<a name="ln9464">    EMSG2(_(e_listarg), sort ? &quot;sort()&quot; : &quot;uniq()&quot;);</a>
<a name="ln9465">  } else {</a>
<a name="ln9466">    list_T *const l = argvars[0].vval.v_list;</a>
<a name="ln9467">    if (var_check_lock(tv_list_locked(l), arg_errmsg, TV_TRANSLATE)) {</a>
<a name="ln9468">      goto theend;</a>
<a name="ln9469">    }</a>
<a name="ln9470">    tv_list_set_ret(rettv, l);</a>
<a name="ln9471"> </a>
<a name="ln9472">    len = tv_list_len(l);</a>
<a name="ln9473">    if (len &lt;= 1) {</a>
<a name="ln9474">      goto theend;  // short list sorts pretty quickly</a>
<a name="ln9475">    }</a>
<a name="ln9476"> </a>
<a name="ln9477">    info.item_compare_ic = false;</a>
<a name="ln9478">    info.item_compare_lc = false;</a>
<a name="ln9479">    info.item_compare_numeric = false;</a>
<a name="ln9480">    info.item_compare_numbers = false;</a>
<a name="ln9481">    info.item_compare_float = false;</a>
<a name="ln9482">    info.item_compare_func = NULL;</a>
<a name="ln9483">    info.item_compare_partial = NULL;</a>
<a name="ln9484">    info.item_compare_selfdict = NULL;</a>
<a name="ln9485"> </a>
<a name="ln9486">    if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln9487">      // optional second argument: {func}</a>
<a name="ln9488">      if (argvars[1].v_type == VAR_FUNC) {</a>
<a name="ln9489">        info.item_compare_func = (const char *)argvars[1].vval.v_string;</a>
<a name="ln9490">      } else if (argvars[1].v_type == VAR_PARTIAL) {</a>
<a name="ln9491">        info.item_compare_partial = argvars[1].vval.v_partial;</a>
<a name="ln9492">      } else {</a>
<a name="ln9493">        bool error = false;</a>
<a name="ln9494"> </a>
<a name="ln9495">        i = tv_get_number_chk(&amp;argvars[1], &amp;error);</a>
<a name="ln9496">        if (error) {</a>
<a name="ln9497">          goto theend;  // type error; errmsg already given</a>
<a name="ln9498">        }</a>
<a name="ln9499">        if (i == 1) {</a>
<a name="ln9500">          info.item_compare_ic = true;</a>
<a name="ln9501">        } else if (argvars[1].v_type != VAR_NUMBER) {</a>
<a name="ln9502">          info.item_compare_func = tv_get_string(&amp;argvars[1]);</a>
<a name="ln9503">        } else if (i != 0) {</a>
<a name="ln9504">          EMSG(_(e_invarg));</a>
<a name="ln9505">          goto theend;</a>
<a name="ln9506">        }</a>
<a name="ln9507">        if (info.item_compare_func != NULL) {</a>
<a name="ln9508">          if (*info.item_compare_func == NUL) {</a>
<a name="ln9509">            // empty string means default sort</a>
<a name="ln9510">            info.item_compare_func = NULL;</a>
<a name="ln9511">          } else if (strcmp(info.item_compare_func, &quot;n&quot;) == 0) {</a>
<a name="ln9512">            info.item_compare_func = NULL;</a>
<a name="ln9513">            info.item_compare_numeric = true;</a>
<a name="ln9514">          } else if (strcmp(info.item_compare_func, &quot;N&quot;) == 0) {</a>
<a name="ln9515">            info.item_compare_func = NULL;</a>
<a name="ln9516">            info.item_compare_numbers = true;</a>
<a name="ln9517">          } else if (strcmp(info.item_compare_func, &quot;f&quot;) == 0) {</a>
<a name="ln9518">            info.item_compare_func = NULL;</a>
<a name="ln9519">            info.item_compare_float = true;</a>
<a name="ln9520">          } else if (strcmp(info.item_compare_func, &quot;i&quot;) == 0) {</a>
<a name="ln9521">            info.item_compare_func = NULL;</a>
<a name="ln9522">            info.item_compare_ic = true;</a>
<a name="ln9523">          } else if (strcmp(info.item_compare_func, &quot;l&quot;) == 0) {</a>
<a name="ln9524">            info.item_compare_func = NULL;</a>
<a name="ln9525">            info.item_compare_lc = true;</a>
<a name="ln9526">          }</a>
<a name="ln9527">        }</a>
<a name="ln9528">      }</a>
<a name="ln9529"> </a>
<a name="ln9530">      if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln9531">        // optional third argument: {dict}</a>
<a name="ln9532">        if (argvars[2].v_type != VAR_DICT) {</a>
<a name="ln9533">          EMSG(_(e_dictreq));</a>
<a name="ln9534">          goto theend;</a>
<a name="ln9535">        }</a>
<a name="ln9536">        info.item_compare_selfdict = argvars[2].vval.v_dict;</a>
<a name="ln9537">      }</a>
<a name="ln9538">    }</a>
<a name="ln9539"> </a>
<a name="ln9540">    // Make an array with each entry pointing to an item in the List.</a>
<a name="ln9541">    ptrs = xmalloc((size_t)(len * sizeof(ListSortItem)));</a>
<a name="ln9542"> </a>
<a name="ln9543">    if (sort) {</a>
<a name="ln9544">      info.item_compare_func_err = false;</a>
<a name="ln9545">      tv_list_item_sort(l, ptrs,</a>
<a name="ln9546">                        ((info.item_compare_func == NULL</a>
<a name="ln9547">                          &amp;&amp; info.item_compare_partial == NULL)</a>
<a name="ln9548">                         ? item_compare_not_keeping_zero</a>
<a name="ln9549">                         : item_compare2_not_keeping_zero),</a>
<a name="ln9550">                        &amp;info.item_compare_func_err);</a>
<a name="ln9551">      if (info.item_compare_func_err) {</a>
<a name="ln9552">        EMSG(_(&quot;E702: Sort compare function failed&quot;));</a>
<a name="ln9553">      }</a>
<a name="ln9554">    } else {</a>
<a name="ln9555">      ListSorter item_compare_func_ptr;</a>
<a name="ln9556"> </a>
<a name="ln9557">      // f_uniq(): ptrs will be a stack of items to remove.</a>
<a name="ln9558">      info.item_compare_func_err = false;</a>
<a name="ln9559">      if (info.item_compare_func != NULL</a>
<a name="ln9560">          || info.item_compare_partial != NULL) {</a>
<a name="ln9561">        item_compare_func_ptr = item_compare2_keeping_zero;</a>
<a name="ln9562">      } else {</a>
<a name="ln9563">        item_compare_func_ptr = item_compare_keeping_zero;</a>
<a name="ln9564">      }</a>
<a name="ln9565"> </a>
<a name="ln9566">      int idx = 0;</a>
<a name="ln9567">      for (listitem_T *li = TV_LIST_ITEM_NEXT(l, tv_list_first(l))</a>
<a name="ln9568">           ; li != NULL;) {</a>
<a name="ln9569">        listitem_T *const prev_li = TV_LIST_ITEM_PREV(l, li);</a>
<a name="ln9570">        if (item_compare_func_ptr(&amp;prev_li, &amp;li) == 0) {</a>
<a name="ln9571">          if (info.item_compare_func_err) {  // -V547</a>
<a name="ln9572">            EMSG(_(&quot;E882: Uniq compare function failed&quot;));</a>
<a name="ln9573">            break;</a>
<a name="ln9574">          }</a>
<a name="ln9575">          li = tv_list_item_remove(l, li);</a>
<a name="ln9576">        } else {</a>
<a name="ln9577">          idx++;</a>
<a name="ln9578">          li = TV_LIST_ITEM_NEXT(l, li);</a>
<a name="ln9579">        }</a>
<a name="ln9580">      }</a>
<a name="ln9581">    }</a>
<a name="ln9582"> </a>
<a name="ln9583">    xfree(ptrs);</a>
<a name="ln9584">  }</a>
<a name="ln9585"> </a>
<a name="ln9586">theend:</a>
<a name="ln9587">  sortinfo = old_sortinfo;</a>
<a name="ln9588">}</a>
<a name="ln9589"> </a>
<a name="ln9590">/// &quot;sort&quot;({list})&quot; function</a>
<a name="ln9591">static void f_sort(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln9592">{</a>
<a name="ln9593">  do_sort_uniq(argvars, rettv, true);</a>
<a name="ln9594">}</a>
<a name="ln9595"> </a>
<a name="ln9596">/// &quot;stdioopen()&quot; function</a>
<a name="ln9597">static void f_stdioopen(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln9598">{</a>
<a name="ln9599">  if (argvars[0].v_type != VAR_DICT) {</a>
<a name="ln9600">    EMSG(_(e_invarg));</a>
<a name="ln9601">    return;</a>
<a name="ln9602">  }</a>
<a name="ln9603"> </a>
<a name="ln9604"> </a>
<a name="ln9605">  bool rpc = false;</a>
<a name="ln9606">  CallbackReader on_stdin = CALLBACK_READER_INIT;</a>
<a name="ln9607">  dict_T *opts = argvars[0].vval.v_dict;</a>
<a name="ln9608">  rpc = tv_dict_get_number(opts, &quot;rpc&quot;) != 0;</a>
<a name="ln9609"> </a>
<a name="ln9610">  if (!tv_dict_get_callback(opts, S_LEN(&quot;on_stdin&quot;), &amp;on_stdin.cb)) {</a>
<a name="ln9611">    return;</a>
<a name="ln9612">  }</a>
<a name="ln9613">  on_stdin.buffered = tv_dict_get_number(opts, &quot;stdin_buffered&quot;);</a>
<a name="ln9614">  if (on_stdin.buffered &amp;&amp; on_stdin.cb.type == kCallbackNone) {</a>
<a name="ln9615">    on_stdin.self = opts;</a>
<a name="ln9616">  }</a>
<a name="ln9617"> </a>
<a name="ln9618">  const char *error;</a>
<a name="ln9619">  uint64_t id = channel_from_stdio(rpc, on_stdin, &amp;error);</a>
<a name="ln9620">  if (!id) {</a>
<a name="ln9621">    EMSG2(e_stdiochan2, error);</a>
<a name="ln9622">  }</a>
<a name="ln9623"> </a>
<a name="ln9624"> </a>
<a name="ln9625">  rettv-&gt;vval.v_number = (varnumber_T)id;</a>
<a name="ln9626">  rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln9627">}</a>
<a name="ln9628"> </a>
<a name="ln9629">/// &quot;uniq({list})&quot; function</a>
<a name="ln9630">static void f_uniq(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln9631">{</a>
<a name="ln9632">  do_sort_uniq(argvars, rettv, false);</a>
<a name="ln9633">}</a>
<a name="ln9634"> </a>
<a name="ln9635">// &quot;reltimefloat()&quot; function</a>
<a name="ln9636">static void f_reltimefloat(typval_T *argvars , typval_T *rettv, FunPtr fptr)</a>
<a name="ln9637">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln9638">{</a>
<a name="ln9639">  proftime_T tm;</a>
<a name="ln9640"> </a>
<a name="ln9641">  rettv-&gt;v_type = VAR_FLOAT;</a>
<a name="ln9642">  rettv-&gt;vval.v_float = 0;</a>
<a name="ln9643">  if (list2proftime(&amp;argvars[0], &amp;tm) == OK) {</a>
<a name="ln9644">    rettv-&gt;vval.v_float = (float_T)profile_signed(tm) / 1000000000.0;</a>
<a name="ln9645">  }</a>
<a name="ln9646">}</a>
<a name="ln9647"> </a>
<a name="ln9648">/*</a>
<a name="ln9649"> * &quot;soundfold({word})&quot; function</a>
<a name="ln9650"> */</a>
<a name="ln9651">static void f_soundfold(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln9652">{</a>
<a name="ln9653">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln9654">  const char *const s = tv_get_string(&amp;argvars[0]);</a>
<a name="ln9655">  rettv-&gt;vval.v_string = (char_u *)eval_soundfold(s);</a>
<a name="ln9656">}</a>
<a name="ln9657"> </a>
<a name="ln9658">/*</a>
<a name="ln9659"> * &quot;spellbadword()&quot; function</a>
<a name="ln9660"> */</a>
<a name="ln9661">static void f_spellbadword(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln9662">{</a>
<a name="ln9663">  const char *word = &quot;&quot;;</a>
<a name="ln9664">  hlf_T attr = HLF_COUNT;</a>
<a name="ln9665">  size_t len = 0;</a>
<a name="ln9666">  const int wo_spell_save = curwin-&gt;w_p_spell;</a>
<a name="ln9667"> </a>
<a name="ln9668">  if (!curwin-&gt;w_p_spell) {</a>
<a name="ln9669">    did_set_spelllang(curwin);</a>
<a name="ln9670">    curwin-&gt;w_p_spell = true;</a>
<a name="ln9671">  }</a>
<a name="ln9672"> </a>
<a name="ln9673">  if (*curwin-&gt;w_s-&gt;b_p_spl == NUL) {</a>
<a name="ln9674">    EMSG(_(e_no_spell));</a>
<a name="ln9675">    curwin-&gt;w_p_spell = wo_spell_save;</a>
<a name="ln9676">    return;</a>
<a name="ln9677">  }</a>
<a name="ln9678"> </a>
<a name="ln9679">  if (argvars[0].v_type == VAR_UNKNOWN) {</a>
<a name="ln9680">    // Find the start and length of the badly spelled word.</a>
<a name="ln9681">    len = spell_move_to(curwin, FORWARD, true, true, &amp;attr);</a>
<a name="ln9682">    if (len != 0) {</a>
<a name="ln9683">      word = (char *)get_cursor_pos_ptr();</a>
<a name="ln9684">      curwin-&gt;w_set_curswant = true;</a>
<a name="ln9685">    }</a>
<a name="ln9686">  } else if (*curbuf-&gt;b_s.b_p_spl != NUL) {</a>
<a name="ln9687">    const char *str = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln9688">    int capcol = -1;</a>
<a name="ln9689"> </a>
<a name="ln9690">    if (str != NULL) {</a>
<a name="ln9691">      // Check the argument for spelling.</a>
<a name="ln9692">      while (*str != NUL) {</a>
<a name="ln9693">        len = spell_check(curwin, (char_u *)str, &amp;attr, &amp;capcol, false);</a>
<a name="ln9694">        if (attr != HLF_COUNT) {</a>
<a name="ln9695">          word = str;</a>
<a name="ln9696">          break;</a>
<a name="ln9697">        }</a>
<a name="ln9698">        str += len;</a>
<a name="ln9699">        capcol -= len;</a>
<a name="ln9700">        len = 0;</a>
<a name="ln9701">      }</a>
<a name="ln9702">    }</a>
<a name="ln9703">  }</a>
<a name="ln9704">  curwin-&gt;w_p_spell = wo_spell_save;</a>
<a name="ln9705"> </a>
<a name="ln9706">  assert(len &lt;= INT_MAX);</a>
<a name="ln9707">  tv_list_alloc_ret(rettv, 2);</a>
<a name="ln9708">  tv_list_append_string(rettv-&gt;vval.v_list, word, len);</a>
<a name="ln9709">  tv_list_append_string(rettv-&gt;vval.v_list,</a>
<a name="ln9710">                        (attr == HLF_SPB ? &quot;bad&quot;</a>
<a name="ln9711">                         : attr == HLF_SPR ? &quot;rare&quot;</a>
<a name="ln9712">                         : attr == HLF_SPL ? &quot;local&quot;</a>
<a name="ln9713">                         : attr == HLF_SPC ? &quot;caps&quot;</a>
<a name="ln9714">                         : NULL), -1);</a>
<a name="ln9715">}</a>
<a name="ln9716"> </a>
<a name="ln9717">/*</a>
<a name="ln9718"> * &quot;spellsuggest()&quot; function</a>
<a name="ln9719"> */</a>
<a name="ln9720">static void f_spellsuggest(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln9721">{</a>
<a name="ln9722">  bool typeerr = false;</a>
<a name="ln9723">  int maxcount;</a>
<a name="ln9724">  garray_T ga = GA_EMPTY_INIT_VALUE;</a>
<a name="ln9725">  bool need_capital = false;</a>
<a name="ln9726">  const int wo_spell_save = curwin-&gt;w_p_spell;</a>
<a name="ln9727"> </a>
<a name="ln9728">  if (!curwin-&gt;w_p_spell) {</a>
<a name="ln9729">    did_set_spelllang(curwin);</a>
<a name="ln9730">    curwin-&gt;w_p_spell = true;</a>
<a name="ln9731">  }</a>
<a name="ln9732"> </a>
<a name="ln9733">  if (*curwin-&gt;w_s-&gt;b_p_spl == NUL) {</a>
<a name="ln9734">    EMSG(_(e_no_spell));</a>
<a name="ln9735">    curwin-&gt;w_p_spell = wo_spell_save;</a>
<a name="ln9736">    return;</a>
<a name="ln9737">  }</a>
<a name="ln9738"> </a>
<a name="ln9739">  if (*curwin-&gt;w_s-&gt;b_p_spl != NUL) {</a>
<a name="ln9740">    const char *const str = tv_get_string(&amp;argvars[0]);</a>
<a name="ln9741">    if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln9742">      maxcount = tv_get_number_chk(&amp;argvars[1], &amp;typeerr);</a>
<a name="ln9743">      if (maxcount &lt;= 0) {</a>
<a name="ln9744">        goto f_spellsuggest_return;</a>
<a name="ln9745">      }</a>
<a name="ln9746">      if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln9747">        need_capital = tv_get_number_chk(&amp;argvars[2], &amp;typeerr);</a>
<a name="ln9748">        if (typeerr) {</a>
<a name="ln9749">          goto f_spellsuggest_return;</a>
<a name="ln9750">        }</a>
<a name="ln9751">      }</a>
<a name="ln9752">    } else {</a>
<a name="ln9753">      maxcount = 25;</a>
<a name="ln9754">    }</a>
<a name="ln9755"> </a>
<a name="ln9756">    spell_suggest_list(&amp;ga, (char_u *)str, maxcount, need_capital, false);</a>
<a name="ln9757">  }</a>
<a name="ln9758"> </a>
<a name="ln9759">f_spellsuggest_return:</a>
<a name="ln9760">  tv_list_alloc_ret(rettv, (ptrdiff_t)ga.ga_len);</a>
<a name="ln9761">  for (int i = 0; i &lt; ga.ga_len; i++) {</a>
<a name="ln9762">    char *const p = ((char **)ga.ga_data)[i];</a>
<a name="ln9763">    tv_list_append_allocated_string(rettv-&gt;vval.v_list, p);</a>
<a name="ln9764">  }</a>
<a name="ln9765">  ga_clear(&amp;ga);</a>
<a name="ln9766">  curwin-&gt;w_p_spell = wo_spell_save;</a>
<a name="ln9767">}</a>
<a name="ln9768"> </a>
<a name="ln9769">static void f_split(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln9770">{</a>
<a name="ln9771">  char_u      *save_cpo;</a>
<a name="ln9772">  int match;</a>
<a name="ln9773">  colnr_T col = 0;</a>
<a name="ln9774">  bool keepempty = false;</a>
<a name="ln9775">  bool typeerr = false;</a>
<a name="ln9776"> </a>
<a name="ln9777">  // Make 'cpoptions' empty, the 'l' flag should not be used here.</a>
<a name="ln9778">  save_cpo = p_cpo;</a>
<a name="ln9779">  p_cpo = (char_u *)&quot;&quot;;</a>
<a name="ln9780"> </a>
<a name="ln9781">  const char *str = tv_get_string(&amp;argvars[0]);</a>
<a name="ln9782">  const char *pat = NULL;</a>
<a name="ln9783">  char patbuf[NUMBUFLEN];</a>
<a name="ln9784">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln9785">    pat = tv_get_string_buf_chk(&amp;argvars[1], patbuf);</a>
<a name="ln9786">    if (pat == NULL) {</a>
<a name="ln9787">      typeerr = true;</a>
<a name="ln9788">    }</a>
<a name="ln9789">    if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln9790">      keepempty = (bool)tv_get_number_chk(&amp;argvars[2], &amp;typeerr);</a>
<a name="ln9791">    }</a>
<a name="ln9792">  }</a>
<a name="ln9793">  if (pat == NULL || *pat == NUL) {</a>
<a name="ln9794">    pat = &quot;[\\x01- ]\\+&quot;;</a>
<a name="ln9795">  }</a>
<a name="ln9796"> </a>
<a name="ln9797">  tv_list_alloc_ret(rettv, kListLenMayKnow);</a>
<a name="ln9798"> </a>
<a name="ln9799">  if (typeerr) {</a>
<a name="ln9800">    goto theend;</a>
<a name="ln9801">  }</a>
<a name="ln9802"> </a>
<a name="ln9803">  regmatch_T regmatch = {</a>
<a name="ln9804">    .regprog = vim_regcomp((char_u *)pat, RE_MAGIC + RE_STRING),</a>
<a name="ln9805">    .startp = { NULL },</a>
<a name="ln9806">    .endp = { NULL },</a>
<a name="ln9807">    .rm_ic = false,</a>
<a name="ln9808">  };</a>
<a name="ln9809">  if (regmatch.regprog != NULL) {</a>
<a name="ln9810">    while (*str != NUL || keepempty) {</a>
<a name="ln9811">      if (*str == NUL) {</a>
<a name="ln9812">        match = false;  // Empty item at the end.</a>
<a name="ln9813">      } else {</a>
<a name="ln9814">        match = vim_regexec_nl(&amp;regmatch, (char_u *)str, col);</a>
<a name="ln9815">      }</a>
<a name="ln9816">      const char *end;</a>
<a name="ln9817">      if (match) {</a>
<a name="ln9818">        end = (const char *)regmatch.startp[0];</a>
<a name="ln9819">      } else {</a>
<a name="ln9820">        end = str + strlen(str);</a>
<a name="ln9821">      }</a>
<a name="ln9822">      if (keepempty || end &gt; str || (tv_list_len(rettv-&gt;vval.v_list) &gt; 0</a>
<a name="ln9823">                                     &amp;&amp; *str != NUL</a>
<a name="ln9824">                                     &amp;&amp; match</a>
<a name="ln9825">                                     &amp;&amp; end &lt; (const char *)regmatch.endp[0])) {</a>
<a name="ln9826">        tv_list_append_string(rettv-&gt;vval.v_list, str, end - str);</a>
<a name="ln9827">      }</a>
<a name="ln9828">      if (!match) {</a>
<a name="ln9829">        break;</a>
<a name="ln9830">      }</a>
<a name="ln9831">      // Advance to just after the match.</a>
<a name="ln9832">      if (regmatch.endp[0] &gt; (char_u *)str) {</a>
<a name="ln9833">        col = 0;</a>
<a name="ln9834">      } else {</a>
<a name="ln9835">        // Don't get stuck at the same match.</a>
<a name="ln9836">        col = (*mb_ptr2len)(regmatch.endp[0]);</a>
<a name="ln9837">      }</a>
<a name="ln9838">      str = (const char *)regmatch.endp[0];</a>
<a name="ln9839">    }</a>
<a name="ln9840"> </a>
<a name="ln9841">    vim_regfree(regmatch.regprog);</a>
<a name="ln9842">  }</a>
<a name="ln9843"> </a>
<a name="ln9844">theend:</a>
<a name="ln9845">  p_cpo = save_cpo;</a>
<a name="ln9846">}</a>
<a name="ln9847"> </a>
<a name="ln9848">/// &quot;stdpath(type)&quot; function</a>
<a name="ln9849">static void f_stdpath(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln9850">{</a>
<a name="ln9851">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln9852">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln9853"> </a>
<a name="ln9854">  const char *const p = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln9855">  if (p == NULL) {</a>
<a name="ln9856">    return;  // Type error; errmsg already given.</a>
<a name="ln9857">  }</a>
<a name="ln9858"> </a>
<a name="ln9859">  if (strequal(p, &quot;config&quot;)) {</a>
<a name="ln9860">    rettv-&gt;vval.v_string = (char_u *)get_xdg_home(kXDGConfigHome);</a>
<a name="ln9861">  } else if (strequal(p, &quot;data&quot;)) {</a>
<a name="ln9862">    rettv-&gt;vval.v_string = (char_u *)get_xdg_home(kXDGDataHome);</a>
<a name="ln9863">  } else if (strequal(p, &quot;cache&quot;)) {</a>
<a name="ln9864">    rettv-&gt;vval.v_string = (char_u *)get_xdg_home(kXDGCacheHome);</a>
<a name="ln9865">  } else if (strequal(p, &quot;config_dirs&quot;)) {</a>
<a name="ln9866">    get_xdg_var_list(kXDGConfigDirs, rettv);</a>
<a name="ln9867">  } else if (strequal(p, &quot;data_dirs&quot;)) {</a>
<a name="ln9868">    get_xdg_var_list(kXDGDataDirs, rettv);</a>
<a name="ln9869">  } else {</a>
<a name="ln9870">    EMSG2(_(&quot;E6100: \&quot;%s\&quot; is not a valid stdpath&quot;), p);</a>
<a name="ln9871">  }</a>
<a name="ln9872">}</a>
<a name="ln9873"> </a>
<a name="ln9874">/*</a>
<a name="ln9875"> * &quot;str2float()&quot; function</a>
<a name="ln9876"> */</a>
<a name="ln9877">static void f_str2float(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln9878">{</a>
<a name="ln9879">  char_u *p = skipwhite((const char_u *)tv_get_string(&amp;argvars[0]));</a>
<a name="ln9880">  bool isneg = (*p == '-');</a>
<a name="ln9881"> </a>
<a name="ln9882">  if (*p == '+' || *p == '-') {</a>
<a name="ln9883">    p = skipwhite(p + 1);</a>
<a name="ln9884">  }</a>
<a name="ln9885">  (void)string2float((char *)p, &amp;rettv-&gt;vval.v_float);</a>
<a name="ln9886">  if (isneg) {</a>
<a name="ln9887">    rettv-&gt;vval.v_float *= -1;</a>
<a name="ln9888">  }</a>
<a name="ln9889">  rettv-&gt;v_type = VAR_FLOAT;</a>
<a name="ln9890">}</a>
<a name="ln9891"> </a>
<a name="ln9892">// &quot;str2list()&quot; function</a>
<a name="ln9893">static void f_str2list(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln9894">{</a>
<a name="ln9895">  tv_list_alloc_ret(rettv, kListLenUnknown);</a>
<a name="ln9896">  const char_u *p = (const char_u *)tv_get_string(&amp;argvars[0]);</a>
<a name="ln9897"> </a>
<a name="ln9898">  for (; *p != NUL; p += utf_ptr2len(p)) {</a>
<a name="ln9899">    tv_list_append_number(rettv-&gt;vval.v_list, utf_ptr2char(p));</a>
<a name="ln9900">  }</a>
<a name="ln9901">}</a>
<a name="ln9902"> </a>
<a name="ln9903">// &quot;str2nr()&quot; function</a>
<a name="ln9904">static void f_str2nr(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln9905">{</a>
<a name="ln9906">  int base = 10;</a>
<a name="ln9907">  varnumber_T n;</a>
<a name="ln9908">  int what;</a>
<a name="ln9909"> </a>
<a name="ln9910">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln9911">    base = tv_get_number(&amp;argvars[1]);</a>
<a name="ln9912">    if (base != 2 &amp;&amp; base != 8 &amp;&amp; base != 10 &amp;&amp; base != 16) {</a>
<a name="ln9913">      EMSG(_(e_invarg));</a>
<a name="ln9914">      return;</a>
<a name="ln9915">    }</a>
<a name="ln9916">  }</a>
<a name="ln9917"> </a>
<a name="ln9918">  char_u *p = skipwhite((const char_u *)tv_get_string(&amp;argvars[0]));</a>
<a name="ln9919">  bool isneg = (*p == '-');</a>
<a name="ln9920">  if (*p == '+' || *p == '-') {</a>
<a name="ln9921">    p = skipwhite(p + 1);</a>
<a name="ln9922">  }</a>
<a name="ln9923">  switch (base) {</a>
<a name="ln9924">    case 2: {</a>
<a name="ln9925">      what = STR2NR_BIN | STR2NR_FORCE;</a>
<a name="ln9926">      break;</a>
<a name="ln9927">    }</a>
<a name="ln9928">    case 8: {</a>
<a name="ln9929">      what = STR2NR_OCT | STR2NR_FORCE;</a>
<a name="ln9930">      break;</a>
<a name="ln9931">    }</a>
<a name="ln9932">    case 16: {</a>
<a name="ln9933">      what = STR2NR_HEX | STR2NR_FORCE;</a>
<a name="ln9934">      break;</a>
<a name="ln9935">    }</a>
<a name="ln9936">    default: {</a>
<a name="ln9937">      what = 0;</a>
<a name="ln9938">    }</a>
<a name="ln9939">  }</a>
<a name="ln9940">  vim_str2nr(p, NULL, NULL, what, &amp;n, NULL, 0);</a>
<a name="ln9941">  if (isneg) {</a>
<a name="ln9942">    rettv-&gt;vval.v_number = -n;</a>
<a name="ln9943">  } else {</a>
<a name="ln9944">    rettv-&gt;vval.v_number = n;</a>
<a name="ln9945">  }</a>
<a name="ln9946">}</a>
<a name="ln9947"> </a>
<a name="ln9948">/*</a>
<a name="ln9949"> * &quot;strftime({format}[, {time}])&quot; function</a>
<a name="ln9950"> */</a>
<a name="ln9951">static void f_strftime(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln9952">{</a>
<a name="ln9953">  time_t seconds;</a>
<a name="ln9954"> </a>
<a name="ln9955">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln9956"> </a>
<a name="ln9957">  char *p = (char *)tv_get_string(&amp;argvars[0]);</a>
<a name="ln9958">  if (argvars[1].v_type == VAR_UNKNOWN) {</a>
<a name="ln9959">    seconds = time(NULL);</a>
<a name="ln9960">  } else {</a>
<a name="ln9961">    seconds = (time_t)tv_get_number(&amp;argvars[1]);</a>
<a name="ln9962">  }</a>
<a name="ln9963"> </a>
<a name="ln9964">  struct tm curtime;</a>
<a name="ln9965">  struct tm *curtime_ptr = os_localtime_r(&amp;seconds, &amp;curtime);</a>
<a name="ln9966">  // MSVC returns NULL for an invalid value of seconds.</a>
<a name="ln9967">  if (curtime_ptr == NULL) {</a>
<a name="ln9968">    rettv-&gt;vval.v_string = vim_strsave((char_u *)_(&quot;(Invalid)&quot;));</a>
<a name="ln9969">  } else {</a>
<a name="ln9970">    vimconv_T conv;</a>
<a name="ln9971">    char_u      *enc;</a>
<a name="ln9972"> </a>
<a name="ln9973">    conv.vc_type = CONV_NONE;</a>
<a name="ln9974">    enc = enc_locale();</a>
<a name="ln9975">    convert_setup(&amp;conv, p_enc, enc);</a>
<a name="ln9976">    if (conv.vc_type != CONV_NONE) {</a>
<a name="ln9977">      p = (char *)string_convert(&amp;conv, (char_u *)p, NULL);</a>
<a name="ln9978">    }</a>
<a name="ln9979">    char result_buf[256];</a>
<a name="ln9980">    if (p != NULL) {</a>
<a name="ln9981">      (void)strftime(result_buf, sizeof(result_buf), p, curtime_ptr);</a>
<a name="ln9982">    } else {</a>
<a name="ln9983">      result_buf[0] = NUL;</a>
<a name="ln9984">    }</a>
<a name="ln9985"> </a>
<a name="ln9986">    if (conv.vc_type != CONV_NONE) {</a>
<a name="ln9987">      xfree(p);</a>
<a name="ln9988">    }</a>
<a name="ln9989">    convert_setup(&amp;conv, enc, p_enc);</a>
<a name="ln9990">    if (conv.vc_type != CONV_NONE) {</a>
<a name="ln9991">      rettv-&gt;vval.v_string = string_convert(&amp;conv, (char_u *)result_buf, NULL);</a>
<a name="ln9992">    } else {</a>
<a name="ln9993">      rettv-&gt;vval.v_string = (char_u *)xstrdup(result_buf);</a>
<a name="ln9994">    }</a>
<a name="ln9995"> </a>
<a name="ln9996">    // Release conversion descriptors.</a>
<a name="ln9997">    convert_setup(&amp;conv, NULL, NULL);</a>
<a name="ln9998">    xfree(enc);</a>
<a name="ln9999">  }</a>
<a name="ln10000">}</a>
<a name="ln10001"> </a>
<a name="ln10002">// &quot;strgetchar()&quot; function</a>
<a name="ln10003">static void f_strgetchar(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10004">{</a>
<a name="ln10005">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln10006"> </a>
<a name="ln10007">  const char *const str = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln10008">  if (str == NULL) {</a>
<a name="ln10009">    return;</a>
<a name="ln10010">  }</a>
<a name="ln10011">  bool error = false;</a>
<a name="ln10012">  varnumber_T charidx = tv_get_number_chk(&amp;argvars[1], &amp;error);</a>
<a name="ln10013">  if (error) {</a>
<a name="ln10014">    return;</a>
<a name="ln10015">  }</a>
<a name="ln10016"> </a>
<a name="ln10017">  const size_t len = STRLEN(str);</a>
<a name="ln10018">  size_t byteidx = 0;</a>
<a name="ln10019"> </a>
<a name="ln10020">  while (charidx &gt;= 0 &amp;&amp; byteidx &lt; len) {</a>
<a name="ln10021">    if (charidx == 0) {</a>
<a name="ln10022">      rettv-&gt;vval.v_number = utf_ptr2char((const char_u *)str + byteidx);</a>
<a name="ln10023">      break;</a>
<a name="ln10024">    }</a>
<a name="ln10025">    charidx--;</a>
<a name="ln10026">    byteidx += MB_CPTR2LEN((const char_u *)str + byteidx);</a>
<a name="ln10027">  }</a>
<a name="ln10028">}</a>
<a name="ln10029"> </a>
<a name="ln10030">/*</a>
<a name="ln10031"> * &quot;stridx()&quot; function</a>
<a name="ln10032"> */</a>
<a name="ln10033">static void f_stridx(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10034">{</a>
<a name="ln10035">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln10036"> </a>
<a name="ln10037">  char buf[NUMBUFLEN];</a>
<a name="ln10038">  const char *const needle = tv_get_string_chk(&amp;argvars[1]);</a>
<a name="ln10039">  const char *haystack = tv_get_string_buf_chk(&amp;argvars[0], buf);</a>
<a name="ln10040">  const char *const haystack_start = haystack;</a>
<a name="ln10041">  if (needle == NULL || haystack == NULL) {</a>
<a name="ln10042">    return;  // Type error; errmsg already given.</a>
<a name="ln10043">  }</a>
<a name="ln10044"> </a>
<a name="ln10045">  if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln10046">    bool error = false;</a>
<a name="ln10047"> </a>
<a name="ln10048">    const ptrdiff_t start_idx = (ptrdiff_t)tv_get_number_chk(&amp;argvars[2],</a>
<a name="ln10049">                                                             &amp;error);</a>
<a name="ln10050">    if (error || start_idx &gt;= (ptrdiff_t)strlen(haystack)) {</a>
<a name="ln10051">      return;</a>
<a name="ln10052">    }</a>
<a name="ln10053">    if (start_idx &gt;= 0) {</a>
<a name="ln10054">      haystack += start_idx;</a>
<a name="ln10055">    }</a>
<a name="ln10056">  }</a>
<a name="ln10057"> </a>
<a name="ln10058">  const char *pos = strstr(haystack, needle);</a>
<a name="ln10059">  if (pos != NULL) {</a>
<a name="ln10060">    rettv-&gt;vval.v_number = (varnumber_T)(pos - haystack_start);</a>
<a name="ln10061">  }</a>
<a name="ln10062">}</a>
<a name="ln10063"> </a>
<a name="ln10064">/*</a>
<a name="ln10065"> * &quot;string()&quot; function</a>
<a name="ln10066"> */</a>
<a name="ln10067">void f_string(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10068">{</a>
<a name="ln10069">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln10070">  rettv-&gt;vval.v_string = (char_u *)encode_tv2string(&amp;argvars[0], NULL);</a>
<a name="ln10071">}</a>
<a name="ln10072"> </a>
<a name="ln10073">/*</a>
<a name="ln10074"> * &quot;strlen()&quot; function</a>
<a name="ln10075"> */</a>
<a name="ln10076">static void f_strlen(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10077">{</a>
<a name="ln10078">  rettv-&gt;vval.v_number = (varnumber_T)strlen(tv_get_string(&amp;argvars[0]));</a>
<a name="ln10079">}</a>
<a name="ln10080"> </a>
<a name="ln10081">/*</a>
<a name="ln10082"> * &quot;strchars()&quot; function</a>
<a name="ln10083"> */</a>
<a name="ln10084">static void f_strchars(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10085">{</a>
<a name="ln10086">  const char *s = tv_get_string(&amp;argvars[0]);</a>
<a name="ln10087">  int skipcc = 0;</a>
<a name="ln10088">  varnumber_T len = 0;</a>
<a name="ln10089">  int (*func_mb_ptr2char_adv)(const char_u **pp);</a>
<a name="ln10090"> </a>
<a name="ln10091">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln10092">    skipcc = tv_get_number_chk(&amp;argvars[1], NULL);</a>
<a name="ln10093">  }</a>
<a name="ln10094">  if (skipcc &lt; 0 || skipcc &gt; 1) {</a>
<a name="ln10095">    EMSG(_(e_invarg));</a>
<a name="ln10096">  } else {</a>
<a name="ln10097">    func_mb_ptr2char_adv = skipcc ? mb_ptr2char_adv : mb_cptr2char_adv;</a>
<a name="ln10098">    while (*s != NUL) {</a>
<a name="ln10099">      func_mb_ptr2char_adv((const char_u **)&amp;s);</a>
<a name="ln10100">      len++;</a>
<a name="ln10101">    }</a>
<a name="ln10102">    rettv-&gt;vval.v_number = len;</a>
<a name="ln10103">  }</a>
<a name="ln10104">}</a>
<a name="ln10105"> </a>
<a name="ln10106">/*</a>
<a name="ln10107"> * &quot;strdisplaywidth()&quot; function</a>
<a name="ln10108"> */</a>
<a name="ln10109">static void f_strdisplaywidth(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10110">{</a>
<a name="ln10111">  const char *const s = tv_get_string(&amp;argvars[0]);</a>
<a name="ln10112">  int col = 0;</a>
<a name="ln10113"> </a>
<a name="ln10114">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln10115">    col = tv_get_number(&amp;argvars[1]);</a>
<a name="ln10116">  }</a>
<a name="ln10117"> </a>
<a name="ln10118">  rettv-&gt;vval.v_number = (varnumber_T)(linetabsize_col(col, (char_u *)s) - col);</a>
<a name="ln10119">}</a>
<a name="ln10120"> </a>
<a name="ln10121">/*</a>
<a name="ln10122"> * &quot;strwidth()&quot; function</a>
<a name="ln10123"> */</a>
<a name="ln10124">static void f_strwidth(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10125">{</a>
<a name="ln10126">  const char *const s = tv_get_string(&amp;argvars[0]);</a>
<a name="ln10127"> </a>
<a name="ln10128">  rettv-&gt;vval.v_number = (varnumber_T)mb_string2cells((const char_u *)s);</a>
<a name="ln10129">}</a>
<a name="ln10130"> </a>
<a name="ln10131">// &quot;strcharpart()&quot; function</a>
<a name="ln10132">static void f_strcharpart(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10133">{</a>
<a name="ln10134">  const char *const p = tv_get_string(&amp;argvars[0]);</a>
<a name="ln10135">  const size_t slen = STRLEN(p);</a>
<a name="ln10136"> </a>
<a name="ln10137">  int nbyte = 0;</a>
<a name="ln10138">  bool error = false;</a>
<a name="ln10139">  varnumber_T nchar = tv_get_number_chk(&amp;argvars[1], &amp;error);</a>
<a name="ln10140">  if (!error) {</a>
<a name="ln10141">    if (nchar &gt; 0) {</a>
<a name="ln10142">      while (nchar &gt; 0 &amp;&amp; (size_t)nbyte &lt; slen) {</a>
<a name="ln10143">        nbyte += MB_CPTR2LEN((const char_u *)p + nbyte);</a>
<a name="ln10144">        nchar--;</a>
<a name="ln10145">      }</a>
<a name="ln10146">    } else {</a>
<a name="ln10147">      nbyte = nchar;</a>
<a name="ln10148">    }</a>
<a name="ln10149">  }</a>
<a name="ln10150">  int len = 0;</a>
<a name="ln10151">  if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln10152">    int charlen = tv_get_number(&amp;argvars[2]);</a>
<a name="ln10153">    while (charlen &gt; 0 &amp;&amp; nbyte + len &lt; (int)slen) {</a>
<a name="ln10154">      int off = nbyte + len;</a>
<a name="ln10155"> </a>
<a name="ln10156">      if (off &lt; 0) {</a>
<a name="ln10157">        len += 1;</a>
<a name="ln10158">      } else {</a>
<a name="ln10159">        len += (size_t)MB_CPTR2LEN((const char_u *)p + off);</a>
<a name="ln10160">      }</a>
<a name="ln10161">      charlen--;</a>
<a name="ln10162">    }</a>
<a name="ln10163">  } else {</a>
<a name="ln10164">    len = slen - nbyte;    // default: all bytes that are available.</a>
<a name="ln10165">  }</a>
<a name="ln10166"> </a>
<a name="ln10167">  // Only return the overlap between the specified part and the actual</a>
<a name="ln10168">  // string.</a>
<a name="ln10169">  if (nbyte &lt; 0) {</a>
<a name="ln10170">    len += nbyte;</a>
<a name="ln10171">    nbyte = 0;</a>
<a name="ln10172">  } else if ((size_t)nbyte &gt; slen) {</a>
<a name="ln10173">    nbyte = slen;</a>
<a name="ln10174">  }</a>
<a name="ln10175">  if (len &lt; 0) {</a>
<a name="ln10176">    len = 0;</a>
<a name="ln10177">  } else if (nbyte + len &gt; (int)slen) {</a>
<a name="ln10178">    len = slen - nbyte;</a>
<a name="ln10179">  }</a>
<a name="ln10180"> </a>
<a name="ln10181">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln10182">  rettv-&gt;vval.v_string = (char_u *)xstrndup(p + nbyte, (size_t)len);</a>
<a name="ln10183">}</a>
<a name="ln10184"> </a>
<a name="ln10185">/*</a>
<a name="ln10186"> * &quot;strpart()&quot; function</a>
<a name="ln10187"> */</a>
<a name="ln10188">static void f_strpart(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10189">{</a>
<a name="ln10190">  bool error = false;</a>
<a name="ln10191"> </a>
<a name="ln10192">  const char *const p = tv_get_string(&amp;argvars[0]);</a>
<a name="ln10193">  const size_t slen = strlen(p);</a>
<a name="ln10194"> </a>
<a name="ln10195">  varnumber_T n = tv_get_number_chk(&amp;argvars[1], &amp;error);</a>
<a name="ln10196">  varnumber_T len;</a>
<a name="ln10197">  if (error) {</a>
<a name="ln10198">    len = 0;</a>
<a name="ln10199">  } else if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln10200">    len = tv_get_number(&amp;argvars[2]);</a>
<a name="ln10201">  } else {</a>
<a name="ln10202">    len = slen - n;  // Default len: all bytes that are available.</a>
<a name="ln10203">  }</a>
<a name="ln10204"> </a>
<a name="ln10205">  // Only return the overlap between the specified part and the actual</a>
<a name="ln10206">  // string.</a>
<a name="ln10207">  if (n &lt; 0) {</a>
<a name="ln10208">    len += n;</a>
<a name="ln10209">    n = 0;</a>
<a name="ln10210">  } else if (n &gt; (varnumber_T)slen) {</a>
<a name="ln10211">    n = slen;</a>
<a name="ln10212">  }</a>
<a name="ln10213">  if (len &lt; 0) {</a>
<a name="ln10214">    len = 0;</a>
<a name="ln10215">  } else if (n + len &gt; (varnumber_T)slen) {</a>
<a name="ln10216">    len = slen - n;</a>
<a name="ln10217">  }</a>
<a name="ln10218"> </a>
<a name="ln10219">  if (argvars[2].v_type != VAR_UNKNOWN &amp;&amp; argvars[3].v_type != VAR_UNKNOWN) {</a>
<a name="ln10220">    int off;</a>
<a name="ln10221"> </a>
<a name="ln10222">    // length in characters</a>
<a name="ln10223">    for (off = n; off &lt; (int)slen &amp;&amp; len &gt; 0; len--) {</a>
<a name="ln10224">      off += utfc_ptr2len((char_u *)p + off);</a>
<a name="ln10225">    }</a>
<a name="ln10226">    len = off - n;</a>
<a name="ln10227">  }</a>
<a name="ln10228"> </a>
<a name="ln10229">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln10230">  rettv-&gt;vval.v_string = (char_u *)xmemdupz(p + n, (size_t)len);</a>
<a name="ln10231">}</a>
<a name="ln10232"> </a>
<a name="ln10233">// &quot;strptime({format}, {timestring})&quot; function</a>
<a name="ln10234">static void f_strptime(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10235">{</a>
<a name="ln10236">  char fmt_buf[NUMBUFLEN];</a>
<a name="ln10237">  char str_buf[NUMBUFLEN];</a>
<a name="ln10238"> </a>
<a name="ln10239">  struct tm tmval = {</a>
<a name="ln10240">    .tm_isdst = -1,</a>
<a name="ln10241">  };</a>
<a name="ln10242">  char *fmt = (char *)tv_get_string_buf(&amp;argvars[0], fmt_buf);</a>
<a name="ln10243">  char *str = (char *)tv_get_string_buf(&amp;argvars[1], str_buf);</a>
<a name="ln10244"> </a>
<a name="ln10245">  vimconv_T conv = {</a>
<a name="ln10246">    .vc_type = CONV_NONE,</a>
<a name="ln10247">  };</a>
<a name="ln10248">  char_u *enc = enc_locale();</a>
<a name="ln10249">  convert_setup(&amp;conv, p_enc, enc);</a>
<a name="ln10250">  if (conv.vc_type != CONV_NONE) {</a>
<a name="ln10251">    fmt = (char *)string_convert(&amp;conv, (char_u *)fmt, NULL);</a>
<a name="ln10252">  }</a>
<a name="ln10253">  if (fmt == NULL</a>
<a name="ln10254">      || os_strptime(str, fmt, &amp;tmval) == NULL</a>
<a name="ln10255">      || (rettv-&gt;vval.v_number = mktime(&amp;tmval)) == -1) {</a>
<a name="ln10256">    rettv-&gt;vval.v_number = 0;</a>
<a name="ln10257">  }</a>
<a name="ln10258">  if (conv.vc_type != CONV_NONE) {</a>
<a name="ln10259">    xfree(fmt);</a>
<a name="ln10260">  }</a>
<a name="ln10261">  convert_setup(&amp;conv, NULL, NULL);</a>
<a name="ln10262">  xfree(enc);</a>
<a name="ln10263">}</a>
<a name="ln10264"> </a>
<a name="ln10265">/*</a>
<a name="ln10266"> * &quot;strridx()&quot; function</a>
<a name="ln10267"> */</a>
<a name="ln10268">static void f_strridx(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10269">{</a>
<a name="ln10270">  char buf[NUMBUFLEN];</a>
<a name="ln10271">  const char *const needle = tv_get_string_chk(&amp;argvars[1]);</a>
<a name="ln10272">  const char *const haystack = tv_get_string_buf_chk(&amp;argvars[0], buf);</a>
<a name="ln10273"> </a>
<a name="ln10274">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln10275">  if (needle == NULL || haystack == NULL) {</a>
<a name="ln10276">    return;  // Type error; errmsg already given.</a>
<a name="ln10277">  }</a>
<a name="ln10278"> </a>
<a name="ln10279">  const size_t haystack_len = STRLEN(haystack);</a>
<a name="ln10280">  ptrdiff_t end_idx;</a>
<a name="ln10281">  if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln10282">    // Third argument: upper limit for index.</a>
<a name="ln10283">    end_idx = (ptrdiff_t)tv_get_number_chk(&amp;argvars[2], NULL);</a>
<a name="ln10284">    if (end_idx &lt; 0) {</a>
<a name="ln10285">      return;  // Can never find a match.</a>
<a name="ln10286">    }</a>
<a name="ln10287">  } else {</a>
<a name="ln10288">    end_idx = (ptrdiff_t)haystack_len;</a>
<a name="ln10289">  }</a>
<a name="ln10290"> </a>
<a name="ln10291">  const char *lastmatch = NULL;</a>
<a name="ln10292">  if (*needle == NUL) {</a>
<a name="ln10293">    // Empty string matches past the end.</a>
<a name="ln10294">    lastmatch = haystack + end_idx;</a>
<a name="ln10295">  } else {</a>
<a name="ln10296">    for (const char *rest = haystack; *rest != NUL; rest++) {</a>
<a name="ln10297">      rest = strstr(rest, needle);</a>
<a name="ln10298">      if (rest == NULL || rest &gt; haystack + end_idx) {</a>
<a name="ln10299">        break;</a>
<a name="ln10300">      }</a>
<a name="ln10301">      lastmatch = rest;</a>
<a name="ln10302">    }</a>
<a name="ln10303">  }</a>
<a name="ln10304"> </a>
<a name="ln10305">  if (lastmatch != NULL) {</a>
<a name="ln10306">    rettv-&gt;vval.v_number = (varnumber_T)(lastmatch - haystack);</a>
<a name="ln10307">  }</a>
<a name="ln10308">}</a>
<a name="ln10309"> </a>
<a name="ln10310">/*</a>
<a name="ln10311"> * &quot;strtrans()&quot; function</a>
<a name="ln10312"> */</a>
<a name="ln10313">static void f_strtrans(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10314">{</a>
<a name="ln10315">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln10316">  rettv-&gt;vval.v_string = (char_u *)transstr(tv_get_string(&amp;argvars[0]));</a>
<a name="ln10317">}</a>
<a name="ln10318"> </a>
<a name="ln10319">/*</a>
<a name="ln10320"> * &quot;submatch()&quot; function</a>
<a name="ln10321"> */</a>
<a name="ln10322">static void f_submatch(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10323">{</a>
<a name="ln10324">  bool error = false;</a>
<a name="ln10325">  int no = (int)tv_get_number_chk(&amp;argvars[0], &amp;error);</a>
<a name="ln10326">  if (error) {</a>
<a name="ln10327">    return;</a>
<a name="ln10328">  }</a>
<a name="ln10329"> </a>
<a name="ln10330">  if (no &lt; 0 || no &gt;= NSUBEXP) {</a>
<a name="ln10331">    emsgf(_(&quot;E935: invalid submatch number: %d&quot;), no);</a>
<a name="ln10332">    return;</a>
<a name="ln10333">  }</a>
<a name="ln10334">  int retList = 0;</a>
<a name="ln10335"> </a>
<a name="ln10336">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln10337">    retList = tv_get_number_chk(&amp;argvars[1], &amp;error);</a>
<a name="ln10338">    if (error) {</a>
<a name="ln10339">      return;</a>
<a name="ln10340">    }</a>
<a name="ln10341">  }</a>
<a name="ln10342"> </a>
<a name="ln10343">  if (retList == 0) {</a>
<a name="ln10344">    rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln10345">    rettv-&gt;vval.v_string = reg_submatch(no);</a>
<a name="ln10346">  } else {</a>
<a name="ln10347">    rettv-&gt;v_type = VAR_LIST;</a>
<a name="ln10348">    rettv-&gt;vval.v_list = reg_submatch_list(no);</a>
<a name="ln10349">  }</a>
<a name="ln10350">}</a>
<a name="ln10351"> </a>
<a name="ln10352">/*</a>
<a name="ln10353"> * &quot;substitute()&quot; function</a>
<a name="ln10354"> */</a>
<a name="ln10355">static void f_substitute(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10356">{</a>
<a name="ln10357">  char patbuf[NUMBUFLEN];</a>
<a name="ln10358">  char subbuf[NUMBUFLEN];</a>
<a name="ln10359">  char flagsbuf[NUMBUFLEN];</a>
<a name="ln10360"> </a>
<a name="ln10361">  const char *const str = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln10362">  const char *const pat = tv_get_string_buf_chk(&amp;argvars[1], patbuf);</a>
<a name="ln10363">  const char *sub = NULL;</a>
<a name="ln10364">  const char *const flg = tv_get_string_buf_chk(&amp;argvars[3], flagsbuf);</a>
<a name="ln10365"> </a>
<a name="ln10366">  typval_T *expr = NULL;</a>
<a name="ln10367">  if (tv_is_func(argvars[2])) {</a>
<a name="ln10368">    expr = &amp;argvars[2];</a>
<a name="ln10369">  } else {</a>
<a name="ln10370">    sub = tv_get_string_buf_chk(&amp;argvars[2], subbuf);</a>
<a name="ln10371">  }</a>
<a name="ln10372"> </a>
<a name="ln10373">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln10374">  if (str == NULL || pat == NULL || (sub == NULL &amp;&amp; expr == NULL)</a>
<a name="ln10375">      || flg == NULL) {</a>
<a name="ln10376">    rettv-&gt;vval.v_string = NULL;</a>
<a name="ln10377">  } else {</a>
<a name="ln10378">    rettv-&gt;vval.v_string = do_string_sub((char_u *)str, (char_u *)pat,</a>
<a name="ln10379">                                         (char_u *)sub, expr, (char_u *)flg);</a>
<a name="ln10380">  }</a>
<a name="ln10381">}</a>
<a name="ln10382"> </a>
<a name="ln10383">/// &quot;swapinfo(swap_filename)&quot; function</a>
<a name="ln10384">static void f_swapinfo(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10385">{</a>
<a name="ln10386">  tv_dict_alloc_ret(rettv);</a>
<a name="ln10387">  get_b0_dict(tv_get_string(argvars), rettv-&gt;vval.v_dict);</a>
<a name="ln10388">}</a>
<a name="ln10389"> </a>
<a name="ln10390">/// &quot;swapname(expr)&quot; function</a>
<a name="ln10391">static void f_swapname(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10392">{</a>
<a name="ln10393">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln10394">  buf_T *buf = tv_get_buf(&amp;argvars[0], false);</a>
<a name="ln10395">  if (buf == NULL</a>
<a name="ln10396">      || buf-&gt;b_ml.ml_mfp == NULL</a>
<a name="ln10397">      || buf-&gt;b_ml.ml_mfp-&gt;mf_fname == NULL) {</a>
<a name="ln10398">    rettv-&gt;vval.v_string = NULL;</a>
<a name="ln10399">  } else {</a>
<a name="ln10400">    rettv-&gt;vval.v_string = vim_strsave(buf-&gt;b_ml.ml_mfp-&gt;mf_fname);</a>
<a name="ln10401">  }</a>
<a name="ln10402">}</a>
<a name="ln10403"> </a>
<a name="ln10404">/// &quot;synID(lnum, col, trans)&quot; function</a>
<a name="ln10405">static void f_synID(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10406">{</a>
<a name="ln10407">  // -1 on type error (both)</a>
<a name="ln10408">  const linenr_T lnum = tv_get_lnum(argvars);</a>
<a name="ln10409">  const colnr_T col = (colnr_T)tv_get_number(&amp;argvars[1]) - 1;</a>
<a name="ln10410"> </a>
<a name="ln10411">  bool transerr = false;</a>
<a name="ln10412">  const int trans = tv_get_number_chk(&amp;argvars[2], &amp;transerr);</a>
<a name="ln10413"> </a>
<a name="ln10414">  int id = 0;</a>
<a name="ln10415">  if (!transerr &amp;&amp; lnum &gt;= 1 &amp;&amp; lnum &lt;= curbuf-&gt;b_ml.ml_line_count</a>
<a name="ln10416">      &amp;&amp; col &gt;= 0 &amp;&amp; (size_t)col &lt; STRLEN(ml_get(lnum))) {</a>
<a name="ln10417">    id = syn_get_id(curwin, lnum, col, trans, NULL, false);</a>
<a name="ln10418">  }</a>
<a name="ln10419"> </a>
<a name="ln10420">  rettv-&gt;vval.v_number = id;</a>
<a name="ln10421">}</a>
<a name="ln10422"> </a>
<a name="ln10423">/*</a>
<a name="ln10424"> * &quot;synIDattr(id, what [, mode])&quot; function</a>
<a name="ln10425"> */</a>
<a name="ln10426">static void f_synIDattr(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10427">{</a>
<a name="ln10428">  const int id = (int)tv_get_number(&amp;argvars[0]);</a>
<a name="ln10429">  const char *const what = tv_get_string(&amp;argvars[1]);</a>
<a name="ln10430">  int modec;</a>
<a name="ln10431">  if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln10432">    char modebuf[NUMBUFLEN];</a>
<a name="ln10433">    const char *const mode = tv_get_string_buf(&amp;argvars[2], modebuf);</a>
<a name="ln10434">    modec = TOLOWER_ASC(mode[0]);</a>
<a name="ln10435">    if (modec != 'c' &amp;&amp; modec != 'g') {</a>
<a name="ln10436">      modec = 0;  // Replace invalid with current.</a>
<a name="ln10437">    }</a>
<a name="ln10438">  } else if (ui_rgb_attached()) {</a>
<a name="ln10439">    modec = 'g';</a>
<a name="ln10440">  } else {</a>
<a name="ln10441">    modec = 'c';</a>
<a name="ln10442">  }</a>
<a name="ln10443"> </a>
<a name="ln10444"> </a>
<a name="ln10445">  const char *p = NULL;</a>
<a name="ln10446">  switch (TOLOWER_ASC(what[0])) {</a>
<a name="ln10447">    case 'b': {</a>
<a name="ln10448">      if (TOLOWER_ASC(what[1]) == 'g') {  // bg[#]</a>
<a name="ln10449">        p = highlight_color(id, what, modec);</a>
<a name="ln10450">      } else {  // bold</a>
<a name="ln10451">        p = highlight_has_attr(id, HL_BOLD, modec);</a>
<a name="ln10452">      }</a>
<a name="ln10453">      break;</a>
<a name="ln10454">    }</a>
<a name="ln10455">    case 'f': {  // fg[#] or font</a>
<a name="ln10456">      p = highlight_color(id, what, modec);</a>
<a name="ln10457">      break;</a>
<a name="ln10458">    }</a>
<a name="ln10459">    case 'i': {</a>
<a name="ln10460">      if (TOLOWER_ASC(what[1]) == 'n') {  // inverse</a>
<a name="ln10461">        p = highlight_has_attr(id, HL_INVERSE, modec);</a>
<a name="ln10462">      } else {  // italic</a>
<a name="ln10463">        p = highlight_has_attr(id, HL_ITALIC, modec);</a>
<a name="ln10464">      }</a>
<a name="ln10465">      break;</a>
<a name="ln10466">    }</a>
<a name="ln10467">    case 'n': {  // name</a>
<a name="ln10468">      p = get_highlight_name_ext(NULL, id - 1, false);</a>
<a name="ln10469">      break;</a>
<a name="ln10470">    }</a>
<a name="ln10471">    case 'r': {  // reverse</a>
<a name="ln10472">      p = highlight_has_attr(id, HL_INVERSE, modec);</a>
<a name="ln10473">      break;</a>
<a name="ln10474">    }</a>
<a name="ln10475">    case 's': {</a>
<a name="ln10476">      if (TOLOWER_ASC(what[1]) == 'p') {  // sp[#]</a>
<a name="ln10477">        p = highlight_color(id, what, modec);</a>
<a name="ln10478">      } else if (TOLOWER_ASC(what[1]) == 't'</a>
<a name="ln10479">                 &amp;&amp; TOLOWER_ASC(what[2]) == 'r') {  // strikethrough</a>
<a name="ln10480">        p = highlight_has_attr(id, HL_STRIKETHROUGH, modec);</a>
<a name="ln10481">      } else {  // standout</a>
<a name="ln10482">        p = highlight_has_attr(id, HL_STANDOUT, modec);</a>
<a name="ln10483">      }</a>
<a name="ln10484">      break;</a>
<a name="ln10485">    }</a>
<a name="ln10486">    case 'u': {</a>
<a name="ln10487">      if (STRLEN(what) &lt;= 5 || TOLOWER_ASC(what[5]) != 'c') {  // underline</a>
<a name="ln10488">        p = highlight_has_attr(id, HL_UNDERLINE, modec);</a>
<a name="ln10489">      } else {  // undercurl</a>
<a name="ln10490">        p = highlight_has_attr(id, HL_UNDERCURL, modec);</a>
<a name="ln10491">      }</a>
<a name="ln10492">      break;</a>
<a name="ln10493">    }</a>
<a name="ln10494">  }</a>
<a name="ln10495"> </a>
<a name="ln10496">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln10497">  rettv-&gt;vval.v_string = (char_u *)(p == NULL ? p : xstrdup(p));</a>
<a name="ln10498">}</a>
<a name="ln10499"> </a>
<a name="ln10500">/*</a>
<a name="ln10501"> * &quot;synIDtrans(id)&quot; function</a>
<a name="ln10502"> */</a>
<a name="ln10503">static void f_synIDtrans(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10504">{</a>
<a name="ln10505">  int id = tv_get_number(&amp;argvars[0]);</a>
<a name="ln10506"> </a>
<a name="ln10507">  if (id &gt; 0) {</a>
<a name="ln10508">    id = syn_get_final_id(id);</a>
<a name="ln10509">  } else {</a>
<a name="ln10510">    id = 0;</a>
<a name="ln10511">  }</a>
<a name="ln10512"> </a>
<a name="ln10513">  rettv-&gt;vval.v_number = id;</a>
<a name="ln10514">}</a>
<a name="ln10515"> </a>
<a name="ln10516">/*</a>
<a name="ln10517"> * &quot;synconcealed(lnum, col)&quot; function</a>
<a name="ln10518"> */</a>
<a name="ln10519">static void f_synconcealed(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10520">{</a>
<a name="ln10521">  int syntax_flags = 0;</a>
<a name="ln10522">  int cchar;</a>
<a name="ln10523">  int matchid = 0;</a>
<a name="ln10524">  char_u str[NUMBUFLEN];</a>
<a name="ln10525"> </a>
<a name="ln10526">  tv_list_set_ret(rettv, NULL);</a>
<a name="ln10527"> </a>
<a name="ln10528">  // -1 on type error (both)</a>
<a name="ln10529">  const linenr_T lnum = tv_get_lnum(argvars);</a>
<a name="ln10530">  const colnr_T col = (colnr_T)tv_get_number(&amp;argvars[1]) - 1;</a>
<a name="ln10531"> </a>
<a name="ln10532">  memset(str, NUL, sizeof(str));</a>
<a name="ln10533"> </a>
<a name="ln10534">  if (lnum &gt;= 1 &amp;&amp; lnum &lt;= curbuf-&gt;b_ml.ml_line_count &amp;&amp; col &gt;= 0</a>
<a name="ln10535">      &amp;&amp; (size_t)col &lt;= STRLEN(ml_get(lnum)) &amp;&amp; curwin-&gt;w_p_cole &gt; 0) {</a>
<a name="ln10536">    (void)syn_get_id(curwin, lnum, col, false, NULL, false);</a>
<a name="ln10537">    syntax_flags = get_syntax_info(&amp;matchid);</a>
<a name="ln10538"> </a>
<a name="ln10539">    // get the conceal character</a>
<a name="ln10540">    if ((syntax_flags &amp; HL_CONCEAL) &amp;&amp; curwin-&gt;w_p_cole &lt; 3) {</a>
<a name="ln10541">      cchar = syn_get_sub_char();</a>
<a name="ln10542">      if (cchar == NUL &amp;&amp; curwin-&gt;w_p_cole == 1) {</a>
<a name="ln10543">        cchar = (curwin-&gt;w_p_lcs_chars.conceal == NUL)</a>
<a name="ln10544">          ? ' '</a>
<a name="ln10545">          : curwin-&gt;w_p_lcs_chars.conceal;</a>
<a name="ln10546">      }</a>
<a name="ln10547">      if (cchar != NUL) {</a>
<a name="ln10548">        utf_char2bytes(cchar, str);</a>
<a name="ln10549">      }</a>
<a name="ln10550">    }</a>
<a name="ln10551">  }</a>
<a name="ln10552"> </a>
<a name="ln10553">  tv_list_alloc_ret(rettv, 3);</a>
<a name="ln10554">  tv_list_append_number(rettv-&gt;vval.v_list, (syntax_flags &amp; HL_CONCEAL) != 0);</a>
<a name="ln10555">  // -1 to auto-determine strlen</a>
<a name="ln10556">  tv_list_append_string(rettv-&gt;vval.v_list, (const char *)str, -1);</a>
<a name="ln10557">  tv_list_append_number(rettv-&gt;vval.v_list, matchid);</a>
<a name="ln10558">}</a>
<a name="ln10559"> </a>
<a name="ln10560">/*</a>
<a name="ln10561"> * &quot;synstack(lnum, col)&quot; function</a>
<a name="ln10562"> */</a>
<a name="ln10563">static void f_synstack(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10564">{</a>
<a name="ln10565">  tv_list_set_ret(rettv, NULL);</a>
<a name="ln10566"> </a>
<a name="ln10567">  // -1 on type error (both)</a>
<a name="ln10568">  const linenr_T lnum = tv_get_lnum(argvars);</a>
<a name="ln10569">  const colnr_T col = (colnr_T)tv_get_number(&amp;argvars[1]) - 1;</a>
<a name="ln10570"> </a>
<a name="ln10571">  if (lnum &gt;= 1</a>
<a name="ln10572">      &amp;&amp; lnum &lt;= curbuf-&gt;b_ml.ml_line_count</a>
<a name="ln10573">      &amp;&amp; col &gt;= 0</a>
<a name="ln10574">      &amp;&amp; (size_t)col &lt;= STRLEN(ml_get(lnum))) {</a>
<a name="ln10575">    tv_list_alloc_ret(rettv, kListLenMayKnow);</a>
<a name="ln10576">    (void)syn_get_id(curwin, lnum, col, false, NULL, true);</a>
<a name="ln10577"> </a>
<a name="ln10578">    int id;</a>
<a name="ln10579">    int i = 0;</a>
<a name="ln10580">    while ((id = syn_get_stack_item(i++)) &gt;= 0) {</a>
<a name="ln10581">      tv_list_append_number(rettv-&gt;vval.v_list, id);</a>
<a name="ln10582">    }</a>
<a name="ln10583">  }</a>
<a name="ln10584">}</a>
<a name="ln10585"> </a>
<a name="ln10586">/// f_system - the VimL system() function</a>
<a name="ln10587">static void f_system(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10588">{</a>
<a name="ln10589">  get_system_output_as_rettv(argvars, rettv, false);</a>
<a name="ln10590">}</a>
<a name="ln10591"> </a>
<a name="ln10592">static void f_systemlist(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10593">{</a>
<a name="ln10594">  get_system_output_as_rettv(argvars, rettv, true);</a>
<a name="ln10595">}</a>
<a name="ln10596"> </a>
<a name="ln10597"> </a>
<a name="ln10598">/*</a>
<a name="ln10599"> * &quot;tabpagebuflist()&quot; function</a>
<a name="ln10600"> */</a>
<a name="ln10601">static void f_tabpagebuflist(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10602">{</a>
<a name="ln10603">  win_T       *wp = NULL;</a>
<a name="ln10604"> </a>
<a name="ln10605">  if (argvars[0].v_type == VAR_UNKNOWN) {</a>
<a name="ln10606">    wp = firstwin;</a>
<a name="ln10607">  } else {</a>
<a name="ln10608">    tabpage_T *const tp = find_tabpage((int)tv_get_number(&amp;argvars[0]));</a>
<a name="ln10609">    if (tp != NULL) {</a>
<a name="ln10610">      wp = (tp == curtab) ? firstwin : tp-&gt;tp_firstwin;</a>
<a name="ln10611">    }</a>
<a name="ln10612">  }</a>
<a name="ln10613">  if (wp != NULL) {</a>
<a name="ln10614">    tv_list_alloc_ret(rettv, kListLenMayKnow);</a>
<a name="ln10615">    while (wp != NULL) {</a>
<a name="ln10616">      tv_list_append_number(rettv-&gt;vval.v_list, wp-&gt;w_buffer-&gt;b_fnum);</a>
<a name="ln10617">      wp = wp-&gt;w_next;</a>
<a name="ln10618">    }</a>
<a name="ln10619">  }</a>
<a name="ln10620">}</a>
<a name="ln10621"> </a>
<a name="ln10622">/*</a>
<a name="ln10623"> * &quot;tabpagenr()&quot; function</a>
<a name="ln10624"> */</a>
<a name="ln10625">static void f_tabpagenr(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10626">{</a>
<a name="ln10627">  int nr = 1;</a>
<a name="ln10628"> </a>
<a name="ln10629">  if (argvars[0].v_type != VAR_UNKNOWN) {</a>
<a name="ln10630">    const char *const arg = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln10631">    nr = 0;</a>
<a name="ln10632">    if (arg != NULL) {</a>
<a name="ln10633">      if (strcmp(arg, &quot;$&quot;) == 0) {</a>
<a name="ln10634">        nr = tabpage_index(NULL) - 1;</a>
<a name="ln10635">      } else if (strcmp(arg, &quot;#&quot;) == 0) {</a>
<a name="ln10636">        nr = valid_tabpage(lastused_tabpage)</a>
<a name="ln10637">             ? tabpage_index(lastused_tabpage)</a>
<a name="ln10638">             : nr;</a>
<a name="ln10639">      } else {</a>
<a name="ln10640">        EMSG2(_(e_invexpr2), arg);</a>
<a name="ln10641">      }</a>
<a name="ln10642">    }</a>
<a name="ln10643">  } else {</a>
<a name="ln10644">    nr = tabpage_index(curtab);</a>
<a name="ln10645">  }</a>
<a name="ln10646">  rettv-&gt;vval.v_number = nr;</a>
<a name="ln10647">}</a>
<a name="ln10648"> </a>
<a name="ln10649"> </a>
<a name="ln10650"> </a>
<a name="ln10651">/*</a>
<a name="ln10652"> * Common code for tabpagewinnr() and winnr().</a>
<a name="ln10653"> */</a>
<a name="ln10654">static int get_winnr(tabpage_T *tp, typval_T *argvar)</a>
<a name="ln10655">{</a>
<a name="ln10656">  win_T       *twin;</a>
<a name="ln10657">  int nr = 1;</a>
<a name="ln10658">  win_T       *wp;</a>
<a name="ln10659"> </a>
<a name="ln10660">  twin = (tp == curtab) ? curwin : tp-&gt;tp_curwin;</a>
<a name="ln10661">  if (argvar-&gt;v_type != VAR_UNKNOWN) {</a>
<a name="ln10662">    bool invalid_arg = false;</a>
<a name="ln10663">    const char *const arg = tv_get_string_chk(argvar);</a>
<a name="ln10664">    if (arg == NULL) {</a>
<a name="ln10665">      nr = 0;  // Type error; errmsg already given.</a>
<a name="ln10666">    } else if (strcmp(arg, &quot;$&quot;) == 0) {</a>
<a name="ln10667">      twin = (tp == curtab) ? lastwin : tp-&gt;tp_lastwin;</a>
<a name="ln10668">    } else if (strcmp(arg, &quot;#&quot;) == 0) {</a>
<a name="ln10669">      twin = (tp == curtab) ? prevwin : tp-&gt;tp_prevwin;</a>
<a name="ln10670">      if (twin == NULL) {</a>
<a name="ln10671">        nr = 0;</a>
<a name="ln10672">      }</a>
<a name="ln10673">    } else {</a>
<a name="ln10674">      // Extract the window count (if specified). e.g. winnr('3j')</a>
<a name="ln10675">      char_u *endp;</a>
<a name="ln10676">      long count = strtol((char *)arg, (char **)&amp;endp, 10);</a>
<a name="ln10677">      if (count &lt;= 0) {</a>
<a name="ln10678">        // if count is not specified, default to 1</a>
<a name="ln10679">        count = 1;</a>
<a name="ln10680">      }</a>
<a name="ln10681">      if (endp != NULL &amp;&amp; *endp != '\0') {</a>
<a name="ln10682">        if (strequal((char *)endp, &quot;j&quot;)) {</a>
<a name="ln10683">          twin = win_vert_neighbor(tp, twin, false, count);</a>
<a name="ln10684">        } else if (strequal((char *)endp, &quot;k&quot;)) {</a>
<a name="ln10685">          twin = win_vert_neighbor(tp, twin, true, count);</a>
<a name="ln10686">        } else if (strequal((char *)endp, &quot;h&quot;)) {</a>
<a name="ln10687">          twin = win_horz_neighbor(tp, twin, true, count);</a>
<a name="ln10688">        } else if (strequal((char *)endp, &quot;l&quot;)) {</a>
<a name="ln10689">          twin = win_horz_neighbor(tp, twin, false, count);</a>
<a name="ln10690">        } else {</a>
<a name="ln10691">          invalid_arg = true;</a>
<a name="ln10692">        }</a>
<a name="ln10693">      } else {</a>
<a name="ln10694">        invalid_arg = true;</a>
<a name="ln10695">      }</a>
<a name="ln10696">    }</a>
<a name="ln10697"> </a>
<a name="ln10698">    if (invalid_arg) {</a>
<a name="ln10699">      EMSG2(_(e_invexpr2), arg);</a>
<a name="ln10700">      nr = 0;</a>
<a name="ln10701">    }</a>
<a name="ln10702">  }</a>
<a name="ln10703"> </a>
<a name="ln10704">  if (nr &gt; 0)</a>
<a name="ln10705">    for (wp = (tp == curtab) ? firstwin : tp-&gt;tp_firstwin;</a>
<a name="ln10706">         wp != twin; wp = wp-&gt;w_next) {</a>
<a name="ln10707">      if (wp == NULL) {</a>
<a name="ln10708">        // didn't find it in this tabpage</a>
<a name="ln10709">        nr = 0;</a>
<a name="ln10710">        break;</a>
<a name="ln10711">      }</a>
<a name="ln10712">      ++nr;</a>
<a name="ln10713">    }</a>
<a name="ln10714">  return nr;</a>
<a name="ln10715">}</a>
<a name="ln10716"> </a>
<a name="ln10717">/*</a>
<a name="ln10718"> * &quot;tabpagewinnr()&quot; function</a>
<a name="ln10719"> */</a>
<a name="ln10720">static void f_tabpagewinnr(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10721">{</a>
<a name="ln10722">  int nr = 1;</a>
<a name="ln10723">  tabpage_T *const tp = find_tabpage((int)tv_get_number(&amp;argvars[0]));</a>
<a name="ln10724">  if (tp == NULL) {</a>
<a name="ln10725">    nr = 0;</a>
<a name="ln10726">  } else {</a>
<a name="ln10727">    nr = get_winnr(tp, &amp;argvars[1]);</a>
<a name="ln10728">  }</a>
<a name="ln10729">  rettv-&gt;vval.v_number = nr;</a>
<a name="ln10730">}</a>
<a name="ln10731"> </a>
<a name="ln10732">/*</a>
<a name="ln10733"> * &quot;tagfiles()&quot; function</a>
<a name="ln10734"> */</a>
<a name="ln10735">static void f_tagfiles(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10736">{</a>
<a name="ln10737">  char *fname;</a>
<a name="ln10738">  tagname_T tn;</a>
<a name="ln10739"> </a>
<a name="ln10740">  tv_list_alloc_ret(rettv, kListLenUnknown);</a>
<a name="ln10741">  fname = xmalloc(MAXPATHL);</a>
<a name="ln10742"> </a>
<a name="ln10743">  bool first = true;</a>
<a name="ln10744">  while (get_tagfname(&amp;tn, first, (char_u *)fname) == OK) {</a>
<a name="ln10745">    tv_list_append_string(rettv-&gt;vval.v_list, fname, -1);</a>
<a name="ln10746">    first = false;</a>
<a name="ln10747">  }</a>
<a name="ln10748"> </a>
<a name="ln10749">  tagname_free(&amp;tn);</a>
<a name="ln10750">  xfree(fname);</a>
<a name="ln10751">}</a>
<a name="ln10752"> </a>
<a name="ln10753">/*</a>
<a name="ln10754"> * &quot;taglist()&quot; function</a>
<a name="ln10755"> */</a>
<a name="ln10756">static void f_taglist(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10757">{</a>
<a name="ln10758">  const char *const tag_pattern = tv_get_string(&amp;argvars[0]);</a>
<a name="ln10759"> </a>
<a name="ln10760">  rettv-&gt;vval.v_number = false;</a>
<a name="ln10761">  if (*tag_pattern == NUL) {</a>
<a name="ln10762">    return;</a>
<a name="ln10763">  }</a>
<a name="ln10764"> </a>
<a name="ln10765">  const char *fname = NULL;</a>
<a name="ln10766">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln10767">    fname = tv_get_string(&amp;argvars[1]);</a>
<a name="ln10768">  }</a>
<a name="ln10769">  (void)get_tags(tv_list_alloc_ret(rettv, kListLenUnknown),</a>
<a name="ln10770">                 (char_u *)tag_pattern, (char_u *)fname);</a>
<a name="ln10771">}</a>
<a name="ln10772"> </a>
<a name="ln10773">/*</a>
<a name="ln10774"> * &quot;tempname()&quot; function</a>
<a name="ln10775"> */</a>
<a name="ln10776">static void f_tempname(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10777">{</a>
<a name="ln10778">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln10779">  rettv-&gt;vval.v_string = vim_tempname();</a>
<a name="ln10780">}</a>
<a name="ln10781"> </a>
<a name="ln10782">// &quot;termopen(cmd[, cwd])&quot; function</a>
<a name="ln10783">static void f_termopen(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10784">{</a>
<a name="ln10785">  if (check_secure()) {</a>
<a name="ln10786">    return;</a>
<a name="ln10787">  }</a>
<a name="ln10788"> </a>
<a name="ln10789">  if (curbuf-&gt;b_changed) {</a>
<a name="ln10790">    EMSG(_(&quot;Can only call this function in an unmodified buffer&quot;));</a>
<a name="ln10791">    return;</a>
<a name="ln10792">  }</a>
<a name="ln10793"> </a>
<a name="ln10794">  const char *cmd;</a>
<a name="ln10795">  bool executable = true;</a>
<a name="ln10796">  char **argv = tv_to_argv(&amp;argvars[0], &amp;cmd, &amp;executable);</a>
<a name="ln10797">  if (!argv) {</a>
<a name="ln10798">    rettv-&gt;vval.v_number = executable ? 0 : -1;</a>
<a name="ln10799">    return;  // Did error message in tv_to_argv.</a>
<a name="ln10800">  }</a>
<a name="ln10801"> </a>
<a name="ln10802">  if (argvars[1].v_type != VAR_DICT &amp;&amp; argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln10803">    // Wrong argument type</a>
<a name="ln10804">    EMSG2(_(e_invarg2), &quot;expected dictionary&quot;);</a>
<a name="ln10805">    shell_free_argv(argv);</a>
<a name="ln10806">    return;</a>
<a name="ln10807">  }</a>
<a name="ln10808"> </a>
<a name="ln10809">  CallbackReader on_stdout = CALLBACK_READER_INIT,</a>
<a name="ln10810">                 on_stderr = CALLBACK_READER_INIT;</a>
<a name="ln10811">  Callback on_exit = CALLBACK_NONE;</a>
<a name="ln10812">  dict_T *job_opts = NULL;</a>
<a name="ln10813">  const char *cwd = &quot;.&quot;;</a>
<a name="ln10814">  dict_T *env = NULL;</a>
<a name="ln10815">  const bool pty = true;</a>
<a name="ln10816">  bool clear_env = false;</a>
<a name="ln10817">  dictitem_T *job_env = NULL;</a>
<a name="ln10818"> </a>
<a name="ln10819">  if (argvars[1].v_type == VAR_DICT) {</a>
<a name="ln10820">    job_opts = argvars[1].vval.v_dict;</a>
<a name="ln10821"> </a>
<a name="ln10822">    const char *const new_cwd = tv_dict_get_string(job_opts, &quot;cwd&quot;, false);</a>
<a name="ln10823">    if (new_cwd &amp;&amp; *new_cwd != NUL) {</a>
<a name="ln10824">      cwd = new_cwd;</a>
<a name="ln10825">      // The new cwd must be a directory.</a>
<a name="ln10826">      if (!os_isdir_executable((const char *)cwd)) {</a>
<a name="ln10827">        EMSG2(_(e_invarg2), &quot;expected valid directory&quot;);</a>
<a name="ln10828">        shell_free_argv(argv);</a>
<a name="ln10829">        return;</a>
<a name="ln10830">      }</a>
<a name="ln10831">    }</a>
<a name="ln10832"> </a>
<a name="ln10833">    job_env = tv_dict_find(job_opts, S_LEN(&quot;env&quot;));</a>
<a name="ln10834">    if (job_env &amp;&amp; job_env-&gt;di_tv.v_type != VAR_DICT) {</a>
<a name="ln10835">      EMSG2(_(e_invarg2), &quot;env&quot;);</a>
<a name="ln10836">      shell_free_argv(argv);</a>
<a name="ln10837">      return;</a>
<a name="ln10838">    }</a>
<a name="ln10839"> </a>
<a name="ln10840">    clear_env = tv_dict_get_number(job_opts, &quot;clear_env&quot;) != 0;</a>
<a name="ln10841"> </a>
<a name="ln10842">    if (!common_job_callbacks(job_opts, &amp;on_stdout, &amp;on_stderr, &amp;on_exit)) {</a>
<a name="ln10843">      shell_free_argv(argv);</a>
<a name="ln10844">      return;</a>
<a name="ln10845">    }</a>
<a name="ln10846">  }</a>
<a name="ln10847"> </a>
<a name="ln10848">  env = create_environment(job_env, clear_env, pty, &quot;xterm-256color&quot;);</a>
<a name="ln10849"> </a>
<a name="ln10850">  const bool rpc = false;</a>
<a name="ln10851">  const bool overlapped = false;</a>
<a name="ln10852">  const bool detach = false;</a>
<a name="ln10853">  uint16_t term_width = MAX(0, curwin-&gt;w_width_inner - win_col_off(curwin));</a>
<a name="ln10854">  Channel *chan = channel_job_start(argv, on_stdout, on_stderr, on_exit,</a>
<a name="ln10855">                                    pty, rpc, overlapped, detach, cwd,</a>
<a name="ln10856">                                    term_width, curwin-&gt;w_height_inner,</a>
<a name="ln10857">                                    env, &amp;rettv-&gt;vval.v_number);</a>
<a name="ln10858">  if (rettv-&gt;vval.v_number &lt;= 0) {</a>
<a name="ln10859">    return;</a>
<a name="ln10860">  }</a>
<a name="ln10861"> </a>
<a name="ln10862">  int pid = chan-&gt;stream.pty.process.pid;</a>
<a name="ln10863"> </a>
<a name="ln10864">  // &quot;./&quot; =&gt; &quot;/home/foo/&quot;</a>
<a name="ln10865">  vim_FullName(cwd, (char *)NameBuff, sizeof(NameBuff), false);</a>
<a name="ln10866">  // &quot;/home/foo/&quot; =&gt; &quot;~/&quot;</a>
<a name="ln10867">  size_t len = home_replace(NULL, NameBuff, IObuff, sizeof(IObuff), true);</a>
<a name="ln10868">  // Trim slash.</a>
<a name="ln10869">  if (IObuff[len - 1] == '\\' || IObuff[len - 1] == '/') {</a>
<a name="ln10870">    IObuff[len - 1] = '\0';</a>
<a name="ln10871">  }</a>
<a name="ln10872"> </a>
<a name="ln10873">  // Terminal URI: &quot;term://$CWD//$PID:$CMD&quot;</a>
<a name="ln10874">  snprintf((char *)NameBuff, sizeof(NameBuff), &quot;term://%s//%d:%s&quot;,</a>
<a name="ln10875">           (char *)IObuff, pid, cmd);</a>
<a name="ln10876">  // at this point the buffer has no terminal instance associated yet, so unset</a>
<a name="ln10877">  // the 'swapfile' option to ensure no swap file will be created</a>
<a name="ln10878">  curbuf-&gt;b_p_swf = false;</a>
<a name="ln10879">  (void)setfname(curbuf, NameBuff, NULL, true);</a>
<a name="ln10880">  // Save the job id and pid in b:terminal_job_{id,pid}</a>
<a name="ln10881">  Error err = ERROR_INIT;</a>
<a name="ln10882">  // deprecated: use 'channel' buffer option</a>
<a name="ln10883">  dict_set_var(curbuf-&gt;b_vars, cstr_as_string(&quot;terminal_job_id&quot;),</a>
<a name="ln10884">               INTEGER_OBJ(chan-&gt;id), false, false, &amp;err);</a>
<a name="ln10885">  api_clear_error(&amp;err);</a>
<a name="ln10886">  dict_set_var(curbuf-&gt;b_vars, cstr_as_string(&quot;terminal_job_pid&quot;),</a>
<a name="ln10887">               INTEGER_OBJ(pid), false, false, &amp;err);</a>
<a name="ln10888">  api_clear_error(&amp;err);</a>
<a name="ln10889"> </a>
<a name="ln10890">  channel_terminal_open(curbuf, chan);</a>
<a name="ln10891">  channel_create_event(chan, NULL);</a>
<a name="ln10892">}</a>
<a name="ln10893"> </a>
<a name="ln10894">// &quot;test_garbagecollect_now()&quot; function</a>
<a name="ln10895">static void f_test_garbagecollect_now(typval_T *argvars,</a>
<a name="ln10896">                                      typval_T *rettv, FunPtr fptr)</a>
<a name="ln10897">{</a>
<a name="ln10898">  // This is dangerous, any Lists and Dicts used internally may be freed</a>
<a name="ln10899">  // while still in use.</a>
<a name="ln10900">  garbage_collect(true);</a>
<a name="ln10901">}</a>
<a name="ln10902"> </a>
<a name="ln10903">// &quot;test_write_list_log()&quot; function</a>
<a name="ln10904">static void f_test_write_list_log(typval_T *const argvars,</a>
<a name="ln10905">                                  typval_T *const rettv,</a>
<a name="ln10906">                                  FunPtr fptr)</a>
<a name="ln10907">{</a>
<a name="ln10908">  const char *const fname = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln10909">  if (fname == NULL) {</a>
<a name="ln10910">    return;</a>
<a name="ln10911">  }</a>
<a name="ln10912">  list_write_log(fname);</a>
<a name="ln10913">}</a>
<a name="ln10914"> </a>
<a name="ln10915">/// &quot;timer_info([timer])&quot; function</a>
<a name="ln10916">static void f_timer_info(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10917">{</a>
<a name="ln10918">  if (argvars[0].v_type != VAR_UNKNOWN) {</a>
<a name="ln10919">    if (argvars[0].v_type != VAR_NUMBER) {</a>
<a name="ln10920">      EMSG(_(e_number_exp));</a>
<a name="ln10921">      return;</a>
<a name="ln10922">    }</a>
<a name="ln10923">    tv_list_alloc_ret(rettv, 1);</a>
<a name="ln10924">    timer_T *timer = find_timer_by_nr(tv_get_number(&amp;argvars[0]));</a>
<a name="ln10925">    if (timer != NULL &amp;&amp; !timer-&gt;stopped) {</a>
<a name="ln10926">      add_timer_info(rettv, timer);</a>
<a name="ln10927">    }</a>
<a name="ln10928">  } else {</a>
<a name="ln10929">    add_timer_info_all(rettv);</a>
<a name="ln10930">  }</a>
<a name="ln10931">}</a>
<a name="ln10932"> </a>
<a name="ln10933">/// &quot;timer_pause(timer, paused)&quot; function</a>
<a name="ln10934">static void f_timer_pause(typval_T *argvars, typval_T *unused, FunPtr fptr)</a>
<a name="ln10935">{</a>
<a name="ln10936">  if (argvars[0].v_type != VAR_NUMBER) {</a>
<a name="ln10937">    EMSG(_(e_number_exp));</a>
<a name="ln10938">    return;</a>
<a name="ln10939">  }</a>
<a name="ln10940">  int paused = (bool)tv_get_number(&amp;argvars[1]);</a>
<a name="ln10941">  timer_T *timer = find_timer_by_nr(tv_get_number(&amp;argvars[0]));</a>
<a name="ln10942">  if (timer != NULL) {</a>
<a name="ln10943">    if (!timer-&gt;paused &amp;&amp; paused) {</a>
<a name="ln10944">      time_watcher_stop(&amp;timer-&gt;tw);</a>
<a name="ln10945">    } else if (timer-&gt;paused &amp;&amp; !paused) {</a>
<a name="ln10946">      time_watcher_start(&amp;timer-&gt;tw, timer_due_cb, timer-&gt;timeout,</a>
<a name="ln10947">                         timer-&gt;timeout);</a>
<a name="ln10948">    }</a>
<a name="ln10949">    timer-&gt;paused = paused;</a>
<a name="ln10950">  }</a>
<a name="ln10951">}</a>
<a name="ln10952"> </a>
<a name="ln10953">/// &quot;timer_start(timeout, callback, opts)&quot; function</a>
<a name="ln10954">static void f_timer_start(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10955">{</a>
<a name="ln10956">  int repeat = 1;</a>
<a name="ln10957">  dict_T *dict;</a>
<a name="ln10958"> </a>
<a name="ln10959">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln10960"> </a>
<a name="ln10961">  if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln10962">    if (argvars[2].v_type != VAR_DICT</a>
<a name="ln10963">        || (dict = argvars[2].vval.v_dict) == NULL) {</a>
<a name="ln10964">      EMSG2(_(e_invarg2), tv_get_string(&amp;argvars[2]));</a>
<a name="ln10965">      return;</a>
<a name="ln10966">    }</a>
<a name="ln10967">    dictitem_T *const di = tv_dict_find(dict, S_LEN(&quot;repeat&quot;));</a>
<a name="ln10968">    if (di != NULL) {</a>
<a name="ln10969">      repeat = tv_get_number(&amp;di-&gt;di_tv);</a>
<a name="ln10970">      if (repeat == 0) {</a>
<a name="ln10971">        repeat = 1;</a>
<a name="ln10972">      }</a>
<a name="ln10973">    }</a>
<a name="ln10974">  }</a>
<a name="ln10975"> </a>
<a name="ln10976">  Callback callback;</a>
<a name="ln10977">  if (!callback_from_typval(&amp;callback, &amp;argvars[1])) {</a>
<a name="ln10978">    return;</a>
<a name="ln10979">  }</a>
<a name="ln10980">  rettv-&gt;vval.v_number =</a>
<a name="ln10981">      timer_start(tv_get_number(&amp;argvars[0]), repeat, &amp;callback);</a>
<a name="ln10982">}</a>
<a name="ln10983"> </a>
<a name="ln10984"> </a>
<a name="ln10985">// &quot;timer_stop(timerid)&quot; function</a>
<a name="ln10986">static void f_timer_stop(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10987">{</a>
<a name="ln10988">    if (argvars[0].v_type != VAR_NUMBER) {</a>
<a name="ln10989">        EMSG(_(e_number_exp));</a>
<a name="ln10990">        return;</a>
<a name="ln10991">    }</a>
<a name="ln10992"> </a>
<a name="ln10993">    timer_T *timer = find_timer_by_nr(tv_get_number(&amp;argvars[0]));</a>
<a name="ln10994">    if (timer == NULL) {</a>
<a name="ln10995">      return;</a>
<a name="ln10996">    }</a>
<a name="ln10997"> </a>
<a name="ln10998">    timer_stop(timer);</a>
<a name="ln10999">}</a>
<a name="ln11000"> </a>
<a name="ln11001">static void f_timer_stopall(typval_T *argvars, typval_T *unused, FunPtr fptr)</a>
<a name="ln11002">{</a>
<a name="ln11003">  timer_stop_all();</a>
<a name="ln11004">}</a>
<a name="ln11005"> </a>
<a name="ln11006">/*</a>
<a name="ln11007"> * &quot;tolower(string)&quot; function</a>
<a name="ln11008"> */</a>
<a name="ln11009">static void f_tolower(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11010">{</a>
<a name="ln11011">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln11012">  rettv-&gt;vval.v_string = (char_u *)strcase_save(tv_get_string(&amp;argvars[0]),</a>
<a name="ln11013">                                                false);</a>
<a name="ln11014">}</a>
<a name="ln11015"> </a>
<a name="ln11016">/*</a>
<a name="ln11017"> * &quot;toupper(string)&quot; function</a>
<a name="ln11018"> */</a>
<a name="ln11019">static void f_toupper(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11020">{</a>
<a name="ln11021">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln11022">  rettv-&gt;vval.v_string = (char_u *)strcase_save(tv_get_string(&amp;argvars[0]),</a>
<a name="ln11023">                                                true);</a>
<a name="ln11024">}</a>
<a name="ln11025"> </a>
<a name="ln11026">/*</a>
<a name="ln11027"> * &quot;tr(string, fromstr, tostr)&quot; function</a>
<a name="ln11028"> */</a>
<a name="ln11029">static void f_tr(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11030">{</a>
<a name="ln11031">  char buf[NUMBUFLEN];</a>
<a name="ln11032">  char buf2[NUMBUFLEN];</a>
<a name="ln11033"> </a>
<a name="ln11034">  const char *in_str = tv_get_string(&amp;argvars[0]);</a>
<a name="ln11035">  const char *fromstr = tv_get_string_buf_chk(&amp;argvars[1], buf);</a>
<a name="ln11036">  const char *tostr = tv_get_string_buf_chk(&amp;argvars[2], buf2);</a>
<a name="ln11037"> </a>
<a name="ln11038">  // Default return value: empty string.</a>
<a name="ln11039">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln11040">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln11041">  if (fromstr == NULL || tostr == NULL) {</a>
<a name="ln11042">    return;  // Type error; errmsg already given.</a>
<a name="ln11043">  }</a>
<a name="ln11044">  garray_T ga;</a>
<a name="ln11045">  ga_init(&amp;ga, (int)sizeof(char), 80);</a>
<a name="ln11046"> </a>
<a name="ln11047">  // fromstr and tostr have to contain the same number of chars.</a>
<a name="ln11048">  bool first = true;</a>
<a name="ln11049">  while (*in_str != NUL) {</a>
<a name="ln11050">    const char *cpstr = in_str;</a>
<a name="ln11051">    const int inlen = utfc_ptr2len((const char_u *)in_str);</a>
<a name="ln11052">    int cplen = inlen;</a>
<a name="ln11053">    int idx = 0;</a>
<a name="ln11054">    int fromlen;</a>
<a name="ln11055">    for (const char *p = fromstr; *p != NUL; p += fromlen) {</a>
<a name="ln11056">      fromlen = utfc_ptr2len((const char_u *)p);</a>
<a name="ln11057">      if (fromlen == inlen &amp;&amp; STRNCMP(in_str, p, inlen) == 0) {</a>
<a name="ln11058">        int tolen;</a>
<a name="ln11059">        for (p = tostr; *p != NUL; p += tolen) {</a>
<a name="ln11060">          tolen = utfc_ptr2len((const char_u *)p);</a>
<a name="ln11061">          if (idx-- == 0) {</a>
<a name="ln11062">            cplen = tolen;</a>
<a name="ln11063">            cpstr = (char *)p;</a>
<a name="ln11064">            break;</a>
<a name="ln11065">          }</a>
<a name="ln11066">        }</a>
<a name="ln11067">        if (*p == NUL) {  // tostr is shorter than fromstr.</a>
<a name="ln11068">          goto error;</a>
<a name="ln11069">        }</a>
<a name="ln11070">        break;</a>
<a name="ln11071">      }</a>
<a name="ln11072">      idx++;</a>
<a name="ln11073">    }</a>
<a name="ln11074"> </a>
<a name="ln11075">    if (first &amp;&amp; cpstr == in_str) {</a>
<a name="ln11076">      // Check that fromstr and tostr have the same number of</a>
<a name="ln11077">      // (multi-byte) characters.  Done only once when a character</a>
<a name="ln11078">      // of in_str doesn't appear in fromstr.</a>
<a name="ln11079">      first = false;</a>
<a name="ln11080">      int tolen;</a>
<a name="ln11081">      for (const char *p = tostr; *p != NUL; p += tolen) {</a>
<a name="ln11082">        tolen = utfc_ptr2len((const char_u *)p);</a>
<a name="ln11083">        idx--;</a>
<a name="ln11084">      }</a>
<a name="ln11085">      if (idx != 0) {</a>
<a name="ln11086">        goto error;</a>
<a name="ln11087">      }</a>
<a name="ln11088">    }</a>
<a name="ln11089"> </a>
<a name="ln11090">    ga_grow(&amp;ga, cplen);</a>
<a name="ln11091">    memmove((char *)ga.ga_data + ga.ga_len, cpstr, (size_t)cplen);</a>
<a name="ln11092">    ga.ga_len += cplen;</a>
<a name="ln11093"> </a>
<a name="ln11094">    in_str += inlen;</a>
<a name="ln11095">  }</a>
<a name="ln11096"> </a>
<a name="ln11097">  // add a terminating NUL</a>
<a name="ln11098">  ga_append(&amp;ga, NUL);</a>
<a name="ln11099"> </a>
<a name="ln11100">  rettv-&gt;vval.v_string = ga.ga_data;</a>
<a name="ln11101">  return;</a>
<a name="ln11102">error:</a>
<a name="ln11103">  EMSG2(_(e_invarg2), fromstr);</a>
<a name="ln11104">  ga_clear(&amp;ga);</a>
<a name="ln11105">  return;</a>
<a name="ln11106">}</a>
<a name="ln11107"> </a>
<a name="ln11108">// &quot;trim({expr})&quot; function</a>
<a name="ln11109">static void f_trim(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11110">{</a>
<a name="ln11111">  char buf1[NUMBUFLEN];</a>
<a name="ln11112">  char buf2[NUMBUFLEN];</a>
<a name="ln11113">  const char_u *head = (const char_u *)tv_get_string_buf_chk(&amp;argvars[0], buf1);</a>
<a name="ln11114">  const char_u *mask = NULL;</a>
<a name="ln11115">  const char_u *tail;</a>
<a name="ln11116">  const char_u *prev;</a>
<a name="ln11117">  const char_u *p;</a>
<a name="ln11118">  int c1;</a>
<a name="ln11119">  int dir = 0;</a>
<a name="ln11120"> </a>
<a name="ln11121">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln11122">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln11123">  if (head == NULL) {</a>
<a name="ln11124">    return;</a>
<a name="ln11125">  }</a>
<a name="ln11126"> </a>
<a name="ln11127">  if (argvars[1].v_type == VAR_STRING) {</a>
<a name="ln11128">    mask = (const char_u *)tv_get_string_buf_chk(&amp;argvars[1], buf2);</a>
<a name="ln11129">    if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln11130">      bool error = false;</a>
<a name="ln11131">      // leading or trailing characters to trim</a>
<a name="ln11132">      dir = (int)tv_get_number_chk(&amp;argvars[2], &amp;error);</a>
<a name="ln11133">      if (error) {</a>
<a name="ln11134">        return;</a>
<a name="ln11135">      }</a>
<a name="ln11136">      if (dir &lt; 0 || dir &gt; 2) {</a>
<a name="ln11137">        emsgf(_(e_invarg2), tv_get_string(&amp;argvars[2]));</a>
<a name="ln11138">        return;</a>
<a name="ln11139">      }</a>
<a name="ln11140">    }</a>
<a name="ln11141">  }</a>
<a name="ln11142"> </a>
<a name="ln11143">  if (dir == 0 || dir == 1) {</a>
<a name="ln11144">    // Trim leading characters</a>
<a name="ln11145">    while (*head != NUL) {</a>
<a name="ln11146">      c1 = PTR2CHAR(head);</a>
<a name="ln11147">      if (mask == NULL) {</a>
<a name="ln11148">        if (c1 &gt; ' ' &amp;&amp; c1 != 0xa0) {</a>
<a name="ln11149">          break;</a>
<a name="ln11150">        }</a>
<a name="ln11151">      } else {</a>
<a name="ln11152">        for (p = mask; *p != NUL; MB_PTR_ADV(p)) {</a>
<a name="ln11153">          if (c1 == PTR2CHAR(p)) {</a>
<a name="ln11154">            break;</a>
<a name="ln11155">          }</a>
<a name="ln11156">        }</a>
<a name="ln11157">        if (*p == NUL) {</a>
<a name="ln11158">          break;</a>
<a name="ln11159">        }</a>
<a name="ln11160">      }</a>
<a name="ln11161">      MB_PTR_ADV(head);</a>
<a name="ln11162">    }</a>
<a name="ln11163">  }</a>
<a name="ln11164"> </a>
<a name="ln11165">  tail = head + STRLEN(head);</a>
<a name="ln11166">  if (dir == 0 || dir == 2) {</a>
<a name="ln11167">    // Trim trailing characters</a>
<a name="ln11168">    for (; tail &gt; head; tail = prev) {</a>
<a name="ln11169">      prev = tail;</a>
<a name="ln11170">      MB_PTR_BACK(head, prev);</a>
<a name="ln11171">      c1 = PTR2CHAR(prev);</a>
<a name="ln11172">      if (mask == NULL) {</a>
<a name="ln11173">        if (c1 &gt; ' ' &amp;&amp; c1 != 0xa0) {</a>
<a name="ln11174">          break;</a>
<a name="ln11175">        }</a>
<a name="ln11176">      } else {</a>
<a name="ln11177">        for (p = mask; *p != NUL; MB_PTR_ADV(p)) {</a>
<a name="ln11178">          if (c1 == PTR2CHAR(p)) {</a>
<a name="ln11179">            break;</a>
<a name="ln11180">          }</a>
<a name="ln11181">        }</a>
<a name="ln11182">        if (*p == NUL) {</a>
<a name="ln11183">          break;</a>
<a name="ln11184">        }</a>
<a name="ln11185">      }</a>
<a name="ln11186">    }</a>
<a name="ln11187">  }</a>
<a name="ln11188">  rettv-&gt;vval.v_string = vim_strnsave(head, tail - head);</a>
<a name="ln11189">}</a>
<a name="ln11190"> </a>
<a name="ln11191">/*</a>
<a name="ln11192"> * &quot;type(expr)&quot; function</a>
<a name="ln11193"> */</a>
<a name="ln11194">static void f_type(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11195">{</a>
<a name="ln11196">  int n = -1;</a>
<a name="ln11197"> </a>
<a name="ln11198">  switch (argvars[0].v_type) {</a>
<a name="ln11199">    case VAR_NUMBER: n = VAR_TYPE_NUMBER; break;</a>
<a name="ln11200">    case VAR_STRING: n = VAR_TYPE_STRING; break;</a>
<a name="ln11201">    case VAR_PARTIAL:</a>
<a name="ln11202">    case VAR_FUNC:   n = VAR_TYPE_FUNC; break;</a>
<a name="ln11203">    case VAR_LIST:   n = VAR_TYPE_LIST; break;</a>
<a name="ln11204">    case VAR_DICT:   n = VAR_TYPE_DICT; break;</a>
<a name="ln11205">    case VAR_FLOAT:  n = VAR_TYPE_FLOAT; break;</a>
<a name="ln11206">    case VAR_BOOL:   n = VAR_TYPE_BOOL; break;</a>
<a name="ln11207">    case VAR_SPECIAL:n = VAR_TYPE_SPECIAL; break;</a>
<a name="ln11208">    case VAR_UNKNOWN: {</a>
<a name="ln11209">      internal_error(&quot;f_type(UNKNOWN)&quot;);</a>
<a name="ln11210">      break;</a>
<a name="ln11211">    }</a>
<a name="ln11212">  }</a>
<a name="ln11213">  rettv-&gt;vval.v_number = n;</a>
<a name="ln11214">}</a>
<a name="ln11215"> </a>
<a name="ln11216">/*</a>
<a name="ln11217"> * &quot;undofile(name)&quot; function</a>
<a name="ln11218"> */</a>
<a name="ln11219">static void f_undofile(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11220">{</a>
<a name="ln11221">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln11222">  const char *const fname = tv_get_string(&amp;argvars[0]);</a>
<a name="ln11223"> </a>
<a name="ln11224">  if (*fname == NUL) {</a>
<a name="ln11225">    // If there is no file name there will be no undo file.</a>
<a name="ln11226">    rettv-&gt;vval.v_string = NULL;</a>
<a name="ln11227">  } else {</a>
<a name="ln11228">    char *ffname = FullName_save(fname, true);</a>
<a name="ln11229"> </a>
<a name="ln11230">    if (ffname != NULL) {</a>
<a name="ln11231">      rettv-&gt;vval.v_string = (char_u *)u_get_undo_file_name(ffname, false);</a>
<a name="ln11232">    }</a>
<a name="ln11233">    xfree(ffname);</a>
<a name="ln11234">  }</a>
<a name="ln11235">}</a>
<a name="ln11236"> </a>
<a name="ln11237">/*</a>
<a name="ln11238"> * &quot;undotree()&quot; function</a>
<a name="ln11239"> */</a>
<a name="ln11240">static void f_undotree(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11241">{</a>
<a name="ln11242">  tv_dict_alloc_ret(rettv);</a>
<a name="ln11243"> </a>
<a name="ln11244">  dict_T *dict = rettv-&gt;vval.v_dict;</a>
<a name="ln11245"> </a>
<a name="ln11246">  tv_dict_add_nr(dict, S_LEN(&quot;synced&quot;), (varnumber_T)curbuf-&gt;b_u_synced);</a>
<a name="ln11247">  tv_dict_add_nr(dict, S_LEN(&quot;seq_last&quot;), (varnumber_T)curbuf-&gt;b_u_seq_last);</a>
<a name="ln11248">  tv_dict_add_nr(dict, S_LEN(&quot;save_last&quot;),</a>
<a name="ln11249">                 (varnumber_T)curbuf-&gt;b_u_save_nr_last);</a>
<a name="ln11250">  tv_dict_add_nr(dict, S_LEN(&quot;seq_cur&quot;), (varnumber_T)curbuf-&gt;b_u_seq_cur);</a>
<a name="ln11251">  tv_dict_add_nr(dict, S_LEN(&quot;time_cur&quot;), (varnumber_T)curbuf-&gt;b_u_time_cur);</a>
<a name="ln11252">  tv_dict_add_nr(dict, S_LEN(&quot;save_cur&quot;), (varnumber_T)curbuf-&gt;b_u_save_nr_cur);</a>
<a name="ln11253"> </a>
<a name="ln11254">  tv_dict_add_list(dict, S_LEN(&quot;entries&quot;), u_eval_tree(curbuf-&gt;b_u_oldhead));</a>
<a name="ln11255">}</a>
<a name="ln11256"> </a>
<a name="ln11257">/*</a>
<a name="ln11258"> * &quot;values(dict)&quot; function</a>
<a name="ln11259"> */</a>
<a name="ln11260">static void f_values(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11261">{</a>
<a name="ln11262">  dict_list(argvars, rettv, 1);</a>
<a name="ln11263">}</a>
<a name="ln11264"> </a>
<a name="ln11265">/*</a>
<a name="ln11266"> * &quot;virtcol(string)&quot; function</a>
<a name="ln11267"> */</a>
<a name="ln11268">static void f_virtcol(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11269">{</a>
<a name="ln11270">  colnr_T vcol = 0;</a>
<a name="ln11271">  pos_T       *fp;</a>
<a name="ln11272">  int fnum = curbuf-&gt;b_fnum;</a>
<a name="ln11273"> </a>
<a name="ln11274">  fp = var2fpos(&amp;argvars[0], FALSE, &amp;fnum);</a>
<a name="ln11275">  if (fp != NULL &amp;&amp; fp-&gt;lnum &lt;= curbuf-&gt;b_ml.ml_line_count</a>
<a name="ln11276">      &amp;&amp; fnum == curbuf-&gt;b_fnum) {</a>
<a name="ln11277">    // Limit the column to a valid value, getvvcol() doesn't check.</a>
<a name="ln11278">    if (fp-&gt;col &lt; 0) {</a>
<a name="ln11279">      fp-&gt;col = 0;</a>
<a name="ln11280">    } else {</a>
<a name="ln11281">      const size_t len = STRLEN(ml_get(fp-&gt;lnum));</a>
<a name="ln11282">      if (fp-&gt;col &gt; (colnr_T)len) {</a>
<a name="ln11283">        fp-&gt;col = (colnr_T)len;</a>
<a name="ln11284">      }</a>
<a name="ln11285">    }</a>
<a name="ln11286">    getvvcol(curwin, fp, NULL, NULL, &amp;vcol);</a>
<a name="ln11287">    ++vcol;</a>
<a name="ln11288">  }</a>
<a name="ln11289"> </a>
<a name="ln11290">  rettv-&gt;vval.v_number = vcol;</a>
<a name="ln11291">}</a>
<a name="ln11292"> </a>
<a name="ln11293">/*</a>
<a name="ln11294"> * &quot;visualmode()&quot; function</a>
<a name="ln11295"> */</a>
<a name="ln11296">static void f_visualmode(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11297">{</a>
<a name="ln11298">  char_u str[2];</a>
<a name="ln11299"> </a>
<a name="ln11300">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln11301">  str[0] = curbuf-&gt;b_visual_mode_eval;</a>
<a name="ln11302">  str[1] = NUL;</a>
<a name="ln11303">  rettv-&gt;vval.v_string = vim_strsave(str);</a>
<a name="ln11304"> </a>
<a name="ln11305">  // A non-zero number or non-empty string argument: reset mode.</a>
<a name="ln11306">  if (non_zero_arg(&amp;argvars[0])) {</a>
<a name="ln11307">    curbuf-&gt;b_visual_mode_eval = NUL;</a>
<a name="ln11308">  }</a>
<a name="ln11309">}</a>
<a name="ln11310"> </a>
<a name="ln11311">/*</a>
<a name="ln11312"> * &quot;wildmenumode()&quot; function</a>
<a name="ln11313"> */</a>
<a name="ln11314">static void f_wildmenumode(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11315">{</a>
<a name="ln11316">  if (wild_menu_showing || ((State &amp; CMDLINE) &amp;&amp; pum_visible())) {</a>
<a name="ln11317">    rettv-&gt;vval.v_number = 1;</a>
<a name="ln11318">  }</a>
<a name="ln11319">}</a>
<a name="ln11320"> </a>
<a name="ln11321">/// &quot;win_findbuf()&quot; function</a>
<a name="ln11322">static void f_win_findbuf(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11323">{</a>
<a name="ln11324">  tv_list_alloc_ret(rettv, kListLenMayKnow);</a>
<a name="ln11325">  win_findbuf(argvars, rettv-&gt;vval.v_list);</a>
<a name="ln11326">}</a>
<a name="ln11327"> </a>
<a name="ln11328">/// &quot;win_getid()&quot; function</a>
<a name="ln11329">static void f_win_getid(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11330">{</a>
<a name="ln11331">  rettv-&gt;vval.v_number = win_getid(argvars);</a>
<a name="ln11332">}</a>
<a name="ln11333"> </a>
<a name="ln11334">/// &quot;win_gettype(nr)&quot; function</a>
<a name="ln11335">static void f_win_gettype(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11336">{</a>
<a name="ln11337">  win_T *wp = curwin;</a>
<a name="ln11338"> </a>
<a name="ln11339">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln11340">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln11341">  if (argvars[0].v_type != VAR_UNKNOWN) {</a>
<a name="ln11342">    wp = find_win_by_nr_or_id(&amp;argvars[0]);</a>
<a name="ln11343">    if (wp == NULL) {</a>
<a name="ln11344">      rettv-&gt;vval.v_string = vim_strsave((char_u *)&quot;unknown&quot;);</a>
<a name="ln11345">      return;</a>
<a name="ln11346">    }</a>
<a name="ln11347">  }</a>
<a name="ln11348">  if (wp == aucmd_win) {</a>
<a name="ln11349">    rettv-&gt;vval.v_string = vim_strsave((char_u *)&quot;autocmd&quot;);</a>
<a name="ln11350">  } else if (wp-&gt;w_p_pvw) {</a>
<a name="ln11351">    rettv-&gt;vval.v_string = vim_strsave((char_u *)&quot;preview&quot;);</a>
<a name="ln11352">  } else if (wp-&gt;w_floating) {</a>
<a name="ln11353">    rettv-&gt;vval.v_string = vim_strsave((char_u *)&quot;popup&quot;);</a>
<a name="ln11354">  } else if (wp == curwin &amp;&amp; cmdwin_type != 0) {</a>
<a name="ln11355">    rettv-&gt;vval.v_string = vim_strsave((char_u *)&quot;command&quot;);</a>
<a name="ln11356">  }</a>
<a name="ln11357">}</a>
<a name="ln11358"> </a>
<a name="ln11359">/// &quot;win_gotoid()&quot; function</a>
<a name="ln11360">static void f_win_gotoid(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11361">{</a>
<a name="ln11362">  rettv-&gt;vval.v_number = win_gotoid(argvars);</a>
<a name="ln11363">}</a>
<a name="ln11364"> </a>
<a name="ln11365">/// &quot;win_id2tabwin()&quot; function</a>
<a name="ln11366">static void f_win_id2tabwin(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11367">{</a>
<a name="ln11368">  win_id2tabwin(argvars, rettv);</a>
<a name="ln11369">}</a>
<a name="ln11370"> </a>
<a name="ln11371">/// &quot;win_id2win()&quot; function</a>
<a name="ln11372">static void f_win_id2win(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11373">{</a>
<a name="ln11374">  rettv-&gt;vval.v_number = win_id2win(argvars);</a>
<a name="ln11375">}</a>
<a name="ln11376"> </a>
<a name="ln11377">/// &quot;winbufnr(nr)&quot; function</a>
<a name="ln11378">static void f_winbufnr(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11379">{</a>
<a name="ln11380">  win_T *wp = find_win_by_nr_or_id(&amp;argvars[0]);</a>
<a name="ln11381">  if (wp == NULL) {</a>
<a name="ln11382">    rettv-&gt;vval.v_number = -1;</a>
<a name="ln11383">  } else {</a>
<a name="ln11384">    rettv-&gt;vval.v_number = wp-&gt;w_buffer-&gt;b_fnum;</a>
<a name="ln11385">  }</a>
<a name="ln11386">}</a>
<a name="ln11387"> </a>
<a name="ln11388">/*</a>
<a name="ln11389"> * &quot;wincol()&quot; function</a>
<a name="ln11390"> */</a>
<a name="ln11391">static void f_wincol(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11392">{</a>
<a name="ln11393">  validate_cursor();</a>
<a name="ln11394">  rettv-&gt;vval.v_number = curwin-&gt;w_wcol + 1;</a>
<a name="ln11395">}</a>
<a name="ln11396"> </a>
<a name="ln11397">/// &quot;winheight(nr)&quot; function</a>
<a name="ln11398">static void f_winheight(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11399">{</a>
<a name="ln11400">  win_T *wp = find_win_by_nr_or_id(&amp;argvars[0]);</a>
<a name="ln11401">  if (wp == NULL) {</a>
<a name="ln11402">    rettv-&gt;vval.v_number = -1;</a>
<a name="ln11403">  } else {</a>
<a name="ln11404">    rettv-&gt;vval.v_number = wp-&gt;w_height;</a>
<a name="ln11405">  }</a>
<a name="ln11406">}</a>
<a name="ln11407"> </a>
<a name="ln11408">// &quot;winlayout()&quot; function</a>
<a name="ln11409">static void f_winlayout(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11410">{</a>
<a name="ln11411">  tabpage_T *tp;</a>
<a name="ln11412"> </a>
<a name="ln11413">  tv_list_alloc_ret(rettv, 2);</a>
<a name="ln11414"> </a>
<a name="ln11415">  if (argvars[0].v_type == VAR_UNKNOWN) {</a>
<a name="ln11416">    tp = curtab;</a>
<a name="ln11417">  } else {</a>
<a name="ln11418">    tp = find_tabpage((int)tv_get_number(&amp;argvars[0]));</a>
<a name="ln11419">    if (tp == NULL) {</a>
<a name="ln11420">      return;</a>
<a name="ln11421">    }</a>
<a name="ln11422">  }</a>
<a name="ln11423"> </a>
<a name="ln11424">  get_framelayout(tp-&gt;tp_topframe, rettv-&gt;vval.v_list, true);</a>
<a name="ln11425">}</a>
<a name="ln11426"> </a>
<a name="ln11427">/*</a>
<a name="ln11428"> * &quot;winline()&quot; function</a>
<a name="ln11429"> */</a>
<a name="ln11430">static void f_winline(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11431">{</a>
<a name="ln11432">  validate_cursor();</a>
<a name="ln11433">  rettv-&gt;vval.v_number = curwin-&gt;w_wrow + 1;</a>
<a name="ln11434">}</a>
<a name="ln11435"> </a>
<a name="ln11436">/*</a>
<a name="ln11437"> * &quot;winnr()&quot; function</a>
<a name="ln11438"> */</a>
<a name="ln11439">static void f_winnr(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11440">{</a>
<a name="ln11441">  int nr = 1;</a>
<a name="ln11442"> </a>
<a name="ln11443">  nr = get_winnr(curtab, &amp;argvars[0]);</a>
<a name="ln11444">  rettv-&gt;vval.v_number = nr;</a>
<a name="ln11445">}</a>
<a name="ln11446"> </a>
<a name="ln11447">/*</a>
<a name="ln11448"> * &quot;winrestcmd()&quot; function</a>
<a name="ln11449"> */</a>
<a name="ln11450">static void f_winrestcmd(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11451">{</a>
<a name="ln11452">  garray_T ga;</a>
<a name="ln11453">  char_u buf[50];</a>
<a name="ln11454"> </a>
<a name="ln11455">  ga_init(&amp;ga, (int)sizeof(char), 70);</a>
<a name="ln11456"> </a>
<a name="ln11457">  // Do this twice to handle some window layouts properly.</a>
<a name="ln11458">  for (int i = 0; i &lt; 2; i++) {</a>
<a name="ln11459">    int winnr = 1;</a>
<a name="ln11460">    FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {</a>
<a name="ln11461">      snprintf((char *)buf, sizeof(buf), &quot;%dresize %d|&quot;, winnr,</a>
<a name="ln11462">               wp-&gt;w_height);</a>
<a name="ln11463">      ga_concat(&amp;ga, buf);</a>
<a name="ln11464">      snprintf((char *)buf, sizeof(buf), &quot;vert %dresize %d|&quot;, winnr,</a>
<a name="ln11465">               wp-&gt;w_width);</a>
<a name="ln11466">      ga_concat(&amp;ga, buf);</a>
<a name="ln11467">      winnr++;</a>
<a name="ln11468">    }</a>
<a name="ln11469">  }</a>
<a name="ln11470">  ga_append(&amp;ga, NUL);</a>
<a name="ln11471"> </a>
<a name="ln11472">  rettv-&gt;vval.v_string = ga.ga_data;</a>
<a name="ln11473">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln11474">}</a>
<a name="ln11475"> </a>
<a name="ln11476">/*</a>
<a name="ln11477"> * &quot;winrestview()&quot; function</a>
<a name="ln11478"> */</a>
<a name="ln11479">static void f_winrestview(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11480">{</a>
<a name="ln11481">  dict_T *dict;</a>
<a name="ln11482"> </a>
<a name="ln11483">  if (argvars[0].v_type != VAR_DICT</a>
<a name="ln11484">      || (dict = argvars[0].vval.v_dict) == NULL) {</a>
<a name="ln11485">    EMSG(_(e_invarg));</a>
<a name="ln11486">  } else {</a>
<a name="ln11487">    dictitem_T *di;</a>
<a name="ln11488">    if ((di = tv_dict_find(dict, S_LEN(&quot;lnum&quot;))) != NULL) {</a>
<a name="ln11489">      curwin-&gt;w_cursor.lnum = tv_get_number(&amp;di-&gt;di_tv);</a>
<a name="ln11490">    }</a>
<a name="ln11491">    if ((di = tv_dict_find(dict, S_LEN(&quot;col&quot;))) != NULL) {</a>
<a name="ln11492">      curwin-&gt;w_cursor.col = tv_get_number(&amp;di-&gt;di_tv);</a>
<a name="ln11493">    }</a>
<a name="ln11494">    if ((di = tv_dict_find(dict, S_LEN(&quot;coladd&quot;))) != NULL) {</a>
<a name="ln11495">      curwin-&gt;w_cursor.coladd = tv_get_number(&amp;di-&gt;di_tv);</a>
<a name="ln11496">    }</a>
<a name="ln11497">    if ((di = tv_dict_find(dict, S_LEN(&quot;curswant&quot;))) != NULL) {</a>
<a name="ln11498">      curwin-&gt;w_curswant = tv_get_number(&amp;di-&gt;di_tv);</a>
<a name="ln11499">      curwin-&gt;w_set_curswant = false;</a>
<a name="ln11500">    }</a>
<a name="ln11501">    if ((di = tv_dict_find(dict, S_LEN(&quot;topline&quot;))) != NULL) {</a>
<a name="ln11502">      set_topline(curwin, tv_get_number(&amp;di-&gt;di_tv));</a>
<a name="ln11503">    }</a>
<a name="ln11504">    if ((di = tv_dict_find(dict, S_LEN(&quot;topfill&quot;))) != NULL) {</a>
<a name="ln11505">      curwin-&gt;w_topfill = tv_get_number(&amp;di-&gt;di_tv);</a>
<a name="ln11506">    }</a>
<a name="ln11507">    if ((di = tv_dict_find(dict, S_LEN(&quot;leftcol&quot;))) != NULL) {</a>
<a name="ln11508">      curwin-&gt;w_leftcol = tv_get_number(&amp;di-&gt;di_tv);</a>
<a name="ln11509">    }</a>
<a name="ln11510">    if ((di = tv_dict_find(dict, S_LEN(&quot;skipcol&quot;))) != NULL) {</a>
<a name="ln11511">      curwin-&gt;w_skipcol = tv_get_number(&amp;di-&gt;di_tv);</a>
<a name="ln11512">    }</a>
<a name="ln11513"> </a>
<a name="ln11514">    check_cursor();</a>
<a name="ln11515">    win_new_height(curwin, curwin-&gt;w_height);</a>
<a name="ln11516">    win_new_width(curwin, curwin-&gt;w_width);</a>
<a name="ln11517">    changed_window_setting();</a>
<a name="ln11518"> </a>
<a name="ln11519">    if (curwin-&gt;w_topline &lt;= 0)</a>
<a name="ln11520">      curwin-&gt;w_topline = 1;</a>
<a name="ln11521">    if (curwin-&gt;w_topline &gt; curbuf-&gt;b_ml.ml_line_count)</a>
<a name="ln11522">      curwin-&gt;w_topline = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln11523">    check_topfill(curwin, true);</a>
<a name="ln11524">  }</a>
<a name="ln11525">}</a>
<a name="ln11526"> </a>
<a name="ln11527">/*</a>
<a name="ln11528"> * &quot;winsaveview()&quot; function</a>
<a name="ln11529"> */</a>
<a name="ln11530">static void f_winsaveview(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11531">{</a>
<a name="ln11532">  dict_T      *dict;</a>
<a name="ln11533"> </a>
<a name="ln11534">  tv_dict_alloc_ret(rettv);</a>
<a name="ln11535">  dict = rettv-&gt;vval.v_dict;</a>
<a name="ln11536"> </a>
<a name="ln11537">  tv_dict_add_nr(dict, S_LEN(&quot;lnum&quot;), (varnumber_T)curwin-&gt;w_cursor.lnum);</a>
<a name="ln11538">  tv_dict_add_nr(dict, S_LEN(&quot;col&quot;), (varnumber_T)curwin-&gt;w_cursor.col);</a>
<a name="ln11539">  tv_dict_add_nr(dict, S_LEN(&quot;coladd&quot;), (varnumber_T)curwin-&gt;w_cursor.coladd);</a>
<a name="ln11540">  update_curswant();</a>
<a name="ln11541">  tv_dict_add_nr(dict, S_LEN(&quot;curswant&quot;), (varnumber_T)curwin-&gt;w_curswant);</a>
<a name="ln11542"> </a>
<a name="ln11543">  tv_dict_add_nr(dict, S_LEN(&quot;topline&quot;), (varnumber_T)curwin-&gt;w_topline);</a>
<a name="ln11544">  tv_dict_add_nr(dict, S_LEN(&quot;topfill&quot;), (varnumber_T)curwin-&gt;w_topfill);</a>
<a name="ln11545">  tv_dict_add_nr(dict, S_LEN(&quot;leftcol&quot;), (varnumber_T)curwin-&gt;w_leftcol);</a>
<a name="ln11546">  tv_dict_add_nr(dict, S_LEN(&quot;skipcol&quot;), (varnumber_T)curwin-&gt;w_skipcol);</a>
<a name="ln11547">}</a>
<a name="ln11548"> </a>
<a name="ln11549">/// &quot;winwidth(nr)&quot; function</a>
<a name="ln11550">static void f_winwidth(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11551">{</a>
<a name="ln11552">  win_T *wp = find_win_by_nr_or_id(&amp;argvars[0]);</a>
<a name="ln11553">  if (wp == NULL) {</a>
<a name="ln11554">    rettv-&gt;vval.v_number = -1;</a>
<a name="ln11555">  } else {</a>
<a name="ln11556">    rettv-&gt;vval.v_number = wp-&gt;w_width;</a>
<a name="ln11557">  }</a>
<a name="ln11558">}</a>
<a name="ln11559"> </a>
<a name="ln11560">// &quot;windowsversion()&quot; function</a>
<a name="ln11561">static void f_windowsversion(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11562">{</a>
<a name="ln11563">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln11564">  rettv-&gt;vval.v_string = (char_u *)xstrdup(windowsVersion);</a>
<a name="ln11565">}</a>
<a name="ln11566"> </a>
<a name="ln11567">/// &quot;wordcount()&quot; function</a>
<a name="ln11568">static void f_wordcount(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11569">{</a>
<a name="ln11570">  tv_dict_alloc_ret(rettv);</a>
<a name="ln11571">  cursor_pos_info(rettv-&gt;vval.v_dict);</a>
<a name="ln11572">}</a>
<a name="ln11573"> </a>
<a name="ln11574">/// &quot;writefile()&quot; function</a>
<a name="ln11575">static void f_writefile(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11576">{</a>
<a name="ln11577">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln11578"> </a>
<a name="ln11579">  if (check_secure()) {</a>
<a name="ln11580">    return;</a>
<a name="ln11581">  }</a>
<a name="ln11582"> </a>
<a name="ln11583">  if (argvars[0].v_type != VAR_LIST) {</a>
<a name="ln11584">    EMSG2(_(e_listarg), &quot;writefile()&quot;);</a>
<a name="ln11585">    return;</a>
<a name="ln11586">  }</a>
<a name="ln11587">  const list_T *const list = argvars[0].vval.v_list;</a>
<a name="ln11588">  TV_LIST_ITER_CONST(list, li, {</a>
<a name="ln11589">    if (!tv_check_str_or_nr(TV_LIST_ITEM_TV(li))) {</a>
<a name="ln11590">      return;</a>
<a name="ln11591">    }</a>
<a name="ln11592">  });</a>
<a name="ln11593"> </a>
<a name="ln11594">  bool binary = false;</a>
<a name="ln11595">  bool append = false;</a>
<a name="ln11596">  bool do_fsync = !!p_fs;</a>
<a name="ln11597">  if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln11598">    const char *const flags = tv_get_string_chk(&amp;argvars[2]);</a>
<a name="ln11599">    if (flags == NULL) {</a>
<a name="ln11600">      return;</a>
<a name="ln11601">    }</a>
<a name="ln11602">    for (const char *p = flags; *p; p++) {</a>
<a name="ln11603">      switch (*p) {</a>
<a name="ln11604">        case 'b': { binary = true; break; }</a>
<a name="ln11605">        case 'a': { append = true; break; }</a>
<a name="ln11606">        case 's': { do_fsync = true; break; }</a>
<a name="ln11607">        case 'S': { do_fsync = false; break; }</a>
<a name="ln11608">        default: {</a>
<a name="ln11609">          // Using %s, p and not %c, *p to preserve multibyte characters</a>
<a name="ln11610">          emsgf(_(&quot;E5060: Unknown flag: %s&quot;), p);</a>
<a name="ln11611">          return;</a>
<a name="ln11612">        }</a>
<a name="ln11613">      }</a>
<a name="ln11614">    }</a>
<a name="ln11615">  }</a>
<a name="ln11616"> </a>
<a name="ln11617">  char buf[NUMBUFLEN];</a>
<a name="ln11618">  const char *const fname = tv_get_string_buf_chk(&amp;argvars[1], buf);</a>
<a name="ln11619">  if (fname == NULL) {</a>
<a name="ln11620">    return;</a>
<a name="ln11621">  }</a>
<a name="ln11622">  FileDescriptor fp;</a>
<a name="ln11623">  int error;</a>
<a name="ln11624">  if (*fname == NUL) {</a>
<a name="ln11625">    EMSG(_(&quot;E482: Can't open file with an empty name&quot;));</a>
<a name="ln11626">  } else if ((error = file_open(&amp;fp, fname,</a>
<a name="ln11627">                                ((append ? kFileAppend : kFileTruncate)</a>
<a name="ln11628">                                 | kFileCreate), 0666)) != 0) {</a>
<a name="ln11629">    emsgf(_(&quot;E482: Can't open file %s for writing: %s&quot;),</a>
<a name="ln11630">          fname, os_strerror(error));</a>
<a name="ln11631">  } else {</a>
<a name="ln11632">    if (write_list(&amp;fp, list, binary)) {</a>
<a name="ln11633">      rettv-&gt;vval.v_number = 0;</a>
<a name="ln11634">    }</a>
<a name="ln11635">    if ((error = file_close(&amp;fp, do_fsync)) != 0) {</a>
<a name="ln11636">      emsgf(_(&quot;E80: Error when closing file %s: %s&quot;),</a>
<a name="ln11637">            fname, os_strerror(error));</a>
<a name="ln11638">    }</a>
<a name="ln11639">  }</a>
<a name="ln11640">}</a>
<a name="ln11641">/*</a>
<a name="ln11642"> * &quot;xor(expr, expr)&quot; function</a>
<a name="ln11643"> */</a>
<a name="ln11644">static void f_xor(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11645">{</a>
<a name="ln11646">  rettv-&gt;vval.v_number = tv_get_number_chk(&amp;argvars[0], NULL)</a>
<a name="ln11647">                         ^ tv_get_number_chk(&amp;argvars[1], NULL);</a>
<a name="ln11648">}</a>

</code></pre>
<div class="balloon" rel="1824"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression is always true.</p></div>
<div class="balloon" rel="8381"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v560/" target="_blank">V560</a> A part of conditional expression is always true.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
