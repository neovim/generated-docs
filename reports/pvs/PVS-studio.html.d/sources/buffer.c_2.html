
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>buffer.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">//</a>
<a name="ln5">// buffer.c: functions for dealing with the buffer structure</a>
<a name="ln6">//</a>
<a name="ln7"> </a>
<a name="ln8">//</a>
<a name="ln9">// The buffer list is a double linked list of all buffers.</a>
<a name="ln10">// Each buffer can be in one of these states:</a>
<a name="ln11">// never loaded: BF_NEVERLOADED is set, only the file name is valid</a>
<a name="ln12">//   not loaded: b_ml.ml_mfp == NULL, no memfile allocated</a>
<a name="ln13">//       hidden: b_nwindows == 0, loaded but not displayed in a window</a>
<a name="ln14">//       normal: loaded and displayed in a window</a>
<a name="ln15">//</a>
<a name="ln16">// Instead of storing file names all over the place, each file name is</a>
<a name="ln17">// stored in the buffer list. It can be referenced by a number.</a>
<a name="ln18">//</a>
<a name="ln19">// The current implementation remembers all file names ever used.</a>
<a name="ln20">//</a>
<a name="ln21"> </a>
<a name="ln22">#include &lt;stdbool.h&gt;</a>
<a name="ln23">#include &lt;string.h&gt;</a>
<a name="ln24">#include &lt;inttypes.h&gt;</a>
<a name="ln25">#include &lt;assert.h&gt;</a>
<a name="ln26"> </a>
<a name="ln27">#include &quot;nvim/api/private/handle.h&quot;</a>
<a name="ln28">#include &quot;nvim/api/private/helpers.h&quot;</a>
<a name="ln29">#include &quot;nvim/api/vim.h&quot;</a>
<a name="ln30">#include &quot;nvim/ascii.h&quot;</a>
<a name="ln31">#include &quot;nvim/assert.h&quot;</a>
<a name="ln32">#include &quot;nvim/channel.h&quot;</a>
<a name="ln33">#include &quot;nvim/vim.h&quot;</a>
<a name="ln34">#include &quot;nvim/buffer.h&quot;</a>
<a name="ln35">#include &quot;nvim/change.h&quot;</a>
<a name="ln36">#include &quot;nvim/charset.h&quot;</a>
<a name="ln37">#include &quot;nvim/cursor.h&quot;</a>
<a name="ln38">#include &quot;nvim/diff.h&quot;</a>
<a name="ln39">#include &quot;nvim/digraph.h&quot;</a>
<a name="ln40">#include &quot;nvim/eval.h&quot;</a>
<a name="ln41">#include &quot;nvim/ex_cmds2.h&quot;</a>
<a name="ln42">#include &quot;nvim/ex_cmds.h&quot;</a>
<a name="ln43">#include &quot;nvim/ex_docmd.h&quot;</a>
<a name="ln44">#include &quot;nvim/ex_eval.h&quot;</a>
<a name="ln45">#include &quot;nvim/ex_getln.h&quot;</a>
<a name="ln46">#include &quot;nvim/fileio.h&quot;</a>
<a name="ln47">#include &quot;nvim/file_search.h&quot;</a>
<a name="ln48">#include &quot;nvim/fold.h&quot;</a>
<a name="ln49">#include &quot;nvim/getchar.h&quot;</a>
<a name="ln50">#include &quot;nvim/hashtab.h&quot;</a>
<a name="ln51">#include &quot;nvim/highlight.h&quot;</a>
<a name="ln52">#include &quot;nvim/indent.h&quot;</a>
<a name="ln53">#include &quot;nvim/indent_c.h&quot;</a>
<a name="ln54">#include &quot;nvim/main.h&quot;</a>
<a name="ln55">#include &quot;nvim/mark.h&quot;</a>
<a name="ln56">#include &quot;nvim/extmark.h&quot;</a>
<a name="ln57">#include &quot;nvim/mbyte.h&quot;</a>
<a name="ln58">#include &quot;nvim/memory.h&quot;</a>
<a name="ln59">#include &quot;nvim/message.h&quot;</a>
<a name="ln60">#include &quot;nvim/misc1.h&quot;</a>
<a name="ln61">#include &quot;nvim/garray.h&quot;</a>
<a name="ln62">#include &quot;nvim/move.h&quot;</a>
<a name="ln63">#include &quot;nvim/option.h&quot;</a>
<a name="ln64">#include &quot;nvim/os_unix.h&quot;</a>
<a name="ln65">#include &quot;nvim/path.h&quot;</a>
<a name="ln66">#include &quot;nvim/quickfix.h&quot;</a>
<a name="ln67">#include &quot;nvim/regexp.h&quot;</a>
<a name="ln68">#include &quot;nvim/screen.h&quot;</a>
<a name="ln69">#include &quot;nvim/sign.h&quot;</a>
<a name="ln70">#include &quot;nvim/spell.h&quot;</a>
<a name="ln71">#include &quot;nvim/strings.h&quot;</a>
<a name="ln72">#include &quot;nvim/syntax.h&quot;</a>
<a name="ln73">#include &quot;nvim/ui.h&quot;</a>
<a name="ln74">#include &quot;nvim/undo.h&quot;</a>
<a name="ln75">#include &quot;nvim/version.h&quot;</a>
<a name="ln76">#include &quot;nvim/window.h&quot;</a>
<a name="ln77">#include &quot;nvim/shada.h&quot;</a>
<a name="ln78">#include &quot;nvim/os/os.h&quot;</a>
<a name="ln79">#include &quot;nvim/os/time.h&quot;</a>
<a name="ln80">#include &quot;nvim/os/input.h&quot;</a>
<a name="ln81">#include &quot;nvim/buffer_updates.h&quot;</a>
<a name="ln82"> </a>
<a name="ln83">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln84"># include &quot;buffer.c.generated.h&quot;</a>
<a name="ln85">#endif</a>
<a name="ln86"> </a>
<a name="ln87">// Determines how deeply nested %{} blocks will be evaluated in statusline.</a>
<a name="ln88">#define MAX_STL_EVAL_DEPTH 100</a>
<a name="ln89"> </a>
<a name="ln90">static char *msg_loclist = N_(&quot;[Location List]&quot;);</a>
<a name="ln91">static char *msg_qflist = N_(&quot;[Quickfix List]&quot;);</a>
<a name="ln92">static char *e_auabort = N_(&quot;E855: Autocommands caused command to abort&quot;);</a>
<a name="ln93"> </a>
<a name="ln94">// Number of times free_buffer() was called.</a>
<a name="ln95">static int buf_free_count = 0;</a>
<a name="ln96"> </a>
<a name="ln97">typedef enum {</a>
<a name="ln98">  kBffClearWinInfo = 1,</a>
<a name="ln99">  kBffInitChangedtick = 2,</a>
<a name="ln100">} BufFreeFlags;</a>
<a name="ln101"> </a>
<a name="ln102">// Read data from buffer for retrying.</a>
<a name="ln103">static int</a>
<a name="ln104">read_buffer(</a>
<a name="ln105">    int     read_stdin,     // read file from stdin, otherwise fifo</a>
<a name="ln106">    exarg_T *eap,           // for forced 'ff' and 'fenc' or NULL</a>
<a name="ln107">    int     flags)          // extra flags for readfile()</a>
<a name="ln108">{</a>
<a name="ln109">  int       retval = OK;</a>
<a name="ln110">  linenr_T  line_count;</a>
<a name="ln111"> </a>
<a name="ln112">  //</a>
<a name="ln113">  // Read from the buffer which the text is already filled in and append at</a>
<a name="ln114">  // the end.  This makes it possible to retry when 'fileformat' or</a>
<a name="ln115">  // 'fileencoding' was guessed wrong.</a>
<a name="ln116">  //</a>
<a name="ln117">  line_count = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln118">  retval = readfile(</a>
<a name="ln119">      read_stdin ? NULL : curbuf-&gt;b_ffname,</a>
<a name="ln120">      read_stdin ? NULL : curbuf-&gt;b_fname,</a>
<a name="ln121">      (linenr_T)line_count, (linenr_T)0, (linenr_T)MAXLNUM, eap,</a>
<a name="ln122">      flags | READ_BUFFER);</a>
<a name="ln123">  if (retval == OK) {</a>
<a name="ln124">    // Delete the binary lines.</a>
<a name="ln125">    while (--line_count &gt;= 0) {</a>
<a name="ln126">      ml_delete((linenr_T)1, false);</a>
<a name="ln127">    }</a>
<a name="ln128">  } else {</a>
<a name="ln129">    // Delete the converted lines.</a>
<a name="ln130">    while (curbuf-&gt;b_ml.ml_line_count &gt; line_count) {</a>
<a name="ln131">      ml_delete(line_count, false);</a>
<a name="ln132">    }</a>
<a name="ln133">  }</a>
<a name="ln134">  // Put the cursor on the first line.</a>
<a name="ln135">  curwin-&gt;w_cursor.lnum = 1;</a>
<a name="ln136">  curwin-&gt;w_cursor.col = 0;</a>
<a name="ln137"> </a>
<a name="ln138">  if (read_stdin) {</a>
<a name="ln139">    // Set or reset 'modified' before executing autocommands, so that</a>
<a name="ln140">    // it can be changed there.</a>
<a name="ln141">    if (!readonlymode &amp;&amp; !buf_is_empty(curbuf)) {</a>
<a name="ln142">      changed();</a>
<a name="ln143">    } else if (retval != FAIL) {</a>
<a name="ln144">      unchanged(curbuf, false, true);</a>
<a name="ln145">    }</a>
<a name="ln146"> </a>
<a name="ln147">    apply_autocmds_retval(EVENT_STDINREADPOST, NULL, NULL, false,</a>
<a name="ln148">                          curbuf, &amp;retval);</a>
<a name="ln149">  }</a>
<a name="ln150">  return retval;</a>
<a name="ln151">}</a>
<a name="ln152"> </a>
<a name="ln153">// Open current buffer, that is: open the memfile and read the file into</a>
<a name="ln154">// memory.</a>
<a name="ln155">// Return FAIL for failure, OK otherwise.</a>
<a name="ln156">int open_buffer(</a>
<a name="ln157">    int read_stdin,   // read file from stdin</a>
<a name="ln158">    exarg_T *eap,     // for forced 'ff' and 'fenc' or NULL</a>
<a name="ln159">    int flags         // extra flags for readfile()</a>
<a name="ln160">)</a>
<a name="ln161">{</a>
<a name="ln162">  int retval = OK;</a>
<a name="ln163">  bufref_T       old_curbuf;</a>
<a name="ln164">  long old_tw = curbuf-&gt;b_p_tw;</a>
<a name="ln165">  int read_fifo = false;</a>
<a name="ln166"> </a>
<a name="ln167">  /*</a>
<a name="ln168">   * The 'readonly' flag is only set when BF_NEVERLOADED is being reset.</a>
<a name="ln169">   * When re-entering the same buffer, it should not change, because the</a>
<a name="ln170">   * user may have reset the flag by hand.</a>
<a name="ln171">   */</a>
<a name="ln172">  if (readonlymode &amp;&amp; curbuf-&gt;b_ffname != NULL</a>
<a name="ln173">      &amp;&amp; (curbuf-&gt;b_flags &amp; BF_NEVERLOADED))</a>
<a name="ln174">    curbuf-&gt;b_p_ro = true;</a>
<a name="ln175"> </a>
<a name="ln176">  if (ml_open(curbuf) == FAIL) {</a>
<a name="ln177">    /*</a>
<a name="ln178">     * There MUST be a memfile, otherwise we can't do anything</a>
<a name="ln179">     * If we can't create one for the current buffer, take another buffer</a>
<a name="ln180">     */</a>
<a name="ln181">    close_buffer(NULL, curbuf, 0, false);</a>
<a name="ln182"> </a>
<a name="ln183">    curbuf = NULL;</a>
<a name="ln184">    FOR_ALL_BUFFERS(buf) {</a>
<a name="ln185">      if (buf-&gt;b_ml.ml_mfp != NULL) {</a>
<a name="ln186">        curbuf = buf;</a>
<a name="ln187">        break;</a>
<a name="ln188">      }</a>
<a name="ln189">    }</a>
<a name="ln190"> </a>
<a name="ln191">    // If there is no memfile at all, exit.</a>
<a name="ln192">    // This is OK, since there are no changes to lose.</a>
<a name="ln193">    if (curbuf == NULL) {</a>
<a name="ln194">      EMSG(_(&quot;E82: Cannot allocate any buffer, exiting...&quot;));</a>
<a name="ln195"> </a>
<a name="ln196">      // Don't try to do any saving, with &quot;curbuf&quot; NULL almost nothing</a>
<a name="ln197">      // will work.</a>
<a name="ln198">      v_dying = 2;</a>
<a name="ln199">      getout(2);</a>
<a name="ln200">    }</a>
<a name="ln201"> </a>
<a name="ln202">    EMSG(_(&quot;E83: Cannot allocate buffer, using other one...&quot;));</a>
<a name="ln203">    enter_buffer(curbuf);</a>
<a name="ln204">    if (old_tw != curbuf-&gt;b_p_tw) {</a>
<a name="ln205">      check_colorcolumn(curwin);</a>
<a name="ln206">    }</a>
<a name="ln207">    return FAIL;</a>
<a name="ln208">  }</a>
<a name="ln209"> </a>
<a name="ln210">  // The autocommands in readfile() may change the buffer, but only AFTER</a>
<a name="ln211">  // reading the file.</a>
<a name="ln212">  set_bufref(&amp;old_curbuf, curbuf);</a>
<a name="ln213">  modified_was_set = false;</a>
<a name="ln214"> </a>
<a name="ln215">  // mark cursor position as being invalid</a>
<a name="ln216">  curwin-&gt;w_valid = 0;</a>
<a name="ln217"> </a>
<a name="ln218">  if (curbuf-&gt;b_ffname != NULL) {</a>
<a name="ln219">    int old_msg_silent = msg_silent;</a>
<a name="ln220">#ifdef UNIX</a>
<a name="ln221">    int save_bin = curbuf-&gt;b_p_bin;</a>
<a name="ln222">    int perm;</a>
<a name="ln223"> </a>
<a name="ln224">    perm = os_getperm((const char *)curbuf-&gt;b_ffname);</a>
<a name="ln225">    if (perm &gt;= 0 &amp;&amp; (0 || S_ISFIFO(perm)</a>
<a name="ln226">                      || S_ISSOCK(perm)</a>
<a name="ln227"># ifdef OPEN_CHR_FILES</a>
<a name="ln228">                      || (S_ISCHR(perm)</a>
<a name="ln229">                          &amp;&amp; is_dev_fd_file(curbuf-&gt;b_ffname))</a>
<a name="ln230"># endif</a>
<a name="ln231">                      )</a>
<a name="ln232">        ) {</a>
<a name="ln233">      read_fifo = true;</a>
<a name="ln234">    }</a>
<a name="ln235">    if (read_fifo) {</a>
<a name="ln236">      curbuf-&gt;b_p_bin = true;</a>
<a name="ln237">    }</a>
<a name="ln238">#endif</a>
<a name="ln239">    if (shortmess(SHM_FILEINFO)) {</a>
<a name="ln240">      msg_silent = 1;</a>
<a name="ln241">    }</a>
<a name="ln242"> </a>
<a name="ln243">    retval = readfile(curbuf-&gt;b_ffname, curbuf-&gt;b_fname,</a>
<a name="ln244">                      (linenr_T)0, (linenr_T)0, (linenr_T)MAXLNUM, eap,</a>
<a name="ln245">                      flags | READ_NEW | (read_fifo ? READ_FIFO : 0));</a>
<a name="ln246">#ifdef UNIX</a>
<a name="ln247">    if (read_fifo) {</a>
<a name="ln248">      curbuf-&gt;b_p_bin = save_bin;</a>
<a name="ln249">      if (retval == OK) {</a>
<a name="ln250">        retval = read_buffer(false, eap, flags);</a>
<a name="ln251">      }</a>
<a name="ln252">    }</a>
<a name="ln253">#endif</a>
<a name="ln254">    msg_silent = old_msg_silent;</a>
<a name="ln255"> </a>
<a name="ln256">    // Help buffer is filtered.</a>
<a name="ln257">    if (bt_help(curbuf)) {</a>
<a name="ln258">      fix_help_buffer();</a>
<a name="ln259">    }</a>
<a name="ln260">  } else if (read_stdin) {</a>
<a name="ln261">    int save_bin = curbuf-&gt;b_p_bin;</a>
<a name="ln262"> </a>
<a name="ln263">    /*</a>
<a name="ln264">     * First read the text in binary mode into the buffer.</a>
<a name="ln265">     * Then read from that same buffer and append at the end.  This makes</a>
<a name="ln266">     * it possible to retry when 'fileformat' or 'fileencoding' was</a>
<a name="ln267">     * guessed wrong.</a>
<a name="ln268">     */</a>
<a name="ln269">    curbuf-&gt;b_p_bin = true;</a>
<a name="ln270">    retval = readfile(NULL, NULL, (linenr_T)0,</a>
<a name="ln271">        (linenr_T)0, (linenr_T)MAXLNUM, NULL,</a>
<a name="ln272">        flags | (READ_NEW + READ_STDIN));</a>
<a name="ln273">    curbuf-&gt;b_p_bin = save_bin;</a>
<a name="ln274">    if (retval == OK) {</a>
<a name="ln275">      retval = read_buffer(true, eap, flags);</a>
<a name="ln276">    }</a>
<a name="ln277">  }</a>
<a name="ln278"> </a>
<a name="ln279">  // if first time loading this buffer, init b_chartab[]</a>
<a name="ln280">  if (curbuf-&gt;b_flags &amp; BF_NEVERLOADED) {</a>
<a name="ln281">    (void)buf_init_chartab(curbuf, false);</a>
<a name="ln282">    parse_cino(curbuf);</a>
<a name="ln283">  }</a>
<a name="ln284"> </a>
<a name="ln285">  // Set/reset the Changed flag first, autocmds may change the buffer.</a>
<a name="ln286">  // Apply the automatic commands, before processing the modelines.</a>
<a name="ln287">  // So the modelines have priority over autocommands.</a>
<a name="ln288"> </a>
<a name="ln289">  // When reading stdin, the buffer contents always needs writing, so set</a>
<a name="ln290">  // the changed flag.  Unless in readonly mode: &quot;ls | nvim -R -&quot;.</a>
<a name="ln291">  // When interrupted and 'cpoptions' contains 'i' set changed flag.</a>
<a name="ln292">  if ((got_int &amp;&amp; vim_strchr(p_cpo, CPO_INTMOD) != NULL)</a>
<a name="ln293">      || modified_was_set               // &quot;:set modified&quot; used in autocmd</a>
<a name="ln294">      || (aborting() &amp;&amp; vim_strchr(p_cpo, CPO_INTMOD) != NULL)) {</a>
<a name="ln295">    changed();</a>
<a name="ln296">  } else if (retval != FAIL &amp;&amp; !read_stdin &amp;&amp; !read_fifo) {</a>
<a name="ln297">    unchanged(curbuf, false, true);</a>
<a name="ln298">  }</a>
<a name="ln299">  save_file_ff(curbuf);                 // keep this fileformat</a>
<a name="ln300"> </a>
<a name="ln301">  // Set last_changedtick to avoid triggering a TextChanged autocommand right</a>
<a name="ln302">  // after it was added.</a>
<a name="ln303">  curbuf-&gt;b_last_changedtick = buf_get_changedtick(curbuf);</a>
<a name="ln304">  curbuf-&gt;b_last_changedtick_pum = buf_get_changedtick(curbuf);</a>
<a name="ln305"> </a>
<a name="ln306">  // require &quot;!&quot; to overwrite the file, because it wasn't read completely</a>
<a name="ln307">  if (aborting()) {</a>
<a name="ln308">    curbuf-&gt;b_flags |= BF_READERR;</a>
<a name="ln309">  }</a>
<a name="ln310"> </a>
<a name="ln311">  /* Need to update automatic folding.  Do this before the autocommands,</a>
<a name="ln312">   * they may use the fold info. */</a>
<a name="ln313">  foldUpdateAll(curwin);</a>
<a name="ln314"> </a>
<a name="ln315">  // need to set w_topline, unless some autocommand already did that.</a>
<a name="ln316">  if (!(curwin-&gt;w_valid &amp; VALID_TOPLINE)) {</a>
<a name="ln317">    curwin-&gt;w_topline = 1;</a>
<a name="ln318">    curwin-&gt;w_topfill = 0;</a>
<a name="ln319">  }</a>
<a name="ln320">  apply_autocmds_retval(EVENT_BUFENTER, NULL, NULL, false, curbuf, &amp;retval);</a>
<a name="ln321"> </a>
<a name="ln322">  if (retval == FAIL) {</a>
<a name="ln323">    return FAIL;</a>
<a name="ln324">  }</a>
<a name="ln325"> </a>
<a name="ln326">  /*</a>
<a name="ln327">   * The autocommands may have changed the current buffer.  Apply the</a>
<a name="ln328">   * modelines to the correct buffer, if it still exists and is loaded.</a>
<a name="ln329">   */</a>
<a name="ln330">  if (bufref_valid(&amp;old_curbuf) &amp;&amp; old_curbuf.br_buf-&gt;b_ml.ml_mfp != NULL) {</a>
<a name="ln331">    aco_save_T aco;</a>
<a name="ln332"> </a>
<a name="ln333">    // Go to the buffer that was opened.</a>
<a name="ln334">    aucmd_prepbuf(&amp;aco, old_curbuf.br_buf);</a>
<a name="ln335">    do_modelines(0);</a>
<a name="ln336">    curbuf-&gt;b_flags &amp;= ~(BF_CHECK_RO | BF_NEVERLOADED);</a>
<a name="ln337"> </a>
<a name="ln338">    apply_autocmds_retval(EVENT_BUFWINENTER, NULL, NULL, false, curbuf,</a>
<a name="ln339">                          &amp;retval);</a>
<a name="ln340"> </a>
<a name="ln341">    // restore curwin/curbuf and a few other things</a>
<a name="ln342">    aucmd_restbuf(&amp;aco);</a>
<a name="ln343">  }</a>
<a name="ln344"> </a>
<a name="ln345">  return retval;</a>
<a name="ln346">}</a>
<a name="ln347"> </a>
<a name="ln348">/// Store &quot;buf&quot; in &quot;bufref&quot; and set the free count.</a>
<a name="ln349">///</a>
<a name="ln350">/// @param bufref Reference to be used for the buffer.</a>
<a name="ln351">/// @param buf    The buffer to reference.</a>
<a name="ln352">void set_bufref(bufref_T *bufref, buf_T *buf)</a>
<a name="ln353">{</a>
<a name="ln354">  bufref-&gt;br_buf = buf;</a>
<a name="ln355">  bufref-&gt;br_fnum = buf == NULL ? 0 : buf-&gt;b_fnum;</a>
<a name="ln356">  bufref-&gt;br_buf_free_count = buf_free_count;</a>
<a name="ln357">}</a>
<a name="ln358"> </a>
<a name="ln359">/// Return true if &quot;bufref-&gt;br_buf&quot; points to the same buffer as when</a>
<a name="ln360">/// set_bufref() was called and it is a valid buffer.</a>
<a name="ln361">/// Only goes through the buffer list if buf_free_count changed.</a>
<a name="ln362">/// Also checks if b_fnum is still the same, a :bwipe followed by :new might get</a>
<a name="ln363">/// the same allocated memory, but it's a different buffer.</a>
<a name="ln364">///</a>
<a name="ln365">/// @param bufref Buffer reference to check for.</a>
<a name="ln366">bool bufref_valid(bufref_T *bufref)</a>
<a name="ln367">{</a>
<a name="ln368">  return bufref-&gt;br_buf_free_count == buf_free_count</a>
<a name="ln369">    ? true</a>
<a name="ln370">    : buf_valid(bufref-&gt;br_buf) &amp;&amp; bufref-&gt;br_fnum == bufref-&gt;br_buf-&gt;b_fnum;</a>
<a name="ln371">}</a>
<a name="ln372"> </a>
<a name="ln373">/// Check that &quot;buf&quot; points to a valid buffer in the buffer list.</a>
<a name="ln374">///</a>
<a name="ln375">/// Can be slow if there are many buffers, prefer using bufref_valid().</a>
<a name="ln376">///</a>
<a name="ln377">/// @param buf The buffer to check for.</a>
<a name="ln378">bool buf_valid(buf_T *buf)</a>
<a name="ln379">  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln380">{</a>
<a name="ln381">  if (buf == NULL) {</a>
<a name="ln382">    return false;</a>
<a name="ln383">  }</a>
<a name="ln384">  // Assume that we more often have a recent buffer,</a>
<a name="ln385">  // start with the last one.</a>
<a name="ln386">  for (buf_T *bp = lastbuf; bp != NULL; bp = bp-&gt;b_prev) {</a>
<a name="ln387">    if (bp == buf) {</a>
<a name="ln388">      return true;</a>
<a name="ln389">    }</a>
<a name="ln390">  }</a>
<a name="ln391">  return false;</a>
<a name="ln392">}</a>
<a name="ln393"> </a>
<a name="ln394">/// Close the link to a buffer.</a>
<a name="ln395">///</a>
<a name="ln396">/// @param win    If not NULL, set b_last_cursor.</a>
<a name="ln397">/// @param buf</a>
<a name="ln398">/// @param action Used when there is no longer a window for the buffer.</a>
<a name="ln399">///               Possible values:</a>
<a name="ln400">///                 0            buffer becomes hidden</a>
<a name="ln401">///                 DOBUF_UNLOAD buffer is unloaded</a>
<a name="ln402">///                 DOBUF_DELETE buffer is unloaded and removed from buffer list</a>
<a name="ln403">///                 DOBUF_WIPE   buffer is unloaded and really deleted</a>
<a name="ln404">///               When doing all but the first one on the current buffer, the</a>
<a name="ln405">///               caller should get a new buffer very soon!</a>
<a name="ln406">///               The 'bufhidden' option can force freeing and deleting.</a>
<a name="ln407">/// @param abort_if_last</a>
<a name="ln408">///               If true, do not close the buffer if autocommands cause</a>
<a name="ln409">///               there to be only one window with this buffer. e.g. when</a>
<a name="ln410">///               &quot;:quit&quot; is supposed to close the window but autocommands</a>
<a name="ln411">///               close all other windows.</a>
<a name="ln412">/// @returns true when we got to the end and b_nwindows was decremented.</a>
<a name="ln413">bool close_buffer(win_T *win, buf_T *buf, int action, bool abort_if_last)</a>
<a name="ln414">{</a>
<a name="ln415">  bool unload_buf = (action != 0);</a>
<a name="ln416">  bool del_buf = (action == DOBUF_DEL || action == DOBUF_WIPE);</a>
<a name="ln417">  bool wipe_buf = (action == DOBUF_WIPE);</a>
<a name="ln418"> </a>
<a name="ln419">  bool is_curwin = (curwin != NULL &amp;&amp; curwin-&gt;w_buffer == buf);</a>
<a name="ln420">  win_T *the_curwin = curwin;</a>
<a name="ln421">  tabpage_T *the_curtab = curtab;</a>
<a name="ln422"> </a>
<a name="ln423">  // Force unloading or deleting when 'bufhidden' says so, but not for terminal</a>
<a name="ln424">  // buffers.</a>
<a name="ln425">  // The caller must take care of NOT deleting/freeing when 'bufhidden' is</a>
<a name="ln426">  // &quot;hide&quot; (otherwise we could never free or delete a buffer).</a>
<a name="ln427">  if (!buf-&gt;terminal) {</a>
<a name="ln428">    if (buf-&gt;b_p_bh[0] == 'd') {         // 'bufhidden' == &quot;delete&quot;</a>
<a name="ln429">      del_buf = true;</a>
<a name="ln430">      unload_buf = true;</a>
<a name="ln431">    } else if (buf-&gt;b_p_bh[0] == 'w') {  // 'bufhidden' == &quot;wipe&quot;</a>
<a name="ln432">      del_buf = true;</a>
<a name="ln433">      unload_buf = true;</a>
<a name="ln434">      wipe_buf = true;</a>
<a name="ln435">    } else if (buf-&gt;b_p_bh[0] == 'u')    // 'bufhidden' == &quot;unload&quot;</a>
<a name="ln436">      unload_buf = true;</a>
<a name="ln437">  }</a>
<a name="ln438"> </a>
<a name="ln439">  if (buf-&gt;terminal &amp;&amp; (unload_buf || del_buf || wipe_buf)) {</a>
<a name="ln440">    // terminal buffers can only be wiped</a>
<a name="ln441">    unload_buf = true;</a>
<a name="ln442">    del_buf = true;</a>
<a name="ln443">    wipe_buf = true;</a>
<a name="ln444">  }</a>
<a name="ln445"> </a>
<a name="ln446">  // Disallow deleting the buffer when it is locked (already being closed or</a>
<a name="ln447">  // halfway a command that relies on it). Unloading is allowed.</a>
<a name="ln448">  if (buf-&gt;b_locked &gt; 0 &amp;&amp; (del_buf || wipe_buf)) {</a>
<a name="ln449">    EMSG(_(&quot;E937: Attempt to delete a buffer that is in use&quot;));</a>
<a name="ln450">    return false;</a>
<a name="ln451">  }</a>
<a name="ln452"> </a>
<a name="ln453">  if (win != NULL  // Avoid bogus clang warning.</a>
<a name="ln454">      &amp;&amp; win_valid_any_tab(win)) {</a>
<a name="ln455">    // Set b_last_cursor when closing the last window for the buffer.</a>
<a name="ln456">    // Remember the last cursor position and window options of the buffer.</a>
<a name="ln457">    // This used to be only for the current window, but then options like</a>
<a name="ln458">    // 'foldmethod' may be lost with a &quot;:only&quot; command.</a>
<a name="ln459">    if (buf-&gt;b_nwindows == 1) {</a>
<a name="ln460">      set_last_cursor(win);</a>
<a name="ln461">    }</a>
<a name="ln462">    buflist_setfpos(buf, win,</a>
<a name="ln463">                    win-&gt;w_cursor.lnum == 1 ? 0 : win-&gt;w_cursor.lnum,</a>
<a name="ln464">                    win-&gt;w_cursor.col, true);</a>
<a name="ln465">  }</a>
<a name="ln466"> </a>
<a name="ln467">  bufref_T bufref;</a>
<a name="ln468">  set_bufref(&amp;bufref, buf);</a>
<a name="ln469"> </a>
<a name="ln470">  // When the buffer is no longer in a window, trigger BufWinLeave</a>
<a name="ln471">  if (buf-&gt;b_nwindows == 1) {</a>
<a name="ln472">    buf-&gt;b_locked++;</a>
<a name="ln473">    if (apply_autocmds(EVENT_BUFWINLEAVE, buf-&gt;b_fname, buf-&gt;b_fname, false,</a>
<a name="ln474">                       buf) &amp;&amp; !bufref_valid(&amp;bufref)) {</a>
<a name="ln475">      // Autocommands deleted the buffer.</a>
<a name="ln476">      EMSG(_(e_auabort));</a>
<a name="ln477">      return false;</a>
<a name="ln478">    }</a>
<a name="ln479">    buf-&gt;b_locked--;</a>
<a name="ln480">    if (abort_if_last &amp;&amp; last_nonfloat(win)) {</a>
<a name="ln481">      // Autocommands made this the only window.</a>
<a name="ln482">      EMSG(_(e_auabort));</a>
<a name="ln483">      return false;</a>
<a name="ln484">    }</a>
<a name="ln485"> </a>
<a name="ln486">    // When the buffer becomes hidden, but is not unloaded, trigger</a>
<a name="ln487">    // BufHidden</a>
<a name="ln488">    if (!unload_buf) {</a>
<a name="ln489">      buf-&gt;b_locked++;</a>
<a name="ln490">      if (apply_autocmds(EVENT_BUFHIDDEN, buf-&gt;b_fname, buf-&gt;b_fname, false,</a>
<a name="ln491">                         buf) &amp;&amp; !bufref_valid(&amp;bufref)) {</a>
<a name="ln492">        // Autocommands deleted the buffer.</a>
<a name="ln493">        EMSG(_(e_auabort));</a>
<a name="ln494">        return false;</a>
<a name="ln495">      }</a>
<a name="ln496">      buf-&gt;b_locked--;</a>
<a name="ln497">      if (abort_if_last &amp;&amp; last_nonfloat(win)) {</a>
<a name="ln498">        // Autocommands made this the only window.</a>
<a name="ln499">        EMSG(_(e_auabort));</a>
<a name="ln500">        return false;</a>
<a name="ln501">      }</a>
<a name="ln502">    }</a>
<a name="ln503">    if (aborting()) {       // autocmds may abort script processing</a>
<a name="ln504">      return false;</a>
<a name="ln505">    }</a>
<a name="ln506">  }</a>
<a name="ln507"> </a>
<a name="ln508">  // If the buffer was in curwin and the window has changed, go back to that</a>
<a name="ln509">  // window, if it still exists.  This avoids that &quot;:edit x&quot; triggering a</a>
<a name="ln510">  // &quot;tabnext&quot; BufUnload autocmd leaves a window behind without a buffer.</a>
<a name="ln511">  if (is_curwin &amp;&amp; curwin != the_curwin &amp;&amp;  win_valid_any_tab(the_curwin)) {</a>
<a name="ln512">    block_autocmds();</a>
<a name="ln513">    goto_tabpage_win(the_curtab, the_curwin);</a>
<a name="ln514">    unblock_autocmds();</a>
<a name="ln515">  }</a>
<a name="ln516"> </a>
<a name="ln517">  int nwindows = buf-&gt;b_nwindows;</a>
<a name="ln518"> </a>
<a name="ln519">  // decrease the link count from windows (unless not in any window)</a>
<a name="ln520">  if (buf-&gt;b_nwindows &gt; 0) {</a>
<a name="ln521">    buf-&gt;b_nwindows--;</a>
<a name="ln522">  }</a>
<a name="ln523"> </a>
<a name="ln524">  if (diffopt_hiddenoff() &amp;&amp; !unload_buf &amp;&amp; buf-&gt;b_nwindows == 0) {</a>
<a name="ln525">    diff_buf_delete(buf);   // Clear 'diff' for hidden buffer.</a>
<a name="ln526">  }</a>
<a name="ln527"> </a>
<a name="ln528">  /* Return when a window is displaying the buffer or when it's not</a>
<a name="ln529">   * unloaded. */</a>
<a name="ln530">  if (buf-&gt;b_nwindows &gt; 0 || !unload_buf) {</a>
<a name="ln531">    return false;</a>
<a name="ln532">  }</a>
<a name="ln533"> </a>
<a name="ln534">  if (buf-&gt;terminal) {</a>
<a name="ln535">    terminal_close(buf-&gt;terminal, NULL);</a>
<a name="ln536">  }</a>
<a name="ln537"> </a>
<a name="ln538">  // Always remove the buffer when there is no file name.</a>
<a name="ln539">  if (buf-&gt;b_ffname == NULL) {</a>
<a name="ln540">    del_buf = true;</a>
<a name="ln541">  }</a>
<a name="ln542"> </a>
<a name="ln543">  /*</a>
<a name="ln544">   * Free all things allocated for this buffer.</a>
<a name="ln545">   * Also calls the &quot;BufDelete&quot; autocommands when del_buf is TRUE.</a>
<a name="ln546">   */</a>
<a name="ln547">  /* Remember if we are closing the current buffer.  Restore the number of</a>
<a name="ln548">   * windows, so that autocommands in buf_freeall() don't get confused. */</a>
<a name="ln549">  bool is_curbuf = (buf == curbuf);</a>
<a name="ln550"> </a>
<a name="ln551">  // When closing the current buffer stop Visual mode before freeing</a>
<a name="ln552">  // anything.</a>
<a name="ln553">  if (is_curbuf &amp;&amp; VIsual_active</a>
<a name="ln554">#if defined(EXITFREE)</a>
<a name="ln555">      &amp;&amp; !entered_free_all_mem</a>
<a name="ln556">#endif</a>
<a name="ln557">      ) {</a>
<a name="ln558">    end_visual_mode();</a>
<a name="ln559">  }</a>
<a name="ln560"> </a>
<a name="ln561">  buf-&gt;b_nwindows = nwindows;</a>
<a name="ln562"> </a>
<a name="ln563">  buf_freeall(buf, (del_buf ? BFA_DEL : 0) + (wipe_buf ? BFA_WIPE : 0));</a>
<a name="ln564"> </a>
<a name="ln565">  if (!bufref_valid(&amp;bufref)) {</a>
<a name="ln566">    // Autocommands may have deleted the buffer.</a>
<a name="ln567">    return false;</a>
<a name="ln568">  }</a>
<a name="ln569">  if (aborting()) {</a>
<a name="ln570">    // Autocmds may abort script processing.</a>
<a name="ln571">    return false;</a>
<a name="ln572">  }</a>
<a name="ln573"> </a>
<a name="ln574">  /*</a>
<a name="ln575">   * It's possible that autocommands change curbuf to the one being deleted.</a>
<a name="ln576">   * This might cause the previous curbuf to be deleted unexpectedly.  But</a>
<a name="ln577">   * in some cases it's OK to delete the curbuf, because a new one is</a>
<a name="ln578">   * obtained anyway.  Therefore only return if curbuf changed to the</a>
<a name="ln579">   * deleted buffer.</a>
<a name="ln580">   */</a>
<a name="ln581">  if (buf == curbuf &amp;&amp; !is_curbuf) {</a>
<a name="ln582">    return false;</a>
<a name="ln583">  }</a>
<a name="ln584"> </a>
<a name="ln585">  if (win != NULL  // Avoid bogus clang warning.</a>
<a name="ln586">      &amp;&amp; win_valid_any_tab(win)</a>
<a name="ln587">      &amp;&amp; win-&gt;w_buffer == buf) {</a>
<a name="ln588">    win-&gt;w_buffer = NULL;  // make sure we don't use the buffer now</a>
<a name="ln589">  }</a>
<a name="ln590"> </a>
<a name="ln591">  // Autocommands may have opened or closed windows for this buffer.</a>
<a name="ln592">  // Decrement the count for the close we do here.</a>
<a name="ln593">  if (buf-&gt;b_nwindows &gt; 0) {</a>
<a name="ln594">    buf-&gt;b_nwindows--;</a>
<a name="ln595">  }</a>
<a name="ln596"> </a>
<a name="ln597">  // Change directories when the 'acd' option is set.</a>
<a name="ln598">  do_autochdir();</a>
<a name="ln599"> </a>
<a name="ln600">  // Disable buffer-updates for the current buffer.</a>
<a name="ln601">  // No need to check `unload_buf`: in that case the function returned above.</a>
<a name="ln602">  buf_updates_unload(buf, false);</a>
<a name="ln603"> </a>
<a name="ln604">  /*</a>
<a name="ln605">   * Remove the buffer from the list.</a>
<a name="ln606">   */</a>
<a name="ln607">  if (wipe_buf) {</a>
<a name="ln608">    if (buf-&gt;b_sfname != buf-&gt;b_ffname) {</a>
<a name="ln609">      XFREE_CLEAR(buf-&gt;b_sfname);</a>
<a name="ln610">    } else {</a>
<a name="ln611">      buf-&gt;b_sfname = NULL;</a>
<a name="ln612">    }</a>
<a name="ln613">    XFREE_CLEAR(buf-&gt;b_ffname);</a>
<a name="ln614">    if (buf-&gt;b_prev == NULL) {</a>
<a name="ln615">      firstbuf = buf-&gt;b_next;</a>
<a name="ln616">    } else {</a>
<a name="ln617">      buf-&gt;b_prev-&gt;b_next = buf-&gt;b_next;</a>
<a name="ln618">    }</a>
<a name="ln619">    if (buf-&gt;b_next == NULL) {</a>
<a name="ln620">      lastbuf = buf-&gt;b_prev;</a>
<a name="ln621">    } else {</a>
<a name="ln622">      buf-&gt;b_next-&gt;b_prev = buf-&gt;b_prev;</a>
<a name="ln623">    }</a>
<a name="ln624">    free_buffer(buf);</a>
<a name="ln625">  } else {</a>
<a name="ln626">    if (del_buf) {</a>
<a name="ln627">      // Free all internal variables and reset option values, to make</a>
<a name="ln628">      // &quot;:bdel&quot; compatible with Vim 5.7.</a>
<a name="ln629">      free_buffer_stuff(buf, kBffClearWinInfo | kBffInitChangedtick);</a>
<a name="ln630"> </a>
<a name="ln631">      // Make it look like a new buffer.</a>
<a name="ln632">      buf-&gt;b_flags = BF_CHECK_RO | BF_NEVERLOADED;</a>
<a name="ln633"> </a>
<a name="ln634">      // Init the options when loaded again.</a>
<a name="ln635">      buf-&gt;b_p_initialized = false;</a>
<a name="ln636">    }</a>
<a name="ln637">    buf_clear_file(buf);</a>
<a name="ln638">    if (del_buf) {</a>
<a name="ln639">      buf-&gt;b_p_bl = false;</a>
<a name="ln640">    }</a>
<a name="ln641">  }</a>
<a name="ln642">  // NOTE: at this point &quot;curbuf&quot; may be invalid!</a>
<a name="ln643">  return true;</a>
<a name="ln644">}</a>
<a name="ln645"> </a>
<a name="ln646">/// Make buffer not contain a file.</a>
<a name="ln647">void buf_clear_file(buf_T *buf)</a>
<a name="ln648">{</a>
<a name="ln649">  buf-&gt;b_ml.ml_line_count = 1;</a>
<a name="ln650">  unchanged(buf, true, true);</a>
<a name="ln651">  buf-&gt;b_p_eol = true;</a>
<a name="ln652">  buf-&gt;b_start_eol = true;</a>
<a name="ln653">  buf-&gt;b_p_bomb = false;</a>
<a name="ln654">  buf-&gt;b_start_bomb = false;</a>
<a name="ln655">  buf-&gt;b_ml.ml_mfp = NULL;</a>
<a name="ln656">  buf-&gt;b_ml.ml_flags = ML_EMPTY;                // empty buffer</a>
<a name="ln657">}</a>
<a name="ln658"> </a>
<a name="ln659">/// Clears the current buffer contents.</a>
<a name="ln660">void buf_clear(void)</a>
<a name="ln661">{</a>
<a name="ln662">  linenr_T line_count = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln663">  while (!(curbuf-&gt;b_ml.ml_flags &amp; ML_EMPTY)) {</a>
<a name="ln664">    ml_delete((linenr_T)1, false);</a>
<a name="ln665">  }</a>
<a name="ln666">  deleted_lines_mark(1, line_count);  // prepare for display</a>
<a name="ln667">  ml_close(curbuf, true);             // free memline_T</a>
<a name="ln668">  buf_clear_file(curbuf);</a>
<a name="ln669">}</a>
<a name="ln670"> </a>
<a name="ln671">/// buf_freeall() - free all things allocated for a buffer that are related to</a>
<a name="ln672">/// the file.  Careful: get here with &quot;curwin&quot; NULL when exiting.</a>
<a name="ln673">///</a>
<a name="ln674">/// @param flags BFA_DEL buffer is going to be deleted</a>
<a name="ln675">///              BFA_WIPE buffer is going to be wiped out</a>
<a name="ln676">///              BFA_KEEP_UNDO  do not free undo information</a>
<a name="ln677">void buf_freeall(buf_T *buf, int flags)</a>
<a name="ln678">{</a>
<a name="ln679">  bool is_curbuf = (buf == curbuf);</a>
<a name="ln680">  int is_curwin = (curwin != NULL &amp;&amp; curwin-&gt;w_buffer == buf);</a>
<a name="ln681">  win_T *the_curwin = curwin;</a>
<a name="ln682">  tabpage_T *the_curtab = curtab;</a>
<a name="ln683"> </a>
<a name="ln684">  // Make sure the buffer isn't closed by autocommands.</a>
<a name="ln685">  buf-&gt;b_locked++;</a>
<a name="ln686"> </a>
<a name="ln687">  bufref_T bufref;</a>
<a name="ln688">  set_bufref(&amp;bufref, buf);</a>
<a name="ln689"> </a>
<a name="ln690">  if ((buf-&gt;b_ml.ml_mfp != NULL)</a>
<a name="ln691">      &amp;&amp; apply_autocmds(EVENT_BUFUNLOAD, buf-&gt;b_fname, buf-&gt;b_fname, false, buf)</a>
<a name="ln692">      &amp;&amp; !bufref_valid(&amp;bufref)) {</a>
<a name="ln693">    // Autocommands deleted the buffer.</a>
<a name="ln694">    return;</a>
<a name="ln695">  }</a>
<a name="ln696">  if ((flags &amp; BFA_DEL)</a>
<a name="ln697">      &amp;&amp; buf-&gt;b_p_bl</a>
<a name="ln698">      &amp;&amp; apply_autocmds(EVENT_BUFDELETE, buf-&gt;b_fname, buf-&gt;b_fname, false, buf)</a>
<a name="ln699">      &amp;&amp; !bufref_valid(&amp;bufref)) {</a>
<a name="ln700">    // Autocommands may delete the buffer.</a>
<a name="ln701">    return;</a>
<a name="ln702">  }</a>
<a name="ln703">  if ((flags &amp; BFA_WIPE)</a>
<a name="ln704">      &amp;&amp; apply_autocmds(EVENT_BUFWIPEOUT, buf-&gt;b_fname, buf-&gt;b_fname, false,</a>
<a name="ln705">                        buf)</a>
<a name="ln706">      &amp;&amp; !bufref_valid(&amp;bufref)) {</a>
<a name="ln707">    // Autocommands may delete the buffer.</a>
<a name="ln708">    return;</a>
<a name="ln709">  }</a>
<a name="ln710">  buf-&gt;b_locked--;</a>
<a name="ln711"> </a>
<a name="ln712">  // If the buffer was in curwin and the window has changed, go back to that</a>
<a name="ln713">  // window, if it still exists.  This avoids that &quot;:edit x&quot; triggering a</a>
<a name="ln714">  // &quot;tabnext&quot; BufUnload autocmd leaves a window behind without a buffer.</a>
<a name="ln715">  if (is_curwin &amp;&amp; curwin != the_curwin &amp;&amp;  win_valid_any_tab(the_curwin)) {</a>
<a name="ln716">    block_autocmds();</a>
<a name="ln717">    goto_tabpage_win(the_curtab, the_curwin);</a>
<a name="ln718">    unblock_autocmds();</a>
<a name="ln719">  }</a>
<a name="ln720">  if (aborting()) {  // autocmds may abort script processing</a>
<a name="ln721">    return;</a>
<a name="ln722">  }</a>
<a name="ln723"> </a>
<a name="ln724">  /*</a>
<a name="ln725">   * It's possible that autocommands change curbuf to the one being deleted.</a>
<a name="ln726">   * This might cause curbuf to be deleted unexpectedly.  But in some cases</a>
<a name="ln727">   * it's OK to delete the curbuf, because a new one is obtained anyway.</a>
<a name="ln728">   * Therefore only return if curbuf changed to the deleted buffer.</a>
<a name="ln729">   */</a>
<a name="ln730">  if (buf == curbuf &amp;&amp; !is_curbuf) {</a>
<a name="ln731">    return;</a>
<a name="ln732">  }</a>
<a name="ln733">  diff_buf_delete(buf);             // Can't use 'diff' for unloaded buffer.</a>
<a name="ln734">  // Remove any ownsyntax, unless exiting.</a>
<a name="ln735">  if (curwin != NULL &amp;&amp; curwin-&gt;w_buffer == buf) {</a>
<a name="ln736">    reset_synblock(curwin);</a>
<a name="ln737">  }</a>
<a name="ln738"> </a>
<a name="ln739">  // No folds in an empty buffer.</a>
<a name="ln740">  FOR_ALL_TAB_WINDOWS(tp, win) {</a>
<a name="ln741">    if (win-&gt;w_buffer == buf) {</a>
<a name="ln742">      clearFolding(win);</a>
<a name="ln743">    }</a>
<a name="ln744">  }</a>
<a name="ln745"> </a>
<a name="ln746">  ml_close(buf, true);              // close and delete the memline/memfile</a>
<a name="ln747">  buf-&gt;b_ml.ml_line_count = 0;      // no lines in buffer</a>
<a name="ln748">  if ((flags &amp; BFA_KEEP_UNDO) == 0) {</a>
<a name="ln749">    u_blockfree(buf);               // free the memory allocated for undo</a>
<a name="ln750">    u_clearall(buf);                // reset all undo information</a>
<a name="ln751">  }</a>
<a name="ln752">  syntax_clear(&amp;buf-&gt;b_s);          // reset syntax info</a>
<a name="ln753">  buf-&gt;b_flags &amp;= ~BF_READERR;      // a read error is no longer relevant</a>
<a name="ln754">}</a>
<a name="ln755"> </a>
<a name="ln756">/*</a>
<a name="ln757"> * Free a buffer structure and the things it contains related to the buffer</a>
<a name="ln758"> * itself (not the file, that must have been done already).</a>
<a name="ln759"> */</a>
<a name="ln760">static void free_buffer(buf_T *buf)</a>
<a name="ln761">{</a>
<a name="ln762">  handle_unregister_buffer(buf);</a>
<a name="ln763">  buf_free_count++;</a>
<a name="ln764">  // b:changedtick uses an item in buf_T.</a>
<a name="ln765">  free_buffer_stuff(buf, kBffClearWinInfo);</a>
<a name="ln766">  if (buf-&gt;b_vars-&gt;dv_refcount &gt; DO_NOT_FREE_CNT) {</a>
<a name="ln767">    tv_dict_add(buf-&gt;b_vars,</a>
<a name="ln768">                tv_dict_item_copy((dictitem_T *)(&amp;buf-&gt;changedtick_di)));</a>
<a name="ln769">  }</a>
<a name="ln770">  unref_var_dict(buf-&gt;b_vars);</a>
<a name="ln771">  aubuflocal_remove(buf);</a>
<a name="ln772">  tv_dict_unref(buf-&gt;additional_data);</a>
<a name="ln773">  xfree(buf-&gt;b_prompt_text);</a>
<a name="ln774">  callback_free(&amp;buf-&gt;b_prompt_callback);</a>
<a name="ln775">  callback_free(&amp;buf-&gt;b_prompt_interrupt);</a>
<a name="ln776">  clear_fmark(&amp;buf-&gt;b_last_cursor);</a>
<a name="ln777">  clear_fmark(&amp;buf-&gt;b_last_insert);</a>
<a name="ln778">  clear_fmark(&amp;buf-&gt;b_last_change);</a>
<a name="ln779">  for (size_t i = 0; i &lt; NMARKS; i++) {</a>
<a name="ln780">    free_fmark(buf-&gt;b_namedm[i]);</a>
<a name="ln781">  }</a>
<a name="ln782">  for (int i = 0; i &lt; buf-&gt;b_changelistlen; i++) {</a>
<a name="ln783">    free_fmark(buf-&gt;b_changelist[i]);</a>
<a name="ln784">  }</a>
<a name="ln785">  if (autocmd_busy) {</a>
<a name="ln786">    // Do not free the buffer structure while autocommands are executing,</a>
<a name="ln787">    // it's still needed. Free it when autocmd_busy is reset.</a>
<a name="ln788">    memset(&amp;buf-&gt;b_namedm[0], 0, sizeof(buf-&gt;b_namedm));</a>
<a name="ln789">    memset(&amp;buf-&gt;b_changelist[0], 0, sizeof(buf-&gt;b_changelist));</a>
<a name="ln790">    buf-&gt;b_next = au_pending_free_buf;</a>
<a name="ln791">    au_pending_free_buf = buf;</a>
<a name="ln792">  } else {</a>
<a name="ln793">    xfree(buf);</a>
<a name="ln794">  }</a>
<a name="ln795">}</a>
<a name="ln796"> </a>
<a name="ln797">/// Free stuff in the buffer for &quot;:bdel&quot; and when wiping out the buffer.</a>
<a name="ln798">///</a>
<a name="ln799">/// @param buf  Buffer pointer</a>
<a name="ln800">/// @param free_flags  BufFreeFlags</a>
<a name="ln801">static void free_buffer_stuff(buf_T *buf, int free_flags)</a>
<a name="ln802">{</a>
<a name="ln803">  if (free_flags &amp; kBffClearWinInfo) {</a>
<a name="ln804">    clear_wininfo(buf);                 // including window-local options</a>
<a name="ln805">    free_buf_options(buf, true);</a>
<a name="ln806">    ga_clear(&amp;buf-&gt;b_s.b_langp);</a>
<a name="ln807">  }</a>
<a name="ln808">  {</a>
<a name="ln809">    // Avoid losing b:changedtick when deleting buffer: clearing variables</a>
<a name="ln810">    // implies using clear_tv() on b:changedtick and that sets changedtick to</a>
<a name="ln811">    // zero.</a>
<a name="ln812">    hashitem_T *const changedtick_hi = hash_find(</a>
<a name="ln813">        &amp;buf-&gt;b_vars-&gt;dv_hashtab, (const char_u *)&quot;changedtick&quot;);</a>
<a name="ln814">    assert(changedtick_hi != NULL);</a>
<a name="ln815">    hash_remove(&amp;buf-&gt;b_vars-&gt;dv_hashtab, changedtick_hi);</a>
<a name="ln816">  }</a>
<a name="ln817">  vars_clear(&amp;buf-&gt;b_vars-&gt;dv_hashtab);   // free all internal variables</a>
<a name="ln818">  hash_init(&amp;buf-&gt;b_vars-&gt;dv_hashtab);</a>
<a name="ln819">  if (free_flags &amp; kBffInitChangedtick) {</a>
<a name="ln820">    buf_init_changedtick(buf);</a>
<a name="ln821">  }</a>
<a name="ln822">  uc_clear(&amp;buf-&gt;b_ucmds);               // clear local user commands</a>
<a name="ln823">  buf_delete_signs(buf, (char_u *)&quot;*&quot;);  // delete any signs</a>
<a name="ln824">  extmark_free_all(buf);                 // delete any extmarks</a>
<a name="ln825">  map_clear_int(buf, MAP_ALL_MODES, true, false);    // clear local mappings</a>
<a name="ln826">  map_clear_int(buf, MAP_ALL_MODES, true, true);     // clear local abbrevs</a>
<a name="ln827">  XFREE_CLEAR(buf-&gt;b_start_fenc);</a>
<a name="ln828"> </a>
<a name="ln829">  buf_updates_unload(buf, false);</a>
<a name="ln830">}</a>
<a name="ln831"> </a>
<a name="ln832">/*</a>
<a name="ln833"> * Free the b_wininfo list for buffer &quot;buf&quot;.</a>
<a name="ln834"> */</a>
<a name="ln835">static void clear_wininfo(buf_T *buf)</a>
<a name="ln836">{</a>
<a name="ln837">  wininfo_T   *wip;</a>
<a name="ln838"> </a>
<a name="ln839">  while (buf-&gt;b_wininfo != NULL) {</a>
<a name="ln840">    wip = buf-&gt;b_wininfo;</a>
<a name="ln841">    buf-&gt;b_wininfo = wip-&gt;wi_next;</a>
<a name="ln842">    free_wininfo(wip, buf);</a>
<a name="ln843">  }</a>
<a name="ln844">}</a>
<a name="ln845"> </a>
<a name="ln846">/*</a>
<a name="ln847"> * Go to another buffer.  Handles the result of the ATTENTION dialog.</a>
<a name="ln848"> */</a>
<a name="ln849">void goto_buffer(exarg_T *eap, int start, int dir, int count)</a>
<a name="ln850">{</a>
<a name="ln851">  bufref_T old_curbuf;</a>
<a name="ln852">  set_bufref(&amp;old_curbuf, curbuf);</a>
<a name="ln853">  swap_exists_action = SEA_DIALOG;</a>
<a name="ln854"> </a>
<a name="ln855">  (void)do_buffer(*eap-&gt;cmd == 's' ? DOBUF_SPLIT : DOBUF_GOTO,</a>
<a name="ln856">                  start, dir, count, eap-&gt;forceit);</a>
<a name="ln857"> </a>
<a name="ln858">  if (swap_exists_action == SEA_QUIT &amp;&amp; *eap-&gt;cmd == 's') {</a>
<a name="ln859">    cleanup_T cs;</a>
<a name="ln860"> </a>
<a name="ln861">    // Reset the error/interrupt/exception state here so that</a>
<a name="ln862">    // aborting() returns false when closing a window.</a>
<a name="ln863">    enter_cleanup(&amp;cs);</a>
<a name="ln864"> </a>
<a name="ln865">    // Quitting means closing the split window, nothing else.</a>
<a name="ln866">    win_close(curwin, true);</a>
<a name="ln867">    swap_exists_action = SEA_NONE;</a>
<a name="ln868">    swap_exists_did_quit = true;</a>
<a name="ln869"> </a>
<a name="ln870">    /* Restore the error/interrupt/exception state if not discarded by a</a>
<a name="ln871">     * new aborting error, interrupt, or uncaught exception. */</a>
<a name="ln872">    leave_cleanup(&amp;cs);</a>
<a name="ln873">  } else {</a>
<a name="ln874">    handle_swap_exists(&amp;old_curbuf);</a>
<a name="ln875">  }</a>
<a name="ln876">}</a>
<a name="ln877"> </a>
<a name="ln878">/// Handle the situation of swap_exists_action being set.</a>
<a name="ln879">///</a>
<a name="ln880">/// It is allowed for &quot;old_curbuf&quot; to be NULL or invalid.</a>
<a name="ln881">///</a>
<a name="ln882">/// @param old_curbuf The buffer to check for.</a>
<a name="ln883">void handle_swap_exists(bufref_T *old_curbuf)</a>
<a name="ln884">{</a>
<a name="ln885">  cleanup_T cs;</a>
<a name="ln886">  long old_tw = curbuf-&gt;b_p_tw;</a>
<a name="ln887">  buf_T *buf;</a>
<a name="ln888"> </a>
<a name="ln889">  if (swap_exists_action == SEA_QUIT) {</a>
<a name="ln890">    // Reset the error/interrupt/exception state here so that</a>
<a name="ln891">    // aborting() returns false when closing a buffer.</a>
<a name="ln892">    enter_cleanup(&amp;cs);</a>
<a name="ln893"> </a>
<a name="ln894">    // User selected Quit at ATTENTION prompt.  Go back to previous</a>
<a name="ln895">    // buffer.  If that buffer is gone or the same as the current one,</a>
<a name="ln896">    // open a new, empty buffer.</a>
<a name="ln897">    swap_exists_action = SEA_NONE;      // don't want it again</a>
<a name="ln898">    swap_exists_did_quit = true;</a>
<a name="ln899">    close_buffer(curwin, curbuf, DOBUF_UNLOAD, false);</a>
<a name="ln900">    if (old_curbuf == NULL</a>
<a name="ln901">        || !bufref_valid(old_curbuf)</a>
<a name="ln902">        || old_curbuf-&gt;br_buf == curbuf) {</a>
<a name="ln903">      // Block autocommands here because curwin-&gt;w_buffer is NULL.</a>
<a name="ln904">      block_autocmds();</a>
<a name="ln905">      buf = buflist_new(NULL, NULL, 1L, BLN_CURBUF | BLN_LISTED);</a>
<a name="ln906">      unblock_autocmds();</a>
<a name="ln907">    } else {</a>
<a name="ln908">      buf = old_curbuf-&gt;br_buf;</a>
<a name="ln909">    }</a>
<a name="ln910">    if (buf != NULL) {</a>
<a name="ln911">      int old_msg_silent = msg_silent;</a>
<a name="ln912"> </a>
<a name="ln913">      if (shortmess(SHM_FILEINFO)) {</a>
<a name="ln914">        msg_silent = 1;  // prevent fileinfo message</a>
<a name="ln915">      }</a>
<a name="ln916">      enter_buffer(buf);</a>
<a name="ln917">      // restore msg_silent, so that the command line will be shown</a>
<a name="ln918">      msg_silent = old_msg_silent;</a>
<a name="ln919"> </a>
<a name="ln920">      if (old_tw != curbuf-&gt;b_p_tw) {</a>
<a name="ln921">        check_colorcolumn(curwin);</a>
<a name="ln922">      }</a>
<a name="ln923">    }</a>
<a name="ln924">    // If &quot;old_curbuf&quot; is NULL we are in big trouble here...</a>
<a name="ln925"> </a>
<a name="ln926">    /* Restore the error/interrupt/exception state if not discarded by a</a>
<a name="ln927">     * new aborting error, interrupt, or uncaught exception. */</a>
<a name="ln928">    leave_cleanup(&amp;cs);</a>
<a name="ln929">  } else if (swap_exists_action == SEA_RECOVER) {</a>
<a name="ln930">    // Reset the error/interrupt/exception state here so that</a>
<a name="ln931">    // aborting() returns false when closing a buffer.</a>
<a name="ln932">    enter_cleanup(&amp;cs);</a>
<a name="ln933"> </a>
<a name="ln934">    // User selected Recover at ATTENTION prompt.</a>
<a name="ln935">    msg_scroll = true;</a>
<a name="ln936">    ml_recover(false);</a>
<a name="ln937">    MSG_PUTS(&quot;\n&quot;);     // don't overwrite the last message</a>
<a name="ln938">    cmdline_row = msg_row;</a>
<a name="ln939">    do_modelines(0);</a>
<a name="ln940"> </a>
<a name="ln941">    /* Restore the error/interrupt/exception state if not discarded by a</a>
<a name="ln942">     * new aborting error, interrupt, or uncaught exception. */</a>
<a name="ln943">    leave_cleanup(&amp;cs);</a>
<a name="ln944">  }</a>
<a name="ln945">  swap_exists_action = SEA_NONE;  // -V519</a>
<a name="ln946">}</a>
<a name="ln947"> </a>
<a name="ln948">/*</a>
<a name="ln949"> * do_bufdel() - delete or unload buffer(s)</a>
<a name="ln950"> *</a>
<a name="ln951"> * addr_count == 0: &quot;:bdel&quot; - delete current buffer</a>
<a name="ln952"> * addr_count == 1: &quot;:N bdel&quot; or &quot;:bdel N [N ..]&quot; - first delete</a>
<a name="ln953"> *		    buffer &quot;end_bnr&quot;, then any other arguments.</a>
<a name="ln954"> * addr_count == 2: &quot;:N,N bdel&quot; - delete buffers in range</a>
<a name="ln955"> *</a>
<a name="ln956"> * command can be DOBUF_UNLOAD (&quot;:bunload&quot;), DOBUF_WIPE (&quot;:bwipeout&quot;) or</a>
<a name="ln957"> * DOBUF_DEL (&quot;:bdel&quot;)</a>
<a name="ln958"> *</a>
<a name="ln959"> * Returns error message or NULL</a>
<a name="ln960"> */</a>
<a name="ln961">char_u *</a>
<a name="ln962">do_bufdel(</a>
<a name="ln963">    int command,</a>
<a name="ln964">    char_u *arg,               // pointer to extra arguments</a>
<a name="ln965">    int addr_count,</a>
<a name="ln966">    int start_bnr,             // first buffer number in a range</a>
<a name="ln967">    int end_bnr,               // buffer nr or last buffer nr in a range</a>
<a name="ln968">    int forceit</a>
<a name="ln969">)</a>
<a name="ln970">{</a>
<a name="ln971">  int do_current = 0;             // delete current buffer?</a>
<a name="ln972">  int deleted = 0;                // number of buffers deleted</a>
<a name="ln973">  char_u      *errormsg = NULL;   // return value</a>
<a name="ln974">  int bnr;                        // buffer number</a>
<a name="ln975">  char_u      *p;</a>
<a name="ln976"> </a>
<a name="ln977">  if (addr_count == 0) {</a>
<a name="ln978">    (void)do_buffer(command, DOBUF_CURRENT, FORWARD, 0, forceit);</a>
<a name="ln979">  } else {</a>
<a name="ln980">    if (addr_count == 2) {</a>
<a name="ln981">      if (*arg) {               // both range and argument is not allowed</a>
<a name="ln982">        return (char_u *)_(e_trailing);</a>
<a name="ln983">      }</a>
<a name="ln984">      bnr = start_bnr;</a>
<a name="ln985">    } else {    // addr_count == 1</a>
<a name="ln986">      bnr = end_bnr;</a>
<a name="ln987">    }</a>
<a name="ln988"> </a>
<a name="ln989">    for (; !got_int; os_breakcheck()) {</a>
<a name="ln990">      /*</a>
<a name="ln991">       * delete the current buffer last, otherwise when the</a>
<a name="ln992">       * current buffer is deleted, the next buffer becomes</a>
<a name="ln993">       * the current one and will be loaded, which may then</a>
<a name="ln994">       * also be deleted, etc.</a>
<a name="ln995">       */</a>
<a name="ln996">      if (bnr == curbuf-&gt;b_fnum) {</a>
<a name="ln997">        do_current = bnr;</a>
<a name="ln998">      } else if (do_buffer(command, DOBUF_FIRST, FORWARD, bnr,</a>
<a name="ln999">                           forceit) == OK) {</a>
<a name="ln1000">        deleted++;</a>
<a name="ln1001">      }</a>
<a name="ln1002"> </a>
<a name="ln1003">      /*</a>
<a name="ln1004">       * find next buffer number to delete/unload</a>
<a name="ln1005">       */</a>
<a name="ln1006">      if (addr_count == 2) {</a>
<a name="ln1007">        if (++bnr &gt; end_bnr) {</a>
<a name="ln1008">          break;</a>
<a name="ln1009">        }</a>
<a name="ln1010">      } else {    // addr_count == 1</a>
<a name="ln1011">        arg = skipwhite(arg);</a>
<a name="ln1012">        if (*arg == NUL) {</a>
<a name="ln1013">          break;</a>
<a name="ln1014">        }</a>
<a name="ln1015">        if (!ascii_isdigit(*arg)) {</a>
<a name="ln1016">          p = skiptowhite_esc(arg);</a>
<a name="ln1017">          bnr = buflist_findpat(arg, p, command == DOBUF_WIPE,</a>
<a name="ln1018">                                false, false);</a>
<a name="ln1019">          if (bnr &lt; 0) {                    // failed</a>
<a name="ln1020">            break;</a>
<a name="ln1021">          }</a>
<a name="ln1022">          arg = p;</a>
<a name="ln1023">        } else {</a>
<a name="ln1024">          bnr = getdigits_int(&amp;arg, false, 0);</a>
<a name="ln1025">        }</a>
<a name="ln1026">      }</a>
<a name="ln1027">    }</a>
<a name="ln1028">    if (!got_int &amp;&amp; do_current</a>
<a name="ln1029">        &amp;&amp; do_buffer(command, DOBUF_FIRST,</a>
<a name="ln1030">                     FORWARD, do_current, forceit) == OK) {</a>
<a name="ln1031">      deleted++;</a>
<a name="ln1032">    }</a>
<a name="ln1033"> </a>
<a name="ln1034">    if (deleted == 0) {</a>
<a name="ln1035">      if (command == DOBUF_UNLOAD) {</a>
<a name="ln1036">        STRCPY(IObuff, _(&quot;E515: No buffers were unloaded&quot;));</a>
<a name="ln1037">      } else if (command == DOBUF_DEL) {</a>
<a name="ln1038">        STRCPY(IObuff, _(&quot;E516: No buffers were deleted&quot;));</a>
<a name="ln1039">      } else {</a>
<a name="ln1040">        STRCPY(IObuff, _(&quot;E517: No buffers were wiped out&quot;));</a>
<a name="ln1041">      }</a>
<a name="ln1042">      errormsg = IObuff;</a>
<a name="ln1043">    } else if (deleted &gt;= p_report) {</a>
<a name="ln1044">      if (command == DOBUF_UNLOAD) {</a>
<a name="ln1045">        if (deleted == 1) {</a>
<a name="ln1046">          MSG(_(&quot;1 buffer unloaded&quot;));</a>
<a name="ln1047">        } else {</a>
<a name="ln1048">          smsg(_(&quot;%d buffers unloaded&quot;), deleted);</a>
<a name="ln1049">        }</a>
<a name="ln1050">      } else if (command == DOBUF_DEL) {</a>
<a name="ln1051">        if (deleted == 1) {</a>
<a name="ln1052">          MSG(_(&quot;1 buffer deleted&quot;));</a>
<a name="ln1053">        } else {</a>
<a name="ln1054">          smsg(_(&quot;%d buffers deleted&quot;), deleted);</a>
<a name="ln1055">        }</a>
<a name="ln1056">      } else {</a>
<a name="ln1057">        if (deleted == 1) {</a>
<a name="ln1058">          MSG(_(&quot;1 buffer wiped out&quot;));</a>
<a name="ln1059">        } else {</a>
<a name="ln1060">          smsg(_(&quot;%d buffers wiped out&quot;), deleted);</a>
<a name="ln1061">        }</a>
<a name="ln1062">      }</a>
<a name="ln1063">    }</a>
<a name="ln1064">  }</a>
<a name="ln1065"> </a>
<a name="ln1066"> </a>
<a name="ln1067">  return errormsg;</a>
<a name="ln1068">}</a>
<a name="ln1069"> </a>
<a name="ln1070"> </a>
<a name="ln1071"> </a>
<a name="ln1072">/*</a>
<a name="ln1073"> * Make the current buffer empty.</a>
<a name="ln1074"> * Used when it is wiped out and it's the last buffer.</a>
<a name="ln1075"> */</a>
<a name="ln1076">static int empty_curbuf(int close_others, int forceit, int action)</a>
<a name="ln1077">{</a>
<a name="ln1078">  int retval;</a>
<a name="ln1079">  buf_T   *buf = curbuf;</a>
<a name="ln1080"> </a>
<a name="ln1081">  if (action == DOBUF_UNLOAD) {</a>
<a name="ln1082">    EMSG(_(&quot;E90: Cannot unload last buffer&quot;));</a>
<a name="ln1083">    return FAIL;</a>
<a name="ln1084">  }</a>
<a name="ln1085"> </a>
<a name="ln1086">  bufref_T bufref;</a>
<a name="ln1087">  set_bufref(&amp;bufref, buf);</a>
<a name="ln1088"> </a>
<a name="ln1089">  if (close_others) {</a>
<a name="ln1090">    // Close any other windows on this buffer, then make it empty.</a>
<a name="ln1091">    close_windows(buf, true);</a>
<a name="ln1092">  }</a>
<a name="ln1093"> </a>
<a name="ln1094">  setpcmark();</a>
<a name="ln1095">  retval = do_ecmd(0, NULL, NULL, NULL, ECMD_ONE,</a>
<a name="ln1096">      forceit ? ECMD_FORCEIT : 0, curwin);</a>
<a name="ln1097"> </a>
<a name="ln1098">  // do_ecmd() may create a new buffer, then we have to delete</a>
<a name="ln1099">  // the old one.  But do_ecmd() may have done that already, check</a>
<a name="ln1100">  // if the buffer still exists.</a>
<a name="ln1101">  if (buf != curbuf &amp;&amp; bufref_valid(&amp;bufref) &amp;&amp; buf-&gt;b_nwindows == 0) {</a>
<a name="ln1102">    close_buffer(NULL, buf, action, false);</a>
<a name="ln1103">  }</a>
<a name="ln1104"> </a>
<a name="ln1105">  if (!close_others) {</a>
<a name="ln1106">    need_fileinfo = false;</a>
<a name="ln1107">  }</a>
<a name="ln1108"> </a>
<a name="ln1109">  return retval;</a>
<a name="ln1110">}</a>
<a name="ln1111">/*</a>
<a name="ln1112"> * Implementation of the commands for the buffer list.</a>
<a name="ln1113"> *</a>
<a name="ln1114"> * action == DOBUF_GOTO	    go to specified buffer</a>
<a name="ln1115"> * action == DOBUF_SPLIT    split window and go to specified buffer</a>
<a name="ln1116"> * action == DOBUF_UNLOAD   unload specified buffer(s)</a>
<a name="ln1117"> * action == DOBUF_DEL	    delete specified buffer(s) from buffer list</a>
<a name="ln1118"> * action == DOBUF_WIPE	    delete specified buffer(s) really</a>
<a name="ln1119"> *</a>
<a name="ln1120"> * start == DOBUF_CURRENT   go to &quot;count&quot; buffer from current buffer</a>
<a name="ln1121"> * start == DOBUF_FIRST	    go to &quot;count&quot; buffer from first buffer</a>
<a name="ln1122"> * start == DOBUF_LAST	    go to &quot;count&quot; buffer from last buffer</a>
<a name="ln1123"> * start == DOBUF_MOD	    go to &quot;count&quot; modified buffer from current buffer</a>
<a name="ln1124"> *</a>
<a name="ln1125"> * Return FAIL or OK.</a>
<a name="ln1126"> */</a>
<a name="ln1127">int</a>
<a name="ln1128">do_buffer(</a>
<a name="ln1129">    int action,</a>
<a name="ln1130">    int start,</a>
<a name="ln1131">    int dir,                        // FORWARD or BACKWARD</a>
<a name="ln1132">    int count,                      // buffer number or number of buffers</a>
<a name="ln1133">    int forceit                     // true for :...!</a>
<a name="ln1134">)</a>
<a name="ln1135">{</a>
<a name="ln1136">  buf_T       *buf;</a>
<a name="ln1137">  buf_T       *bp;</a>
<a name="ln1138">  int unload = (action == DOBUF_UNLOAD || action == DOBUF_DEL</a>
<a name="ln1139">                || action == DOBUF_WIPE);</a>
<a name="ln1140"> </a>
<a name="ln1141">  switch (start) {</a>
<a name="ln1142">  case DOBUF_FIRST:   buf = firstbuf; break;</a>
<a name="ln1143">  case DOBUF_LAST:    buf = lastbuf;  break;</a>
<a name="ln1144">  default:            buf = curbuf;   break;</a>
<a name="ln1145">  }</a>
<a name="ln1146">  if (start == DOBUF_MOD) {         // find next modified buffer</a>
<a name="ln1147">    while (count-- &gt; 0) {</a>
<a name="ln1148">      do {</a>
<a name="ln1149">        buf = buf-&gt;b_next;</a>
<a name="ln1150">        if (buf == NULL) {</a>
<a name="ln1151">          buf = firstbuf;</a>
<a name="ln1152">        }</a>
<a name="ln1153">      } while (buf != curbuf &amp;&amp; !bufIsChanged(buf));</a>
<a name="ln1154">    }</a>
<a name="ln1155">    if (!bufIsChanged(buf)) {</a>
<a name="ln1156">      EMSG(_(&quot;E84: No modified buffer found&quot;));</a>
<a name="ln1157">      return FAIL;</a>
<a name="ln1158">    }</a>
<a name="ln1159">  } else if (start == DOBUF_FIRST &amp;&amp; count) {  // find specified buffer number</a>
<a name="ln1160">    while (buf != NULL &amp;&amp; buf-&gt;b_fnum != count) {</a>
<a name="ln1161">      buf = buf-&gt;b_next;</a>
<a name="ln1162">    }</a>
<a name="ln1163">  } else {</a>
<a name="ln1164">    bp = NULL;</a>
<a name="ln1165">    while (count &gt; 0 || (!unload &amp;&amp; !buf-&gt;b_p_bl &amp;&amp; bp != buf)) {</a>
<a name="ln1166">      /* remember the buffer where we start, we come back there when all</a>
<a name="ln1167">       * buffers are unlisted. */</a>
<a name="ln1168">      if (bp == NULL) {</a>
<a name="ln1169">        bp = buf;</a>
<a name="ln1170">      }</a>
<a name="ln1171">      if (dir == FORWARD) {</a>
<a name="ln1172">        buf = buf-&gt;b_next;</a>
<a name="ln1173">        if (buf == NULL) {</a>
<a name="ln1174">          buf = firstbuf;</a>
<a name="ln1175">        }</a>
<a name="ln1176">      } else {</a>
<a name="ln1177">        buf = buf-&gt;b_prev;</a>
<a name="ln1178">        if (buf == NULL) {</a>
<a name="ln1179">          buf = lastbuf;</a>
<a name="ln1180">        }</a>
<a name="ln1181">      }</a>
<a name="ln1182">      // don't count unlisted buffers</a>
<a name="ln1183">      if (unload || buf-&gt;b_p_bl) {</a>
<a name="ln1184">        count--;</a>
<a name="ln1185">        bp = NULL;              // use this buffer as new starting point</a>
<a name="ln1186">      }</a>
<a name="ln1187">      if (bp == buf) {</a>
<a name="ln1188">        // back where we started, didn't find anything.</a>
<a name="ln1189">        EMSG(_(&quot;E85: There is no listed buffer&quot;));</a>
<a name="ln1190">        return FAIL;</a>
<a name="ln1191">      }</a>
<a name="ln1192">    }</a>
<a name="ln1193">  }</a>
<a name="ln1194"> </a>
<a name="ln1195">  if (buf == NULL) {        // could not find it</a>
<a name="ln1196">    if (start == DOBUF_FIRST) {</a>
<a name="ln1197">      // don't warn when deleting</a>
<a name="ln1198">      if (!unload) {</a>
<a name="ln1199">        EMSGN(_(e_nobufnr), count);</a>
<a name="ln1200">      }</a>
<a name="ln1201">    } else if (dir == FORWARD) {</a>
<a name="ln1202">      EMSG(_(&quot;E87: Cannot go beyond last buffer&quot;));</a>
<a name="ln1203">    } else {</a>
<a name="ln1204">      EMSG(_(&quot;E88: Cannot go before first buffer&quot;));</a>
<a name="ln1205">    }</a>
<a name="ln1206">    return FAIL;</a>
<a name="ln1207">  }</a>
<a name="ln1208"> </a>
<a name="ln1209"> </a>
<a name="ln1210">  /*</a>
<a name="ln1211">   * delete buffer buf from memory and/or the list</a>
<a name="ln1212">   */</a>
<a name="ln1213">  if (unload) {</a>
<a name="ln1214">    int forward;</a>
<a name="ln1215">    bufref_T bufref;</a>
<a name="ln1216">    set_bufref(&amp;bufref, buf);</a>
<a name="ln1217"> </a>
<a name="ln1218">    /* When unloading or deleting a buffer that's already unloaded and</a>
<a name="ln1219">     * unlisted: fail silently. */</a>
<a name="ln1220">    if (action != DOBUF_WIPE &amp;&amp; buf-&gt;b_ml.ml_mfp == NULL &amp;&amp; !buf-&gt;b_p_bl) {</a>
<a name="ln1221">      return FAIL;</a>
<a name="ln1222">    }</a>
<a name="ln1223"> </a>
<a name="ln1224">    if (!forceit &amp;&amp; (buf-&gt;terminal || bufIsChanged(buf))) {</a>
<a name="ln1225">      if ((p_confirm || cmdmod.confirm) &amp;&amp; p_write &amp;&amp; !buf-&gt;terminal) {</a>
<a name="ln1226">        dialog_changed(buf, false);</a>
<a name="ln1227">        if (!bufref_valid(&amp;bufref)) {</a>
<a name="ln1228">          // Autocommand deleted buffer, oops! It's not changed now.</a>
<a name="ln1229">          return FAIL;</a>
<a name="ln1230">        }</a>
<a name="ln1231">        // If it's still changed fail silently, the dialog already</a>
<a name="ln1232">        // mentioned why it fails.</a>
<a name="ln1233">        if (bufIsChanged(buf)) {</a>
<a name="ln1234">          return FAIL;</a>
<a name="ln1235">        }</a>
<a name="ln1236">      } else {</a>
<a name="ln1237">        if (buf-&gt;terminal) {</a>
<a name="ln1238">          if (p_confirm || cmdmod.confirm) {</a>
<a name="ln1239">            if (!dialog_close_terminal(buf)) {</a>
<a name="ln1240">              return FAIL;</a>
<a name="ln1241">            }</a>
<a name="ln1242">          } else {</a>
<a name="ln1243">            EMSG2(_(&quot;E89: %s will be killed (add ! to override)&quot;),</a>
<a name="ln1244">                  (char *)buf-&gt;b_fname);</a>
<a name="ln1245">            return FAIL;</a>
<a name="ln1246">          }</a>
<a name="ln1247">        } else {</a>
<a name="ln1248">          EMSGN(_(&quot;E89: No write since last change for buffer %&quot; PRId64</a>
<a name="ln1249">                  &quot; (add ! to override)&quot;),</a>
<a name="ln1250">                buf-&gt;b_fnum);</a>
<a name="ln1251">          return FAIL;</a>
<a name="ln1252">        }</a>
<a name="ln1253">      }</a>
<a name="ln1254">    }</a>
<a name="ln1255"> </a>
<a name="ln1256">    // When closing the current buffer stop Visual mode.</a>
<a name="ln1257">    if (buf == curbuf &amp;&amp; VIsual_active) {</a>
<a name="ln1258">      end_visual_mode();</a>
<a name="ln1259">    }</a>
<a name="ln1260"> </a>
<a name="ln1261">    /*</a>
<a name="ln1262">     * If deleting the last (listed) buffer, make it empty.</a>
<a name="ln1263">     * The last (listed) buffer cannot be unloaded.</a>
<a name="ln1264">     */</a>
<a name="ln1265">    bp = NULL;</a>
<a name="ln1266">    FOR_ALL_BUFFERS(bp2) {</a>
<a name="ln1267">      if (bp2-&gt;b_p_bl &amp;&amp; bp2 != buf) {</a>
<a name="ln1268">        bp = bp2;</a>
<a name="ln1269">        break;</a>
<a name="ln1270">      }</a>
<a name="ln1271">    }</a>
<a name="ln1272">    if (bp == NULL &amp;&amp; buf == curbuf) {</a>
<a name="ln1273">      return empty_curbuf(true, forceit, action);</a>
<a name="ln1274">    }</a>
<a name="ln1275"> </a>
<a name="ln1276">    /*</a>
<a name="ln1277">     * If the deleted buffer is the current one, close the current window</a>
<a name="ln1278">     * (unless it's the only window).  Repeat this so long as we end up in</a>
<a name="ln1279">     * a window with this buffer.</a>
<a name="ln1280">     */</a>
<a name="ln1281">    while (buf == curbuf</a>
<a name="ln1282">           &amp;&amp; !(curwin-&gt;w_closing || curwin-&gt;w_buffer-&gt;b_locked &gt; 0)</a>
<a name="ln1283">           &amp;&amp; (!ONE_WINDOW || first_tabpage-&gt;tp_next != NULL)) {</a>
<a name="ln1284">      if (win_close(curwin, false) == FAIL) {</a>
<a name="ln1285">        break;</a>
<a name="ln1286">      }</a>
<a name="ln1287">    }</a>
<a name="ln1288"> </a>
<a name="ln1289">    /*</a>
<a name="ln1290">     * If the buffer to be deleted is not the current one, delete it here.</a>
<a name="ln1291">     */</a>
<a name="ln1292">    if (buf != curbuf) {</a>
<a name="ln1293">      close_windows(buf, false);</a>
<a name="ln1294">      if (buf != curbuf &amp;&amp; bufref_valid(&amp;bufref) &amp;&amp; buf-&gt;b_nwindows &lt;= 0) {</a>
<a name="ln1295">        close_buffer(NULL, buf, action, false);</a>
<a name="ln1296">      }</a>
<a name="ln1297">      return OK;</a>
<a name="ln1298">    }</a>
<a name="ln1299"> </a>
<a name="ln1300">    // Deleting the current buffer: Need to find another buffer to go to.</a>
<a name="ln1301">    // There should be another, otherwise it would have been handled</a>
<a name="ln1302">    // above.  However, autocommands may have deleted all buffers.</a>
<a name="ln1303">    // First use au_new_curbuf.br_buf, if it is valid.</a>
<a name="ln1304">    // Then prefer the buffer we most recently visited.</a>
<a name="ln1305">    // Else try to find one that is loaded, after the current buffer,</a>
<a name="ln1306">    // then before the current buffer.</a>
<a name="ln1307">    // Finally use any buffer.</a>
<a name="ln1308">    buf = NULL;  // Selected buffer.</a>
<a name="ln1309">    bp = NULL;   // Used when no loaded buffer found.</a>
<a name="ln1310">    if (au_new_curbuf.br_buf != NULL &amp;&amp; bufref_valid(&amp;au_new_curbuf)) {</a>
<a name="ln1311">      buf = au_new_curbuf.br_buf;</a>
<a name="ln1312">    } else if (curwin-&gt;w_jumplistlen &gt; 0) {</a>
<a name="ln1313">      int jumpidx;</a>
<a name="ln1314"> </a>
<a name="ln1315">      jumpidx = curwin-&gt;w_jumplistidx - 1;</a>
<a name="ln1316">      if (jumpidx &lt; 0) {</a>
<a name="ln1317">        jumpidx = curwin-&gt;w_jumplistlen - 1;</a>
<a name="ln1318">      }</a>
<a name="ln1319"> </a>
<a name="ln1320">      forward = jumpidx;</a>
<a name="ln1321">      while (jumpidx != curwin-&gt;w_jumplistidx) {</a>
<a name="ln1322">        buf = buflist_findnr(curwin-&gt;w_jumplist[jumpidx].fmark.fnum);</a>
<a name="ln1323">        if (buf != NULL) {</a>
<a name="ln1324">          if (buf == curbuf || !buf-&gt;b_p_bl) {</a>
<a name="ln1325">            buf = NULL;                 // skip current and unlisted bufs</a>
<a name="ln1326">          } else if (buf-&gt;b_ml.ml_mfp == NULL) {</a>
<a name="ln1327">            // skip unloaded buf, but may keep it for later</a>
<a name="ln1328">            if (bp == NULL) {</a>
<a name="ln1329">              bp = buf;</a>
<a name="ln1330">            }</a>
<a name="ln1331">            buf = NULL;</a>
<a name="ln1332">          }</a>
<a name="ln1333">        }</a>
<a name="ln1334">        if (buf != NULL) {         // found a valid buffer: stop searching</a>
<a name="ln1335">          break;</a>
<a name="ln1336">        }</a>
<a name="ln1337">        // advance to older entry in jump list</a>
<a name="ln1338">        if (!jumpidx &amp;&amp; curwin-&gt;w_jumplistidx == curwin-&gt;w_jumplistlen) {</a>
<a name="ln1339">          break;</a>
<a name="ln1340">        }</a>
<a name="ln1341">        if (--jumpidx &lt; 0) {</a>
<a name="ln1342">          jumpidx = curwin-&gt;w_jumplistlen - 1;</a>
<a name="ln1343">        }</a>
<a name="ln1344">        if (jumpidx == forward) {               // List exhausted for sure</a>
<a name="ln1345">          break;</a>
<a name="ln1346">        }</a>
<a name="ln1347">      }</a>
<a name="ln1348">    }</a>
<a name="ln1349"> </a>
<a name="ln1350">    if (buf == NULL) {          // No previous buffer, Try 2'nd approach</a>
<a name="ln1351">      forward = true;</a>
<a name="ln1352">      buf = curbuf-&gt;b_next;</a>
<a name="ln1353">      for (;; ) {</a>
<a name="ln1354">        if (buf == NULL) {</a>
<a name="ln1355">          if (!forward) {               // tried both directions</a>
<a name="ln1356">            break;</a>
<a name="ln1357">          }</a>
<a name="ln1358">          buf = curbuf-&gt;b_prev;</a>
<a name="ln1359">          forward = false;</a>
<a name="ln1360">          continue;</a>
<a name="ln1361">        }</a>
<a name="ln1362">        // in non-help buffer, try to skip help buffers, and vv</a>
<a name="ln1363">        if (buf-&gt;b_help == curbuf-&gt;b_help &amp;&amp; buf-&gt;b_p_bl) {</a>
<a name="ln1364">          if (buf-&gt;b_ml.ml_mfp != NULL) {           // found loaded buffer</a>
<a name="ln1365">            break;</a>
<a name="ln1366">          }</a>
<a name="ln1367">          if (bp == NULL) {             // remember unloaded buf for later</a>
<a name="ln1368">            bp = buf;</a>
<a name="ln1369">          }</a>
<a name="ln1370">        }</a>
<a name="ln1371">        if (forward) {</a>
<a name="ln1372">          buf = buf-&gt;b_next;</a>
<a name="ln1373">        } else {</a>
<a name="ln1374">          buf = buf-&gt;b_prev;</a>
<a name="ln1375">        }</a>
<a name="ln1376">      }</a>
<a name="ln1377">    }</a>
<a name="ln1378">    if (buf == NULL) {          // No loaded buffer, use unloaded one</a>
<a name="ln1379">      buf = bp;</a>
<a name="ln1380">    }</a>
<a name="ln1381">    if (buf == NULL) {          // No loaded buffer, find listed one</a>
<a name="ln1382">      FOR_ALL_BUFFERS(buf2) {</a>
<a name="ln1383">        if (buf2-&gt;b_p_bl &amp;&amp; buf2 != curbuf) {</a>
<a name="ln1384">          buf = buf2;</a>
<a name="ln1385">          break;</a>
<a name="ln1386">        }</a>
<a name="ln1387">      }</a>
<a name="ln1388">    }</a>
<a name="ln1389">    if (buf == NULL) {          // Still no buffer, just take one</a>
<a name="ln1390">      if (curbuf-&gt;b_next != NULL) {</a>
<a name="ln1391">        buf = curbuf-&gt;b_next;</a>
<a name="ln1392">      } else {</a>
<a name="ln1393">        buf = curbuf-&gt;b_prev;</a>
<a name="ln1394">      }</a>
<a name="ln1395">    }</a>
<a name="ln1396">  }</a>
<a name="ln1397"> </a>
<a name="ln1398">  if (buf == NULL) {</a>
<a name="ln1399">    /* Autocommands must have wiped out all other buffers.  Only option</a>
<a name="ln1400">     * now is to make the current buffer empty. */</a>
<a name="ln1401">    return empty_curbuf(false, forceit, action);</a>
<a name="ln1402">  }</a>
<a name="ln1403"> </a>
<a name="ln1404">  /*</a>
<a name="ln1405">   * make buf current buffer</a>
<a name="ln1406">   */</a>
<a name="ln1407">  if (action == DOBUF_SPLIT) {      // split window first</a>
<a name="ln1408">    // If 'switchbuf' contains &quot;useopen&quot;: jump to first window containing</a>
<a name="ln1409">    // &quot;buf&quot; if one exists</a>
<a name="ln1410">    if ((swb_flags &amp; SWB_USEOPEN) &amp;&amp; buf_jump_open_win(buf)) {</a>
<a name="ln1411">      return OK;</a>
<a name="ln1412">    }</a>
<a name="ln1413">    // If 'switchbuf' contains &quot;usetab&quot;: jump to first window in any tab</a>
<a name="ln1414">    // page containing &quot;buf&quot; if one exists</a>
<a name="ln1415">    if ((swb_flags &amp; SWB_USETAB) &amp;&amp; buf_jump_open_tab(buf)) {</a>
<a name="ln1416">      return OK;</a>
<a name="ln1417">    }</a>
<a name="ln1418">    if (win_split(0, 0) == FAIL) {</a>
<a name="ln1419">      return FAIL;</a>
<a name="ln1420">    }</a>
<a name="ln1421">  }</a>
<a name="ln1422"> </a>
<a name="ln1423">  // go to current buffer - nothing to do</a>
<a name="ln1424">  if (buf == curbuf) {</a>
<a name="ln1425">    return OK;</a>
<a name="ln1426">  }</a>
<a name="ln1427"> </a>
<a name="ln1428">  /*</a>
<a name="ln1429">   * Check if the current buffer may be abandoned.</a>
<a name="ln1430">   */</a>
<a name="ln1431">  if (action == DOBUF_GOTO &amp;&amp; !can_abandon(curbuf, forceit)) {</a>
<a name="ln1432">    if ((p_confirm || cmdmod.confirm) &amp;&amp; p_write) {</a>
<a name="ln1433">      bufref_T bufref;</a>
<a name="ln1434">      set_bufref(&amp;bufref, buf);</a>
<a name="ln1435">      dialog_changed(curbuf, false);</a>
<a name="ln1436">      if (!bufref_valid(&amp;bufref)) {</a>
<a name="ln1437">        // Autocommand deleted buffer, oops!</a>
<a name="ln1438">        return FAIL;</a>
<a name="ln1439">      }</a>
<a name="ln1440">    }</a>
<a name="ln1441">    if (bufIsChanged(curbuf)) {</a>
<a name="ln1442">      no_write_message();</a>
<a name="ln1443">      return FAIL;</a>
<a name="ln1444">    }</a>
<a name="ln1445">  }</a>
<a name="ln1446"> </a>
<a name="ln1447">  // Go to the other buffer.</a>
<a name="ln1448">  set_curbuf(buf, action);</a>
<a name="ln1449"> </a>
<a name="ln1450">  if (action == DOBUF_SPLIT) {</a>
<a name="ln1451">    RESET_BINDING(curwin);      // reset 'scrollbind' and 'cursorbind'</a>
<a name="ln1452">  }</a>
<a name="ln1453"> </a>
<a name="ln1454">  if (aborting()) {         // autocmds may abort script processing</a>
<a name="ln1455">    return FAIL;</a>
<a name="ln1456">  }</a>
<a name="ln1457"> </a>
<a name="ln1458">  return OK;</a>
<a name="ln1459">}</a>
<a name="ln1460"> </a>
<a name="ln1461"> </a>
<a name="ln1462">/*</a>
<a name="ln1463"> * Set current buffer to &quot;buf&quot;.  Executes autocommands and closes current</a>
<a name="ln1464"> * buffer.  &quot;action&quot; tells how to close the current buffer:</a>
<a name="ln1465"> * DOBUF_GOTO	    free or hide it</a>
<a name="ln1466"> * DOBUF_SPLIT	    nothing</a>
<a name="ln1467"> * DOBUF_UNLOAD	    unload it</a>
<a name="ln1468"> * DOBUF_DEL	    delete it</a>
<a name="ln1469"> * DOBUF_WIPE	    wipe it out</a>
<a name="ln1470"> */</a>
<a name="ln1471">void set_curbuf(buf_T *buf, int action)</a>
<a name="ln1472">{</a>
<a name="ln1473">  buf_T       *prevbuf;</a>
<a name="ln1474">  int unload = (action == DOBUF_UNLOAD || action == DOBUF_DEL</a>
<a name="ln1475">                || action == DOBUF_WIPE);</a>
<a name="ln1476">  long old_tw = curbuf-&gt;b_p_tw;</a>
<a name="ln1477"> </a>
<a name="ln1478">  setpcmark();</a>
<a name="ln1479">  if (!cmdmod.keepalt) {</a>
<a name="ln1480">    curwin-&gt;w_alt_fnum = curbuf-&gt;b_fnum;     // remember alternate file</a>
<a name="ln1481">  }</a>
<a name="ln1482">  buflist_altfpos(curwin);                       // remember curpos</a>
<a name="ln1483"> </a>
<a name="ln1484">  // Don't restart Select mode after switching to another buffer.</a>
<a name="ln1485">  VIsual_reselect = false;</a>
<a name="ln1486"> </a>
<a name="ln1487">  // close_windows() or apply_autocmds() may change curbuf and wipe out &quot;buf&quot;</a>
<a name="ln1488">  prevbuf = curbuf;</a>
<a name="ln1489">  bufref_T newbufref;</a>
<a name="ln1490">  bufref_T prevbufref;</a>
<a name="ln1491">  set_bufref(&amp;prevbufref, prevbuf);</a>
<a name="ln1492">  set_bufref(&amp;newbufref, buf);</a>
<a name="ln1493"> </a>
<a name="ln1494">  // Autocommands may delete the curren buffer and/or the buffer we want to go</a>
<a name="ln1495">  // to.  In those cases don't close the buffer.</a>
<a name="ln1496">  if (!apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, false, curbuf)</a>
<a name="ln1497">      || (bufref_valid(&amp;prevbufref) &amp;&amp; bufref_valid(&amp;newbufref)</a>
<a name="ln1498">          &amp;&amp; !aborting())) {</a>
<a name="ln1499">    if (prevbuf == curwin-&gt;w_buffer) {</a>
<a name="ln1500">      reset_synblock(curwin);</a>
<a name="ln1501">    }</a>
<a name="ln1502">    if (unload) {</a>
<a name="ln1503">      close_windows(prevbuf, false);</a>
<a name="ln1504">    }</a>
<a name="ln1505">    if (bufref_valid(&amp;prevbufref) &amp;&amp; !aborting()) {</a>
<a name="ln1506">      win_T  *previouswin = curwin;</a>
<a name="ln1507">      if (prevbuf == curbuf) {</a>
<a name="ln1508">        u_sync(false);</a>
<a name="ln1509">      }</a>
<a name="ln1510">      close_buffer(prevbuf == curwin-&gt;w_buffer ? curwin : NULL,</a>
<a name="ln1511">                   prevbuf,</a>
<a name="ln1512">                   unload</a>
<a name="ln1513">                   ? action</a>
<a name="ln1514">                   : (action == DOBUF_GOTO &amp;&amp; !buf_hide(prevbuf)</a>
<a name="ln1515">                      &amp;&amp; !bufIsChanged(prevbuf)) ? DOBUF_UNLOAD : 0,</a>
<a name="ln1516">                   false);</a>
<a name="ln1517">      if (curwin != previouswin &amp;&amp; win_valid(previouswin)) {</a>
<a name="ln1518">        // autocommands changed curwin, Grr!</a>
<a name="ln1519">        curwin = previouswin;</a>
<a name="ln1520">      }</a>
<a name="ln1521">    }</a>
<a name="ln1522">  }</a>
<a name="ln1523">  /* An autocommand may have deleted &quot;buf&quot;, already entered it (e.g., when</a>
<a name="ln1524">   * it did &quot;:bunload&quot;) or aborted the script processing!</a>
<a name="ln1525">   * If curwin-&gt;w_buffer is null, enter_buffer() will make it valid again */</a>
<a name="ln1526">  if ((buf_valid(buf) &amp;&amp; buf != curbuf</a>
<a name="ln1527">       &amp;&amp; !aborting()</a>
<a name="ln1528">       ) || curwin-&gt;w_buffer == NULL</a>
<a name="ln1529">      ) {</a>
<a name="ln1530">    enter_buffer(buf);</a>
<a name="ln1531">    if (old_tw != curbuf-&gt;b_p_tw) {</a>
<a name="ln1532">      check_colorcolumn(curwin);</a>
<a name="ln1533">    }</a>
<a name="ln1534">  }</a>
<a name="ln1535"> </a>
<a name="ln1536">  if (bufref_valid(&amp;prevbufref) &amp;&amp; prevbuf-&gt;terminal != NULL) {</a>
<a name="ln1537">    terminal_check_size(prevbuf-&gt;terminal);</a>
<a name="ln1538">  }</a>
<a name="ln1539">}</a>
<a name="ln1540"> </a>
<a name="ln1541">/*</a>
<a name="ln1542"> * Enter a new current buffer.</a>
<a name="ln1543"> * Old curbuf must have been abandoned already!  This also means &quot;curbuf&quot; may</a>
<a name="ln1544"> * be pointing to freed memory.</a>
<a name="ln1545"> */</a>
<a name="ln1546">void enter_buffer(buf_T *buf)</a>
<a name="ln1547">{</a>
<a name="ln1548">  // Copy buffer and window local option values.  Not for a help buffer.</a>
<a name="ln1549">  buf_copy_options(buf, BCO_ENTER | BCO_NOHELP);</a>
<a name="ln1550">  if (!buf-&gt;b_help) {</a>
<a name="ln1551">    get_winopts(buf);</a>
<a name="ln1552">  } else {</a>
<a name="ln1553">    // Remove all folds in the window.</a>
<a name="ln1554">    clearFolding(curwin);</a>
<a name="ln1555">  }</a>
<a name="ln1556">  foldUpdateAll(curwin);        // update folds (later).</a>
<a name="ln1557"> </a>
<a name="ln1558">  // Get the buffer in the current window.</a>
<a name="ln1559">  curwin-&gt;w_buffer = buf;</a>
<a name="ln1560">  curbuf = buf;</a>
<a name="ln1561">  curbuf-&gt;b_nwindows++;</a>
<a name="ln1562"> </a>
<a name="ln1563">  if (curwin-&gt;w_p_diff) {</a>
<a name="ln1564">    diff_buf_add(curbuf);</a>
<a name="ln1565">  }</a>
<a name="ln1566"> </a>
<a name="ln1567">  curwin-&gt;w_s = &amp;(curbuf-&gt;b_s);</a>
<a name="ln1568"> </a>
<a name="ln1569">  // Cursor on first line by default.</a>
<a name="ln1570">  curwin-&gt;w_cursor.lnum = 1;</a>
<a name="ln1571">  curwin-&gt;w_cursor.col = 0;</a>
<a name="ln1572">  curwin-&gt;w_cursor.coladd = 0;</a>
<a name="ln1573">  curwin-&gt;w_set_curswant = true;</a>
<a name="ln1574">  curwin-&gt;w_topline_was_set = false;</a>
<a name="ln1575"> </a>
<a name="ln1576">  // mark cursor position as being invalid</a>
<a name="ln1577">  curwin-&gt;w_valid = 0;</a>
<a name="ln1578"> </a>
<a name="ln1579">  // Make sure the buffer is loaded.</a>
<a name="ln1580">  if (curbuf-&gt;b_ml.ml_mfp == NULL) {    // need to load the file</a>
<a name="ln1581">    // If there is no filetype, allow for detecting one.  Esp. useful for</a>
<a name="ln1582">    // &quot;:ball&quot; used in an autocommand.  If there already is a filetype we</a>
<a name="ln1583">    // might prefer to keep it.</a>
<a name="ln1584">    if (*curbuf-&gt;b_p_ft == NUL) {</a>
<a name="ln1585">      did_filetype = false;</a>
<a name="ln1586">    }</a>
<a name="ln1587"> </a>
<a name="ln1588">    open_buffer(false, NULL, 0);</a>
<a name="ln1589">  } else {</a>
<a name="ln1590">    if (!msg_silent &amp;&amp; !shortmess(SHM_FILEINFO)) {</a>
<a name="ln1591">      need_fileinfo = true;             // display file info after redraw</a>
<a name="ln1592">    }</a>
<a name="ln1593">    // check if file changed</a>
<a name="ln1594">    (void)buf_check_timestamp(curbuf);</a>
<a name="ln1595"> </a>
<a name="ln1596">    curwin-&gt;w_topline = 1;</a>
<a name="ln1597">    curwin-&gt;w_topfill = 0;</a>
<a name="ln1598">    apply_autocmds(EVENT_BUFENTER, NULL, NULL, false, curbuf);</a>
<a name="ln1599">    apply_autocmds(EVENT_BUFWINENTER, NULL, NULL, false, curbuf);</a>
<a name="ln1600">  }</a>
<a name="ln1601"> </a>
<a name="ln1602">  /* If autocommands did not change the cursor position, restore cursor lnum</a>
<a name="ln1603">   * and possibly cursor col. */</a>
<a name="ln1604">  if (curwin-&gt;w_cursor.lnum == 1 &amp;&amp; inindent(0)) {</a>
<a name="ln1605">    buflist_getfpos();</a>
<a name="ln1606">  }</a>
<a name="ln1607"> </a>
<a name="ln1608">  check_arg_idx(curwin);                // check for valid arg_idx</a>
<a name="ln1609">  maketitle();</a>
<a name="ln1610">  // when autocmds didn't change it</a>
<a name="ln1611">  if (curwin-&gt;w_topline == 1 &amp;&amp; !curwin-&gt;w_topline_was_set) {</a>
<a name="ln1612">    scroll_cursor_halfway(false);       // redisplay at correct position</a>
<a name="ln1613">  }</a>
<a name="ln1614"> </a>
<a name="ln1615"> </a>
<a name="ln1616">  // Change directories when the 'acd' option is set.</a>
<a name="ln1617">  do_autochdir();</a>
<a name="ln1618"> </a>
<a name="ln1619">  if (curbuf-&gt;b_kmap_state &amp; KEYMAP_INIT) {</a>
<a name="ln1620">    (void)keymap_init();</a>
<a name="ln1621">  }</a>
<a name="ln1622">  // May need to set the spell language.  Can only do this after the buffer</a>
<a name="ln1623">  // has been properly setup.</a>
<a name="ln1624">  if (!curbuf-&gt;b_help &amp;&amp; curwin-&gt;w_p_spell &amp;&amp; *curwin-&gt;w_s-&gt;b_p_spl != NUL) {</a>
<a name="ln1625">    (void)did_set_spelllang(curwin);</a>
<a name="ln1626">  }</a>
<a name="ln1627">  curbuf-&gt;b_last_used = time(NULL);</a>
<a name="ln1628"> </a>
<a name="ln1629">  redraw_later(curwin, NOT_VALID);</a>
<a name="ln1630">}</a>
<a name="ln1631"> </a>
<a name="ln1632">// Change to the directory of the current buffer.</a>
<a name="ln1633">// Don't do this while still starting up.</a>
<a name="ln1634">void do_autochdir(void)</a>
<a name="ln1635">{</a>
<a name="ln1636">  if (p_acd) {</a>
<a name="ln1637">    if (starting == 0</a>
<a name="ln1638">        &amp;&amp; curbuf-&gt;b_ffname != NULL</a>
<a name="ln1639">        &amp;&amp; vim_chdirfile(curbuf-&gt;b_ffname) == OK) {</a>
<a name="ln1640">      post_chdir(kCdScopeGlobal, false);</a>
<a name="ln1641">      shorten_fnames(true);</a>
<a name="ln1642">    }</a>
<a name="ln1643">  }</a>
<a name="ln1644">}</a>
<a name="ln1645"> </a>
<a name="ln1646">void no_write_message(void)</a>
<a name="ln1647">{</a>
<a name="ln1648">  if (curbuf-&gt;terminal</a>
<a name="ln1649">      &amp;&amp; channel_job_running((uint64_t)curbuf-&gt;b_p_channel)) {</a>
<a name="ln1650">    EMSG(_(&quot;E948: Job still running (add ! to end the job)&quot;));</a>
<a name="ln1651">  } else {</a>
<a name="ln1652">    EMSG(_(&quot;E37: No write since last change (add ! to override)&quot;));</a>
<a name="ln1653">  }</a>
<a name="ln1654">}</a>
<a name="ln1655"> </a>
<a name="ln1656">void no_write_message_nobang(const buf_T *const buf)</a>
<a name="ln1657">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln1658">{</a>
<a name="ln1659">  if (buf-&gt;terminal</a>
<a name="ln1660">      &amp;&amp; channel_job_running((uint64_t)buf-&gt;b_p_channel)) {</a>
<a name="ln1661">    EMSG(_(&quot;E948: Job still running&quot;));</a>
<a name="ln1662">  } else {</a>
<a name="ln1663">    EMSG(_(&quot;E37: No write since last change&quot;));</a>
<a name="ln1664">  }</a>
<a name="ln1665">}</a>
<a name="ln1666"> </a>
<a name="ln1667">//</a>
<a name="ln1668">// functions for dealing with the buffer list</a>
<a name="ln1669">//</a>
<a name="ln1670"> </a>
<a name="ln1671">static int top_file_num = 1;            ///&lt; highest file number</a>
<a name="ln1672"> </a>
<a name="ln1673">/// Initialize b:changedtick and changedtick_val attribute</a>
<a name="ln1674">///</a>
<a name="ln1675">/// @param[out]  buf  Buffer to initialize for.</a>
<a name="ln1676">static inline void buf_init_changedtick(buf_T *const buf)</a>
<a name="ln1677">  FUNC_ATTR_ALWAYS_INLINE FUNC_ATTR_NONNULL_ALL</a>
<a name="ln1678">{</a>
<a name="ln1679">  STATIC_ASSERT(sizeof(&quot;changedtick&quot;) &lt;= sizeof(buf-&gt;changedtick_di.di_key),</a>
<a name="ln1680">                &quot;buf-&gt;changedtick_di cannot hold large enough keys&quot;);</a>
<a name="ln1681">  buf-&gt;changedtick_di = (ChangedtickDictItem) {</a>
<a name="ln1682">    .di_flags = DI_FLAGS_RO|DI_FLAGS_FIX,  // Must not include DI_FLAGS_ALLOC.</a>
<a name="ln1683">    .di_tv = (typval_T) {</a>
<a name="ln1684">      .v_type = VAR_NUMBER,</a>
<a name="ln1685">      .v_lock = VAR_FIXED,</a>
<a name="ln1686">      .vval.v_number = buf_get_changedtick(buf),</a>
<a name="ln1687">    },</a>
<a name="ln1688">    .di_key = &quot;changedtick&quot;,</a>
<a name="ln1689">  };</a>
<a name="ln1690">  tv_dict_add(buf-&gt;b_vars, (dictitem_T *)&amp;buf-&gt;changedtick_di);</a>
<a name="ln1691">}</a>
<a name="ln1692"> </a>
<a name="ln1693">/// Add a file name to the buffer list.</a>
<a name="ln1694">/// If the same file name already exists return a pointer to that buffer.</a>
<a name="ln1695">/// If it does not exist, or if fname == NULL, a new entry is created.</a>
<a name="ln1696">/// If (flags &amp; BLN_CURBUF) is true, may use current buffer.</a>
<a name="ln1697">/// If (flags &amp; BLN_LISTED) is true, add new buffer to buffer list.</a>
<a name="ln1698">/// If (flags &amp; BLN_DUMMY) is true, don't count it as a real buffer.</a>
<a name="ln1699">/// If (flags &amp; BLN_NEW) is true, don't use an existing buffer.</a>
<a name="ln1700">/// If (flags &amp; BLN_NOOPT) is true, don't copy options from the current buffer</a>
<a name="ln1701">///                                 if the buffer already exists.</a>
<a name="ln1702">/// This is the ONLY way to create a new buffer.</a>
<a name="ln1703">///</a>
<a name="ln1704">/// @param ffname_arg  full path of fname or relative</a>
<a name="ln1705">/// @param sfname_arg  short fname or NULL</a>
<a name="ln1706">/// @param lnum   preferred cursor line</a>
<a name="ln1707">/// @param flags  BLN_ defines</a>
<a name="ln1708">/// @param bufnr</a>
<a name="ln1709">///</a>
<a name="ln1710">/// @return pointer to the buffer</a>
<a name="ln1711">buf_T *buflist_new(char_u *ffname_arg, char_u *sfname_arg, linenr_T lnum,</a>
<a name="ln1712">                   int flags)</a>
<a name="ln1713">{</a>
<a name="ln1714">  char_u *ffname = ffname_arg;</a>
<a name="ln1715">  char_u *sfname = sfname_arg;</a>
<a name="ln1716">  buf_T       *buf;</a>
<a name="ln1717"> </a>
<a name="ln1718">  fname_expand(curbuf, &amp;ffname, &amp;sfname);       // will allocate ffname</a>
<a name="ln1719"> </a>
<a name="ln1720">  /*</a>
<a name="ln1721">   * If file name already exists in the list, update the entry.</a>
<a name="ln1722">   */</a>
<a name="ln1723">  /* We can use inode numbers when the file exists.  Works better</a>
<a name="ln1724">   * for hard links. */</a>
<a name="ln1725">  FileID file_id;</a>
<a name="ln1726">  bool file_id_valid = (sfname != NULL</a>
<a name="ln1727">                        &amp;&amp; os_fileid((char *)sfname, &amp;file_id));</a>
<a name="ln1728">  if (ffname != NULL &amp;&amp; !(flags &amp; (BLN_DUMMY | BLN_NEW))</a>
<a name="ln1729">      &amp;&amp; (buf = buflist_findname_file_id(ffname, &amp;file_id,</a>
<a name="ln1730">                                         file_id_valid)) != NULL) {</a>
<a name="ln1731">    xfree(ffname);</a>
<a name="ln1732">    if (lnum != 0) {</a>
<a name="ln1733">      buflist_setfpos(buf, (flags &amp; BLN_NOCURWIN) ? NULL : curwin,</a>
<a name="ln1734">                      lnum, (colnr_T)0, false);</a>
<a name="ln1735">    }</a>
<a name="ln1736">    if ((flags &amp; BLN_NOOPT) == 0) {</a>
<a name="ln1737">      // Copy the options now, if 'cpo' doesn't have 's' and not done already.</a>
<a name="ln1738">      buf_copy_options(buf, 0);</a>
<a name="ln1739">    }</a>
<a name="ln1740">    if ((flags &amp; BLN_LISTED) &amp;&amp; !buf-&gt;b_p_bl) {</a>
<a name="ln1741">      buf-&gt;b_p_bl = true;</a>
<a name="ln1742">      bufref_T bufref;</a>
<a name="ln1743">      set_bufref(&amp;bufref, buf);</a>
<a name="ln1744">      if (!(flags &amp; BLN_DUMMY)) {</a>
<a name="ln1745">        if (apply_autocmds(EVENT_BUFADD, NULL, NULL, false, buf)</a>
<a name="ln1746">            &amp;&amp; !bufref_valid(&amp;bufref)) {</a>
<a name="ln1747">          return NULL;</a>
<a name="ln1748">        }</a>
<a name="ln1749">      }</a>
<a name="ln1750">    }</a>
<a name="ln1751">    return buf;</a>
<a name="ln1752">  }</a>
<a name="ln1753"> </a>
<a name="ln1754">  /*</a>
<a name="ln1755">   * If the current buffer has no name and no contents, use the current</a>
<a name="ln1756">   * buffer.	Otherwise: Need to allocate a new buffer structure.</a>
<a name="ln1757">   *</a>
<a name="ln1758">   * This is the ONLY place where a new buffer structure is allocated!</a>
<a name="ln1759">   * (A spell file buffer is allocated in spell.c, but that's not a normal</a>
<a name="ln1760">   * buffer.)</a>
<a name="ln1761">   */</a>
<a name="ln1762">  buf = NULL;</a>
<a name="ln1763">  if ((flags &amp; BLN_CURBUF) &amp;&amp; curbuf_reusable()) {</a>
<a name="ln1764">    assert(curbuf != NULL);</a>
<a name="ln1765">    buf = curbuf;</a>
<a name="ln1766">    /* It's like this buffer is deleted.  Watch out for autocommands that</a>
<a name="ln1767">     * change curbuf!  If that happens, allocate a new buffer anyway. */</a>
<a name="ln1768">    if (curbuf-&gt;b_p_bl) {</a>
<a name="ln1769">      apply_autocmds(EVENT_BUFDELETE, NULL, NULL, false, curbuf);</a>
<a name="ln1770">    }</a>
<a name="ln1771">    if (buf == curbuf) {</a>
<a name="ln1772">      apply_autocmds(EVENT_BUFWIPEOUT, NULL, NULL, false, curbuf);</a>
<a name="ln1773">    }</a>
<a name="ln1774">    if (aborting()) {           // autocmds may abort script processing</a>
<a name="ln1775">      xfree(ffname);</a>
<a name="ln1776">      return NULL;</a>
<a name="ln1777">    }</a>
<a name="ln1778">    if (buf == curbuf) {</a>
<a name="ln1779">      // Make sure 'bufhidden' and 'buftype' are empty</a>
<a name="ln1780">      clear_string_option(&amp;buf-&gt;b_p_bh);</a>
<a name="ln1781">      clear_string_option(&amp;buf-&gt;b_p_bt);</a>
<a name="ln1782">    }</a>
<a name="ln1783">  }</a>
<a name="ln1784">  if (buf != curbuf || curbuf == NULL) {</a>
<a name="ln1785">    buf = xcalloc(1, sizeof(buf_T));</a>
<a name="ln1786">    // init b: variables</a>
<a name="ln1787">    buf-&gt;b_vars = tv_dict_alloc();</a>
<a name="ln1788">    buf-&gt;b_signcols_valid = false;</a>
<a name="ln1789">    init_var_dict(buf-&gt;b_vars, &amp;buf-&gt;b_bufvar, VAR_SCOPE);</a>
<a name="ln1790">    buf_init_changedtick(buf);</a>
<a name="ln1791">  }</a>
<a name="ln1792"> </a>
<a name="ln1793">  if (ffname != NULL) {</a>
<a name="ln1794">    buf-&gt;b_ffname = ffname;</a>
<a name="ln1795">    buf-&gt;b_sfname = vim_strsave(sfname);</a>
<a name="ln1796">  }</a>
<a name="ln1797"> </a>
<a name="ln1798">  clear_wininfo(buf);</a>
<a name="ln1799">  buf-&gt;b_wininfo = xcalloc(1, sizeof(wininfo_T));</a>
<a name="ln1800"> </a>
<a name="ln1801">  if (ffname != NULL &amp;&amp; (buf-&gt;b_ffname == NULL || buf-&gt;b_sfname == NULL)) {</a>
<a name="ln1802">    if (buf-&gt;b_sfname != buf-&gt;b_ffname) {</a>
<a name="ln1803">      XFREE_CLEAR(buf-&gt;b_sfname);</a>
<a name="ln1804">    } else {</a>
<a name="ln1805">      buf-&gt;b_sfname = NULL;</a>
<a name="ln1806">    }</a>
<a name="ln1807">    XFREE_CLEAR(buf-&gt;b_ffname);</a>
<a name="ln1808">    if (buf != curbuf) {</a>
<a name="ln1809">      free_buffer(buf);</a>
<a name="ln1810">    }</a>
<a name="ln1811">    return NULL;</a>
<a name="ln1812">  }</a>
<a name="ln1813"> </a>
<a name="ln1814">  if (buf == curbuf) {</a>
<a name="ln1815">    // free all things allocated for this buffer</a>
<a name="ln1816">    buf_freeall(buf, 0);</a>
<a name="ln1817">    if (buf != curbuf) {         // autocommands deleted the buffer!</a>
<a name="ln1818">      return NULL;</a>
<a name="ln1819">    }</a>
<a name="ln1820">    if (aborting()) {           // autocmds may abort script processing</a>
<a name="ln1821">      return NULL;</a>
<a name="ln1822">    }</a>
<a name="ln1823">    free_buffer_stuff(buf, kBffInitChangedtick);  // delete local vars et al.</a>
<a name="ln1824"> </a>
<a name="ln1825">    // Init the options.</a>
<a name="ln1826">    buf-&gt;b_p_initialized = false;</a>
<a name="ln1827">    buf_copy_options(buf, BCO_ENTER);</a>
<a name="ln1828"> </a>
<a name="ln1829">    // need to reload lmaps and set b:keymap_name</a>
<a name="ln1830">    curbuf-&gt;b_kmap_state |= KEYMAP_INIT;</a>
<a name="ln1831">  } else {</a>
<a name="ln1832">    /*</a>
<a name="ln1833">     * put new buffer at the end of the buffer list</a>
<a name="ln1834">     */</a>
<a name="ln1835">    buf-&gt;b_next = NULL;</a>
<a name="ln1836">    if (firstbuf == NULL) {             // buffer list is empty</a>
<a name="ln1837">      buf-&gt;b_prev = NULL;</a>
<a name="ln1838">      firstbuf = buf;</a>
<a name="ln1839">    } else {                            // append new buffer at end of list</a>
<a name="ln1840">      lastbuf-&gt;b_next = buf;</a>
<a name="ln1841">      buf-&gt;b_prev = lastbuf;</a>
<a name="ln1842">    }</a>
<a name="ln1843">    lastbuf = buf;</a>
<a name="ln1844"> </a>
<a name="ln1845">    buf-&gt;b_fnum = top_file_num++;</a>
<a name="ln1846">    handle_register_buffer(buf);</a>
<a name="ln1847">    if (top_file_num &lt; 0) {  // wrap around (may cause duplicates)</a>
<a name="ln1848">      EMSG(_(&quot;W14: Warning: List of file names overflow&quot;));</a>
<a name="ln1849">      if (emsg_silent == 0) {</a>
<a name="ln1850">        ui_flush();</a>
<a name="ln1851">        os_delay(3001L, true);  // make sure it is noticed</a>
<a name="ln1852">      }</a>
<a name="ln1853">      top_file_num = 1;</a>
<a name="ln1854">    }</a>
<a name="ln1855"> </a>
<a name="ln1856">    /*</a>
<a name="ln1857">     * Always copy the options from the current buffer.</a>
<a name="ln1858">     */</a>
<a name="ln1859">    buf_copy_options(buf, BCO_ALWAYS);</a>
<a name="ln1860">  }</a>
<a name="ln1861"> </a>
<a name="ln1862">  buf-&gt;b_wininfo-&gt;wi_fpos.lnum = lnum;</a>
<a name="ln1863">  buf-&gt;b_wininfo-&gt;wi_win = curwin;</a>
<a name="ln1864"> </a>
<a name="ln1865">  hash_init(&amp;buf-&gt;b_s.b_keywtab);</a>
<a name="ln1866">  hash_init(&amp;buf-&gt;b_s.b_keywtab_ic);</a>
<a name="ln1867"> </a>
<a name="ln1868">  buf-&gt;b_fname = buf-&gt;b_sfname;</a>
<a name="ln1869">  if (!file_id_valid) {</a>
<a name="ln1870">    buf-&gt;file_id_valid = false;</a>
<a name="ln1871">  } else {</a>
<a name="ln1872">    buf-&gt;file_id_valid = true;</a>
<a name="ln1873">    buf-&gt;file_id = file_id;</a>
<a name="ln1874">  }</a>
<a name="ln1875">  buf-&gt;b_u_synced = true;</a>
<a name="ln1876">  buf-&gt;b_flags = BF_CHECK_RO | BF_NEVERLOADED;</a>
<a name="ln1877">  if (flags &amp; BLN_DUMMY) {</a>
<a name="ln1878">    buf-&gt;b_flags |= BF_DUMMY;</a>
<a name="ln1879">  }</a>
<a name="ln1880">  buf_clear_file(buf);</a>
<a name="ln1881">  clrallmarks(buf);                     // clear marks</a>
<a name="ln1882">  fmarks_check_names(buf);              // check file marks for this file</a>
<a name="ln1883">  buf-&gt;b_p_bl = (flags &amp; BLN_LISTED) ? true : false;    // init 'buflisted'</a>
<a name="ln1884">  kv_destroy(buf-&gt;update_channels);</a>
<a name="ln1885">  kv_init(buf-&gt;update_channels);</a>
<a name="ln1886">  kv_destroy(buf-&gt;update_callbacks);</a>
<a name="ln1887">  kv_init(buf-&gt;update_callbacks);</a>
<a name="ln1888">  if (!(flags &amp; BLN_DUMMY)) {</a>
<a name="ln1889">    // Tricky: these autocommands may change the buffer list.  They could also</a>
<a name="ln1890">    // split the window with re-using the one empty buffer. This may result in</a>
<a name="ln1891">    // unexpectedly losing the empty buffer.</a>
<a name="ln1892">    bufref_T bufref;</a>
<a name="ln1893">    set_bufref(&amp;bufref, buf);</a>
<a name="ln1894">    if (apply_autocmds(EVENT_BUFNEW, NULL, NULL, false, buf)</a>
<a name="ln1895">        &amp;&amp; !bufref_valid(&amp;bufref)) {</a>
<a name="ln1896">      return NULL;</a>
<a name="ln1897">    }</a>
<a name="ln1898">    if ((flags &amp; BLN_LISTED)</a>
<a name="ln1899">        &amp;&amp; apply_autocmds(EVENT_BUFADD, NULL, NULL, false, buf)</a>
<a name="ln1900">        &amp;&amp; !bufref_valid(&amp;bufref)) {</a>
<a name="ln1901">      return NULL;</a>
<a name="ln1902">    }</a>
<a name="ln1903">    if (aborting()) {</a>
<a name="ln1904">      // Autocmds may abort script processing.</a>
<a name="ln1905">      return NULL;</a>
<a name="ln1906">    }</a>
<a name="ln1907">  }</a>
<a name="ln1908"> </a>
<a name="ln1909">  buf-&gt;b_prompt_callback.type = kCallbackNone;</a>
<a name="ln1910">  buf-&gt;b_prompt_interrupt.type = kCallbackNone;</a>
<a name="ln1911">  buf-&gt;b_prompt_text = NULL;</a>
<a name="ln1912"> </a>
<a name="ln1913">  return buf;</a>
<a name="ln1914">}</a>
<a name="ln1915"> </a>
<a name="ln1916">/// Return true if the current buffer is empty, unnamed, unmodified and used in</a>
<a name="ln1917">/// only one window. That means it can be reused.</a>
<a name="ln1918">bool curbuf_reusable(void)</a>
<a name="ln1919">{</a>
<a name="ln1920">  return (curbuf != NULL</a>
<a name="ln1921">          &amp;&amp; curbuf-&gt;b_ffname == NULL</a>
<a name="ln1922">          &amp;&amp; curbuf-&gt;b_nwindows &lt;= 1</a>
<a name="ln1923">          &amp;&amp; (curbuf-&gt;b_ml.ml_mfp == NULL || buf_is_empty(curbuf))</a>
<a name="ln1924">          &amp;&amp; !bt_quickfix(curbuf)</a>
<a name="ln1925">          &amp;&amp; !curbufIsChanged());</a>
<a name="ln1926">}</a>
<a name="ln1927"> </a>
<a name="ln1928">/*</a>
<a name="ln1929"> * Free the memory for the options of a buffer.</a>
<a name="ln1930"> * If &quot;free_p_ff&quot; is true also free 'fileformat', 'buftype' and</a>
<a name="ln1931"> * 'fileencoding'.</a>
<a name="ln1932"> */</a>
<a name="ln1933">void free_buf_options(buf_T *buf, int free_p_ff)</a>
<a name="ln1934">{</a>
<a name="ln1935">  if (free_p_ff) {</a>
<a name="ln1936">    clear_string_option(&amp;buf-&gt;b_p_fenc);</a>
<a name="ln1937">    clear_string_option(&amp;buf-&gt;b_p_ff);</a>
<a name="ln1938">    clear_string_option(&amp;buf-&gt;b_p_bh);</a>
<a name="ln1939">    clear_string_option(&amp;buf-&gt;b_p_bt);</a>
<a name="ln1940">  }</a>
<a name="ln1941">  clear_string_option(&amp;buf-&gt;b_p_def);</a>
<a name="ln1942">  clear_string_option(&amp;buf-&gt;b_p_inc);</a>
<a name="ln1943">  clear_string_option(&amp;buf-&gt;b_p_inex);</a>
<a name="ln1944">  clear_string_option(&amp;buf-&gt;b_p_inde);</a>
<a name="ln1945">  clear_string_option(&amp;buf-&gt;b_p_indk);</a>
<a name="ln1946">  clear_string_option(&amp;buf-&gt;b_p_fp);</a>
<a name="ln1947">  clear_string_option(&amp;buf-&gt;b_p_fex);</a>
<a name="ln1948">  clear_string_option(&amp;buf-&gt;b_p_kp);</a>
<a name="ln1949">  clear_string_option(&amp;buf-&gt;b_p_mps);</a>
<a name="ln1950">  clear_string_option(&amp;buf-&gt;b_p_fo);</a>
<a name="ln1951">  clear_string_option(&amp;buf-&gt;b_p_flp);</a>
<a name="ln1952">  clear_string_option(&amp;buf-&gt;b_p_isk);</a>
<a name="ln1953">  clear_string_option(&amp;buf-&gt;b_p_vsts);</a>
<a name="ln1954">  xfree(buf-&gt;b_p_vsts_nopaste);</a>
<a name="ln1955">  buf-&gt;b_p_vsts_nopaste = NULL;</a>
<a name="ln1956">  xfree(buf-&gt;b_p_vsts_array);</a>
<a name="ln1957">  buf-&gt;b_p_vsts_array = NULL;</a>
<a name="ln1958">  clear_string_option(&amp;buf-&gt;b_p_vts);</a>
<a name="ln1959">  XFREE_CLEAR(buf-&gt;b_p_vts_array);</a>
<a name="ln1960">  clear_string_option(&amp;buf-&gt;b_p_keymap);</a>
<a name="ln1961">  keymap_ga_clear(&amp;buf-&gt;b_kmap_ga);</a>
<a name="ln1962">  ga_clear(&amp;buf-&gt;b_kmap_ga);</a>
<a name="ln1963">  clear_string_option(&amp;buf-&gt;b_p_com);</a>
<a name="ln1964">  clear_string_option(&amp;buf-&gt;b_p_cms);</a>
<a name="ln1965">  clear_string_option(&amp;buf-&gt;b_p_nf);</a>
<a name="ln1966">  clear_string_option(&amp;buf-&gt;b_p_syn);</a>
<a name="ln1967">  clear_string_option(&amp;buf-&gt;b_s.b_syn_isk);</a>
<a name="ln1968">  clear_string_option(&amp;buf-&gt;b_s.b_p_spc);</a>
<a name="ln1969">  clear_string_option(&amp;buf-&gt;b_s.b_p_spf);</a>
<a name="ln1970">  vim_regfree(buf-&gt;b_s.b_cap_prog);</a>
<a name="ln1971">  buf-&gt;b_s.b_cap_prog = NULL;</a>
<a name="ln1972">  clear_string_option(&amp;buf-&gt;b_s.b_p_spl);</a>
<a name="ln1973">  clear_string_option(&amp;buf-&gt;b_s.b_p_spo);</a>
<a name="ln1974">  clear_string_option(&amp;buf-&gt;b_p_sua);</a>
<a name="ln1975">  clear_string_option(&amp;buf-&gt;b_p_ft);</a>
<a name="ln1976">  clear_string_option(&amp;buf-&gt;b_p_cink);</a>
<a name="ln1977">  clear_string_option(&amp;buf-&gt;b_p_cino);</a>
<a name="ln1978">  clear_string_option(&amp;buf-&gt;b_p_cinw);</a>
<a name="ln1979">  clear_string_option(&amp;buf-&gt;b_p_cpt);</a>
<a name="ln1980">  clear_string_option(&amp;buf-&gt;b_p_cfu);</a>
<a name="ln1981">  clear_string_option(&amp;buf-&gt;b_p_ofu);</a>
<a name="ln1982">  clear_string_option(&amp;buf-&gt;b_p_gp);</a>
<a name="ln1983">  clear_string_option(&amp;buf-&gt;b_p_mp);</a>
<a name="ln1984">  clear_string_option(&amp;buf-&gt;b_p_efm);</a>
<a name="ln1985">  clear_string_option(&amp;buf-&gt;b_p_ep);</a>
<a name="ln1986">  clear_string_option(&amp;buf-&gt;b_p_path);</a>
<a name="ln1987">  clear_string_option(&amp;buf-&gt;b_p_tags);</a>
<a name="ln1988">  clear_string_option(&amp;buf-&gt;b_p_tc);</a>
<a name="ln1989">  clear_string_option(&amp;buf-&gt;b_p_tfu);</a>
<a name="ln1990">  clear_string_option(&amp;buf-&gt;b_p_dict);</a>
<a name="ln1991">  clear_string_option(&amp;buf-&gt;b_p_tsr);</a>
<a name="ln1992">  clear_string_option(&amp;buf-&gt;b_p_qe);</a>
<a name="ln1993">  buf-&gt;b_p_ar = -1;</a>
<a name="ln1994">  buf-&gt;b_p_ul = NO_LOCAL_UNDOLEVEL;</a>
<a name="ln1995">  clear_string_option(&amp;buf-&gt;b_p_lw);</a>
<a name="ln1996">  clear_string_option(&amp;buf-&gt;b_p_bkc);</a>
<a name="ln1997">  clear_string_option(&amp;buf-&gt;b_p_menc);</a>
<a name="ln1998">}</a>
<a name="ln1999"> </a>
<a name="ln2000"> </a>
<a name="ln2001">/// Get alternate file &quot;n&quot;.</a>
<a name="ln2002">/// Set linenr to &quot;lnum&quot; or altfpos.lnum if &quot;lnum&quot; == 0.</a>
<a name="ln2003">/// Also set cursor column to altfpos.col if 'startofline' is not set.</a>
<a name="ln2004">/// if (options &amp; GETF_SETMARK) call setpcmark()</a>
<a name="ln2005">/// if (options &amp; GETF_ALT) we are jumping to an alternate file.</a>
<a name="ln2006">/// if (options &amp; GETF_SWITCH) respect 'switchbuf' settings when jumping</a>
<a name="ln2007">///</a>
<a name="ln2008">/// Return FAIL for failure, OK for success.</a>
<a name="ln2009">int buflist_getfile(int n, linenr_T lnum, int options, int forceit)</a>
<a name="ln2010">{</a>
<a name="ln2011">  buf_T       *buf;</a>
<a name="ln2012">  win_T       *wp = NULL;</a>
<a name="ln2013">  pos_T       *fpos;</a>
<a name="ln2014">  colnr_T col;</a>
<a name="ln2015"> </a>
<a name="ln2016">  buf = buflist_findnr(n);</a>
<a name="ln2017">  if (buf == NULL) {</a>
<a name="ln2018">    if ((options &amp; GETF_ALT) &amp;&amp; n == 0) {</a>
<a name="ln2019">      EMSG(_(e_noalt));</a>
<a name="ln2020">    } else {</a>
<a name="ln2021">      EMSGN(_(&quot;E92: Buffer %&quot; PRId64 &quot; not found&quot;), n);</a>
<a name="ln2022">    }</a>
<a name="ln2023">    return FAIL;</a>
<a name="ln2024">  }</a>
<a name="ln2025"> </a>
<a name="ln2026">  // if alternate file is the current buffer, nothing to do</a>
<a name="ln2027">  if (buf == curbuf) {</a>
<a name="ln2028">    return OK;</a>
<a name="ln2029">  }</a>
<a name="ln2030"> </a>
<a name="ln2031">  if (text_locked()) {</a>
<a name="ln2032">    text_locked_msg();</a>
<a name="ln2033">    return FAIL;</a>
<a name="ln2034">  }</a>
<a name="ln2035">  if (curbuf_locked()) {</a>
<a name="ln2036">    return FAIL;</a>
<a name="ln2037">  }</a>
<a name="ln2038"> </a>
<a name="ln2039">  // altfpos may be changed by getfile(), get it now</a>
<a name="ln2040">  if (lnum == 0) {</a>
<a name="ln2041">    fpos = buflist_findfpos(buf);</a>
<a name="ln2042">    lnum = fpos-&gt;lnum;</a>
<a name="ln2043">    col = fpos-&gt;col;</a>
<a name="ln2044">  } else</a>
<a name="ln2045">    col = 0;</a>
<a name="ln2046"> </a>
<a name="ln2047">  if (options &amp; GETF_SWITCH) {</a>
<a name="ln2048">    // If 'switchbuf' contains &quot;useopen&quot;: jump to first window containing</a>
<a name="ln2049">    // &quot;buf&quot; if one exists</a>
<a name="ln2050">    if (swb_flags &amp; SWB_USEOPEN) {</a>
<a name="ln2051">      wp = buf_jump_open_win(buf);</a>
<a name="ln2052">    }</a>
<a name="ln2053"> </a>
<a name="ln2054">    // If 'switchbuf' contains &quot;usetab&quot;: jump to first window in any tab</a>
<a name="ln2055">    // page containing &quot;buf&quot; if one exists</a>
<a name="ln2056">    if (wp == NULL &amp;&amp; (swb_flags &amp; SWB_USETAB)) {</a>
<a name="ln2057">      wp = buf_jump_open_tab(buf);</a>
<a name="ln2058">    }</a>
<a name="ln2059"> </a>
<a name="ln2060">    // If 'switchbuf' contains &quot;split&quot;, &quot;vsplit&quot; or &quot;newtab&quot; and the</a>
<a name="ln2061">    // current buffer isn't empty: open new tab or window</a>
<a name="ln2062">    if (wp == NULL &amp;&amp; (swb_flags &amp; (SWB_VSPLIT | SWB_SPLIT | SWB_NEWTAB))</a>
<a name="ln2063">        &amp;&amp; !buf_is_empty(curbuf)) {</a>
<a name="ln2064">      if (swb_flags &amp; SWB_NEWTAB) {</a>
<a name="ln2065">        tabpage_new();</a>
<a name="ln2066">      } else if (win_split(0, (swb_flags &amp; SWB_VSPLIT) ? WSP_VERT : 0)</a>
<a name="ln2067">                 == FAIL) {</a>
<a name="ln2068">        return FAIL;</a>
<a name="ln2069">      }</a>
<a name="ln2070">      RESET_BINDING(curwin);</a>
<a name="ln2071">    }</a>
<a name="ln2072">  }</a>
<a name="ln2073"> </a>
<a name="ln2074">  RedrawingDisabled++;</a>
<a name="ln2075">  if (GETFILE_SUCCESS(getfile(buf-&gt;b_fnum, NULL, NULL,</a>
<a name="ln2076">                              (options &amp; GETF_SETMARK), lnum, forceit))) {</a>
<a name="ln2077">    RedrawingDisabled--;</a>
<a name="ln2078"> </a>
<a name="ln2079">    // cursor is at to BOL and w_cursor.lnum is checked due to getfile()</a>
<a name="ln2080">    if (!p_sol &amp;&amp; col != 0) {</a>
<a name="ln2081">      curwin-&gt;w_cursor.col = col;</a>
<a name="ln2082">      check_cursor_col();</a>
<a name="ln2083">      curwin-&gt;w_cursor.coladd = 0;</a>
<a name="ln2084">      curwin-&gt;w_set_curswant = true;</a>
<a name="ln2085">    }</a>
<a name="ln2086">    return OK;</a>
<a name="ln2087">  }</a>
<a name="ln2088">  RedrawingDisabled--;</a>
<a name="ln2089">  return FAIL;</a>
<a name="ln2090">}</a>
<a name="ln2091"> </a>
<a name="ln2092">// Go to the last known line number for the current buffer.</a>
<a name="ln2093">void buflist_getfpos(void)</a>
<a name="ln2094">{</a>
<a name="ln2095">  pos_T       *fpos;</a>
<a name="ln2096"> </a>
<a name="ln2097">  fpos = buflist_findfpos(curbuf);</a>
<a name="ln2098"> </a>
<a name="ln2099">  curwin-&gt;w_cursor.lnum = fpos-&gt;lnum;</a>
<a name="ln2100">  check_cursor_lnum();</a>
<a name="ln2101"> </a>
<a name="ln2102">  if (p_sol) {</a>
<a name="ln2103">    curwin-&gt;w_cursor.col = 0;</a>
<a name="ln2104">  } else {</a>
<a name="ln2105">    curwin-&gt;w_cursor.col = fpos-&gt;col;</a>
<a name="ln2106">    check_cursor_col();</a>
<a name="ln2107">    curwin-&gt;w_cursor.coladd = 0;</a>
<a name="ln2108">    curwin-&gt;w_set_curswant = true;</a>
<a name="ln2109">  }</a>
<a name="ln2110">}</a>
<a name="ln2111"> </a>
<a name="ln2112">/*</a>
<a name="ln2113"> * Find file in buffer list by name (it has to be for the current window).</a>
<a name="ln2114"> * Returns NULL if not found.</a>
<a name="ln2115"> */</a>
<a name="ln2116">buf_T *buflist_findname_exp(char_u *fname)</a>
<a name="ln2117">{</a>
<a name="ln2118">  char_u      *ffname;</a>
<a name="ln2119">  buf_T       *buf = NULL;</a>
<a name="ln2120"> </a>
<a name="ln2121">  // First make the name into a full path name</a>
<a name="ln2122">  ffname = (char_u *)FullName_save((char *)fname,</a>
<a name="ln2123">#ifdef UNIX</a>
<a name="ln2124">                                   // force expansion, get rid of symbolic links</a>
<a name="ln2125">                                   true</a>
<a name="ln2126">#else</a>
<a name="ln2127">                                   false</a>
<a name="ln2128">#endif</a>
<a name="ln2129">      );</a>
<a name="ln2130">  if (ffname != NULL) {</a>
<a name="ln2131">    buf = buflist_findname(ffname);</a>
<a name="ln2132">    xfree(ffname);</a>
<a name="ln2133">  }</a>
<a name="ln2134">  return buf;</a>
<a name="ln2135">}</a>
<a name="ln2136"> </a>
<a name="ln2137">/*</a>
<a name="ln2138"> * Find file in buffer list by name (it has to be for the current window).</a>
<a name="ln2139"> * &quot;ffname&quot; must have a full path.</a>
<a name="ln2140"> * Skips dummy buffers.</a>
<a name="ln2141"> * Returns NULL if not found.</a>
<a name="ln2142"> */</a>
<a name="ln2143">buf_T *buflist_findname(char_u *ffname)</a>
<a name="ln2144">{</a>
<a name="ln2145">  FileID file_id;</a>
<a name="ln2146">  bool file_id_valid = os_fileid((char *)ffname, &amp;file_id);</a>
<a name="ln2147">  return buflist_findname_file_id(ffname, &amp;file_id, file_id_valid);</a>
<a name="ln2148">}</a>
<a name="ln2149"> </a>
<a name="ln2150">/*</a>
<a name="ln2151"> * Same as buflist_findname(), but pass the FileID structure to avoid</a>
<a name="ln2152"> * getting it twice for the same file.</a>
<a name="ln2153"> * Returns NULL if not found.</a>
<a name="ln2154"> */</a>
<a name="ln2155">static buf_T *buflist_findname_file_id(char_u *ffname, FileID *file_id,</a>
<a name="ln2156">                                       bool file_id_valid)</a>
<a name="ln2157">{</a>
<a name="ln2158">  // Start at the last buffer, expect to find a match sooner.</a>
<a name="ln2159">  FOR_ALL_BUFFERS_BACKWARDS(buf) {</a>
<a name="ln2160">    if ((buf-&gt;b_flags &amp; BF_DUMMY) == 0</a>
<a name="ln2161">        &amp;&amp; !otherfile_buf(buf, ffname, file_id, file_id_valid)) {</a>
<a name="ln2162">      return buf;</a>
<a name="ln2163">    }</a>
<a name="ln2164">  }</a>
<a name="ln2165">  return NULL;</a>
<a name="ln2166">}</a>
<a name="ln2167"> </a>
<a name="ln2168">/// Find file in buffer list by a regexp pattern.</a>
<a name="ln2169">/// Return fnum of the found buffer.</a>
<a name="ln2170">/// Return &lt; 0 for error.</a>
<a name="ln2171">int buflist_findpat(</a>
<a name="ln2172">    const char_u *pattern,</a>
<a name="ln2173">    const char_u *pattern_end,  // pointer to first char after pattern</a>
<a name="ln2174">    bool unlisted,              // find unlisted buffers</a>
<a name="ln2175">    bool diffmode,              // find diff-mode buffers only</a>
<a name="ln2176">    bool curtab_only            // find buffers in current tab only</a>
<a name="ln2177">)</a>
<a name="ln2178">  FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln2179">{</a>
<a name="ln2180">  int match = -1;</a>
<a name="ln2181">  int find_listed;</a>
<a name="ln2182">  char_u      *pat;</a>
<a name="ln2183">  char_u      *patend;</a>
<a name="ln2184">  int attempt;</a>
<a name="ln2185">  char_u      *p;</a>
<a name="ln2186">  int toggledollar;</a>
<a name="ln2187"> </a>
<a name="ln2188">  if (pattern_end == pattern + 1 &amp;&amp; (*pattern == '%' || *pattern == '#')) {</a>
<a name="ln2189">    if (*pattern == '%') {</a>
<a name="ln2190">      match = curbuf-&gt;b_fnum;</a>
<a name="ln2191">    } else {</a>
<a name="ln2192">      match = curwin-&gt;w_alt_fnum;</a>
<a name="ln2193">    }</a>
<a name="ln2194">    buf_T *found_buf = buflist_findnr(match);</a>
<a name="ln2195">    if (diffmode &amp;&amp; !(found_buf &amp;&amp; diff_mode_buf(found_buf))) {</a>
<a name="ln2196">      match = -1;</a>
<a name="ln2197">    }</a>
<a name="ln2198">  } else {</a>
<a name="ln2199">    //</a>
<a name="ln2200">    // Try four ways of matching a listed buffer:</a>
<a name="ln2201">    // attempt == 0: without '^' or '$' (at any position)</a>
<a name="ln2202">    // attempt == 1: with '^' at start (only at position 0)</a>
<a name="ln2203">    // attempt == 2: with '$' at end (only match at end)</a>
<a name="ln2204">    // attempt == 3: with '^' at start and '$' at end (only full match)</a>
<a name="ln2205">    // Repeat this for finding an unlisted buffer if there was no matching</a>
<a name="ln2206">    // listed buffer.</a>
<a name="ln2207">    //</a>
<a name="ln2208"> </a>
<a name="ln2209">    pat = file_pat_to_reg_pat(pattern, pattern_end, NULL, false);</a>
<a name="ln2210">    if (pat == NULL) {</a>
<a name="ln2211">      return -1;</a>
<a name="ln2212">    }</a>
<a name="ln2213">    patend = pat + STRLEN(pat) - 1;</a>
<a name="ln2214">    toggledollar = (patend &gt; pat &amp;&amp; *patend == '$');</a>
<a name="ln2215"> </a>
<a name="ln2216">    // First try finding a listed buffer.  If not found and &quot;unlisted&quot;</a>
<a name="ln2217">    // is true, try finding an unlisted buffer.</a>
<a name="ln2218">    find_listed = true;</a>
<a name="ln2219">    for (;; ) {</a>
<a name="ln2220">      for (attempt = 0; attempt &lt;= 3; attempt++) {</a>
<a name="ln2221">        // may add '^' and '$'</a>
<a name="ln2222">        if (toggledollar) {</a>
<a name="ln2223">          *patend = (attempt &lt; 2) ? NUL : '$';           // add/remove '$'</a>
<a name="ln2224">        }</a>
<a name="ln2225">        p = pat;</a>
<a name="ln2226">        if (*p == '^' &amp;&amp; !(attempt &amp; 1)) {               // add/remove '^'</a>
<a name="ln2227">          p++;</a>
<a name="ln2228">        }</a>
<a name="ln2229"> </a>
<a name="ln2230">        regmatch_T regmatch;</a>
<a name="ln2231">        regmatch.regprog = vim_regcomp(p, p_magic ? RE_MAGIC : 0);</a>
<a name="ln2232">        if (regmatch.regprog == NULL) {</a>
<a name="ln2233">          xfree(pat);</a>
<a name="ln2234">          return -1;</a>
<a name="ln2235">        }</a>
<a name="ln2236"> </a>
<a name="ln2237">        FOR_ALL_BUFFERS_BACKWARDS(buf) {</a>
<a name="ln2238">          if (buf-&gt;b_p_bl == find_listed</a>
<a name="ln2239">              &amp;&amp; (!diffmode || diff_mode_buf(buf))</a>
<a name="ln2240">              &amp;&amp; buflist_match(&amp;regmatch, buf, false) != NULL) {</a>
<a name="ln2241">            if (curtab_only) {</a>
<a name="ln2242">              /* Ignore the match if the buffer is not open in</a>
<a name="ln2243">               * the current tab. */</a>
<a name="ln2244">              bool found_window = false;</a>
<a name="ln2245">              FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {</a>
<a name="ln2246">                if (wp-&gt;w_buffer == buf) {</a>
<a name="ln2247">                  found_window = true;</a>
<a name="ln2248">                  break;</a>
<a name="ln2249">                }</a>
<a name="ln2250">              }</a>
<a name="ln2251">              if (!found_window) {</a>
<a name="ln2252">                continue;</a>
<a name="ln2253">              }</a>
<a name="ln2254">            }</a>
<a name="ln2255">            if (match &gt;= 0) {                   // already found a match</a>
<a name="ln2256">              match = -2;</a>
<a name="ln2257">              break;</a>
<a name="ln2258">            }</a>
<a name="ln2259">            match = buf-&gt;b_fnum;                // remember first match</a>
<a name="ln2260">          }</a>
<a name="ln2261">        }</a>
<a name="ln2262"> </a>
<a name="ln2263">        vim_regfree(regmatch.regprog);</a>
<a name="ln2264">        if (match &gt;= 0) {                       // found one match</a>
<a name="ln2265">          break;</a>
<a name="ln2266">        }</a>
<a name="ln2267">      }</a>
<a name="ln2268"> </a>
<a name="ln2269">      /* Only search for unlisted buffers if there was no match with</a>
<a name="ln2270">       * a listed buffer. */</a>
<a name="ln2271">      if (!unlisted || !find_listed || match != -1) {</a>
<a name="ln2272">        break;</a>
<a name="ln2273">      }</a>
<a name="ln2274">      find_listed = false;</a>
<a name="ln2275">    }</a>
<a name="ln2276"> </a>
<a name="ln2277">    xfree(pat);</a>
<a name="ln2278">  }</a>
<a name="ln2279"> </a>
<a name="ln2280">  if (match == -2) {</a>
<a name="ln2281">    EMSG2(_(&quot;E93: More than one match for %s&quot;), pattern);</a>
<a name="ln2282">  } else if (match &lt; 0) {</a>
<a name="ln2283">    EMSG2(_(&quot;E94: No matching buffer for %s&quot;), pattern);</a>
<a name="ln2284">  }</a>
<a name="ln2285">  return match;</a>
<a name="ln2286">}</a>
<a name="ln2287"> </a>
<a name="ln2288">typedef struct {</a>
<a name="ln2289">    buf_T   *buf;</a>
<a name="ln2290">    char_u  *match;</a>
<a name="ln2291">} bufmatch_T;</a>
<a name="ln2292"> </a>
<a name="ln2293">/// Compare functions for qsort() below, that compares b_last_used.</a>
<a name="ln2294">static int</a>
<a name="ln2295">buf_time_compare(const void *s1, const void *s2)</a>
<a name="ln2296">{</a>
<a name="ln2297">  buf_T *buf1 = *(buf_T **)s1;</a>
<a name="ln2298">  buf_T *buf2 = *(buf_T **)s2;</a>
<a name="ln2299"> </a>
<a name="ln2300">  if (buf1-&gt;b_last_used == buf2-&gt;b_last_used) {</a>
<a name="ln2301">    return 0;</a>
<a name="ln2302">  }</a>
<a name="ln2303">  return buf1-&gt;b_last_used &gt; buf2-&gt;b_last_used ? -1 : 1;</a>
<a name="ln2304">}</a>
<a name="ln2305"> </a>
<a name="ln2306">/*</a>
<a name="ln2307"> * Find all buffer names that match.</a>
<a name="ln2308"> * For command line expansion of &quot;:buf&quot; and &quot;:sbuf&quot;.</a>
<a name="ln2309"> * Return OK if matches found, FAIL otherwise.</a>
<a name="ln2310"> */</a>
<a name="ln2311">int ExpandBufnames(char_u *pat, int *num_file, char_u ***file, int options)</a>
<a name="ln2312">{</a>
<a name="ln2313">  int count = 0;</a>
<a name="ln2314">  int round;</a>
<a name="ln2315">  char_u      *p;</a>
<a name="ln2316">  int attempt;</a>
<a name="ln2317">  char_u      *patc;</a>
<a name="ln2318">  bufmatch_T  *matches = NULL;</a>
<a name="ln2319"> </a>
<a name="ln2320">  *num_file = 0;                    // return values in case of FAIL</a>
<a name="ln2321">  *file = NULL;</a>
<a name="ln2322"> </a>
<a name="ln2323">  if ((options &amp; BUF_DIFF_FILTER) &amp;&amp; !curwin-&gt;w_p_diff) {</a>
<a name="ln2324">    return FAIL;</a>
<a name="ln2325">  }</a>
<a name="ln2326"> </a>
<a name="ln2327">  // Make a copy of &quot;pat&quot; and change &quot;^&quot; to &quot;\(^\|[\/]\)&quot;.</a>
<a name="ln2328">  if (*pat == '^') {</a>
<a name="ln2329">    patc = xmalloc(STRLEN(pat) + 11);</a>
<a name="ln2330">    STRCPY(patc, &quot;\\(^\\|[\\/]\\)&quot;);</a>
<a name="ln2331">    STRCPY(patc + 11, pat + 1);</a>
<a name="ln2332">  } else</a>
<a name="ln2333">    patc = pat;</a>
<a name="ln2334"> </a>
<a name="ln2335">  /*</a>
<a name="ln2336">   * attempt == 0: try match with    '\&lt;', match at start of word</a>
<a name="ln2337">   * attempt == 1: try match without '\&lt;', match anywhere</a>
<a name="ln2338">   */</a>
<a name="ln2339">  for (attempt = 0; attempt &lt;= 1; attempt++) {</a>
<a name="ln2340">    if (attempt &gt; 0 &amp;&amp; patc == pat) {</a>
<a name="ln2341">      break;            // there was no anchor, no need to try again</a>
<a name="ln2342">    }</a>
<a name="ln2343"> </a>
<a name="ln2344">    regmatch_T regmatch;</a>
<a name="ln2345">    regmatch.regprog = vim_regcomp(patc + attempt * 11, RE_MAGIC);</a>
<a name="ln2346">    if (regmatch.regprog == NULL) {</a>
<a name="ln2347">      if (patc != pat) {</a>
<a name="ln2348">        xfree(patc);</a>
<a name="ln2349">      }</a>
<a name="ln2350">      return FAIL;</a>
<a name="ln2351">    }</a>
<a name="ln2352"> </a>
<a name="ln2353">    /*</a>
<a name="ln2354">     * round == 1: Count the matches.</a>
<a name="ln2355">     * round == 2: Build the array to keep the matches.</a>
<a name="ln2356">     */</a>
<a name="ln2357">    for (round = 1; round &lt;= 2; round++) {</a>
<a name="ln2358">      count = 0;</a>
<a name="ln2359">      FOR_ALL_BUFFERS(buf) {</a>
<a name="ln2360">        if (!buf-&gt;b_p_bl) {             // skip unlisted buffers</a>
<a name="ln2361">          continue;</a>
<a name="ln2362">        }</a>
<a name="ln2363">        if (options &amp; BUF_DIFF_FILTER) {</a>
<a name="ln2364">          // Skip buffers not suitable for</a>
<a name="ln2365">          // :diffget or :diffput completion.</a>
<a name="ln2366">          if (buf == curbuf || !diff_mode_buf(buf)) {</a>
<a name="ln2367">            continue;</a>
<a name="ln2368">          }</a>
<a name="ln2369">        }</a>
<a name="ln2370">        p = buflist_match(&amp;regmatch, buf, p_wic);</a>
<a name="ln2371">        if (p != NULL) {</a>
<a name="ln2372">          if (round == 1) {</a>
<a name="ln2373">            count++;</a>
<a name="ln2374">          } else {</a>
<a name="ln2375">            if (options &amp; WILD_HOME_REPLACE) {</a>
<a name="ln2376">              p = home_replace_save(buf, p);</a>
<a name="ln2377">            } else {</a>
<a name="ln2378">              p = vim_strsave(p);</a>
<a name="ln2379">            }</a>
<a name="ln2380">            if (matches != NULL) {</a>
<a name="ln2381">              matches[count].buf = buf;</a>
<a name="ln2382">              matches[count].match = p;</a>
<a name="ln2383">              count++;</a>
<a name="ln2384">            } else {</a>
<a name="ln2385">              (*file)[count++] = p;</a>
<a name="ln2386">            }</a>
<a name="ln2387">          }</a>
<a name="ln2388">        }</a>
<a name="ln2389">      }</a>
<a name="ln2390">      if (count == 0) {         // no match found, break here</a>
<a name="ln2391">        break;</a>
<a name="ln2392">      }</a>
<a name="ln2393">      if (round == 1) {</a>
<a name="ln2394">        *file = xmalloc((size_t)count * sizeof(**file));</a>
<a name="ln2395"> </a>
<a name="ln2396">        if (options &amp; WILD_BUFLASTUSED) {</a>
<a name="ln2397">          matches = xmalloc((size_t)count * sizeof(*matches));</a>
<a name="ln2398">        }</a>
<a name="ln2399">      }</a>
<a name="ln2400">    }</a>
<a name="ln2401">    vim_regfree(regmatch.regprog);</a>
<a name="ln2402">    if (count) {                // match(es) found, break here</a>
<a name="ln2403">      break;</a>
<a name="ln2404">    }</a>
<a name="ln2405">  }</a>
<a name="ln2406"> </a>
<a name="ln2407">  if (patc != pat) {</a>
<a name="ln2408">    xfree(patc);</a>
<a name="ln2409">  }</a>
<a name="ln2410"> </a>
<a name="ln2411">  if (matches != NULL) {</a>
<a name="ln2412">    if (count &gt; 1) {</a>
<a name="ln2413">      qsort(matches, (size_t)count, sizeof(bufmatch_T), buf_time_compare);</a>
<a name="ln2414">    }</a>
<a name="ln2415"> </a>
<a name="ln2416">    // if the current buffer is first in the list, place it at the end</a>
<a name="ln2417">    if (matches[0].buf == curbuf) {</a>
<a name="ln2418">      for (int i = 1; i &lt; count; i++) {</a>
<a name="ln2419">        (*file)[i-1] = matches[i].match;</a>
<a name="ln2420">      }</a>
<a name="ln2421">      (*file)[count-1] = matches[0].match;</a>
<a name="ln2422">    } else {</a>
<a name="ln2423">      for (int i = 0; i &lt; count; i++) {</a>
<a name="ln2424">        (*file)[i] = matches[i].match;</a>
<a name="ln2425">      }</a>
<a name="ln2426">    }</a>
<a name="ln2427">    xfree(matches);</a>
<a name="ln2428">  }</a>
<a name="ln2429"> </a>
<a name="ln2430">  *num_file = count;</a>
<a name="ln2431">  return count == 0 ? FAIL : OK;</a>
<a name="ln2432">}</a>
<a name="ln2433"> </a>
<a name="ln2434"> </a>
<a name="ln2435">/// Check for a match on the file name for buffer &quot;buf&quot; with regprog &quot;prog&quot;.</a>
<a name="ln2436">///</a>
<a name="ln2437">/// @param ignore_case When true, ignore case. Use 'fic' otherwise.</a>
<a name="ln2438">static char_u *buflist_match(regmatch_T *rmp, buf_T *buf, bool ignore_case)</a>
<a name="ln2439">{</a>
<a name="ln2440">  // First try the short file name, then the long file name.</a>
<a name="ln2441">  char_u *match = fname_match(rmp, buf-&gt;b_sfname, ignore_case);</a>
<a name="ln2442">  if (match == NULL) {</a>
<a name="ln2443">    match = fname_match(rmp, buf-&gt;b_ffname, ignore_case);</a>
<a name="ln2444">  }</a>
<a name="ln2445">  return match;</a>
<a name="ln2446">}</a>
<a name="ln2447"> </a>
<a name="ln2448">/// Try matching the regexp in &quot;prog&quot; with file name &quot;name&quot;.</a>
<a name="ln2449">///</a>
<a name="ln2450">/// @param ignore_case When true, ignore case. Use 'fileignorecase' otherwise.</a>
<a name="ln2451">/// @return &quot;name&quot; when there is a match, NULL when not.</a>
<a name="ln2452">static char_u *fname_match(regmatch_T *rmp, char_u *name, bool ignore_case)</a>
<a name="ln2453">{</a>
<a name="ln2454">  char_u      *match = NULL;</a>
<a name="ln2455">  char_u      *p;</a>
<a name="ln2456"> </a>
<a name="ln2457">  if (name != NULL) {</a>
<a name="ln2458">    // Ignore case when 'fileignorecase' or the argument is set.</a>
<a name="ln2459">    rmp-&gt;rm_ic = p_fic || ignore_case;</a>
<a name="ln2460">    if (vim_regexec(rmp, name, (colnr_T)0)) {</a>
<a name="ln2461">      match = name;</a>
<a name="ln2462">    } else {</a>
<a name="ln2463">      // Replace $(HOME) with '~' and try matching again.</a>
<a name="ln2464">      p = home_replace_save(NULL, name);</a>
<a name="ln2465">      if (vim_regexec(rmp, p, (colnr_T)0)) {</a>
<a name="ln2466">        match = name;</a>
<a name="ln2467">      }</a>
<a name="ln2468">      xfree(p);</a>
<a name="ln2469">    }</a>
<a name="ln2470">  }</a>
<a name="ln2471"> </a>
<a name="ln2472">  return match;</a>
<a name="ln2473">}</a>
<a name="ln2474"> </a>
<a name="ln2475">/// Find a file in the buffer list by buffer number.</a>
<a name="ln2476">buf_T *buflist_findnr(int nr)</a>
<a name="ln2477">{</a>
<a name="ln2478">  if (nr == 0) {</a>
<a name="ln2479">    nr = curwin-&gt;w_alt_fnum;</a>
<a name="ln2480">  }</a>
<a name="ln2481"> </a>
<a name="ln2482">  return handle_get_buffer((handle_T)nr);</a>
<a name="ln2483">}</a>
<a name="ln2484"> </a>
<a name="ln2485">/*</a>
<a name="ln2486"> * Get name of file 'n' in the buffer list.</a>
<a name="ln2487"> * When the file has no name an empty string is returned.</a>
<a name="ln2488"> * home_replace() is used to shorten the file name (used for marks).</a>
<a name="ln2489"> * Returns a pointer to allocated memory, of NULL when failed.</a>
<a name="ln2490"> */</a>
<a name="ln2491">char_u *</a>
<a name="ln2492">buflist_nr2name(</a>
<a name="ln2493">    int n,</a>
<a name="ln2494">    int fullname,</a>
<a name="ln2495">    int helptail                   // for help buffers return tail only</a>
<a name="ln2496">)</a>
<a name="ln2497">{</a>
<a name="ln2498">  buf_T       *buf;</a>
<a name="ln2499"> </a>
<a name="ln2500">  buf = buflist_findnr(n);</a>
<a name="ln2501">  if (buf == NULL) {</a>
<a name="ln2502">    return NULL;</a>
<a name="ln2503">  }</a>
<a name="ln2504">  return home_replace_save(helptail ? buf : NULL,</a>
<a name="ln2505">      fullname ? buf-&gt;b_ffname : buf-&gt;b_fname);</a>
<a name="ln2506">}</a>
<a name="ln2507"> </a>
<a name="ln2508">/// Set the line and column numbers for the given buffer and window</a>
<a name="ln2509">///</a>
<a name="ln2510">/// @param[in,out]  buf           Buffer for which line and column are set.</a>
<a name="ln2511">/// @param[in,out]  win           Window for which line and column are set.</a>
<a name="ln2512">///                               May be NULL when using :badd.</a>
<a name="ln2513">/// @param[in]      lnum          Line number to be set. If it is zero then only</a>
<a name="ln2514">///                               options are touched.</a>
<a name="ln2515">/// @param[in]      col           Column number to be set.</a>
<a name="ln2516">/// @param[in]      copy_options  If true save the local window option values.</a>
<a name="ln2517">void buflist_setfpos(buf_T *const buf, win_T *const win,</a>
<a name="ln2518">                     linenr_T lnum, colnr_T col,</a>
<a name="ln2519">                     bool copy_options)</a>
<a name="ln2520">  FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln2521">{</a>
<a name="ln2522">  wininfo_T   *wip;</a>
<a name="ln2523"> </a>
<a name="ln2524">  for (wip = buf-&gt;b_wininfo; wip != NULL; wip = wip-&gt;wi_next) {</a>
<a name="ln2525">    if (wip-&gt;wi_win == win) {</a>
<a name="ln2526">      break;</a>
<a name="ln2527">    }</a>
<a name="ln2528">  }</a>
<a name="ln2529">  if (wip == NULL) {</a>
<a name="ln2530">    // allocate a new entry</a>
<a name="ln2531">    wip = xcalloc(1, sizeof(wininfo_T));</a>
<a name="ln2532">    wip-&gt;wi_win = win;</a>
<a name="ln2533">    if (lnum == 0) {            // set lnum even when it's 0</a>
<a name="ln2534">      lnum = 1;</a>
<a name="ln2535">    }</a>
<a name="ln2536">  } else {</a>
<a name="ln2537">    // remove the entry from the list</a>
<a name="ln2538">    if (wip-&gt;wi_prev) {</a>
<a name="ln2539">      wip-&gt;wi_prev-&gt;wi_next = wip-&gt;wi_next;</a>
<a name="ln2540">    } else {</a>
<a name="ln2541">      buf-&gt;b_wininfo = wip-&gt;wi_next;</a>
<a name="ln2542">    }</a>
<a name="ln2543">    if (wip-&gt;wi_next) {</a>
<a name="ln2544">      wip-&gt;wi_next-&gt;wi_prev = wip-&gt;wi_prev;</a>
<a name="ln2545">    }</a>
<a name="ln2546">    if (copy_options &amp;&amp; wip-&gt;wi_optset) {</a>
<a name="ln2547">      clear_winopt(&amp;wip-&gt;wi_opt);</a>
<a name="ln2548">      deleteFoldRecurse(buf, &amp;wip-&gt;wi_folds);</a>
<a name="ln2549">    }</a>
<a name="ln2550">  }</a>
<a name="ln2551">  if (lnum != 0) {</a>
<a name="ln2552">    wip-&gt;wi_fpos.lnum = lnum;</a>
<a name="ln2553">    wip-&gt;wi_fpos.col = col;</a>
<a name="ln2554">  }</a>
<a name="ln2555">  if (copy_options &amp;&amp; win != NULL) {</a>
<a name="ln2556">    // Save the window-specific option values.</a>
<a name="ln2557">    copy_winopt(&amp;win-&gt;w_onebuf_opt, &amp;wip-&gt;wi_opt);</a>
<a name="ln2558">    wip-&gt;wi_fold_manual = win-&gt;w_fold_manual;</a>
<a name="ln2559">    cloneFoldGrowArray(&amp;win-&gt;w_folds, &amp;wip-&gt;wi_folds);</a>
<a name="ln2560">    wip-&gt;wi_optset = true;</a>
<a name="ln2561">  }</a>
<a name="ln2562"> </a>
<a name="ln2563">  // insert the entry in front of the list</a>
<a name="ln2564">  wip-&gt;wi_next = buf-&gt;b_wininfo;</a>
<a name="ln2565">  buf-&gt;b_wininfo = wip;</a>
<a name="ln2566">  wip-&gt;wi_prev = NULL;</a>
<a name="ln2567">  if (wip-&gt;wi_next) {</a>
<a name="ln2568">    wip-&gt;wi_next-&gt;wi_prev = wip;</a>
<a name="ln2569">  }</a>
<a name="ln2570"> </a>
<a name="ln2571">  return;</a>
<a name="ln2572">}</a>
<a name="ln2573"> </a>
<a name="ln2574"> </a>
<a name="ln2575">/// Check that &quot;wip&quot; has 'diff' set and the diff is only for another tab page.</a>
<a name="ln2576">/// That's because a diff is local to a tab page.</a>
<a name="ln2577">static bool wininfo_other_tab_diff(wininfo_T *wip)</a>
<a name="ln2578">  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2579">{</a>
<a name="ln2580">  if (wip-&gt;wi_opt.wo_diff) {</a>
<a name="ln2581">    FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {</a>
<a name="ln2582">      // return false when it's a window in the current tab page, thus</a>
<a name="ln2583">      // the buffer was in diff mode here</a>
<a name="ln2584">      if (wip-&gt;wi_win == wp) {</a>
<a name="ln2585">        return false;</a>
<a name="ln2586">      }</a>
<a name="ln2587">    }</a>
<a name="ln2588">    return true;</a>
<a name="ln2589">  }</a>
<a name="ln2590">  return false;</a>
<a name="ln2591">}</a>
<a name="ln2592"> </a>
<a name="ln2593">// Find info for the current window in buffer &quot;buf&quot;.</a>
<a name="ln2594">// If not found, return the info for the most recently used window.</a>
<a name="ln2595">// When &quot;need_options&quot; is true skip entries where wi_optset is false.</a>
<a name="ln2596">// When &quot;skip_diff_buffer&quot; is true avoid windows with 'diff' set that is in</a>
<a name="ln2597">// another tab page.</a>
<a name="ln2598">// Returns NULL when there isn't any info.</a>
<a name="ln2599">static wininfo_T *find_wininfo(buf_T *buf, bool need_options,</a>
<a name="ln2600">                               bool skip_diff_buffer)</a>
<a name="ln2601">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2602">{</a>
<a name="ln2603">  wininfo_T   *wip;</a>
<a name="ln2604"> </a>
<a name="ln2605">  for (wip = buf-&gt;b_wininfo; wip != NULL; wip = wip-&gt;wi_next) {</a>
<a name="ln2606">    if (wip-&gt;wi_win == curwin</a>
<a name="ln2607">        &amp;&amp; (!skip_diff_buffer || !wininfo_other_tab_diff(wip))</a>
<a name="ln2608">        &amp;&amp; (!need_options || wip-&gt;wi_optset)) {</a>
<a name="ln2609">      break;</a>
<a name="ln2610">    }</a>
<a name="ln2611">  }</a>
<a name="ln2612"> </a>
<a name="ln2613">  // If no wininfo for curwin, use the first in the list (that doesn't have</a>
<a name="ln2614">  // 'diff' set and is in another tab page).</a>
<a name="ln2615">  // If &quot;need_options&quot; is true skip entries that don't have options set,</a>
<a name="ln2616">  // unless the window is editing &quot;buf&quot;, so we can copy from the window</a>
<a name="ln2617">  // itself.</a>
<a name="ln2618">  if (wip == NULL) {</a>
<a name="ln2619">    if (skip_diff_buffer) {</a>
<a name="ln2620">      for (wip = buf-&gt;b_wininfo; wip != NULL; wip = wip-&gt;wi_next) {</a>
<a name="ln2621">        if (!wininfo_other_tab_diff(wip)</a>
<a name="ln2622">            &amp;&amp; (!need_options</a>
<a name="ln2623">                || wip-&gt;wi_optset</a>
<a name="ln2624">                || (wip-&gt;wi_win != NULL</a>
<a name="ln2625">                    &amp;&amp; wip-&gt;wi_win-&gt;w_buffer == buf))) {</a>
<a name="ln2626">          break;</a>
<a name="ln2627">        }</a>
<a name="ln2628">      }</a>
<a name="ln2629">    } else {</a>
<a name="ln2630">      wip = buf-&gt;b_wininfo;</a>
<a name="ln2631">    }</a>
<a name="ln2632">  }</a>
<a name="ln2633">  return wip;</a>
<a name="ln2634">}</a>
<a name="ln2635"> </a>
<a name="ln2636">/*</a>
<a name="ln2637"> * Reset the local window options to the values last used in this window.</a>
<a name="ln2638"> * If the buffer wasn't used in this window before, use the values from</a>
<a name="ln2639"> * the most recently used window.  If the values were never set, use the</a>
<a name="ln2640"> * global values for the window.</a>
<a name="ln2641"> */</a>
<a name="ln2642">void get_winopts(buf_T *buf)</a>
<a name="ln2643">{</a>
<a name="ln2644">  clear_winopt(&amp;curwin-&gt;w_onebuf_opt);</a>
<a name="ln2645">  clearFolding(curwin);</a>
<a name="ln2646"> </a>
<a name="ln2647">  wininfo_T *const wip = find_wininfo(buf, true, true);</a>
<a name="ln2648">  if (wip != NULL &amp;&amp; wip-&gt;wi_win != curwin &amp;&amp; wip-&gt;wi_win != NULL</a>
<a name="ln2649">      &amp;&amp; wip-&gt;wi_win-&gt;w_buffer == buf) {</a>
<a name="ln2650">    win_T *wp = wip-&gt;wi_win;</a>
<a name="ln2651">    copy_winopt(&amp;wp-&gt;w_onebuf_opt, &amp;curwin-&gt;w_onebuf_opt);</a>
<a name="ln2652">    curwin-&gt;w_fold_manual = wp-&gt;w_fold_manual;</a>
<a name="ln2653">    curwin-&gt;w_foldinvalid = true;</a>
<a name="ln2654">    cloneFoldGrowArray(&amp;wp-&gt;w_folds, &amp;curwin-&gt;w_folds);</a>
<a name="ln2655">  } else if (wip != NULL &amp;&amp; wip-&gt;wi_optset) {</a>
<a name="ln2656">    copy_winopt(&amp;wip-&gt;wi_opt, &amp;curwin-&gt;w_onebuf_opt);</a>
<a name="ln2657">    curwin-&gt;w_fold_manual = wip-&gt;wi_fold_manual;</a>
<a name="ln2658">    curwin-&gt;w_foldinvalid = true;</a>
<a name="ln2659">    cloneFoldGrowArray(&amp;wip-&gt;wi_folds, &amp;curwin-&gt;w_folds);</a>
<a name="ln2660">  } else</a>
<a name="ln2661">    copy_winopt(&amp;curwin-&gt;w_allbuf_opt, &amp;curwin-&gt;w_onebuf_opt);</a>
<a name="ln2662"> </a>
<a name="ln2663">  if (curwin-&gt;w_float_config.style == kWinStyleMinimal) {</a>
<a name="ln2664">    didset_window_options(curwin);</a>
<a name="ln2665">    win_set_minimal_style(curwin);</a>
<a name="ln2666">  }</a>
<a name="ln2667"> </a>
<a name="ln2668">  // Set 'foldlevel' to 'foldlevelstart' if it's not negative.</a>
<a name="ln2669">  if (p_fdls &gt;= 0) {</a>
<a name="ln2670">    curwin-&gt;w_p_fdl = p_fdls;</a>
<a name="ln2671">  }</a>
<a name="ln2672">  didset_window_options(curwin);</a>
<a name="ln2673">}</a>
<a name="ln2674"> </a>
<a name="ln2675">/*</a>
<a name="ln2676"> * Find the position (lnum and col) for the buffer 'buf' for the current</a>
<a name="ln2677"> * window.</a>
<a name="ln2678"> * Returns a pointer to no_position if no position is found.</a>
<a name="ln2679"> */</a>
<a name="ln2680">pos_T *buflist_findfpos(buf_T *buf)</a>
<a name="ln2681">{</a>
<a name="ln2682">  static pos_T no_position = { 1, 0, 0 };</a>
<a name="ln2683"> </a>
<a name="ln2684">  wininfo_T *const wip = find_wininfo(buf, false, false);</a>
<a name="ln2685">  return (wip == NULL) ? &amp;no_position : &amp;(wip-&gt;wi_fpos);</a>
<a name="ln2686">}</a>
<a name="ln2687"> </a>
<a name="ln2688">/*</a>
<a name="ln2689"> * Find the lnum for the buffer 'buf' for the current window.</a>
<a name="ln2690"> */</a>
<a name="ln2691">linenr_T buflist_findlnum(buf_T *buf)</a>
<a name="ln2692">{</a>
<a name="ln2693">  return buflist_findfpos(buf)-&gt;lnum;</a>
<a name="ln2694">}</a>
<a name="ln2695"> </a>
<a name="ln2696">// List all known file names (for :files and :buffers command).</a>
<a name="ln2697">void buflist_list(exarg_T *eap)</a>
<a name="ln2698">{</a>
<a name="ln2699">  buf_T       *buf = firstbuf;</a>
<a name="ln2700">  int len;</a>
<a name="ln2701">  int i;</a>
<a name="ln2702"> </a>
<a name="ln2703">  garray_T buflist;</a>
<a name="ln2704">  buf_T **buflist_data = NULL;</a>
<a name="ln2705"> </a>
<a name="ln2706">  if (vim_strchr(eap-&gt;arg, 't')) {</a>
<a name="ln2707">    ga_init(&amp;buflist, sizeof(buf_T *), 50);</a>
<a name="ln2708">    for (buf = firstbuf; buf != NULL; buf = buf-&gt;b_next) {</a>
<a name="ln2709">      ga_grow(&amp;buflist, 1);</a>
<a name="ln2710">      ((buf_T **)buflist.ga_data)[buflist.ga_len++] = buf;</a>
<a name="ln2711">    }</a>
<a name="ln2712"> </a>
<a name="ln2713">    qsort(buflist.ga_data, (size_t)buflist.ga_len,</a>
<a name="ln2714">          sizeof(buf_T *), buf_time_compare);</a>
<a name="ln2715"> </a>
<a name="ln2716">    buflist_data = (buf_T **)buflist.ga_data;</a>
<a name="ln2717">    buf = *buflist_data;</a>
<a name="ln2718">  }</a>
<a name="ln2719">  buf_T **p = buflist_data;</a>
<a name="ln2720"> </a>
<a name="ln2721">  for (;</a>
<a name="ln2722">       buf != NULL &amp;&amp; !got_int;</a>
<a name="ln2723">       buf = buflist_data != NULL</a>
<a name="ln2724">       ? (++p &lt; buflist_data + buflist.ga_len ? *p : NULL)</a>
<a name="ln2725">       : buf-&gt;b_next) {</a>
<a name="ln2726">    const bool is_terminal = buf-&gt;terminal;</a>
<a name="ln2727">    const bool job_running = buf-&gt;terminal &amp;&amp; terminal_running(buf-&gt;terminal);</a>
<a name="ln2728"> </a>
<a name="ln2729">    // skip unspecified buffers</a>
<a name="ln2730">    if ((!buf-&gt;b_p_bl &amp;&amp; !eap-&gt;forceit &amp;&amp; !strchr((char *)eap-&gt;arg, 'u'))</a>
<a name="ln2731">        || (strchr((char *)eap-&gt;arg, 'u') &amp;&amp; buf-&gt;b_p_bl)</a>
<a name="ln2732">        || (strchr((char *)eap-&gt;arg, '+')</a>
<a name="ln2733">            &amp;&amp; ((buf-&gt;b_flags &amp; BF_READERR) || !bufIsChanged(buf)))</a>
<a name="ln2734">        || (strchr((char *)eap-&gt;arg, 'a')</a>
<a name="ln2735">            &amp;&amp; (buf-&gt;b_ml.ml_mfp == NULL || buf-&gt;b_nwindows == 0))</a>
<a name="ln2736">        || (strchr((char *)eap-&gt;arg, 'h')</a>
<a name="ln2737">            &amp;&amp; (buf-&gt;b_ml.ml_mfp == NULL || buf-&gt;b_nwindows != 0))</a>
<a name="ln2738">        || (strchr((char *)eap-&gt;arg, 'R') &amp;&amp; (!is_terminal || !job_running))</a>
<a name="ln2739">        || (strchr((char *)eap-&gt;arg, 'F') &amp;&amp; (!is_terminal || job_running))</a>
<a name="ln2740">        || (strchr((char *)eap-&gt;arg, '-') &amp;&amp; buf-&gt;b_p_ma)</a>
<a name="ln2741">        || (strchr((char *)eap-&gt;arg, '=') &amp;&amp; !buf-&gt;b_p_ro)</a>
<a name="ln2742">        || (strchr((char *)eap-&gt;arg, 'x') &amp;&amp; !(buf-&gt;b_flags &amp; BF_READERR))</a>
<a name="ln2743">        || (strchr((char *)eap-&gt;arg, '%') &amp;&amp; buf != curbuf)</a>
<a name="ln2744">        || (strchr((char *)eap-&gt;arg, '#')</a>
<a name="ln2745">            &amp;&amp; (buf == curbuf || curwin-&gt;w_alt_fnum != buf-&gt;b_fnum))) {</a>
<a name="ln2746">      continue;</a>
<a name="ln2747">    }</a>
<a name="ln2748">    if (buf_spname(buf) != NULL) {</a>
<a name="ln2749">      STRLCPY(NameBuff, buf_spname(buf), MAXPATHL);</a>
<a name="ln2750">    } else {</a>
<a name="ln2751">      home_replace(buf, buf-&gt;b_fname, NameBuff, MAXPATHL, true);</a>
<a name="ln2752">    }</a>
<a name="ln2753"> </a>
<a name="ln2754">    if (message_filtered(NameBuff)) {</a>
<a name="ln2755">      continue;</a>
<a name="ln2756">    }</a>
<a name="ln2757"> </a>
<a name="ln2758">    const int changed_char = (buf-&gt;b_flags &amp; BF_READERR)</a>
<a name="ln2759">      ? 'x'</a>
<a name="ln2760">      : (bufIsChanged(buf) ? '+' : ' ');</a>
<a name="ln2761">    int ro_char = !MODIFIABLE(buf) ? '-' : (buf-&gt;b_p_ro ? '=' : ' ');</a>
<a name="ln2762">    if (buf-&gt;terminal) {</a>
<a name="ln2763">      ro_char = channel_job_running((uint64_t)buf-&gt;b_p_channel) ? 'R' : 'F';</a>
<a name="ln2764">    }</a>
<a name="ln2765"> </a>
<a name="ln2766">    msg_putchar('\n');</a>
<a name="ln2767">    len = vim_snprintf(</a>
<a name="ln2768">        (char *)IObuff, IOSIZE - 20, &quot;%3d%c%c%c%c%c \&quot;%s\&quot;&quot;,</a>
<a name="ln2769">        buf-&gt;b_fnum,</a>
<a name="ln2770">        buf-&gt;b_p_bl ? ' ' : 'u',</a>
<a name="ln2771">        buf == curbuf ? '%' : (curwin-&gt;w_alt_fnum == buf-&gt;b_fnum ? '#' : ' '),</a>
<a name="ln2772">        buf-&gt;b_ml.ml_mfp == NULL ? ' ' : (buf-&gt;b_nwindows == 0 ? 'h' : 'a'),</a>
<a name="ln2773">        ro_char,</a>
<a name="ln2774">        changed_char,</a>
<a name="ln2775">        NameBuff);</a>
<a name="ln2776"> </a>
<a name="ln2777">    if (len &gt; IOSIZE - 20) {</a>
<a name="ln2778">        len = IOSIZE - 20;</a>
<a name="ln2779">    }</a>
<a name="ln2780"> </a>
<a name="ln2781">    // put &quot;line 999&quot; in column 40 or after the file name</a>
<a name="ln2782">    i = 40 - vim_strsize(IObuff);</a>
<a name="ln2783">    do {</a>
<a name="ln2784">      IObuff[len++] = ' ';</a>
<a name="ln2785">    } while (--i &gt; 0 &amp;&amp; len &lt; IOSIZE - 18);</a>
<a name="ln2786">    if (vim_strchr(eap-&gt;arg, 't') &amp;&amp; buf-&gt;b_last_used) {</a>
<a name="ln2787">      add_time(IObuff + len, (size_t)(IOSIZE - len), buf-&gt;b_last_used);</a>
<a name="ln2788">    } else {</a>
<a name="ln2789">      vim_snprintf((char *)IObuff + len, (size_t)(IOSIZE - len),</a>
<a name="ln2790">                   _(&quot;line %&quot; PRId64),</a>
<a name="ln2791">                   buf == curbuf ? (int64_t)curwin-&gt;w_cursor.lnum</a>
<a name="ln2792">                   : (int64_t)buflist_findlnum(buf));</a>
<a name="ln2793">    }</a>
<a name="ln2794"> </a>
<a name="ln2795">    msg_outtrans(IObuff);</a>
<a name="ln2796">    line_breakcheck();</a>
<a name="ln2797">  }</a>
<a name="ln2798"> </a>
<a name="ln2799">  if (buflist_data) {</a>
<a name="ln2800">    ga_clear(&amp;buflist);</a>
<a name="ln2801">  }</a>
<a name="ln2802">}</a>
<a name="ln2803"> </a>
<a name="ln2804">/*</a>
<a name="ln2805"> * Get file name and line number for file 'fnum'.</a>
<a name="ln2806"> * Used by DoOneCmd() for translating '%' and '#'.</a>
<a name="ln2807"> * Used by insert_reg() and cmdline_paste() for '#' register.</a>
<a name="ln2808"> * Return FAIL if not found, OK for success.</a>
<a name="ln2809"> */</a>
<a name="ln2810">int buflist_name_nr(int fnum, char_u **fname, linenr_T *lnum)</a>
<a name="ln2811">{</a>
<a name="ln2812">  buf_T       *buf;</a>
<a name="ln2813"> </a>
<a name="ln2814">  buf = buflist_findnr(fnum);</a>
<a name="ln2815">  if (buf == NULL || buf-&gt;b_fname == NULL) {</a>
<a name="ln2816">    return FAIL;</a>
<a name="ln2817">  }</a>
<a name="ln2818"> </a>
<a name="ln2819">  *fname = buf-&gt;b_fname;</a>
<a name="ln2820">  *lnum = buflist_findlnum(buf);</a>
<a name="ln2821"> </a>
<a name="ln2822">  return OK;</a>
<a name="ln2823">}</a>
<a name="ln2824"> </a>
<a name="ln2825">// Set the file name for &quot;buf&quot; to &quot;ffname_arg&quot;, short file name to</a>
<a name="ln2826">// &quot;sfname_arg&quot;.</a>
<a name="ln2827">// The file name with the full path is also remembered, for when :cd is used.</a>
<a name="ln2828">// Returns FAIL for failure (file name already in use by other buffer)</a>
<a name="ln2829">//      OK otherwise.</a>
<a name="ln2830">int setfname(</a>
<a name="ln2831">    buf_T *buf,</a>
<a name="ln2832">    char_u *ffname_arg,</a>
<a name="ln2833">    char_u *sfname_arg,</a>
<a name="ln2834">    bool message                  // give message when buffer already exists</a>
<a name="ln2835">)</a>
<a name="ln2836">{</a>
<a name="ln2837">  char_u *ffname = ffname_arg;</a>
<a name="ln2838">  char_u *sfname = sfname_arg;</a>
<a name="ln2839">  buf_T       *obuf = NULL;</a>
<a name="ln2840">  FileID file_id;</a>
<a name="ln2841">  bool file_id_valid = false;</a>
<a name="ln2842"> </a>
<a name="ln2843">  if (ffname == NULL || *ffname == NUL) {</a>
<a name="ln2844">    // Removing the name.</a>
<a name="ln2845">    if (buf-&gt;b_sfname != buf-&gt;b_ffname) {</a>
<a name="ln2846">      XFREE_CLEAR(buf-&gt;b_sfname);</a>
<a name="ln2847">    } else {</a>
<a name="ln2848">      buf-&gt;b_sfname = NULL;</a>
<a name="ln2849">    }</a>
<a name="ln2850">    XFREE_CLEAR(buf-&gt;b_ffname);</a>
<a name="ln2851">  } else {</a>
<a name="ln2852">    fname_expand(buf, &amp;ffname, &amp;sfname);    // will allocate ffname</a>
<a name="ln2853">    if (ffname == NULL) {                   // out of memory</a>
<a name="ln2854">      return FAIL;</a>
<a name="ln2855">    }</a>
<a name="ln2856"> </a>
<a name="ln2857">    /*</a>
<a name="ln2858">     * if the file name is already used in another buffer:</a>
<a name="ln2859">     * - if the buffer is loaded, fail</a>
<a name="ln2860">     * - if the buffer is not loaded, delete it from the list</a>
<a name="ln2861">     */</a>
<a name="ln2862">    file_id_valid = os_fileid((char *)ffname, &amp;file_id);</a>
<a name="ln2863">    if (!(buf-&gt;b_flags &amp; BF_DUMMY)) {</a>
<a name="ln2864">      obuf = buflist_findname_file_id(ffname, &amp;file_id, file_id_valid);</a>
<a name="ln2865">    }</a>
<a name="ln2866">    if (obuf != NULL &amp;&amp; obuf != buf) {</a>
<a name="ln2867">      if (obuf-&gt;b_ml.ml_mfp != NULL) {          // it's loaded, fail</a>
<a name="ln2868">        if (message) {</a>
<a name="ln2869">          EMSG(_(&quot;E95: Buffer with this name already exists&quot;));</a>
<a name="ln2870">        }</a>
<a name="ln2871">        xfree(ffname);</a>
<a name="ln2872">        return FAIL;</a>
<a name="ln2873">      }</a>
<a name="ln2874">      // delete from the list</a>
<a name="ln2875">      close_buffer(NULL, obuf, DOBUF_WIPE, false);</a>
<a name="ln2876">    }</a>
<a name="ln2877">    sfname = vim_strsave(sfname);</a>
<a name="ln2878">#ifdef USE_FNAME_CASE</a>
<a name="ln2879">    path_fix_case(sfname);            // set correct case for short file name</a>
<a name="ln2880">#endif</a>
<a name="ln2881">    if (buf-&gt;b_sfname != buf-&gt;b_ffname) {</a>
<a name="ln2882">      xfree(buf-&gt;b_sfname);</a>
<a name="ln2883">    }</a>
<a name="ln2884">    xfree(buf-&gt;b_ffname);</a>
<a name="ln2885">    buf-&gt;b_ffname = ffname;</a>
<a name="ln2886">    buf-&gt;b_sfname = sfname;</a>
<a name="ln2887">  }</a>
<a name="ln2888">  buf-&gt;b_fname = buf-&gt;b_sfname;</a>
<a name="ln2889">  if (!file_id_valid) {</a>
<a name="ln2890">    buf-&gt;file_id_valid = false;</a>
<a name="ln2891">  } else {</a>
<a name="ln2892">    buf-&gt;file_id_valid = true;</a>
<a name="ln2893">    buf-&gt;file_id = file_id;</a>
<a name="ln2894">  }</a>
<a name="ln2895"> </a>
<a name="ln2896">  buf_name_changed(buf);</a>
<a name="ln2897">  return OK;</a>
<a name="ln2898">}</a>
<a name="ln2899"> </a>
<a name="ln2900">/*</a>
<a name="ln2901"> * Crude way of changing the name of a buffer.  Use with care!</a>
<a name="ln2902"> * The name should be relative to the current directory.</a>
<a name="ln2903"> */</a>
<a name="ln2904">void buf_set_name(int fnum, char_u *name)</a>
<a name="ln2905">{</a>
<a name="ln2906">  buf_T       *buf;</a>
<a name="ln2907"> </a>
<a name="ln2908">  buf = buflist_findnr(fnum);</a>
<a name="ln2909">  if (buf != NULL) {</a>
<a name="ln2910">    if (buf-&gt;b_sfname != buf-&gt;b_ffname) {</a>
<a name="ln2911">      xfree(buf-&gt;b_sfname);</a>
<a name="ln2912">    }</a>
<a name="ln2913">    xfree(buf-&gt;b_ffname);</a>
<a name="ln2914">    buf-&gt;b_ffname = vim_strsave(name);</a>
<a name="ln2915">    buf-&gt;b_sfname = NULL;</a>
<a name="ln2916">    /* Allocate ffname and expand into full path.  Also resolves .lnk</a>
<a name="ln2917">     * files on Win32. */</a>
<a name="ln2918">    fname_expand(buf, &amp;buf-&gt;b_ffname, &amp;buf-&gt;b_sfname);</a>
<a name="ln2919">    buf-&gt;b_fname = buf-&gt;b_sfname;</a>
<a name="ln2920">  }</a>
<a name="ln2921">}</a>
<a name="ln2922"> </a>
<a name="ln2923">/*</a>
<a name="ln2924"> * Take care of what needs to be done when the name of buffer &quot;buf&quot; has</a>
<a name="ln2925"> * changed.</a>
<a name="ln2926"> */</a>
<a name="ln2927">void buf_name_changed(buf_T *buf)</a>
<a name="ln2928">{</a>
<a name="ln2929">  /*</a>
<a name="ln2930">   * If the file name changed, also change the name of the swapfile</a>
<a name="ln2931">   */</a>
<a name="ln2932">  if (buf-&gt;b_ml.ml_mfp != NULL) {</a>
<a name="ln2933">    ml_setname(buf);</a>
<a name="ln2934">  }</a>
<a name="ln2935"> </a>
<a name="ln2936">  if (curwin-&gt;w_buffer == buf) {</a>
<a name="ln2937">    check_arg_idx(curwin);      // check file name for arg list</a>
<a name="ln2938">  }</a>
<a name="ln2939">  maketitle();                  // set window title</a>
<a name="ln2940">  status_redraw_all();          // status lines need to be redrawn</a>
<a name="ln2941">  fmarks_check_names(buf);      // check named file marks</a>
<a name="ln2942">  ml_timestamp(buf);            // reset timestamp</a>
<a name="ln2943">}</a>
<a name="ln2944"> </a>
<a name="ln2945">/*</a>
<a name="ln2946"> * set alternate file name for current window</a>
<a name="ln2947"> *</a>
<a name="ln2948"> * Used by do_one_cmd(), do_write() and do_ecmd().</a>
<a name="ln2949"> * Return the buffer.</a>
<a name="ln2950"> */</a>
<a name="ln2951">buf_T *setaltfname(char_u *ffname, char_u *sfname, linenr_T lnum)</a>
<a name="ln2952">{</a>
<a name="ln2953">  buf_T       *buf;</a>
<a name="ln2954"> </a>
<a name="ln2955">  // Create a buffer.  'buflisted' is not set if it's a new buffer</a>
<a name="ln2956">  buf = buflist_new(ffname, sfname, lnum, 0);</a>
<a name="ln2957">  if (buf != NULL &amp;&amp; !cmdmod.keepalt) {</a>
<a name="ln2958">    curwin-&gt;w_alt_fnum = buf-&gt;b_fnum;</a>
<a name="ln2959">  }</a>
<a name="ln2960">  return buf;</a>
<a name="ln2961">}</a>
<a name="ln2962"> </a>
<a name="ln2963">/*</a>
<a name="ln2964"> * Get alternate file name for current window.</a>
<a name="ln2965"> * Return NULL if there isn't any, and give error message if requested.</a>
<a name="ln2966"> */</a>
<a name="ln2967">char_u * getaltfname(</a>
<a name="ln2968">    bool errmsg                   // give error message</a>
<a name="ln2969">)</a>
<a name="ln2970">{</a>
<a name="ln2971">  char_u      *fname;</a>
<a name="ln2972">  linenr_T dummy;</a>
<a name="ln2973"> </a>
<a name="ln2974">  if (buflist_name_nr(0, &amp;fname, &amp;dummy) == FAIL) {</a>
<a name="ln2975">    if (errmsg) {</a>
<a name="ln2976">      EMSG(_(e_noalt));</a>
<a name="ln2977">    }</a>
<a name="ln2978">    return NULL;</a>
<a name="ln2979">  }</a>
<a name="ln2980">  return fname;</a>
<a name="ln2981">}</a>
<a name="ln2982"> </a>
<a name="ln2983">/*</a>
<a name="ln2984"> * Add a file name to the buflist and return its number.</a>
<a name="ln2985"> * Uses same flags as buflist_new(), except BLN_DUMMY.</a>
<a name="ln2986"> *</a>
<a name="ln2987"> * used by qf_init(), main() and doarglist()</a>
<a name="ln2988"> */</a>
<a name="ln2989">int buflist_add(char_u *fname, int flags)</a>
<a name="ln2990">{</a>
<a name="ln2991">  buf_T       *buf;</a>
<a name="ln2992"> </a>
<a name="ln2993">  buf = buflist_new(fname, NULL, (linenr_T)0, flags);</a>
<a name="ln2994">  if (buf != NULL) {</a>
<a name="ln2995">    return buf-&gt;b_fnum;</a>
<a name="ln2996">  }</a>
<a name="ln2997">  return 0;</a>
<a name="ln2998">}</a>
<a name="ln2999"> </a>
<a name="ln3000">#if defined(BACKSLASH_IN_FILENAME)</a>
<a name="ln3001">/*</a>
<a name="ln3002"> * Adjust slashes in file names.  Called after 'shellslash' was set.</a>
<a name="ln3003"> */</a>
<a name="ln3004">void buflist_slash_adjust(void)</a>
<a name="ln3005">{</a>
<a name="ln3006">  FOR_ALL_BUFFERS(bp) {</a>
<a name="ln3007">    if (bp-&gt;b_ffname != NULL) {</a>
<a name="ln3008">      slash_adjust(bp-&gt;b_ffname);</a>
<a name="ln3009">    }</a>
<a name="ln3010">    if (bp-&gt;b_sfname != NULL) {</a>
<a name="ln3011">      slash_adjust(bp-&gt;b_sfname);</a>
<a name="ln3012">    }</a>
<a name="ln3013">  }</a>
<a name="ln3014">}</a>
<a name="ln3015"> </a>
<a name="ln3016">#endif</a>
<a name="ln3017"> </a>
<a name="ln3018">/*</a>
<a name="ln3019"> * Set alternate cursor position for the current buffer and window &quot;win&quot;.</a>
<a name="ln3020"> * Also save the local window option values.</a>
<a name="ln3021"> */</a>
<a name="ln3022">void buflist_altfpos(win_T *win)</a>
<a name="ln3023">{</a>
<a name="ln3024">  buflist_setfpos(curbuf, win, win-&gt;w_cursor.lnum, win-&gt;w_cursor.col, true);</a>
<a name="ln3025">}</a>
<a name="ln3026"> </a>
<a name="ln3027">/// Check that &quot;ffname&quot; is not the same file as current file.</a>
<a name="ln3028">/// Fname must have a full path (expanded by path_to_absolute()).</a>
<a name="ln3029">///</a>
<a name="ln3030">/// @param  ffname  full path name to check</a>
<a name="ln3031">bool otherfile(char_u *ffname)</a>
<a name="ln3032">  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_ALL</a>
<a name="ln3033">{</a>
<a name="ln3034">  return otherfile_buf(curbuf, ffname, NULL, false);</a>
<a name="ln3035">}</a>
<a name="ln3036"> </a>
<a name="ln3037">/// Check that &quot;ffname&quot; is not the same file as the file loaded in &quot;buf&quot;.</a>
<a name="ln3038">/// Fname must have a full path (expanded by path_to_absolute()).</a>
<a name="ln3039">///</a>
<a name="ln3040">/// @param  buf            buffer to check</a>
<a name="ln3041">/// @param  ffname         full path name to check</a>
<a name="ln3042">/// @param  file_id_p      information about the file at &quot;ffname&quot;.</a>
<a name="ln3043">/// @param  file_id_valid  whether a valid &quot;file_id_p&quot; was passed in.</a>
<a name="ln3044">static bool otherfile_buf(buf_T *buf, char_u *ffname, FileID *file_id_p,</a>
<a name="ln3045">                          bool file_id_valid)</a>
<a name="ln3046">  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln3047">{</a>
<a name="ln3048">  // no name is different</a>
<a name="ln3049">  if (ffname == NULL || *ffname == NUL || buf-&gt;b_ffname == NULL) {</a>
<a name="ln3050">    return true;</a>
<a name="ln3051">  }</a>
<a name="ln3052">  if (fnamecmp(ffname, buf-&gt;b_ffname) == 0) {</a>
<a name="ln3053">    return false;</a>
<a name="ln3054">  }</a>
<a name="ln3055">  {</a>
<a name="ln3056">    FileID file_id;</a>
<a name="ln3057">    // If no struct stat given, get it now</a>
<a name="ln3058">    if (file_id_p == NULL) {</a>
<a name="ln3059">      file_id_p = &amp;file_id;</a>
<a name="ln3060">      file_id_valid = os_fileid((char *)ffname, file_id_p);</a>
<a name="ln3061">    }</a>
<a name="ln3062">    if (!file_id_valid) {</a>
<a name="ln3063">      // file_id not valid, assume files are different.</a>
<a name="ln3064">      return true;</a>
<a name="ln3065">    }</a>
<a name="ln3066">    // Use dev/ino to check if the files are the same, even when the names</a>
<a name="ln3067">    // are different (possible with links).  Still need to compare the</a>
<a name="ln3068">    // name above, for when the file doesn't exist yet.</a>
<a name="ln3069">    // Problem: The dev/ino changes when a file is deleted (and created</a>
<a name="ln3070">    // again) and remains the same when renamed/moved.  We don't want to</a>
<a name="ln3071">    // stat() each buffer each time, that would be too slow.  Get the</a>
<a name="ln3072">    // dev/ino again when they appear to match, but not when they appear</a>
<a name="ln3073">    // to be different: Could skip a buffer when it's actually the same</a>
<a name="ln3074">    // file.</a>
<a name="ln3075">    if (buf_same_file_id(buf, file_id_p)) {</a>
<a name="ln3076">      buf_set_file_id(buf);</a>
<a name="ln3077">      if (buf_same_file_id(buf, file_id_p)) {</a>
<a name="ln3078">        return false;</a>
<a name="ln3079">      }</a>
<a name="ln3080">    }</a>
<a name="ln3081">  }</a>
<a name="ln3082">  return true;</a>
<a name="ln3083">}</a>
<a name="ln3084"> </a>
<a name="ln3085">// Set file_id for a buffer.</a>
<a name="ln3086">// Must always be called when b_fname is changed!</a>
<a name="ln3087">void buf_set_file_id(buf_T *buf)</a>
<a name="ln3088">{</a>
<a name="ln3089">  FileID file_id;</a>
<a name="ln3090">  if (buf-&gt;b_fname != NULL</a>
<a name="ln3091">      &amp;&amp; os_fileid((char *)buf-&gt;b_fname, &amp;file_id)) {</a>
<a name="ln3092">    buf-&gt;file_id_valid = true;</a>
<a name="ln3093">    buf-&gt;file_id = file_id;</a>
<a name="ln3094">  } else {</a>
<a name="ln3095">    buf-&gt;file_id_valid = false;</a>
<a name="ln3096">  }</a>
<a name="ln3097">}</a>
<a name="ln3098"> </a>
<a name="ln3099">/// Check that file_id in buffer &quot;buf&quot; matches with &quot;file_id&quot;.</a>
<a name="ln3100">///</a>
<a name="ln3101">/// @param  buf      buffer</a>
<a name="ln3102">/// @param  file_id  file id</a>
<a name="ln3103">static bool buf_same_file_id(buf_T *buf, FileID *file_id)</a>
<a name="ln3104">  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_ALL</a>
<a name="ln3105">{</a>
<a name="ln3106">  return buf-&gt;file_id_valid &amp;&amp; os_fileid_equal(&amp;(buf-&gt;file_id), file_id);</a>
<a name="ln3107">}</a>
<a name="ln3108"> </a>
<a name="ln3109">/*</a>
<a name="ln3110"> * Print info about the current buffer.</a>
<a name="ln3111"> */</a>
<a name="ln3112">void</a>
<a name="ln3113">fileinfo(</a>
<a name="ln3114">    int fullname,               // when non-zero print full path</a>
<a name="ln3115">    int shorthelp,</a>
<a name="ln3116">    int dont_truncate</a>
<a name="ln3117">)</a>
<a name="ln3118">{</a>
<a name="ln3119">  char_u      *name;</a>
<a name="ln3120">  int n;</a>
<a name="ln3121">  char_u      *p;</a>
<a name="ln3122">  char_u      *buffer;</a>
<a name="ln3123">  size_t len;</a>
<a name="ln3124"> </a>
<a name="ln3125">  buffer = xmalloc(IOSIZE);</a>
<a name="ln3126"> </a>
<a name="ln3127">  if (fullname &gt; 1) {       // 2 CTRL-G: include buffer number</a>
<a name="ln3128">    vim_snprintf((char *)buffer, IOSIZE, &quot;buf %d: &quot;, curbuf-&gt;b_fnum);</a>
<a name="ln3129">    p = buffer + STRLEN(buffer);</a>
<a name="ln3130">  } else</a>
<a name="ln3131">    p = buffer;</a>
<a name="ln3132"> </a>
<a name="ln3133">  *p++ = '&quot;';</a>
<a name="ln3134">  if (buf_spname(curbuf) != NULL) {</a>
<a name="ln3135">    STRLCPY(p, buf_spname(curbuf), IOSIZE - (p - buffer));</a>
<a name="ln3136">  } else {</a>
<a name="ln3137">    if (!fullname &amp;&amp; curbuf-&gt;b_fname != NULL) {</a>
<a name="ln3138">      name = curbuf-&gt;b_fname;</a>
<a name="ln3139">    } else {</a>
<a name="ln3140">      name = curbuf-&gt;b_ffname;</a>
<a name="ln3141">    }</a>
<a name="ln3142">    home_replace(shorthelp ? curbuf : NULL, name, p,</a>
<a name="ln3143">                 (size_t)(IOSIZE - (p - buffer)), true);</a>
<a name="ln3144">  }</a>
<a name="ln3145"> </a>
<a name="ln3146">  vim_snprintf_add((char *)buffer, IOSIZE, &quot;\&quot;%s%s%s%s%s%s&quot;,</a>
<a name="ln3147">                   curbufIsChanged()</a>
<a name="ln3148">                   ? (shortmess(SHM_MOD) ?  &quot; [+]&quot; : _(&quot; [Modified]&quot;)) : &quot; &quot;,</a>
<a name="ln3149">                   (curbuf-&gt;b_flags &amp; BF_NOTEDITED) &amp;&amp; !bt_dontwrite(curbuf)</a>
<a name="ln3150">                   ? _(&quot;[Not edited]&quot;) : &quot;&quot;,</a>
<a name="ln3151">                   (curbuf-&gt;b_flags &amp; BF_NEW) &amp;&amp; !bt_dontwrite(curbuf)</a>
<a name="ln3152">                   ? new_file_message() : &quot;&quot;,</a>
<a name="ln3153">                   (curbuf-&gt;b_flags &amp; BF_READERR)</a>
<a name="ln3154">                   ? _(&quot;[Read errors]&quot;) : &quot;&quot;,</a>
<a name="ln3155">                   curbuf-&gt;b_p_ro</a>
<a name="ln3156">                   ? (shortmess(SHM_RO) ? _(&quot;[RO]&quot;) : _(&quot;[readonly]&quot;)) : &quot;&quot;,</a>
<a name="ln3157">                   (curbufIsChanged()</a>
<a name="ln3158">                    || (curbuf-&gt;b_flags &amp; BF_WRITE_MASK)</a>
<a name="ln3159">                    || curbuf-&gt;b_p_ro)</a>
<a name="ln3160">                   ? &quot; &quot; : &quot;&quot;);</a>
<a name="ln3161">  // With 32 bit longs and more than 21,474,836 lines multiplying by 100</a>
<a name="ln3162">  // causes an overflow, thus for large numbers divide instead.</a>
<a name="ln3163">  if (curwin-&gt;w_cursor.lnum &gt; 1000000L) {</a>
<a name="ln3164">    n = (int)(((long)curwin-&gt;w_cursor.lnum) /</a>
<a name="ln3165">              ((long)curbuf-&gt;b_ml.ml_line_count / 100L));</a>
<a name="ln3166">  } else {</a>
<a name="ln3167">    n = (int)(((long)curwin-&gt;w_cursor.lnum * 100L) /</a>
<a name="ln3168">              (long)curbuf-&gt;b_ml.ml_line_count);</a>
<a name="ln3169">  }</a>
<a name="ln3170">  if (curbuf-&gt;b_ml.ml_flags &amp; ML_EMPTY) {</a>
<a name="ln3171">    vim_snprintf_add((char *)buffer, IOSIZE, &quot;%s&quot;, _(no_lines_msg));</a>
<a name="ln3172">  } else if (p_ru) {</a>
<a name="ln3173">    // Current line and column are already on the screen -- webb</a>
<a name="ln3174">    if (curbuf-&gt;b_ml.ml_line_count == 1) {</a>
<a name="ln3175">      vim_snprintf_add((char *)buffer, IOSIZE, _(&quot;1 line --%d%%--&quot;), n);</a>
<a name="ln3176">    } else {</a>
<a name="ln3177">      vim_snprintf_add((char *)buffer, IOSIZE, _(&quot;%&quot; PRId64 &quot; lines --%d%%--&quot;),</a>
<a name="ln3178">                       (int64_t)curbuf-&gt;b_ml.ml_line_count, n);</a>
<a name="ln3179">    }</a>
<a name="ln3180">  } else {</a>
<a name="ln3181">    vim_snprintf_add((char *)buffer, IOSIZE,</a>
<a name="ln3182">        _(&quot;line %&quot; PRId64 &quot; of %&quot; PRId64 &quot; --%d%%-- col &quot;),</a>
<a name="ln3183">        (int64_t)curwin-&gt;w_cursor.lnum,</a>
<a name="ln3184">        (int64_t)curbuf-&gt;b_ml.ml_line_count,</a>
<a name="ln3185">        n);</a>
<a name="ln3186">    validate_virtcol();</a>
<a name="ln3187">    len = STRLEN(buffer);</a>
<a name="ln3188">    col_print(buffer + len, IOSIZE - len,</a>
<a name="ln3189">        (int)curwin-&gt;w_cursor.col + 1, (int)curwin-&gt;w_virtcol + 1);</a>
<a name="ln3190">  }</a>
<a name="ln3191"> </a>
<a name="ln3192">  (void)append_arg_number(curwin, buffer, IOSIZE, !shortmess(SHM_FILE));</a>
<a name="ln3193"> </a>
<a name="ln3194">  if (dont_truncate) {</a>
<a name="ln3195">    /* Temporarily set msg_scroll to avoid the message being truncated.</a>
<a name="ln3196">     * First call msg_start() to get the message in the right place. */</a>
<a name="ln3197">    msg_start();</a>
<a name="ln3198">    n = msg_scroll;</a>
<a name="ln3199">    msg_scroll = true;</a>
<a name="ln3200">    msg(buffer);</a>
<a name="ln3201">    msg_scroll = n;</a>
<a name="ln3202">  } else {</a>
<a name="ln3203">    p = msg_trunc_attr(buffer, false, 0);</a>
<a name="ln3204">    if (restart_edit != 0 || (msg_scrolled &amp;&amp; !need_wait_return)) {</a>
<a name="ln3205">      // Need to repeat the message after redrawing when:</a>
<a name="ln3206">      // - When restart_edit is set (otherwise there will be a delay</a>
<a name="ln3207">      //   before redrawing).</a>
<a name="ln3208">      // - When the screen was scrolled but there is no wait-return</a>
<a name="ln3209">      //   prompt.</a>
<a name="ln3210">      set_keep_msg(p, 0);</a>
<a name="ln3211">    }</a>
<a name="ln3212">  }</a>
<a name="ln3213"> </a>
<a name="ln3214">  xfree(buffer);</a>
<a name="ln3215">}</a>
<a name="ln3216"> </a>
<a name="ln3217">void col_print(char_u *buf, size_t buflen, int col, int vcol)</a>
<a name="ln3218">{</a>
<a name="ln3219">  if (col == vcol) {</a>
<a name="ln3220">    vim_snprintf((char *)buf, buflen, &quot;%d&quot;, col);</a>
<a name="ln3221">  } else {</a>
<a name="ln3222">    vim_snprintf((char *)buf, buflen, &quot;%d-%d&quot;, col, vcol);</a>
<a name="ln3223">  }</a>
<a name="ln3224">}</a>
<a name="ln3225"> </a>
<a name="ln3226">static char_u *lasttitle = NULL;</a>
<a name="ln3227">static char_u *lasticon = NULL;</a>
<a name="ln3228"> </a>
<a name="ln3229"> </a>
<a name="ln3230">// Put the title name in the title bar and icon of the window.</a>
<a name="ln3231">void maketitle(void)</a>
<a name="ln3232">{</a>
<a name="ln3233">  char_u *title_str = NULL;</a>
<a name="ln3234">  char_u *icon_str = NULL;</a>
<a name="ln3235">  int maxlen = 0;</a>
<a name="ln3236">  int len;</a>
<a name="ln3237">  int mustset;</a>
<a name="ln3238">  char buf[IOSIZE];</a>
<a name="ln3239"> </a>
<a name="ln3240">  if (!redrawing()) {</a>
<a name="ln3241">    // Postpone updating the title when 'lazyredraw' is set.</a>
<a name="ln3242">    need_maketitle = true;</a>
<a name="ln3243">    return;</a>
<a name="ln3244">  }</a>
<a name="ln3245"> </a>
<a name="ln3246">  need_maketitle = false;</a>
<a name="ln3247">  if (!p_title &amp;&amp; !p_icon &amp;&amp; lasttitle == NULL &amp;&amp; lasticon == NULL) {</a>
<a name="ln3248">    return;  // nothing to do</a>
<a name="ln3249">  }</a>
<a name="ln3250"> </a>
<a name="ln3251">  if (p_title) {</a>
<a name="ln3252">    if (p_titlelen &gt; 0) {</a>
<a name="ln3253">      maxlen = (int)(p_titlelen * Columns / 100);</a>
<a name="ln3254">      if (maxlen &lt; 10) {</a>
<a name="ln3255">        maxlen = 10;</a>
<a name="ln3256">      }</a>
<a name="ln3257">    }</a>
<a name="ln3258"> </a>
<a name="ln3259">    if (*p_titlestring != NUL) {</a>
<a name="ln3260">      if (stl_syntax &amp; STL_IN_TITLE) {</a>
<a name="ln3261">        int use_sandbox = false;</a>
<a name="ln3262">        int save_called_emsg = called_emsg;</a>
<a name="ln3263"> </a>
<a name="ln3264">        use_sandbox = was_set_insecurely(curwin, (char_u *)&quot;titlestring&quot;, 0);</a>
<a name="ln3265">        called_emsg = false;</a>
<a name="ln3266">        build_stl_str_hl(curwin, (char_u *)buf, sizeof(buf),</a>
<a name="ln3267">                         p_titlestring, use_sandbox,</a>
<a name="ln3268">                         0, maxlen, NULL, NULL);</a>
<a name="ln3269">        title_str = (char_u *)buf;</a>
<a name="ln3270">        if (called_emsg) {</a>
<a name="ln3271">          set_string_option_direct(&quot;titlestring&quot;, -1, (char_u *)&quot;&quot;,</a>
<a name="ln3272">                                   OPT_FREE, SID_ERROR);</a>
<a name="ln3273">        }</a>
<a name="ln3274">        called_emsg |= save_called_emsg;</a>
<a name="ln3275">      } else {</a>
<a name="ln3276">        title_str = p_titlestring;</a>
<a name="ln3277">      }</a>
<a name="ln3278">    } else {</a>
<a name="ln3279">      // Format: &quot;fname + (path) (1 of 2) - VIM&quot;.</a>
<a name="ln3280"> </a>
<a name="ln3281">#define SPACE_FOR_FNAME (sizeof(buf) - 100)</a>
<a name="ln3282">#define SPACE_FOR_DIR   (sizeof(buf) - 20)</a>
<a name="ln3283">#define SPACE_FOR_ARGNR (sizeof(buf) - 10)  // At least room for &quot; - NVIM&quot;.</a>
<a name="ln3284">      char *buf_p = buf;</a>
<a name="ln3285">      if (curbuf-&gt;b_fname == NULL) {</a>
<a name="ln3286">        const size_t size = xstrlcpy(buf_p, _(&quot;[No Name]&quot;),</a>
<a name="ln3287">                                     SPACE_FOR_FNAME + 1);</a>
<a name="ln3288">        buf_p += MIN(size, SPACE_FOR_FNAME);</a>
<a name="ln3289">      } else {</a>
<a name="ln3290">        buf_p += transstr_buf((const char *)path_tail(curbuf-&gt;b_fname),</a>
<a name="ln3291">                              buf_p, SPACE_FOR_FNAME + 1);</a>
<a name="ln3292">      }</a>
<a name="ln3293"> </a>
<a name="ln3294">      switch (bufIsChanged(curbuf)</a>
<a name="ln3295">              | (curbuf-&gt;b_p_ro &lt;&lt; 1)</a>
<a name="ln3296">              | (!MODIFIABLE(curbuf) &lt;&lt; 2)) {</a>
<a name="ln3297">        case 0: break;</a>
<a name="ln3298">        case 1: buf_p = strappend(buf_p, &quot; +&quot;); break;</a>
<a name="ln3299">        case 2: buf_p = strappend(buf_p, &quot; =&quot;); break;</a>
<a name="ln3300">        case 3: buf_p = strappend(buf_p, &quot; =+&quot;); break;</a>
<a name="ln3301">        case 4:</a>
<a name="ln3302">        case 6: buf_p = strappend(buf_p, &quot; -&quot;); break;</a>
<a name="ln3303">        case 5:</a>
<a name="ln3304">        case 7: buf_p = strappend(buf_p, &quot; -+&quot;); break;</a>
<a name="ln3305">        default: abort();</a>
<a name="ln3306">      }</a>
<a name="ln3307"> </a>
<a name="ln3308">      if (curbuf-&gt;b_fname != NULL) {</a>
<a name="ln3309">        // Get path of file, replace home dir with ~.</a>
<a name="ln3310">        *buf_p++ = ' ';</a>
<a name="ln3311">        *buf_p++ = '(';</a>
<a name="ln3312">        home_replace(curbuf, curbuf-&gt;b_ffname, (char_u *)buf_p,</a>
<a name="ln3313">                     (SPACE_FOR_DIR - (size_t)(buf_p - buf)), true);</a>
<a name="ln3314">#ifdef BACKSLASH_IN_FILENAME</a>
<a name="ln3315">        // Avoid &quot;c:/name&quot; to be reduced to &quot;c&quot;.</a>
<a name="ln3316">        if (isalpha((uint8_t)buf_p) &amp;&amp; *(buf_p + 1) == ':') {</a>
<a name="ln3317">          buf_p += 2;</a>
<a name="ln3318">        }</a>
<a name="ln3319">#endif</a>
<a name="ln3320">        // Remove the file name.</a>
<a name="ln3321">        char *p = (char *)path_tail_with_sep((char_u *)buf_p);</a>
<a name="ln3322">        if (p == buf_p) {</a>
<a name="ln3323">          // Must be a help buffer.</a>
<a name="ln3324">          xstrlcpy(buf_p, _(&quot;help&quot;), SPACE_FOR_DIR - (size_t)(buf_p - buf));</a>
<a name="ln3325">        } else {</a>
<a name="ln3326">          *p = NUL;</a>
<a name="ln3327">        }</a>
<a name="ln3328"> </a>
<a name="ln3329">        // Translate unprintable chars and concatenate.  Keep some</a>
<a name="ln3330">        // room for the server name.  When there is no room (very long</a>
<a name="ln3331">        // file name) use (...).</a>
<a name="ln3332">        if ((size_t)(buf_p - buf) &lt; SPACE_FOR_DIR) {</a>
<a name="ln3333">          char *const tbuf = transstr(buf_p);</a>
<a name="ln3334">          const size_t free_space = SPACE_FOR_DIR - (size_t)(buf_p - buf) + 1;</a>
<a name="ln3335">          const size_t dir_len = xstrlcpy(buf_p, tbuf, free_space);</a>
<a name="ln3336">          buf_p += MIN(dir_len, free_space - 1);</a>
<a name="ln3337">          xfree(tbuf);</a>
<a name="ln3338">        } else {</a>
<a name="ln3339">          const size_t free_space = SPACE_FOR_ARGNR - (size_t)(buf_p - buf) + 1;</a>
<a name="ln3340">          const size_t dots_len = xstrlcpy(buf_p, &quot;...&quot;, free_space);</a>
<a name="ln3341">          buf_p += MIN(dots_len, free_space - 1);</a>
<a name="ln3342">        }</a>
<a name="ln3343">        *buf_p++ = ')';</a>
<a name="ln3344">        *buf_p = NUL;</a>
<a name="ln3345">      } else {</a>
<a name="ln3346">        *buf_p = NUL;</a>
<a name="ln3347">      }</a>
<a name="ln3348"> </a>
<a name="ln3349">      append_arg_number(curwin, (char_u *)buf_p,</a>
<a name="ln3350">                        (int)(SPACE_FOR_ARGNR - (size_t)(buf_p - buf)), false);</a>
<a name="ln3351"> </a>
<a name="ln3352">      xstrlcat(buf_p, &quot; - NVIM&quot;, (sizeof(buf) - (size_t)(buf_p - buf)));</a>
<a name="ln3353"> </a>
<a name="ln3354">      if (maxlen &gt; 0) {</a>
<a name="ln3355">        // Make it shorter by removing a bit in the middle.</a>
<a name="ln3356">        if (vim_strsize((char_u *)buf) &gt; maxlen) {</a>
<a name="ln3357">          trunc_string((char_u *)buf, (char_u *)buf, maxlen, sizeof(buf));</a>
<a name="ln3358">        }</a>
<a name="ln3359">      }</a>
<a name="ln3360">      title_str = (char_u *)buf;</a>
<a name="ln3361">#undef SPACE_FOR_FNAME</a>
<a name="ln3362">#undef SPACE_FOR_DIR</a>
<a name="ln3363">#undef SPACE_FOR_ARGNR</a>
<a name="ln3364">    }</a>
<a name="ln3365">  }</a>
<a name="ln3366">  mustset = value_change(title_str, &amp;lasttitle);</a>
<a name="ln3367"> </a>
<a name="ln3368">  if (p_icon) {</a>
<a name="ln3369">    icon_str = (char_u *)buf;</a>
<a name="ln3370">    if (*p_iconstring != NUL) {</a>
<a name="ln3371">      if (stl_syntax &amp; STL_IN_ICON) {</a>
<a name="ln3372">        int use_sandbox = false;</a>
<a name="ln3373">        int save_called_emsg = called_emsg;</a>
<a name="ln3374"> </a>
<a name="ln3375">        use_sandbox = was_set_insecurely(curwin, (char_u *)&quot;iconstring&quot;, 0);</a>
<a name="ln3376">        called_emsg = false;</a>
<a name="ln3377">        build_stl_str_hl(curwin, icon_str, sizeof(buf),</a>
<a name="ln3378">                         p_iconstring, use_sandbox,</a>
<a name="ln3379">                         0, 0, NULL, NULL);</a>
<a name="ln3380">        if (called_emsg) {</a>
<a name="ln3381">          set_string_option_direct(&quot;iconstring&quot;, -1,</a>
<a name="ln3382">                                   (char_u *)&quot;&quot;, OPT_FREE, SID_ERROR);</a>
<a name="ln3383">        }</a>
<a name="ln3384">        called_emsg |= save_called_emsg;</a>
<a name="ln3385">      } else {</a>
<a name="ln3386">        icon_str = p_iconstring;</a>
<a name="ln3387">      }</a>
<a name="ln3388">    } else {</a>
<a name="ln3389">      char_u *buf_p;</a>
<a name="ln3390">      if (buf_spname(curbuf) != NULL) {</a>
<a name="ln3391">        buf_p = buf_spname(curbuf);</a>
<a name="ln3392">      } else {                        // use file name only in icon</a>
<a name="ln3393">        buf_p = path_tail(curbuf-&gt;b_ffname);</a>
<a name="ln3394">      }</a>
<a name="ln3395">      *icon_str = NUL;</a>
<a name="ln3396">      // Truncate name at 100 bytes.</a>
<a name="ln3397">      len = (int)STRLEN(buf_p);</a>
<a name="ln3398">      if (len &gt; 100) {</a>
<a name="ln3399">        len -= 100;</a>
<a name="ln3400">        len += (*mb_tail_off)(buf_p, buf_p + len) + 1;</a>
<a name="ln3401">        buf_p += len;</a>
<a name="ln3402">      }</a>
<a name="ln3403">      STRCPY(icon_str, buf_p);</a>
<a name="ln3404">      trans_characters(icon_str, IOSIZE);</a>
<a name="ln3405">    }</a>
<a name="ln3406">  }</a>
<a name="ln3407"> </a>
<a name="ln3408">  mustset |= value_change(icon_str, &amp;lasticon);</a>
<a name="ln3409"> </a>
<a name="ln3410">  if (mustset) {</a>
<a name="ln3411">    resettitle();</a>
<a name="ln3412">  }</a>
<a name="ln3413">}</a>
<a name="ln3414"> </a>
<a name="ln3415">/// Used for title and icon: Check if &quot;str&quot; differs from &quot;*last&quot;.  Set &quot;*last&quot;</a>
<a name="ln3416">/// from &quot;str&quot; if it does by freeing the old value of &quot;*last&quot; and duplicating</a>
<a name="ln3417">/// &quot;str&quot;.</a>
<a name="ln3418">///</a>
<a name="ln3419">/// @param          str   desired title string</a>
<a name="ln3420">/// @param[in,out]  last  current title string</a>
<a name="ln3421">//</a>
<a name="ln3422">/// @return true if resettitle() is to be called.</a>
<a name="ln3423">static bool value_change(char_u *str, char_u **last)</a>
<a name="ln3424">  FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln3425">{</a>
<a name="ln3426">  if ((str == NULL) != (*last == NULL)</a>
<a name="ln3427">      || (str != NULL &amp;&amp; *last != NULL &amp;&amp; STRCMP(str, *last) != 0)) {</a>
<a name="ln3428">    xfree(*last);</a>
<a name="ln3429">    if (str == NULL) {</a>
<a name="ln3430">      *last = NULL;</a>
<a name="ln3431">      resettitle();</a>
<a name="ln3432">    } else {</a>
<a name="ln3433">      *last = vim_strsave(str);</a>
<a name="ln3434">      return true;</a>
<a name="ln3435">    }</a>
<a name="ln3436">  }</a>
<a name="ln3437">  return false;</a>
<a name="ln3438">}</a>
<a name="ln3439"> </a>
<a name="ln3440"> </a>
<a name="ln3441">/// Set current window title</a>
<a name="ln3442">void resettitle(void)</a>
<a name="ln3443">{</a>
<a name="ln3444">  ui_call_set_icon(cstr_as_string((char *)lasticon));</a>
<a name="ln3445">  ui_call_set_title(cstr_as_string((char *)lasttitle));</a>
<a name="ln3446">  ui_flush();</a>
<a name="ln3447">}</a>
<a name="ln3448"> </a>
<a name="ln3449"># if defined(EXITFREE)</a>
<a name="ln3450">void free_titles(void)</a>
<a name="ln3451">{</a>
<a name="ln3452">  xfree(lasttitle);</a>
<a name="ln3453">  xfree(lasticon);</a>
<a name="ln3454">}</a>
<a name="ln3455"> </a>
<a name="ln3456"># endif</a>
<a name="ln3457"> </a>
<a name="ln3458">/// Enumeration specifying the valid numeric bases that can</a>
<a name="ln3459">/// be used when printing numbers in the status line.</a>
<a name="ln3460">typedef enum {</a>
<a name="ln3461">  kNumBaseDecimal = 10,</a>
<a name="ln3462">  kNumBaseHexadecimal = 16</a>
<a name="ln3463">} NumberBase;</a>
<a name="ln3464"> </a>
<a name="ln3465"> </a>
<a name="ln3466">/// Build a string from the status line items in &quot;fmt&quot;.</a>
<a name="ln3467">/// Return length of string in screen cells.</a>
<a name="ln3468">///</a>
<a name="ln3469">/// Normally works for window &quot;wp&quot;, except when working for 'tabline' then it</a>
<a name="ln3470">/// is &quot;curwin&quot;.</a>
<a name="ln3471">///</a>
<a name="ln3472">/// Items are drawn interspersed with the text that surrounds it</a>
<a name="ln3473">/// Specials: %-&lt;wid&gt;(xxx%) =&gt; group, %= =&gt; separation marker, %&lt; =&gt; truncation</a>
<a name="ln3474">/// Item: %-&lt;minwid&gt;.&lt;maxwid&gt;&lt;itemch&gt; All but &lt;itemch&gt; are optional</a>
<a name="ln3475">///</a>
<a name="ln3476">/// If maxwidth is not zero, the string will be filled at any middle marker</a>
<a name="ln3477">/// or truncated if too long, fillchar is used for all whitespace.</a>
<a name="ln3478">///</a>
<a name="ln3479">/// @param wp The window to build a statusline for</a>
<a name="ln3480">/// @param out The output buffer to write the statusline to</a>
<a name="ln3481">///            Note: This should not be NameBuff</a>
<a name="ln3482">/// @param outlen The length of the output buffer</a>
<a name="ln3483">/// @param fmt The statusline format string</a>
<a name="ln3484">/// @param use_sandbox Use a sandboxed environment when evaluating fmt</a>
<a name="ln3485">/// @param fillchar Character to use when filling empty space in the statusline</a>
<a name="ln3486">/// @param maxwidth The maximum width to make the statusline</a>
<a name="ln3487">/// @param hltab HL attributes (can be NULL)</a>
<a name="ln3488">/// @param tabtab Tab clicks definition (can be NULL).</a>
<a name="ln3489">///</a>
<a name="ln3490">/// @return The final width of the statusline</a>
<a name="ln3491">int build_stl_str_hl(</a>
<a name="ln3492">    win_T *wp,</a>
<a name="ln3493">    char_u *out,</a>
<a name="ln3494">    size_t outlen,</a>
<a name="ln3495">    char_u *fmt,</a>
<a name="ln3496">    int use_sandbox,</a>
<a name="ln3497">    char_u fillchar,</a>
<a name="ln3498">    int maxwidth,</a>
<a name="ln3499">    stl_hlrec_t **hltab,</a>
<a name="ln3500">    StlClickRecord **tabtab</a>
<a name="ln3501">)</a>
<a name="ln3502">{</a>
<a name="ln3503">  static size_t stl_items_len = 20;  // Initial value, grows as needed.</a>
<a name="ln3504">  static stl_item_t *stl_items = NULL;</a>
<a name="ln3505">  static int *stl_groupitems = NULL;</a>
<a name="ln3506">  static stl_hlrec_t *stl_hltab = NULL;</a>
<a name="ln3507">  static StlClickRecord *stl_tabtab = NULL;</a>
<a name="ln3508">  static int *stl_separator_locations = NULL;</a>
<a name="ln3509"> </a>
<a name="ln3510">#define TMPLEN 70</a>
<a name="ln3511">  char_u buf_tmp[TMPLEN];</a>
<a name="ln3512">  char_u win_tmp[TMPLEN];</a>
<a name="ln3513">  char_u      *usefmt = fmt;</a>
<a name="ln3514">  const int save_must_redraw = must_redraw;</a>
<a name="ln3515">  const int save_redr_type = curwin-&gt;w_redr_type;</a>
<a name="ln3516"> </a>
<a name="ln3517">  if (stl_items == NULL) {</a>
<a name="ln3518">    stl_items = xmalloc(sizeof(stl_item_t) * stl_items_len);</a>
<a name="ln3519">    stl_groupitems = xmalloc(sizeof(int) * stl_items_len);</a>
<a name="ln3520">    stl_hltab  = xmalloc(sizeof(stl_hlrec_t) * stl_items_len);</a>
<a name="ln3521">    stl_tabtab = xmalloc(sizeof(StlClickRecord) * stl_items_len);</a>
<a name="ln3522">    stl_separator_locations = xmalloc(sizeof(int) * stl_items_len);</a>
<a name="ln3523">  }</a>
<a name="ln3524"> </a>
<a name="ln3525">  // When the format starts with &quot;%!&quot; then evaluate it as an expression and</a>
<a name="ln3526">  // use the result as the actual format string.</a>
<a name="ln3527">  if (fmt[0] == '%' &amp;&amp; fmt[1] == '!') {</a>
<a name="ln3528">    typval_T tv = {</a>
<a name="ln3529">      .v_type = VAR_NUMBER,</a>
<a name="ln3530">      .vval.v_number = wp-&gt;handle,</a>
<a name="ln3531">    };</a>
<a name="ln3532">    set_var(S_LEN(&quot;g:statusline_winid&quot;), &amp;tv, false);</a>
<a name="ln3533"> </a>
<a name="ln3534">    usefmt = eval_to_string_safe(fmt + 2, NULL, use_sandbox);</a>
<a name="ln3535">    if (usefmt == NULL) {</a>
<a name="ln3536">      usefmt = fmt;</a>
<a name="ln3537">    }</a>
<a name="ln3538"> </a>
<a name="ln3539">    do_unlet(S_LEN(&quot;g:statusline_winid&quot;), true);</a>
<a name="ln3540">  }</a>
<a name="ln3541"> </a>
<a name="ln3542">  if (fillchar == 0) {</a>
<a name="ln3543">    fillchar = ' ';</a>
<a name="ln3544">  } else if (mb_char2len(fillchar) &gt; 1) {</a>
<a name="ln3545">    // Can't handle a multi-byte fill character yet.</a>
<a name="ln3546">    fillchar = '-';</a>
<a name="ln3547">  }</a>
<a name="ln3548"> </a>
<a name="ln3549">  // The cursor in windows other than the current one isn't always</a>
<a name="ln3550">  // up-to-date, esp. because of autocommands and timers.</a>
<a name="ln3551">  linenr_T lnum = wp-&gt;w_cursor.lnum;</a>
<a name="ln3552">  if (lnum &gt; wp-&gt;w_buffer-&gt;b_ml.ml_line_count) {</a>
<a name="ln3553">    lnum = wp-&gt;w_buffer-&gt;b_ml.ml_line_count;</a>
<a name="ln3554">    wp-&gt;w_cursor.lnum = lnum;</a>
<a name="ln3555">  }</a>
<a name="ln3556"> </a>
<a name="ln3557">  // Get line &amp; check if empty (cursorpos will show &quot;0-1&quot;).</a>
<a name="ln3558">  const char_u *line_ptr = ml_get_buf(wp-&gt;w_buffer, lnum, false);</a>
<a name="ln3559">  bool empty_line = (*line_ptr == NUL);</a>
<a name="ln3560"> </a>
<a name="ln3561">  // Get the byte value now, in case we need it below. This is more</a>
<a name="ln3562">  // efficient than making a copy of the line.</a>
<a name="ln3563">  int byteval;</a>
<a name="ln3564">  const size_t len = STRLEN(line_ptr);</a>
<a name="ln3565">  if (wp-&gt;w_cursor.col &gt; (colnr_T)len) {</a>
<a name="ln3566">    // Line may have changed since checking the cursor column, or the lnum</a>
<a name="ln3567">    // was adjusted above.</a>
<a name="ln3568">    wp-&gt;w_cursor.col = (colnr_T)len;</a>
<a name="ln3569">    wp-&gt;w_cursor.coladd = 0;</a>
<a name="ln3570">    byteval = 0;</a>
<a name="ln3571">  } else {</a>
<a name="ln3572">    byteval = utf_ptr2char(line_ptr + wp-&gt;w_cursor.col);</a>
<a name="ln3573">  }</a>
<a name="ln3574"> </a>
<a name="ln3575">  int groupdepth = 0;</a>
<a name="ln3576">  int evaldepth  = 0;</a>
<a name="ln3577"> </a>
<a name="ln3578">  int curitem = 0;</a>
<a name="ln3579">  bool prevchar_isflag = true;</a>
<a name="ln3580">  bool prevchar_isitem = false;</a>
<a name="ln3581"> </a>
<a name="ln3582">  // out_p is the current position in the output buffer</a>
<a name="ln3583">  char_u *out_p = out;</a>
<a name="ln3584"> </a>
<a name="ln3585">  // out_end_p is the last valid character in the output buffer</a>
<a name="ln3586">  // Note: The null termination character must occur here or earlier,</a>
<a name="ln3587">  //       so any user-visible characters must occur before here.</a>
<a name="ln3588">  char_u *out_end_p = (out + outlen) - 1;</a>
<a name="ln3589"> </a>
<a name="ln3590"> </a>
<a name="ln3591">  // Proceed character by character through the statusline format string</a>
<a name="ln3592">  // fmt_p is the current position in the input buffer</a>
<a name="ln3593">  for (char_u *fmt_p = usefmt; *fmt_p; ) {</a>
<a name="ln3594">    if (curitem == (int)stl_items_len) {</a>
<a name="ln3595">        size_t new_len = stl_items_len * 3 / 2;</a>
<a name="ln3596"> </a>
<a name="ln3597">        stl_items = xrealloc(stl_items, sizeof(stl_item_t) * new_len);</a>
<a name="ln3598">        stl_groupitems = xrealloc(stl_groupitems, sizeof(int) * new_len);</a>
<a name="ln3599">        stl_hltab = xrealloc(stl_hltab, sizeof(stl_hlrec_t) * new_len);</a>
<a name="ln3600">        stl_tabtab = xrealloc(stl_tabtab, sizeof(StlClickRecord) * new_len);</a>
<a name="ln3601">        stl_separator_locations =</a>
<a name="ln3602">          xrealloc(stl_separator_locations, sizeof(int) * new_len);</a>
<a name="ln3603"> </a>
<a name="ln3604">        stl_items_len = new_len;</a>
<a name="ln3605">    }</a>
<a name="ln3606"> </a>
<a name="ln3607">    if (*fmt_p != NUL &amp;&amp; *fmt_p != '%') {</a>
<a name="ln3608">      prevchar_isflag = prevchar_isitem = false;</a>
<a name="ln3609">    }</a>
<a name="ln3610"> </a>
<a name="ln3611">    // Copy the formatting verbatim until we reach the end of the string</a>
<a name="ln3612">    // or find a formatting item (denoted by `%`)</a>
<a name="ln3613">    // or run out of room in our output buffer.</a>
<a name="ln3614">    while (*fmt_p != NUL &amp;&amp; *fmt_p != '%' &amp;&amp; out_p &lt; out_end_p)</a>
<a name="ln3615">      *out_p++ = *fmt_p++;</a>
<a name="ln3616"> </a>
<a name="ln3617">    // If we have processed the entire format string or run out of</a>
<a name="ln3618">    // room in our output buffer, exit the loop.</a>
<a name="ln3619">    if (*fmt_p == NUL || out_p &gt;= out_end_p) {</a>
<a name="ln3620">      break;</a>
<a name="ln3621">    }</a>
<a name="ln3622"> </a>
<a name="ln3623">    // The rest of this loop will handle a single `%` item.</a>
<a name="ln3624">    // Note: We increment here to skip over the `%` character we are currently</a>
<a name="ln3625">    //       on so we can process the item's contents.</a>
<a name="ln3626">    fmt_p++;</a>
<a name="ln3627"> </a>
<a name="ln3628">    // Ignore `%` at the end of the format string</a>
<a name="ln3629">    if (*fmt_p == NUL) {</a>
<a name="ln3630">      break;</a>
<a name="ln3631">    }</a>
<a name="ln3632"> </a>
<a name="ln3633">    // Two `%` in a row is the escape sequence to print a</a>
<a name="ln3634">    // single `%` in the output buffer.</a>
<a name="ln3635">    if (*fmt_p == '%') {</a>
<a name="ln3636">      *out_p++ = *fmt_p++;</a>
<a name="ln3637">      prevchar_isflag = prevchar_isitem = false;</a>
<a name="ln3638">      continue;</a>
<a name="ln3639">    }</a>
<a name="ln3640"> </a>
<a name="ln3641">    // STL_SEPARATE: Separation place between left and right aligned items.</a>
<a name="ln3642">    if (*fmt_p == STL_SEPARATE) {</a>
<a name="ln3643">      fmt_p++;</a>
<a name="ln3644">      // Ignored when we are inside of a grouping</a>
<a name="ln3645">      if (groupdepth &gt; 0) {</a>
<a name="ln3646">        continue;</a>
<a name="ln3647">      }</a>
<a name="ln3648">      stl_items[curitem].type = Separate;</a>
<a name="ln3649">      stl_items[curitem++].start = out_p;</a>
<a name="ln3650">      continue;</a>
<a name="ln3651">    }</a>
<a name="ln3652"> </a>
<a name="ln3653">    // STL_TRUNCMARK: Where to begin truncating if the statusline is too long.</a>
<a name="ln3654">    if (*fmt_p == STL_TRUNCMARK) {</a>
<a name="ln3655">      fmt_p++;</a>
<a name="ln3656">      stl_items[curitem].type = Trunc;</a>
<a name="ln3657">      stl_items[curitem++].start = out_p;</a>
<a name="ln3658">      continue;</a>
<a name="ln3659">    }</a>
<a name="ln3660"> </a>
<a name="ln3661">    // The end of a grouping</a>
<a name="ln3662">    if (*fmt_p == ')') {</a>
<a name="ln3663">      fmt_p++;</a>
<a name="ln3664">      // Ignore if we are not actually inside a group currently</a>
<a name="ln3665">      if (groupdepth &lt; 1) {</a>
<a name="ln3666">        continue;</a>
<a name="ln3667">      }</a>
<a name="ln3668">      groupdepth--;</a>
<a name="ln3669"> </a>
<a name="ln3670">      // Determine how long the group is.</a>
<a name="ln3671">      // Note: We set the current output position to null</a>
<a name="ln3672">      //       so `vim_strsize` will work.</a>
<a name="ln3673">      char_u *t = stl_items[stl_groupitems[groupdepth]].start;</a>
<a name="ln3674">      *out_p = NUL;</a>
<a name="ln3675">      long group_len = vim_strsize(t);</a>
<a name="ln3676"> </a>
<a name="ln3677">      // If the group contained internal items</a>
<a name="ln3678">      // and the group did not have a minimum width,</a>
<a name="ln3679">      // and if there were no normal items in the group,</a>
<a name="ln3680">      // move the output pointer back to where the group started.</a>
<a name="ln3681">      // Note: This erases any non-item characters that were in the group.</a>
<a name="ln3682">      //       Otherwise there would be no reason to do this step.</a>
<a name="ln3683">      if (curitem &gt; stl_groupitems[groupdepth] + 1</a>
<a name="ln3684">          &amp;&amp; stl_items[stl_groupitems[groupdepth]].minwid == 0) {</a>
<a name="ln3685">        // remove group if all items are empty and highlight group</a>
<a name="ln3686">        // doesn't change</a>
<a name="ln3687">        int group_start_userhl = 0;</a>
<a name="ln3688">        int group_end_userhl = 0;</a>
<a name="ln3689">        int n;</a>
<a name="ln3690">        for (n = stl_groupitems[groupdepth] - 1; n &gt;= 0; n--) {</a>
<a name="ln3691">          if (stl_items[n].type == Highlight) {</a>
<a name="ln3692">            group_start_userhl = group_end_userhl = stl_items[n].minwid;</a>
<a name="ln3693">            break;</a>
<a name="ln3694">          }</a>
<a name="ln3695">        }</a>
<a name="ln3696">        for (n = stl_groupitems[groupdepth] + 1; n &lt; curitem; n++) {</a>
<a name="ln3697">          if (stl_items[n].type == Normal) {</a>
<a name="ln3698">            break;</a>
<a name="ln3699">          }</a>
<a name="ln3700">          if (stl_items[n].type == Highlight) {</a>
<a name="ln3701">            group_end_userhl = stl_items[n].minwid;</a>
<a name="ln3702">          }</a>
<a name="ln3703">        }</a>
<a name="ln3704">        if (n == curitem &amp;&amp; group_start_userhl == group_end_userhl) {</a>
<a name="ln3705">          // empty group</a>
<a name="ln3706">          out_p = t;</a>
<a name="ln3707">          group_len = 0;</a>
<a name="ln3708">          for (n = stl_groupitems[groupdepth] + 1; n &lt; curitem; n++) {</a>
<a name="ln3709">            // do not use the highlighting from the removed group</a>
<a name="ln3710">            if (stl_items[n].type == Highlight) {</a>
<a name="ln3711">              stl_items[n].type = Empty;</a>
<a name="ln3712">            }</a>
<a name="ln3713">            // adjust the start position of TabPage to the next</a>
<a name="ln3714">            // item position</a>
<a name="ln3715">            if (stl_items[n].type == TabPage) {</a>
<a name="ln3716">              stl_items[n].start = out_p;</a>
<a name="ln3717">            }</a>
<a name="ln3718">          }</a>
<a name="ln3719">        }</a>
<a name="ln3720">      }</a>
<a name="ln3721"> </a>
<a name="ln3722">      // If the group is longer than it is allowed to be</a>
<a name="ln3723">      // truncate by removing bytes from the start of the group text.</a>
<a name="ln3724">      if (group_len &gt; stl_items[stl_groupitems[groupdepth]].maxwid) {</a>
<a name="ln3725">        // { Determine the number of bytes to remove</a>
<a name="ln3726"> </a>
<a name="ln3727">        // Find the first character that should be included.</a>
<a name="ln3728">        long n = 0;</a>
<a name="ln3729">        while (group_len &gt;= stl_items[stl_groupitems[groupdepth]].maxwid) {</a>
<a name="ln3730">          group_len -= ptr2cells(t + n);</a>
<a name="ln3731">          n += (*mb_ptr2len)(t + n);</a>
<a name="ln3732">        }</a>
<a name="ln3733">        // }</a>
<a name="ln3734"> </a>
<a name="ln3735">        // Prepend the `&lt;` to indicate that the output was truncated.</a>
<a name="ln3736">        *t = '&lt;';</a>
<a name="ln3737"> </a>
<a name="ln3738">        // { Move the truncated output</a>
<a name="ln3739">        memmove(t + 1, t + n, (size_t)(out_p - (t + n)));</a>
<a name="ln3740">        out_p = out_p - n + 1;</a>
<a name="ln3741">        // Fill up space left over by half a double-wide char.</a>
<a name="ln3742">        while (++group_len &lt; stl_items[stl_groupitems[groupdepth]].minwid) {</a>
<a name="ln3743">          *out_p++ = fillchar;</a>
<a name="ln3744">        }</a>
<a name="ln3745">        // }</a>
<a name="ln3746"> </a>
<a name="ln3747">        // correct the start of the items for the truncation</a>
<a name="ln3748">        for (int idx = stl_groupitems[groupdepth] + 1; idx &lt; curitem; idx++) {</a>
<a name="ln3749">          // Shift everything back by the number of removed bytes</a>
<a name="ln3750">          stl_items[idx].start -= n;</a>
<a name="ln3751"> </a>
<a name="ln3752">          // If the item was partially or completely truncated, set its</a>
<a name="ln3753">          // start to the start of the group</a>
<a name="ln3754">          if (stl_items[idx].start &lt; t) {</a>
<a name="ln3755">            stl_items[idx].start = t;</a>
<a name="ln3756">          }</a>
<a name="ln3757">        }</a>
<a name="ln3758">      // If the group is shorter than the minimum width, add padding characters.</a>
<a name="ln3759">      } else if (</a>
<a name="ln3760">          abs(stl_items[stl_groupitems[groupdepth]].minwid) &gt; group_len) {</a>
<a name="ln3761">        long min_group_width = stl_items[stl_groupitems[groupdepth]].minwid;</a>
<a name="ln3762">        // If the group is left-aligned, add characters to the right.</a>
<a name="ln3763">        if (min_group_width &lt; 0) {</a>
<a name="ln3764">          min_group_width = 0 - min_group_width;</a>
<a name="ln3765">          while (group_len++ &lt; min_group_width &amp;&amp; out_p &lt; out_end_p)</a>
<a name="ln3766">            *out_p++ = fillchar;</a>
<a name="ln3767">        // If the group is right-aligned, shift everything to the right and</a>
<a name="ln3768">        // prepend with filler characters.</a>
<a name="ln3769">        } else {</a>
<a name="ln3770">          // { Move the group to the right</a>
<a name="ln3771">          memmove(t + min_group_width - group_len, t, (size_t)(out_p - t));</a>
<a name="ln3772">          group_len = min_group_width - group_len;</a>
<a name="ln3773">          if (out_p + group_len &gt;= (out_end_p + 1)) {</a>
<a name="ln3774">            group_len = (long)(out_end_p - out_p);</a>
<a name="ln3775">          }</a>
<a name="ln3776">          out_p += group_len;</a>
<a name="ln3777">          // }</a>
<a name="ln3778"> </a>
<a name="ln3779">          // Adjust item start positions</a>
<a name="ln3780">          for (int n = stl_groupitems[groupdepth] + 1; n &lt; curitem; n++) {</a>
<a name="ln3781">            stl_items[n].start += group_len;</a>
<a name="ln3782">          }</a>
<a name="ln3783"> </a>
<a name="ln3784">          // Prepend the fill characters</a>
<a name="ln3785">          for (; group_len &gt; 0; group_len--) {</a>
<a name="ln3786">            *t++ = fillchar;</a>
<a name="ln3787">          }</a>
<a name="ln3788">        }</a>
<a name="ln3789">      }</a>
<a name="ln3790">      continue;</a>
<a name="ln3791">    }</a>
<a name="ln3792">    int minwid = 0;</a>
<a name="ln3793">    int maxwid = 9999;</a>
<a name="ln3794">    bool left_align = false;</a>
<a name="ln3795"> </a>
<a name="ln3796">    // Denotes that numbers should be left-padded with zeros</a>
<a name="ln3797">    bool zeropad = (*fmt_p == '0');</a>
<a name="ln3798">    if (zeropad) {</a>
<a name="ln3799">      fmt_p++;</a>
<a name="ln3800">    }</a>
<a name="ln3801"> </a>
<a name="ln3802">    // Denotes that the item should be left-aligned.</a>
<a name="ln3803">    // This is tracked by using a negative length.</a>
<a name="ln3804">    if (*fmt_p == '-') {</a>
<a name="ln3805">      fmt_p++;</a>
<a name="ln3806">      left_align = true;</a>
<a name="ln3807">    }</a>
<a name="ln3808"> </a>
<a name="ln3809">    // The first digit group is the item's min width</a>
<a name="ln3810">    if (ascii_isdigit(*fmt_p)) {</a>
<a name="ln3811">      minwid = getdigits_int(&amp;fmt_p, false, 0);</a>
<a name="ln3812">    }</a>
<a name="ln3813"> </a>
<a name="ln3814">    // User highlight groups override the min width field</a>
<a name="ln3815">    // to denote the styling to use.</a>
<a name="ln3816">    if (*fmt_p == STL_USER_HL) {</a>
<a name="ln3817">      stl_items[curitem].type = Highlight;</a>
<a name="ln3818">      stl_items[curitem].start = out_p;</a>
<a name="ln3819">      stl_items[curitem].minwid = minwid &gt; 9 ? 1 : minwid;</a>
<a name="ln3820">      fmt_p++;</a>
<a name="ln3821">      curitem++;</a>
<a name="ln3822">      continue;</a>
<a name="ln3823">    }</a>
<a name="ln3824"> </a>
<a name="ln3825">    // TABPAGE pairs are used to denote a region that when clicked will</a>
<a name="ln3826">    // either switch to or close a tab.</a>
<a name="ln3827">    //</a>
<a name="ln3828">    // Ex: tabline=%0Ttab\ zero%X</a>
<a name="ln3829">    //   This tabline has a TABPAGENR item with minwid `0`,</a>
<a name="ln3830">    //   which is then closed with a TABCLOSENR item.</a>
<a name="ln3831">    //   Clicking on this region with mouse enabled will switch to tab 0.</a>
<a name="ln3832">    //   Setting the minwid to a different value will switch</a>
<a name="ln3833">    //   to that tab, if it exists</a>
<a name="ln3834">    //</a>
<a name="ln3835">    // Ex: tabline=%1Xtab\ one%X</a>
<a name="ln3836">    //   This tabline has a TABCLOSENR item with minwid `1`,</a>
<a name="ln3837">    //   which is then closed with a TABCLOSENR item.</a>
<a name="ln3838">    //   Clicking on this region with mouse enabled will close tab 0.</a>
<a name="ln3839">    //   This is determined by the following formula:</a>
<a name="ln3840">    //      tab to close = (1 - minwid)</a>
<a name="ln3841">    //   This is because for TABPAGENR we use `minwid` = `tab number`.</a>
<a name="ln3842">    //   For TABCLOSENR we store the tab number as a negative value.</a>
<a name="ln3843">    //   Because 0 is a valid TABPAGENR value, we have to</a>
<a name="ln3844">    //   start our numbering at `-1`.</a>
<a name="ln3845">    //   So, `-1` corresponds to us wanting to close tab `0`</a>
<a name="ln3846">    //</a>
<a name="ln3847">    // Note: These options are only valid when creating a tabline.</a>
<a name="ln3848">    if (*fmt_p == STL_TABPAGENR || *fmt_p == STL_TABCLOSENR) {</a>
<a name="ln3849">      if (*fmt_p == STL_TABCLOSENR) {</a>
<a name="ln3850">        if (minwid == 0) {</a>
<a name="ln3851">          // %X ends the close label, go back to the previous tab label nr.</a>
<a name="ln3852">          for (long n = curitem - 1; n &gt;= 0; n--) {</a>
<a name="ln3853">            if (stl_items[n].type == TabPage &amp;&amp; stl_items[n].minwid &gt;= 0) {</a>
<a name="ln3854">              minwid = stl_items[n].minwid;</a>
<a name="ln3855">              break;</a>
<a name="ln3856">            }</a>
<a name="ln3857">          }</a>
<a name="ln3858">        } else {</a>
<a name="ln3859">          // close nrs are stored as negative values</a>
<a name="ln3860">          minwid = -minwid;</a>
<a name="ln3861">        }</a>
<a name="ln3862">      }</a>
<a name="ln3863">      stl_items[curitem].type = TabPage;</a>
<a name="ln3864">      stl_items[curitem].start = out_p;</a>
<a name="ln3865">      stl_items[curitem].minwid = minwid;</a>
<a name="ln3866">      fmt_p++;</a>
<a name="ln3867">      curitem++;</a>
<a name="ln3868">      continue;</a>
<a name="ln3869">    }</a>
<a name="ln3870"> </a>
<a name="ln3871">    if (*fmt_p == STL_CLICK_FUNC) {</a>
<a name="ln3872">      fmt_p++;</a>
<a name="ln3873">      char *t = (char *) fmt_p;</a>
<a name="ln3874">      while (*fmt_p != STL_CLICK_FUNC &amp;&amp; *fmt_p) {</a>
<a name="ln3875">        fmt_p++;</a>
<a name="ln3876">      }</a>
<a name="ln3877">      if (*fmt_p != STL_CLICK_FUNC) {</a>
<a name="ln3878">        break;</a>
<a name="ln3879">      }</a>
<a name="ln3880">      stl_items[curitem].type = ClickFunc;</a>
<a name="ln3881">      stl_items[curitem].start = out_p;</a>
<a name="ln3882">      stl_items[curitem].cmd = xmemdupz(t, (size_t)(((char *)fmt_p - t)));</a>
<a name="ln3883">      stl_items[curitem].minwid = minwid;</a>
<a name="ln3884">      fmt_p++;</a>
<a name="ln3885">      curitem++;</a>
<a name="ln3886">      continue;</a>
<a name="ln3887">    }</a>
<a name="ln3888"> </a>
<a name="ln3889">    // Denotes the end of the minwid</a>
<a name="ln3890">    // the maxwid may follow immediately after</a>
<a name="ln3891">    if (*fmt_p == '.') {</a>
<a name="ln3892">      fmt_p++;</a>
<a name="ln3893">      if (ascii_isdigit(*fmt_p)) {</a>
<a name="ln3894">        maxwid = getdigits_int(&amp;fmt_p, false, 50);</a>
<a name="ln3895">      }</a>
<a name="ln3896">    }</a>
<a name="ln3897"> </a>
<a name="ln3898">    // Bound the minimum width at 50.</a>
<a name="ln3899">    // Make the number negative to denote left alignment of the item</a>
<a name="ln3900">    minwid = (minwid &gt; 50 ? 50 : minwid) * (left_align ? -1 : 1);</a>
<a name="ln3901"> </a>
<a name="ln3902">    // Denotes the start of a new group</a>
<a name="ln3903">    if (*fmt_p == '(') {</a>
<a name="ln3904">      stl_groupitems[groupdepth++] = curitem;</a>
<a name="ln3905">      stl_items[curitem].type = Group;</a>
<a name="ln3906">      stl_items[curitem].start = out_p;</a>
<a name="ln3907">      stl_items[curitem].minwid = minwid;</a>
<a name="ln3908">      stl_items[curitem].maxwid = maxwid;</a>
<a name="ln3909">      fmt_p++;</a>
<a name="ln3910">      curitem++;</a>
<a name="ln3911">      continue;</a>
<a name="ln3912">    }</a>
<a name="ln3913"> </a>
<a name="ln3914">    // Denotes end of expanded %{} block</a>
<a name="ln3915">    if (*fmt_p == '}' &amp;&amp; evaldepth &gt; 0) {</a>
<a name="ln3916">        fmt_p++;</a>
<a name="ln3917">        evaldepth--;</a>
<a name="ln3918">        continue;</a>
<a name="ln3919">    }</a>
<a name="ln3920"> </a>
<a name="ln3921">    // An invalid item was specified.</a>
<a name="ln3922">    // Continue processing on the next character of the format string.</a>
<a name="ln3923">    if (vim_strchr(STL_ALL, *fmt_p) == NULL) {</a>
<a name="ln3924">      fmt_p++;</a>
<a name="ln3925">      continue;</a>
<a name="ln3926">    }</a>
<a name="ln3927"> </a>
<a name="ln3928">    // The status line item type</a>
<a name="ln3929">    char_u opt = *fmt_p++;</a>
<a name="ln3930"> </a>
<a name="ln3931">    // OK - now for the real work</a>
<a name="ln3932">    NumberBase base = kNumBaseDecimal;</a>
<a name="ln3933">    bool itemisflag = false;</a>
<a name="ln3934">    bool fillable = true;</a>
<a name="ln3935">    long num = -1;</a>
<a name="ln3936">    char_u *str = NULL;</a>
<a name="ln3937">    switch (opt) {</a>
<a name="ln3938">    case STL_FILEPATH:</a>
<a name="ln3939">    case STL_FULLPATH:</a>
<a name="ln3940">    case STL_FILENAME:</a>
<a name="ln3941">    {</a>
<a name="ln3942">      // Set fillable to false so that ' ' in the filename will not</a>
<a name="ln3943">      // get replaced with the fillchar</a>
<a name="ln3944">      fillable = false;</a>
<a name="ln3945">      if (buf_spname(wp-&gt;w_buffer) != NULL) {</a>
<a name="ln3946">        STRLCPY(NameBuff, buf_spname(wp-&gt;w_buffer), MAXPATHL);</a>
<a name="ln3947">      } else {</a>
<a name="ln3948">        char_u *t = (opt == STL_FULLPATH) ? wp-&gt;w_buffer-&gt;b_ffname</a>
<a name="ln3949">                     : wp-&gt;w_buffer-&gt;b_fname;</a>
<a name="ln3950">        home_replace(wp-&gt;w_buffer, t, NameBuff, MAXPATHL, true);</a>
<a name="ln3951">      }</a>
<a name="ln3952">      trans_characters(NameBuff, MAXPATHL);</a>
<a name="ln3953">      if (opt != STL_FILENAME) {</a>
<a name="ln3954">        str = NameBuff;</a>
<a name="ln3955">      } else {</a>
<a name="ln3956">        str = path_tail(NameBuff);</a>
<a name="ln3957">      }</a>
<a name="ln3958">      break;</a>
<a name="ln3959">    }</a>
<a name="ln3960">    case STL_VIM_EXPR:     // '{'</a>
<a name="ln3961">    {</a>
<a name="ln3962">      char_u *block_start = fmt_p - 1;</a>
<a name="ln3963">      int reevaluate = (*fmt_p == '%');</a>
<a name="ln3964">      itemisflag = true;</a>
<a name="ln3965"> </a>
<a name="ln3966">      if (reevaluate) {</a>
<a name="ln3967">        fmt_p++;</a>
<a name="ln3968">      }</a>
<a name="ln3969"> </a>
<a name="ln3970">      // Attempt to copy the expression to evaluate into</a>
<a name="ln3971">      // the output buffer as a null-terminated string.</a>
<a name="ln3972">      char_u *t = out_p;</a>
<a name="ln3973">      while ((*fmt_p != '}' || (reevaluate &amp;&amp; fmt_p[-1] != '%'))</a>
<a name="ln3974">             &amp;&amp; *fmt_p != NUL &amp;&amp; out_p &lt; out_end_p) {</a>
<a name="ln3975">        *out_p++ = *fmt_p++;</a>
<a name="ln3976">      }</a>
<a name="ln3977">      if (*fmt_p != '}') {          // missing '}' or out of space</a>
<a name="ln3978">        break;</a>
<a name="ln3979">      }</a>
<a name="ln3980">      fmt_p++;</a>
<a name="ln3981">      if (reevaluate) {</a>
<a name="ln3982">        out_p[-1] = 0;  // remove the % at the end of %{% expr %}</a>
<a name="ln3983">      } else {</a>
<a name="ln3984">        *out_p = 0;</a>
<a name="ln3985">      }</a>
<a name="ln3986"> </a>
<a name="ln3987">      // Move our position in the output buffer</a>
<a name="ln3988">      // to the beginning of the expression</a>
<a name="ln3989">      out_p = t;</a>
<a name="ln3990"> </a>
<a name="ln3991">      // { Evaluate the expression</a>
<a name="ln3992"> </a>
<a name="ln3993">      // Store the current buffer number as a string variable</a>
<a name="ln3994">      vim_snprintf((char *)buf_tmp, sizeof(buf_tmp), &quot;%d&quot;, curbuf-&gt;b_fnum);</a>
<a name="ln3995">      set_internal_string_var(&quot;g:actual_curbuf&quot;, buf_tmp);</a>
<a name="ln3996">      vim_snprintf((char *)win_tmp, sizeof(win_tmp), &quot;%d&quot;, curwin-&gt;handle);</a>
<a name="ln3997">      set_internal_string_var(&quot;g:actual_curwin&quot;, win_tmp);</a>
<a name="ln3998"> </a>
<a name="ln3999">      buf_T *const save_curbuf = curbuf;</a>
<a name="ln4000">      win_T *const save_curwin = curwin;</a>
<a name="ln4001">      const int save_VIsual_active = VIsual_active;</a>
<a name="ln4002">      curwin = wp;</a>
<a name="ln4003">      curbuf = wp-&gt;w_buffer;</a>
<a name="ln4004">      // Visual mode is only valid in the current window.</a>
<a name="ln4005">      if (curwin != save_curwin) {</a>
<a name="ln4006">        VIsual_active = false;</a>
<a name="ln4007">      }</a>
<a name="ln4008"> </a>
<a name="ln4009">      // Note: The result stored in `t` is unused.</a>
<a name="ln4010">      str = eval_to_string_safe(out_p, &amp;t, use_sandbox);</a>
<a name="ln4011"> </a>
<a name="ln4012">      curwin = save_curwin;</a>
<a name="ln4013">      curbuf = save_curbuf;</a>
<a name="ln4014">      VIsual_active = save_VIsual_active;</a>
<a name="ln4015"> </a>
<a name="ln4016">      // Remove the variable we just stored</a>
<a name="ln4017">      do_unlet(S_LEN(&quot;g:actual_curbuf&quot;), true);</a>
<a name="ln4018">      do_unlet(S_LEN(&quot;g:actual_curwin&quot;), true);</a>
<a name="ln4019"> </a>
<a name="ln4020">      // }</a>
<a name="ln4021"> </a>
<a name="ln4022">      // Check if the evaluated result is a number.</a>
<a name="ln4023">      // If so, convert the number to an int and free the string.</a>
<a name="ln4024">      if (str != NULL &amp;&amp; *str != 0) {</a>
<a name="ln4025">        if (*skipdigits(str) == NUL) {</a>
<a name="ln4026">          num = atoi((char *)str);</a>
<a name="ln4027">          XFREE_CLEAR(str);</a>
<a name="ln4028">          itemisflag = false;</a>
<a name="ln4029">        }</a>
<a name="ln4030">      }</a>
<a name="ln4031"> </a>
<a name="ln4032"> </a>
<a name="ln4033">      // If the output of the expression needs to be evaluated</a>
<a name="ln4034">      // replace the %{} block with the result of evaluation</a>
<a name="ln4035">      if (reevaluate &amp;&amp; str != NULL &amp;&amp; *str != 0</a>
<a name="ln4036">          &amp;&amp; strchr((const char *)str, '%') != NULL</a>
<a name="ln4037">          &amp;&amp; evaldepth &lt; MAX_STL_EVAL_DEPTH) {</a>
<a name="ln4038">        size_t parsed_usefmt = (size_t)(block_start - usefmt);</a>
<a name="ln4039">        size_t str_length = strlen((const char *)str);</a>
<a name="ln4040">        size_t fmt_length = strlen((const char *)fmt_p);</a>
<a name="ln4041">        size_t new_fmt_len = parsed_usefmt</a>
<a name="ln4042">          + str_length + fmt_length + 3;</a>
<a name="ln4043">        char_u *new_fmt = (char_u *)xmalloc(new_fmt_len * sizeof(char_u));</a>
<a name="ln4044">        char_u *new_fmt_p = new_fmt;</a>
<a name="ln4045"> </a>
<a name="ln4046">        new_fmt_p = (char_u *)memcpy(new_fmt_p, usefmt, parsed_usefmt)</a>
<a name="ln4047">          + parsed_usefmt;</a>
<a name="ln4048">        new_fmt_p = (char_u *)memcpy(new_fmt_p , str, str_length)</a>
<a name="ln4049">          + str_length;</a>
<a name="ln4050">        new_fmt_p = (char_u *)memcpy(new_fmt_p, &quot;%}&quot;, 2) + 2;</a>
<a name="ln4051">        new_fmt_p = (char_u *)memcpy(new_fmt_p , fmt_p, fmt_length)</a>
<a name="ln4052">          + fmt_length;</a>
<a name="ln4053">        *new_fmt_p = 0;</a>
<a name="ln4054">        new_fmt_p = NULL;</a>
<a name="ln4055"> </a>
<a name="ln4056">        if (usefmt != fmt) {</a>
<a name="ln4057">          xfree(usefmt);</a>
<a name="ln4058">        }</a>
<a name="ln4059">        XFREE_CLEAR(str);</a>
<a name="ln4060">        usefmt = new_fmt;</a>
<a name="ln4061">        fmt_p = usefmt + parsed_usefmt;</a>
<a name="ln4062">        evaldepth++;</a>
<a name="ln4063">        continue;</a>
<a name="ln4064">      }</a>
<a name="ln4065">      break;</a>
<a name="ln4066">    }</a>
<a name="ln4067"> </a>
<a name="ln4068">    case STL_LINE:</a>
<a name="ln4069">      num = (wp-&gt;w_buffer-&gt;b_ml.ml_flags &amp; ML_EMPTY)</a>
<a name="ln4070">            ? 0L : (long)(wp-&gt;w_cursor.lnum);</a>
<a name="ln4071">      break;</a>
<a name="ln4072"> </a>
<a name="ln4073">    case STL_NUMLINES:</a>
<a name="ln4074">      num = wp-&gt;w_buffer-&gt;b_ml.ml_line_count;</a>
<a name="ln4075">      break;</a>
<a name="ln4076"> </a>
<a name="ln4077">    case STL_COLUMN:</a>
<a name="ln4078">      num = !(State &amp; INSERT) &amp;&amp; empty_line</a>
<a name="ln4079">            ? 0 : (int)wp-&gt;w_cursor.col + 1;</a>
<a name="ln4080">      break;</a>
<a name="ln4081"> </a>
<a name="ln4082">    case STL_VIRTCOL:</a>
<a name="ln4083">    case STL_VIRTCOL_ALT:</a>
<a name="ln4084">    {</a>
<a name="ln4085">      // In list mode virtcol needs to be recomputed</a>
<a name="ln4086">      colnr_T virtcol = wp-&gt;w_virtcol;</a>
<a name="ln4087">      if (wp-&gt;w_p_list &amp;&amp; wp-&gt;w_p_lcs_chars.tab1 == NUL) {</a>
<a name="ln4088">        wp-&gt;w_p_list = false;</a>
<a name="ln4089">        getvcol(wp, &amp;wp-&gt;w_cursor, NULL, &amp;virtcol, NULL);</a>
<a name="ln4090">        wp-&gt;w_p_list = true;</a>
<a name="ln4091">      }</a>
<a name="ln4092">      virtcol++;</a>
<a name="ln4093">      // Don't display %V if it's the same as %c.</a>
<a name="ln4094">      if (opt == STL_VIRTCOL_ALT</a>
<a name="ln4095">          &amp;&amp; (virtcol == (colnr_T)(!(State &amp; INSERT) &amp;&amp; empty_line</a>
<a name="ln4096">                                   ? 0 : (int)wp-&gt;w_cursor.col + 1)))</a>
<a name="ln4097">        break;</a>
<a name="ln4098">      num = (long)virtcol;</a>
<a name="ln4099">      break;</a>
<a name="ln4100">    }</a>
<a name="ln4101"> </a>
<a name="ln4102">    case STL_PERCENTAGE:</a>
<a name="ln4103">      num = (int)(((long)wp-&gt;w_cursor.lnum * 100L) /</a>
<a name="ln4104">                  (long)wp-&gt;w_buffer-&gt;b_ml.ml_line_count);</a>
<a name="ln4105">      break;</a>
<a name="ln4106"> </a>
<a name="ln4107">    case STL_ALTPERCENT:</a>
<a name="ln4108">      // Store the position percentage in our temporary buffer.</a>
<a name="ln4109">      // Note: We cannot store the value in `num` because</a>
<a name="ln4110">      //       `get_rel_pos` can return a named position. Ex: &quot;Top&quot;</a>
<a name="ln4111">      get_rel_pos(wp, buf_tmp, TMPLEN);</a>
<a name="ln4112">      str = buf_tmp;</a>
<a name="ln4113">      break;</a>
<a name="ln4114"> </a>
<a name="ln4115">    case STL_ARGLISTSTAT:</a>
<a name="ln4116">      fillable = false;</a>
<a name="ln4117"> </a>
<a name="ln4118">      // Note: This is important because `append_arg_number` starts appending</a>
<a name="ln4119">      //       at the end of the null-terminated string.</a>
<a name="ln4120">      //       Setting the first byte to null means it will place the argument</a>
<a name="ln4121">      //       number string at the beginning of the buffer.</a>
<a name="ln4122">      buf_tmp[0] = 0;</a>
<a name="ln4123"> </a>
<a name="ln4124">      // Note: The call will only return true if it actually</a>
<a name="ln4125">      //       appended data to the `buf_tmp` buffer.</a>
<a name="ln4126">      if (append_arg_number(wp, buf_tmp, (int)sizeof(buf_tmp), false)) {</a>
<a name="ln4127">        str = buf_tmp;</a>
<a name="ln4128">      }</a>
<a name="ln4129">      break;</a>
<a name="ln4130"> </a>
<a name="ln4131">    case STL_KEYMAP:</a>
<a name="ln4132">      fillable = false;</a>
<a name="ln4133">      if (get_keymap_str(wp, (char_u *)&quot;&lt;%s&gt;&quot;, buf_tmp, TMPLEN)) {</a>
<a name="ln4134">        str = buf_tmp;</a>
<a name="ln4135">      }</a>
<a name="ln4136">      break;</a>
<a name="ln4137">    case STL_PAGENUM:</a>
<a name="ln4138">      num = printer_page_num;</a>
<a name="ln4139">      break;</a>
<a name="ln4140"> </a>
<a name="ln4141">    case STL_BUFNO:</a>
<a name="ln4142">      num = wp-&gt;w_buffer-&gt;b_fnum;</a>
<a name="ln4143">      break;</a>
<a name="ln4144"> </a>
<a name="ln4145">    case STL_OFFSET_X:</a>
<a name="ln4146">      base = kNumBaseHexadecimal;</a>
<a name="ln4147">      FALLTHROUGH;</a>
<a name="ln4148">    case STL_OFFSET:</a>
<a name="ln4149">    {</a>
<a name="ln4150">      long l = ml_find_line_or_offset(wp-&gt;w_buffer, wp-&gt;w_cursor.lnum, NULL,</a>
<a name="ln4151">                                      false);</a>
<a name="ln4152">      num = (wp-&gt;w_buffer-&gt;b_ml.ml_flags &amp; ML_EMPTY) || l &lt; 0 ?</a>
<a name="ln4153">            0L : l + 1 + (!(State &amp; INSERT) &amp;&amp; empty_line ?</a>
<a name="ln4154">                          0 : (int)wp-&gt;w_cursor.col);</a>
<a name="ln4155">      break;</a>
<a name="ln4156">    }</a>
<a name="ln4157">    case STL_BYTEVAL_X:</a>
<a name="ln4158">      base = kNumBaseHexadecimal;</a>
<a name="ln4159">      FALLTHROUGH;</a>
<a name="ln4160">    case STL_BYTEVAL:</a>
<a name="ln4161">      num = byteval;</a>
<a name="ln4162">      if (num == NL) {</a>
<a name="ln4163">        num = 0;</a>
<a name="ln4164">      } else if (num == CAR &amp;&amp; get_fileformat(wp-&gt;w_buffer) == EOL_MAC) {</a>
<a name="ln4165">        num = NL;</a>
<a name="ln4166">      }</a>
<a name="ln4167">      break;</a>
<a name="ln4168"> </a>
<a name="ln4169">    case STL_ROFLAG:</a>
<a name="ln4170">    case STL_ROFLAG_ALT:</a>
<a name="ln4171">      itemisflag = true;</a>
<a name="ln4172">      if (wp-&gt;w_buffer-&gt;b_p_ro) {</a>
<a name="ln4173">        str = (char_u *)((opt == STL_ROFLAG_ALT) ? &quot;,RO&quot; : _(&quot;[RO]&quot;));</a>
<a name="ln4174">      }</a>
<a name="ln4175">      break;</a>
<a name="ln4176"> </a>
<a name="ln4177">    case STL_HELPFLAG:</a>
<a name="ln4178">    case STL_HELPFLAG_ALT:</a>
<a name="ln4179">      itemisflag = true;</a>
<a name="ln4180">      if (wp-&gt;w_buffer-&gt;b_help)</a>
<a name="ln4181">        str = (char_u *)((opt == STL_HELPFLAG_ALT) ? &quot;,HLP&quot;</a>
<a name="ln4182">                         : _(&quot;[Help]&quot;));</a>
<a name="ln4183">      break;</a>
<a name="ln4184"> </a>
<a name="ln4185">    case STL_FILETYPE:</a>
<a name="ln4186">      // Copy the filetype if it is not null and the formatted string will fit</a>
<a name="ln4187">      // in the temporary buffer</a>
<a name="ln4188">      // (including the brackets and null terminating character)</a>
<a name="ln4189">      if (*wp-&gt;w_buffer-&gt;b_p_ft != NUL</a>
<a name="ln4190">          &amp;&amp; STRLEN(wp-&gt;w_buffer-&gt;b_p_ft) &lt; TMPLEN - 3) {</a>
<a name="ln4191">        vim_snprintf((char *)buf_tmp, sizeof(buf_tmp), &quot;[%s]&quot;,</a>
<a name="ln4192">                     wp-&gt;w_buffer-&gt;b_p_ft);</a>
<a name="ln4193">        str = buf_tmp;</a>
<a name="ln4194">      }</a>
<a name="ln4195">      break;</a>
<a name="ln4196"> </a>
<a name="ln4197">    case STL_FILETYPE_ALT:</a>
<a name="ln4198">    {</a>
<a name="ln4199">      itemisflag = true;</a>
<a name="ln4200">      // Copy the filetype if it is not null and the formatted string will fit</a>
<a name="ln4201">      // in the temporary buffer</a>
<a name="ln4202">      // (including the comma and null terminating character)</a>
<a name="ln4203">      if (*wp-&gt;w_buffer-&gt;b_p_ft != NUL</a>
<a name="ln4204">          &amp;&amp; STRLEN(wp-&gt;w_buffer-&gt;b_p_ft) &lt; TMPLEN - 2) {</a>
<a name="ln4205">        vim_snprintf((char *)buf_tmp, sizeof(buf_tmp), &quot;,%s&quot;,</a>
<a name="ln4206">                     wp-&gt;w_buffer-&gt;b_p_ft);</a>
<a name="ln4207">        // Uppercase the file extension</a>
<a name="ln4208">        for (char_u *t = buf_tmp; *t != 0; t++) {</a>
<a name="ln4209">          *t = (char_u)TOUPPER_LOC(*t);</a>
<a name="ln4210">        }</a>
<a name="ln4211">        str = buf_tmp;</a>
<a name="ln4212">      }</a>
<a name="ln4213">      break;</a>
<a name="ln4214">    }</a>
<a name="ln4215">    case STL_PREVIEWFLAG:</a>
<a name="ln4216">    case STL_PREVIEWFLAG_ALT:</a>
<a name="ln4217">      itemisflag = true;</a>
<a name="ln4218">      if (wp-&gt;w_p_pvw)</a>
<a name="ln4219">        str = (char_u *)((opt == STL_PREVIEWFLAG_ALT) ? &quot;,PRV&quot;</a>
<a name="ln4220">                         : _(&quot;[Preview]&quot;));</a>
<a name="ln4221">      break;</a>
<a name="ln4222"> </a>
<a name="ln4223">    case STL_QUICKFIX:</a>
<a name="ln4224">      if (bt_quickfix(wp-&gt;w_buffer))</a>
<a name="ln4225">        str = (char_u *)(wp-&gt;w_llist_ref</a>
<a name="ln4226">                         ? _(msg_loclist)</a>
<a name="ln4227">                         : _(msg_qflist));</a>
<a name="ln4228">      break;</a>
<a name="ln4229"> </a>
<a name="ln4230">    case STL_MODIFIED:</a>
<a name="ln4231">    case STL_MODIFIED_ALT:</a>
<a name="ln4232">      itemisflag = true;</a>
<a name="ln4233">      switch ((opt == STL_MODIFIED_ALT)</a>
<a name="ln4234">              + bufIsChanged(wp-&gt;w_buffer) * 2</a>
<a name="ln4235">              + (!MODIFIABLE(wp-&gt;w_buffer)) * 4) {</a>
<a name="ln4236">      case 2: str = (char_u *)&quot;[+]&quot;; break;</a>
<a name="ln4237">      case 3: str = (char_u *)&quot;,+&quot;; break;</a>
<a name="ln4238">      case 4: str = (char_u *)&quot;[-]&quot;; break;</a>
<a name="ln4239">      case 5: str = (char_u *)&quot;,-&quot;; break;</a>
<a name="ln4240">      case 6: str = (char_u *)&quot;[+-]&quot;; break;</a>
<a name="ln4241">      case 7: str = (char_u *)&quot;,+-&quot;; break;</a>
<a name="ln4242">      }</a>
<a name="ln4243">      break;</a>
<a name="ln4244"> </a>
<a name="ln4245">    case STL_HIGHLIGHT:</a>
<a name="ln4246">    {</a>
<a name="ln4247">      // { The name of the highlight is surrounded by `#`</a>
<a name="ln4248">      char_u *t = fmt_p;</a>
<a name="ln4249">      while (*fmt_p != '#' &amp;&amp; *fmt_p != NUL) {</a>
<a name="ln4250">        fmt_p++;</a>
<a name="ln4251">      }</a>
<a name="ln4252">      // }</a>
<a name="ln4253"> </a>
<a name="ln4254">      // Create a highlight item based on the name</a>
<a name="ln4255">      if (*fmt_p == '#') {</a>
<a name="ln4256">        stl_items[curitem].type = Highlight;</a>
<a name="ln4257">        stl_items[curitem].start = out_p;</a>
<a name="ln4258">        stl_items[curitem].minwid = -syn_namen2id(t, (int)(fmt_p - t));</a>
<a name="ln4259">        curitem++;</a>
<a name="ln4260">        fmt_p++;</a>
<a name="ln4261">      }</a>
<a name="ln4262">      continue;</a>
<a name="ln4263">    }</a>
<a name="ln4264">    }</a>
<a name="ln4265"> </a>
<a name="ln4266">    // If we made it this far, the item is normal and starts at</a>
<a name="ln4267">    // our current position in the output buffer.</a>
<a name="ln4268">    // Non-normal items would have `continued`.</a>
<a name="ln4269">    stl_items[curitem].start = out_p;</a>
<a name="ln4270">    stl_items[curitem].type = Normal;</a>
<a name="ln4271"> </a>
<a name="ln4272">    // Copy the item string into the output buffer</a>
<a name="ln4273">    if (str != NULL &amp;&amp; *str) {</a>
<a name="ln4274">      // { Skip the leading `,` or ` ` if the item is a flag</a>
<a name="ln4275">      //  and the proper conditions are met</a>
<a name="ln4276">      char_u *t = str;</a>
<a name="ln4277">      if (itemisflag) {</a>
<a name="ln4278">        if ((t[0] &amp;&amp; t[1])</a>
<a name="ln4279">            &amp;&amp; ((!prevchar_isitem &amp;&amp; *t == ',')</a>
<a name="ln4280">                || (prevchar_isflag &amp;&amp; *t == ' ')))</a>
<a name="ln4281">          t++;</a>
<a name="ln4282">        prevchar_isflag = true;</a>
<a name="ln4283">      }</a>
<a name="ln4284">      // }</a>
<a name="ln4285"> </a>
<a name="ln4286">      long l = vim_strsize(t);</a>
<a name="ln4287"> </a>
<a name="ln4288">      // If this item is non-empty, record that the last thing</a>
<a name="ln4289">      // we put in the output buffer was an item</a>
<a name="ln4290">      if (l &gt; 0) {</a>
<a name="ln4291">        prevchar_isitem = true;</a>
<a name="ln4292">      }</a>
<a name="ln4293"> </a>
<a name="ln4294">      // If the item is too wide, truncate it from the beginning</a>
<a name="ln4295">      if (l &gt; maxwid) {</a>
<a name="ln4296">        while (l &gt;= maxwid) {</a>
<a name="ln4297">          l -= ptr2cells(t);</a>
<a name="ln4298">          t += utfc_ptr2len(t);</a>
<a name="ln4299">        }</a>
<a name="ln4300"> </a>
<a name="ln4301">        // Early out if there isn't enough room for the truncation marker</a>
<a name="ln4302">        if (out_p &gt;= out_end_p) {</a>
<a name="ln4303">          break;</a>
<a name="ln4304">        }</a>
<a name="ln4305"> </a>
<a name="ln4306">        // Add the truncation marker</a>
<a name="ln4307">        *out_p++ = '&lt;';</a>
<a name="ln4308">      }</a>
<a name="ln4309"> </a>
<a name="ln4310">      // If the item is right aligned and not wide enough,</a>
<a name="ln4311">      // pad with fill characters.</a>
<a name="ln4312">      if (minwid &gt; 0) {</a>
<a name="ln4313">        for (; l &lt; minwid &amp;&amp; out_p &lt; out_end_p; l++) {</a>
<a name="ln4314">          // Don't put a &quot;-&quot; in front of a digit.</a>
<a name="ln4315">          if (l + 1 == minwid &amp;&amp; fillchar == '-' &amp;&amp; ascii_isdigit(*t)) {</a>
<a name="ln4316">            *out_p++ = ' ';</a>
<a name="ln4317">          } else {</a>
<a name="ln4318">            *out_p++ = fillchar;</a>
<a name="ln4319">          }</a>
<a name="ln4320">        }</a>
<a name="ln4321">        minwid = 0;</a>
<a name="ln4322">      } else {</a>
<a name="ln4323">        // Note: The negative value denotes a left aligned item.</a>
<a name="ln4324">        //       Here we switch the minimum width back to a positive value.</a>
<a name="ln4325">        minwid *= -1;</a>
<a name="ln4326">      }</a>
<a name="ln4327"> </a>
<a name="ln4328">      // { Copy the string text into the output buffer</a>
<a name="ln4329">      while (*t &amp;&amp; out_p &lt; out_end_p) {</a>
<a name="ln4330">        *out_p++ = *t++;</a>
<a name="ln4331">        // Change a space by fillchar, unless fillchar is '-' and a</a>
<a name="ln4332">        // digit follows.</a>
<a name="ln4333">        if (fillable &amp;&amp; out_p[-1] == ' '</a>
<a name="ln4334">            &amp;&amp; (!ascii_isdigit(*t) || fillchar != '-'))</a>
<a name="ln4335">          out_p[-1] = fillchar;</a>
<a name="ln4336">      }</a>
<a name="ln4337">      // }</a>
<a name="ln4338"> </a>
<a name="ln4339">      // For left-aligned items, fill any remaining space with the fillchar</a>
<a name="ln4340">      for (; l &lt; minwid &amp;&amp; out_p &lt; out_end_p; l++) {</a>
<a name="ln4341">        *out_p++ = fillchar;</a>
<a name="ln4342">      }</a>
<a name="ln4343"> </a>
<a name="ln4344">    // Otherwise if the item is a number, copy that to the output buffer.</a>
<a name="ln4345">    } else if (num &gt;= 0) {</a>
<a name="ln4346">      if (out_p + 20 &gt; out_end_p) {</a>
<a name="ln4347">        break;                  // not sufficient space</a>
<a name="ln4348">      }</a>
<a name="ln4349">      prevchar_isitem = true;</a>
<a name="ln4350"> </a>
<a name="ln4351">      // { Build the formatting string</a>
<a name="ln4352">      char_u nstr[20];</a>
<a name="ln4353">      char_u *t = nstr;</a>
<a name="ln4354">      if (opt == STL_VIRTCOL_ALT) {</a>
<a name="ln4355">        *t++ = '-';</a>
<a name="ln4356">        minwid--;</a>
<a name="ln4357">      }</a>
<a name="ln4358">      *t++ = '%';</a>
<a name="ln4359">      if (zeropad) {</a>
<a name="ln4360">        *t++ = '0';</a>
<a name="ln4361">      }</a>
<a name="ln4362"> </a>
<a name="ln4363">      // Note: The `*` means we take the width as one of the arguments</a>
<a name="ln4364">      *t++ = '*';</a>
<a name="ln4365">      *t++ = (char_u)(base == kNumBaseHexadecimal ? 'X' : 'd');</a>
<a name="ln4366">      *t = 0;</a>
<a name="ln4367">      // }</a>
<a name="ln4368"> </a>
<a name="ln4369">      // { Determine how many characters the number will take up when printed</a>
<a name="ln4370">      //  Note: We have to cast the base because the compiler uses</a>
<a name="ln4371">      //        unsigned ints for the enum values.</a>
<a name="ln4372">      long num_chars = 1;</a>
<a name="ln4373">      for (long n = num; n &gt;= (int) base; n /= (int) base) {</a>
<a name="ln4374">        num_chars++;</a>
<a name="ln4375">      }</a>
<a name="ln4376"> </a>
<a name="ln4377">      // VIRTCOL_ALT takes up an extra character because</a>
<a name="ln4378">      // of the `-` we added above.</a>
<a name="ln4379">      if (opt == STL_VIRTCOL_ALT) {</a>
<a name="ln4380">        num_chars++;</a>
<a name="ln4381">      }</a>
<a name="ln4382">      // }</a>
<a name="ln4383"> </a>
<a name="ln4384">      assert(out_end_p &gt;= out_p);</a>
<a name="ln4385">      size_t remaining_buf_len = (size_t)(out_end_p - out_p) + 1;</a>
<a name="ln4386"> </a>
<a name="ln4387">      // If the number is going to take up too much room</a>
<a name="ln4388">      // Figure out the approximate number in &quot;scientific&quot; type notation.</a>
<a name="ln4389">      // Ex: 14532 with maxwid of 4 -&gt; '14&gt;3'</a>
<a name="ln4390">      if (num_chars &gt; maxwid) {</a>
<a name="ln4391">        // Add two to the width because the power piece will take</a>
<a name="ln4392">        // two extra characters</a>
<a name="ln4393">        num_chars += 2;</a>
<a name="ln4394"> </a>
<a name="ln4395">        // How many extra characters there are</a>
<a name="ln4396">        long n = num_chars - maxwid;</a>
<a name="ln4397"> </a>
<a name="ln4398">        // { Reduce the number by base^n</a>
<a name="ln4399">        while (num_chars-- &gt; maxwid) {</a>
<a name="ln4400">          num /= (long)base;</a>
<a name="ln4401">        }</a>
<a name="ln4402">        // }</a>
<a name="ln4403"> </a>
<a name="ln4404">        // { Add the format string for the exponent bit</a>
<a name="ln4405">        *t++ = '&gt;';</a>
<a name="ln4406">        *t++ = '%';</a>
<a name="ln4407">        // Use the same base as the first number</a>
<a name="ln4408">        *t = t[-3];</a>
<a name="ln4409">        *++t = 0;</a>
<a name="ln4410">        // }</a>
<a name="ln4411"> </a>
<a name="ln4412">        vim_snprintf((char *)out_p, remaining_buf_len, (char *)nstr,</a>
<a name="ln4413">            0, num, n);</a>
<a name="ln4414">      } else {</a>
<a name="ln4415">        vim_snprintf((char *)out_p, remaining_buf_len, (char *)nstr,</a>
<a name="ln4416">            minwid, num);</a>
<a name="ln4417">      }</a>
<a name="ln4418"> </a>
<a name="ln4419">      // Advance the output buffer position to the end of the</a>
<a name="ln4420">      // number we just printed</a>
<a name="ln4421">      out_p += STRLEN(out_p);</a>
<a name="ln4422"> </a>
<a name="ln4423">    // Otherwise, there was nothing to print so mark the item as empty</a>
<a name="ln4424">    } else {</a>
<a name="ln4425">      stl_items[curitem].type = Empty;</a>
<a name="ln4426">    }</a>
<a name="ln4427"> </a>
<a name="ln4428">    // Only free the string buffer if we allocated it.</a>
<a name="ln4429">    // Note: This is not needed if `str` is pointing at `tmp`</a>
<a name="ln4430">    if (opt == STL_VIM_EXPR) {</a>
<a name="ln4431">      xfree(str);</a>
<a name="ln4432">    }</a>
<a name="ln4433"> </a>
<a name="ln4434">    if (num &gt;= 0 || (!itemisflag &amp;&amp; str &amp;&amp; *str)) {</a>
<a name="ln4435">      prevchar_isflag = false;              // Item not NULL, but not a flag</a>
<a name="ln4436">    }</a>
<a name="ln4437"> </a>
<a name="ln4438">    // Item processed, move to the next</a>
<a name="ln4439">    curitem++;</a>
<a name="ln4440">  }</a>
<a name="ln4441"> </a>
<a name="ln4442">  *out_p = NUL;</a>
<a name="ln4443">  int itemcnt = curitem;</a>
<a name="ln4444"> </a>
<a name="ln4445">  // Free the format buffer if we allocated it internally</a>
<a name="ln4446">  if (usefmt != fmt) {</a>
<a name="ln4447">    xfree(usefmt);</a>
<a name="ln4448">  }</a>
<a name="ln4449"> </a>
<a name="ln4450">  // We have now processed the entire statusline format string.</a>
<a name="ln4451">  // What follows is post-processing to handle alignment and highlighting.</a>
<a name="ln4452"> </a>
<a name="ln4453">  int width = vim_strsize(out);</a>
<a name="ln4454">  if (maxwidth &gt; 0 &amp;&amp; width &gt; maxwidth) {</a>
<a name="ln4455">    // Result is too long, must truncate somewhere.</a>
<a name="ln4456">    int item_idx = 0;</a>
<a name="ln4457">    char_u *trunc_p;</a>
<a name="ln4458"> </a>
<a name="ln4459">    // If there are no items, truncate from beginning</a>
<a name="ln4460">    if (itemcnt == 0) {</a>
<a name="ln4461">      trunc_p = out;</a>
<a name="ln4462"> </a>
<a name="ln4463">    // Otherwise, look for the truncation item</a>
<a name="ln4464">    } else {</a>
<a name="ln4465">      // Default to truncating at the first item</a>
<a name="ln4466">      trunc_p = stl_items[0].start;</a>
<a name="ln4467">      item_idx = 0;</a>
<a name="ln4468"> </a>
<a name="ln4469">      for (int i = 0; i &lt; itemcnt; i++) {</a>
<a name="ln4470">        if (stl_items[i].type == Trunc) {</a>
<a name="ln4471">          // Truncate at %&lt; stl_items.</a>
<a name="ln4472">          trunc_p = stl_items[i].start;</a>
<a name="ln4473">          item_idx = i;</a>
<a name="ln4474">          break;</a>
<a name="ln4475">        }</a>
<a name="ln4476">      }</a>
<a name="ln4477">    }</a>
<a name="ln4478"> </a>
<a name="ln4479">    // If the truncation point we found is beyond the maximum</a>
<a name="ln4480">    // length of the string, truncate the end of the string.</a>
<a name="ln4481">    if (width - vim_strsize(trunc_p) &gt;= maxwidth) {</a>
<a name="ln4482">      // Walk from the beginning of the</a>
<a name="ln4483">      // string to find the last character that will fit.</a>
<a name="ln4484">      trunc_p = out;</a>
<a name="ln4485">      width = 0;</a>
<a name="ln4486">      for (;; ) {</a>
<a name="ln4487">        width += ptr2cells(trunc_p);</a>
<a name="ln4488">        if (width &gt;= maxwidth) {</a>
<a name="ln4489">          break;</a>
<a name="ln4490">        }</a>
<a name="ln4491"> </a>
<a name="ln4492">        // Note: Only advance the pointer if the next</a>
<a name="ln4493">        //       character will fit in the available output space</a>
<a name="ln4494">        trunc_p += utfc_ptr2len(trunc_p);</a>
<a name="ln4495">      }</a>
<a name="ln4496"> </a>
<a name="ln4497">      // Ignore any items in the statusline that occur after</a>
<a name="ln4498">      // the truncation point</a>
<a name="ln4499">      for (int i = 0; i &lt; itemcnt; i++) {</a>
<a name="ln4500">        if (stl_items[i].start &gt; trunc_p) {</a>
<a name="ln4501">          itemcnt = i;</a>
<a name="ln4502">          break;</a>
<a name="ln4503">        }</a>
<a name="ln4504">      }</a>
<a name="ln4505"> </a>
<a name="ln4506">      // Truncate the output</a>
<a name="ln4507">      *trunc_p++ = '&gt;';</a>
<a name="ln4508">      *trunc_p = 0;</a>
<a name="ln4509"> </a>
<a name="ln4510">    // Truncate at the truncation point we found</a>
<a name="ln4511">    } else {</a>
<a name="ln4512">      // { Determine how many bytes to remove</a>
<a name="ln4513">      long trunc_len = 0;</a>
<a name="ln4514">      while (width &gt;= maxwidth) {</a>
<a name="ln4515">        width     -= ptr2cells(trunc_p + trunc_len);</a>
<a name="ln4516">        trunc_len += utfc_ptr2len(trunc_p + trunc_len);</a>
<a name="ln4517">      }</a>
<a name="ln4518">      // }</a>
<a name="ln4519"> </a>
<a name="ln4520">      // { Truncate the string</a>
<a name="ln4521">      char_u *trunc_end_p = trunc_p + trunc_len;</a>
<a name="ln4522">      STRMOVE(trunc_p + 1, trunc_end_p);</a>
<a name="ln4523"> </a>
<a name="ln4524">      // Put a `&lt;` to mark where we truncated at</a>
<a name="ln4525">      *trunc_p = '&lt;';</a>
<a name="ln4526"> </a>
<a name="ln4527">      if (width + 1 &lt; maxwidth) {</a>
<a name="ln4528">        // Advance the pointer to the end of the string</a>
<a name="ln4529">        trunc_p = trunc_p + STRLEN(trunc_p);</a>
<a name="ln4530">      }</a>
<a name="ln4531"> </a>
<a name="ln4532">      // Fill up for half a double-wide character.</a>
<a name="ln4533">      while (++width &lt; maxwidth) {</a>
<a name="ln4534">        *trunc_p++ = fillchar;</a>
<a name="ln4535">        *trunc_p = NUL;</a>
<a name="ln4536">      }</a>
<a name="ln4537">      // }</a>
<a name="ln4538"> </a>
<a name="ln4539">      // { Change the start point for items based on</a>
<a name="ln4540">      //  their position relative to our truncation point</a>
<a name="ln4541"> </a>
<a name="ln4542">      // Note: The offset is one less than the truncation length because</a>
<a name="ln4543">      //       the truncation marker `&lt;` is not counted.</a>
<a name="ln4544">      long item_offset = trunc_len - 1;</a>
<a name="ln4545"> </a>
<a name="ln4546">      for (int i = item_idx; i &lt; itemcnt; i++) {</a>
<a name="ln4547">        // Items starting at or after the end of the truncated section need</a>
<a name="ln4548">        // to be moved backwards.</a>
<a name="ln4549">        if (stl_items[i].start &gt;= trunc_end_p) {</a>
<a name="ln4550">          stl_items[i].start -= item_offset;</a>
<a name="ln4551">        // Anything inside the truncated area is set to start</a>
<a name="ln4552">        // at the `&lt;` truncation character.</a>
<a name="ln4553">        } else {</a>
<a name="ln4554">          stl_items[i].start = trunc_p;</a>
<a name="ln4555">        }</a>
<a name="ln4556">      }</a>
<a name="ln4557">      // }</a>
<a name="ln4558">    }</a>
<a name="ln4559">    width = maxwidth;</a>
<a name="ln4560"> </a>
<a name="ln4561">  // If there is room left in our statusline, and room left in our buffer,</a>
<a name="ln4562">  // add characters at the separate marker (if there is one) to</a>
<a name="ln4563">  // fill up the available space.</a>
<a name="ln4564">  } else if (width &lt; maxwidth</a>
<a name="ln4565">             &amp;&amp; STRLEN(out) + (size_t)(maxwidth - width) + 1 &lt; outlen) {</a>
<a name="ln4566">    // Find how many separators there are, which we will use when</a>
<a name="ln4567">    // figuring out how many groups there are.</a>
<a name="ln4568">    int num_separators = 0;</a>
<a name="ln4569">    for (int i = 0; i &lt; itemcnt; i++) {</a>
<a name="ln4570">      if (stl_items[i].type == Separate) {</a>
<a name="ln4571">        // Create an array of the start location for each</a>
<a name="ln4572">        // separator mark.</a>
<a name="ln4573">        stl_separator_locations[num_separators] = i;</a>
<a name="ln4574">        num_separators++;</a>
<a name="ln4575">      }</a>
<a name="ln4576">    }</a>
<a name="ln4577"> </a>
<a name="ln4578">    // If we have separated groups, then we deal with it now</a>
<a name="ln4579">    if (num_separators) {</a>
<a name="ln4580">      int standard_spaces = (maxwidth - width) / num_separators;</a>
<a name="ln4581">      int final_spaces = (maxwidth - width) -</a>
<a name="ln4582">        standard_spaces * (num_separators - 1);</a>
<a name="ln4583"> </a>
<a name="ln4584">      for (int i = 0; i &lt; num_separators; i++) {</a>
<a name="ln4585">        int dislocation = (i == (num_separators - 1))</a>
<a name="ln4586">                          ? final_spaces : standard_spaces;</a>
<a name="ln4587">        char_u *start = stl_items[stl_separator_locations[i]].start;</a>
<a name="ln4588">        char_u *seploc = start + dislocation;</a>
<a name="ln4589">        STRMOVE(seploc, start);</a>
<a name="ln4590">        for (char_u *s = start; s &lt; seploc; s++) {</a>
<a name="ln4591">          *s = fillchar;</a>
<a name="ln4592">        }</a>
<a name="ln4593"> </a>
<a name="ln4594">        for (int item_idx = stl_separator_locations[i] + 1;</a>
<a name="ln4595">             item_idx &lt; itemcnt;</a>
<a name="ln4596">             item_idx++) {</a>
<a name="ln4597">          stl_items[item_idx].start += dislocation;</a>
<a name="ln4598">        }</a>
<a name="ln4599">      }</a>
<a name="ln4600"> </a>
<a name="ln4601">      width = maxwidth;</a>
<a name="ln4602">    }</a>
<a name="ln4603">  }</a>
<a name="ln4604"> </a>
<a name="ln4605">  // Store the info about highlighting.</a>
<a name="ln4606">  if (hltab != NULL) {</a>
<a name="ln4607">    *hltab = stl_hltab;</a>
<a name="ln4608">    stl_hlrec_t *sp = stl_hltab;</a>
<a name="ln4609">    for (long l = 0; l &lt; itemcnt; l++) {</a>
<a name="ln4610">      if (stl_items[l].type == Highlight) {</a>
<a name="ln4611">        sp-&gt;start = stl_items[l].start;</a>
<a name="ln4612">        sp-&gt;userhl = stl_items[l].minwid;</a>
<a name="ln4613">        sp++;</a>
<a name="ln4614">      }</a>
<a name="ln4615">    }</a>
<a name="ln4616">    sp-&gt;start = NULL;</a>
<a name="ln4617">    sp-&gt;userhl = 0;</a>
<a name="ln4618">  }</a>
<a name="ln4619"> </a>
<a name="ln4620">  // Store the info about tab pages labels.</a>
<a name="ln4621">  if (tabtab != NULL) {</a>
<a name="ln4622">    *tabtab = stl_tabtab;</a>
<a name="ln4623">    StlClickRecord *cur_tab_rec = stl_tabtab;</a>
<a name="ln4624">    for (long l = 0; l &lt; itemcnt; l++) {</a>
<a name="ln4625">      if (stl_items[l].type == TabPage) {</a>
<a name="ln4626">        cur_tab_rec-&gt;start = (char *)stl_items[l].start;</a>
<a name="ln4627">        if (stl_items[l].minwid == 0) {</a>
<a name="ln4628">          cur_tab_rec-&gt;def.type = kStlClickDisabled;</a>
<a name="ln4629">          cur_tab_rec-&gt;def.tabnr = 0;</a>
<a name="ln4630">        } else {</a>
<a name="ln4631">          int tabnr = stl_items[l].minwid;</a>
<a name="ln4632">          if (stl_items[l].minwid &gt; 0) {</a>
<a name="ln4633">            cur_tab_rec-&gt;def.type = kStlClickTabSwitch;</a>
<a name="ln4634">          } else {</a>
<a name="ln4635">            cur_tab_rec-&gt;def.type = kStlClickTabClose;</a>
<a name="ln4636">            tabnr = -tabnr;</a>
<a name="ln4637">          }</a>
<a name="ln4638">          cur_tab_rec-&gt;def.tabnr = tabnr;</a>
<a name="ln4639">        }</a>
<a name="ln4640">        cur_tab_rec-&gt;def.func = NULL;</a>
<a name="ln4641">        cur_tab_rec++;</a>
<a name="ln4642">      } else if (stl_items[l].type == ClickFunc) {</a>
<a name="ln4643">        cur_tab_rec-&gt;start = (char *)stl_items[l].start;</a>
<a name="ln4644">        cur_tab_rec-&gt;def.type = kStlClickFuncRun;</a>
<a name="ln4645">        cur_tab_rec-&gt;def.tabnr = stl_items[l].minwid;</a>
<a name="ln4646">        cur_tab_rec-&gt;def.func = stl_items[l].cmd;</a>
<a name="ln4647">        cur_tab_rec++;</a>
<a name="ln4648">      }</a>
<a name="ln4649">    }</a>
<a name="ln4650">    cur_tab_rec-&gt;start = NULL;</a>
<a name="ln4651">    cur_tab_rec-&gt;def.type = kStlClickDisabled;</a>
<a name="ln4652">    cur_tab_rec-&gt;def.tabnr = 0;</a>
<a name="ln4653">    cur_tab_rec-&gt;def.func = NULL;</a>
<a name="ln4654">  }</a>
<a name="ln4655"> </a>
<a name="ln4656">  // When inside update_screen we do not want redrawing a stausline, ruler,</a>
<a name="ln4657">  // title, etc. to trigger another redraw, it may cause an endless loop.</a>
<a name="ln4658">  if (updating_screen) {</a>
<a name="ln4659">    must_redraw = save_must_redraw;</a>
<a name="ln4660">    curwin-&gt;w_redr_type = save_redr_type;</a>
<a name="ln4661">  }</a>
<a name="ln4662"> </a>
<a name="ln4663">  return width;</a>
<a name="ln4664">}</a>
<a name="ln4665"> </a>
<a name="ln4666">/*</a>
<a name="ln4667"> * Get relative cursor position in window into &quot;buf[buflen]&quot;, in the form 99%,</a>
<a name="ln4668"> * using &quot;Top&quot;, &quot;Bot&quot; or &quot;All&quot; when appropriate.</a>
<a name="ln4669"> */</a>
<a name="ln4670">void get_rel_pos(win_T *wp, char_u *buf, int buflen)</a>
<a name="ln4671">{</a>
<a name="ln4672">  // Need at least 3 chars for writing.</a>
<a name="ln4673">  if (buflen &lt; 3) {</a>
<a name="ln4674">    return;</a>
<a name="ln4675">  }</a>
<a name="ln4676"> </a>
<a name="ln4677">  long above;          // number of lines above window</a>
<a name="ln4678">  long below;          // number of lines below window</a>
<a name="ln4679"> </a>
<a name="ln4680">  above = wp-&gt;w_topline - 1;</a>
<a name="ln4681">  above += diff_check_fill(wp, wp-&gt;w_topline) - wp-&gt;w_topfill;</a>
<a name="ln4682">  if (wp-&gt;w_topline == 1 &amp;&amp; wp-&gt;w_topfill &gt;= 1) {</a>
<a name="ln4683">    // All buffer lines are displayed and there is an indication</a>
<a name="ln4684">    // of filler lines, that can be considered seeing all lines.</a>
<a name="ln4685">    above = 0;</a>
<a name="ln4686">  }</a>
<a name="ln4687">  below = wp-&gt;w_buffer-&gt;b_ml.ml_line_count - wp-&gt;w_botline + 1;</a>
<a name="ln4688">  if (below &lt;= 0) {</a>
<a name="ln4689">    STRLCPY(buf, (above == 0 ? _(&quot;All&quot;) : _(&quot;Bot&quot;)), buflen);</a>
<a name="ln4690">  } else if (above &lt;= 0) {</a>
<a name="ln4691">    STRLCPY(buf, _(&quot;Top&quot;), buflen);</a>
<a name="ln4692">  } else {</a>
<a name="ln4693">    vim_snprintf((char *)buf, (size_t)buflen, &quot;%2d%%&quot;, above &gt; 1000000L</a>
<a name="ln4694">                 ? (int)(above / ((above + below) / 100L))</a>
<a name="ln4695">                 : (int)(above * 100L / (above + below)));</a>
<a name="ln4696">  }</a>
<a name="ln4697">}</a>
<a name="ln4698"> </a>
<a name="ln4699">/// Append (file 2 of 8) to &quot;buf[buflen]&quot;, if editing more than one file.</a>
<a name="ln4700">///</a>
<a name="ln4701">/// @param          wp        window whose buffers to check</a>
<a name="ln4702">/// @param[in,out]  buf       string buffer to add the text to</a>
<a name="ln4703">/// @param          buflen    length of the string buffer</a>
<a name="ln4704">/// @param          add_file  if true, add &quot;file&quot; before the arg number</a>
<a name="ln4705">///</a>
<a name="ln4706">/// @return true if it was appended.</a>
<a name="ln4707">static bool append_arg_number(win_T *wp, char_u *buf, int buflen, bool add_file)</a>
<a name="ln4708">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln4709">{</a>
<a name="ln4710">  // Nothing to do</a>
<a name="ln4711">  if (ARGCOUNT &lt;= 1) {</a>
<a name="ln4712">    return false;</a>
<a name="ln4713">  }</a>
<a name="ln4714"> </a>
<a name="ln4715">  char_u *p = buf + STRLEN(buf);  // go to the end of the buffer</a>
<a name="ln4716"> </a>
<a name="ln4717">  // Early out if the string is getting too long</a>
<a name="ln4718">  if (p - buf + 35 &gt;= buflen) {</a>
<a name="ln4719">    return false;</a>
<a name="ln4720">  }</a>
<a name="ln4721"> </a>
<a name="ln4722">  *p++ = ' ';</a>
<a name="ln4723">  *p++ = '(';</a>
<a name="ln4724">  if (add_file) {</a>
<a name="ln4725">    STRCPY(p, &quot;file &quot;);</a>
<a name="ln4726">    p += 5;</a>
<a name="ln4727">  }</a>
<a name="ln4728">  vim_snprintf((char *)p, (size_t)(buflen - (p - buf)),</a>
<a name="ln4729">               wp-&gt;w_arg_idx_invalid</a>
<a name="ln4730">               ? &quot;(%d) of %d)&quot;</a>
<a name="ln4731">               : &quot;%d of %d)&quot;, wp-&gt;w_arg_idx + 1, ARGCOUNT);</a>
<a name="ln4732">  return true;</a>
<a name="ln4733">}</a>
<a name="ln4734"> </a>
<a name="ln4735">// Make &quot;*ffname&quot; a full file name, set &quot;*sfname&quot; to &quot;*ffname&quot; if not NULL.</a>
<a name="ln4736">// &quot;*ffname&quot; becomes a pointer to allocated memory (or NULL).</a>
<a name="ln4737">// When resolving a link both &quot;*sfname&quot; and &quot;*ffname&quot; will point to the same</a>
<a name="ln4738">// allocated memory.</a>
<a name="ln4739">// The &quot;*ffname&quot; and &quot;*sfname&quot; pointer values on call will not be freed.</a>
<a name="ln4740">// Note that the resulting &quot;*ffname&quot; pointer should be considered not allocated.</a>
<a name="ln4741">void fname_expand(buf_T *buf, char_u **ffname, char_u **sfname)</a>
<a name="ln4742">{</a>
<a name="ln4743">  if (*ffname == NULL) {  // no file name given, nothing to do</a>
<a name="ln4744">    return;</a>
<a name="ln4745">  }</a>
<a name="ln4746">  if (*sfname == NULL) {  // no short file name given, use ffname</a>
<a name="ln4747">    *sfname = *ffname;</a>
<a name="ln4748">  }</a>
<a name="ln4749">  *ffname = (char_u *)fix_fname((char *)(*ffname));     // expand to full path</a>
<a name="ln4750"> </a>
<a name="ln4751">#ifdef WIN32</a>
<a name="ln4752">  if (!buf-&gt;b_p_bin) {</a>
<a name="ln4753">    // If the file name is a shortcut file, use the file it links to.</a>
<a name="ln4754">    char *rfname = os_resolve_shortcut((const char *)(*ffname));</a>
<a name="ln4755">    if (rfname != NULL) {</a>
<a name="ln4756">      xfree(*ffname);</a>
<a name="ln4757">      *ffname = (char_u *)rfname;</a>
<a name="ln4758">      *sfname = (char_u *)rfname;</a>
<a name="ln4759">    }</a>
<a name="ln4760">  }</a>
<a name="ln4761">#endif</a>
<a name="ln4762">}</a>
<a name="ln4763"> </a>
<a name="ln4764">/*</a>
<a name="ln4765"> * Get the file name for an argument list entry.</a>
<a name="ln4766"> */</a>
<a name="ln4767">char_u *alist_name(aentry_T *aep)</a>
<a name="ln4768">{</a>
<a name="ln4769">  buf_T       *bp;</a>
<a name="ln4770"> </a>
<a name="ln4771">  // Use the name from the associated buffer if it exists.</a>
<a name="ln4772">  bp = buflist_findnr(aep-&gt;ae_fnum);</a>
<a name="ln4773">  if (bp == NULL || bp-&gt;b_fname == NULL) {</a>
<a name="ln4774">    return aep-&gt;ae_fname;</a>
<a name="ln4775">  }</a>
<a name="ln4776">  return bp-&gt;b_fname;</a>
<a name="ln4777">}</a>
<a name="ln4778"> </a>
<a name="ln4779">/*</a>
<a name="ln4780"> * do_arg_all(): Open up to 'count' windows, one for each argument.</a>
<a name="ln4781"> */</a>
<a name="ln4782">void</a>
<a name="ln4783">do_arg_all(</a>
<a name="ln4784">    int count,</a>
<a name="ln4785">    int forceit,                  // hide buffers in current windows</a>
<a name="ln4786">    int keep_tabs                 // keep current tabs, for &quot;:tab drop file&quot;</a>
<a name="ln4787">)</a>
<a name="ln4788">{</a>
<a name="ln4789">  char_u      *opened;          // Array of weight for which args are open:</a>
<a name="ln4790">                                //  0: not opened</a>
<a name="ln4791">                                //  1: opened in other tab</a>
<a name="ln4792">                                //  2: opened in curtab</a>
<a name="ln4793">                                //  3: opened in curtab and curwin</a>
<a name="ln4794"> </a>
<a name="ln4795">  int opened_len;               // length of opened[]</a>
<a name="ln4796">  int use_firstwin = false;     // use first window for arglist</a>
<a name="ln4797">  bool tab_drop_empty_window = false;</a>
<a name="ln4798">  int split_ret = OK;</a>
<a name="ln4799">  bool p_ea_save;</a>
<a name="ln4800">  alist_T     *alist;           // argument list to be used</a>
<a name="ln4801">  buf_T       *buf;</a>
<a name="ln4802">  tabpage_T   *tpnext;</a>
<a name="ln4803">  int had_tab = cmdmod.tab;</a>
<a name="ln4804">  win_T       *old_curwin, *last_curwin;</a>
<a name="ln4805">  tabpage_T   *old_curtab, *last_curtab;</a>
<a name="ln4806">  win_T       *new_curwin = NULL;</a>
<a name="ln4807">  tabpage_T   *new_curtab = NULL;</a>
<a name="ln4808"> </a>
<a name="ln4809">  assert(firstwin != NULL);  // satisfy coverity</a>
<a name="ln4810"> </a>
<a name="ln4811">  if (ARGCOUNT &lt;= 0) {</a>
<a name="ln4812">    /* Don't give an error message.  We don't want it when the &quot;:all&quot;</a>
<a name="ln4813">     * command is in the .vimrc. */</a>
<a name="ln4814">    return;</a>
<a name="ln4815">  }</a>
<a name="ln4816">  setpcmark();</a>
<a name="ln4817"> </a>
<a name="ln4818">  opened_len = ARGCOUNT;</a>
<a name="ln4819">  opened = xcalloc((size_t)opened_len, 1);</a>
<a name="ln4820"> </a>
<a name="ln4821">  /* Autocommands may do anything to the argument list.  Make sure it's not</a>
<a name="ln4822">   * freed while we are working here by &quot;locking&quot; it.  We still have to</a>
<a name="ln4823">   * watch out for its size to be changed. */</a>
<a name="ln4824">  alist = curwin-&gt;w_alist;</a>
<a name="ln4825">  alist-&gt;al_refcount++;</a>
<a name="ln4826"> </a>
<a name="ln4827">  old_curwin = curwin;</a>
<a name="ln4828">  old_curtab = curtab;</a>
<a name="ln4829"> </a>
<a name="ln4830"> </a>
<a name="ln4831">  /*</a>
<a name="ln4832">   * Try closing all windows that are not in the argument list.</a>
<a name="ln4833">   * Also close windows that are not full width;</a>
<a name="ln4834">   * When 'hidden' or &quot;forceit&quot; set the buffer becomes hidden.</a>
<a name="ln4835">   * Windows that have a changed buffer and can't be hidden won't be closed.</a>
<a name="ln4836">   * When the &quot;:tab&quot; modifier was used do this for all tab pages.</a>
<a name="ln4837">   */</a>
<a name="ln4838">  if (had_tab &gt; 0) {</a>
<a name="ln4839">    goto_tabpage_tp(first_tabpage, true, true);</a>
<a name="ln4840">  }</a>
<a name="ln4841">  for (;; ) {</a>
<a name="ln4842">    win_T *wpnext = NULL;</a>
<a name="ln4843">    tpnext = curtab-&gt;tp_next;</a>
<a name="ln4844">    for (win_T *wp = firstwin; wp != NULL; wp = wpnext) {</a>
<a name="ln4845">      int i;</a>
<a name="ln4846">      wpnext = wp-&gt;w_next;</a>
<a name="ln4847">      buf = wp-&gt;w_buffer;</a>
<a name="ln4848">      if (buf-&gt;b_ffname == NULL</a>
<a name="ln4849">          || (!keep_tabs &amp;&amp; (buf-&gt;b_nwindows &gt; 1 || wp-&gt;w_width != Columns))) {</a>
<a name="ln4850">        i = opened_len;</a>
<a name="ln4851">      } else {</a>
<a name="ln4852">        // check if the buffer in this window is in the arglist</a>
<a name="ln4853">        for (i = 0; i &lt; opened_len; i++) {</a>
<a name="ln4854">          if (i &lt; alist-&gt;al_ga.ga_len</a>
<a name="ln4855">              &amp;&amp; (AARGLIST(alist)[i].ae_fnum == buf-&gt;b_fnum</a>
<a name="ln4856">                  || path_full_compare(alist_name(&amp;AARGLIST(alist)[i]),</a>
<a name="ln4857">                                       buf-&gt;b_ffname,</a>
<a name="ln4858">                                       true, true) &amp; kEqualFiles)) {</a>
<a name="ln4859">            int weight = 1;</a>
<a name="ln4860"> </a>
<a name="ln4861">            if (old_curtab == curtab) {</a>
<a name="ln4862">              weight++;</a>
<a name="ln4863">              if (old_curwin == wp) {</a>
<a name="ln4864">                weight++;</a>
<a name="ln4865">              }</a>
<a name="ln4866">            }</a>
<a name="ln4867"> </a>
<a name="ln4868">            if (weight &gt; (int)opened[i]) {</a>
<a name="ln4869">              opened[i] = (char_u)weight;</a>
<a name="ln4870">              if (i == 0) {</a>
<a name="ln4871">                if (new_curwin != NULL) {</a>
<a name="ln4872">                  new_curwin-&gt;w_arg_idx = opened_len;</a>
<a name="ln4873">                }</a>
<a name="ln4874">                new_curwin = wp;</a>
<a name="ln4875">                new_curtab = curtab;</a>
<a name="ln4876">              }</a>
<a name="ln4877">            } else if (keep_tabs) {</a>
<a name="ln4878">              i = opened_len;</a>
<a name="ln4879">            }</a>
<a name="ln4880"> </a>
<a name="ln4881">            if (wp-&gt;w_alist != alist) {</a>
<a name="ln4882">              /* Use the current argument list for all windows</a>
<a name="ln4883">               * containing a file from it. */</a>
<a name="ln4884">              alist_unlink(wp-&gt;w_alist);</a>
<a name="ln4885">              wp-&gt;w_alist = alist;</a>
<a name="ln4886">              wp-&gt;w_alist-&gt;al_refcount++;</a>
<a name="ln4887">            }</a>
<a name="ln4888">            break;</a>
<a name="ln4889">          }</a>
<a name="ln4890">        }</a>
<a name="ln4891">      }</a>
<a name="ln4892">      wp-&gt;w_arg_idx = i;</a>
<a name="ln4893"> </a>
<a name="ln4894">      if (i == opened_len &amp;&amp; !keep_tabs) {    // close this window</a>
<a name="ln4895">        if (buf_hide(buf) || forceit || buf-&gt;b_nwindows &gt; 1</a>
<a name="ln4896">            || !bufIsChanged(buf)) {</a>
<a name="ln4897">          /* If the buffer was changed, and we would like to hide it,</a>
<a name="ln4898">           * try autowriting. */</a>
<a name="ln4899">          if (!buf_hide(buf) &amp;&amp; buf-&gt;b_nwindows &lt;= 1 &amp;&amp; bufIsChanged(buf)) {</a>
<a name="ln4900">            bufref_T bufref;</a>
<a name="ln4901">            set_bufref(&amp;bufref, buf);</a>
<a name="ln4902">            (void)autowrite(buf, false);</a>
<a name="ln4903">            // Check if autocommands removed the window.</a>
<a name="ln4904">            if (!win_valid(wp) || !bufref_valid(&amp;bufref)) {</a>
<a name="ln4905">              wpnext = firstwin;  // Start all over...</a>
<a name="ln4906">              continue;</a>
<a name="ln4907">            }</a>
<a name="ln4908">          }</a>
<a name="ln4909">          // don't close last window</a>
<a name="ln4910">          if (ONE_WINDOW</a>
<a name="ln4911">              &amp;&amp; (first_tabpage-&gt;tp_next == NULL || !had_tab)) {</a>
<a name="ln4912">            use_firstwin = true;</a>
<a name="ln4913">          } else {</a>
<a name="ln4914">            win_close(wp, !buf_hide(buf) &amp;&amp; !bufIsChanged(buf));</a>
<a name="ln4915">            // check if autocommands removed the next window</a>
<a name="ln4916">            if (!win_valid(wpnext)) {</a>
<a name="ln4917">              // start all over...</a>
<a name="ln4918">              wpnext = firstwin;</a>
<a name="ln4919">            }</a>
<a name="ln4920">          }</a>
<a name="ln4921">        }</a>
<a name="ln4922">      }</a>
<a name="ln4923">    }</a>
<a name="ln4924"> </a>
<a name="ln4925">    // Without the &quot;:tab&quot; modifier only do the current tab page.</a>
<a name="ln4926">    if (had_tab == 0 || tpnext == NULL) {</a>
<a name="ln4927">      break;</a>
<a name="ln4928">    }</a>
<a name="ln4929"> </a>
<a name="ln4930">    // check if autocommands removed the next tab page</a>
<a name="ln4931">    if (!valid_tabpage(tpnext)) {</a>
<a name="ln4932">      tpnext = first_tabpage;           // start all over...</a>
<a name="ln4933">    }</a>
<a name="ln4934">    goto_tabpage_tp(tpnext, true, true);</a>
<a name="ln4935">  }</a>
<a name="ln4936"> </a>
<a name="ln4937">  /*</a>
<a name="ln4938">   * Open a window for files in the argument list that don't have one.</a>
<a name="ln4939">   * ARGCOUNT may change while doing this, because of autocommands.</a>
<a name="ln4940">   */</a>
<a name="ln4941">  if (count &gt; opened_len || count &lt;= 0) {</a>
<a name="ln4942">    count = opened_len;</a>
<a name="ln4943">  }</a>
<a name="ln4944"> </a>
<a name="ln4945">  // Don't execute Win/Buf Enter/Leave autocommands here.</a>
<a name="ln4946">  autocmd_no_enter++;</a>
<a name="ln4947">  autocmd_no_leave++;</a>
<a name="ln4948">  last_curwin = curwin;</a>
<a name="ln4949">  last_curtab = curtab;</a>
<a name="ln4950">  win_enter(lastwin, false);</a>
<a name="ln4951">  // &quot;:tab drop file&quot; should re-use an empty window to avoid &quot;--remote-tab&quot;</a>
<a name="ln4952">  // leaving an empty tab page when executed locally.</a>
<a name="ln4953">  if (keep_tabs &amp;&amp; buf_is_empty(curbuf) &amp;&amp; curbuf-&gt;b_nwindows == 1</a>
<a name="ln4954">      &amp;&amp; curbuf-&gt;b_ffname == NULL &amp;&amp; !curbuf-&gt;b_changed) {</a>
<a name="ln4955">    use_firstwin = true;</a>
<a name="ln4956">    tab_drop_empty_window = true;</a>
<a name="ln4957">  }</a>
<a name="ln4958"> </a>
<a name="ln4959">  for (int i = 0; i &lt; count &amp;&amp; !got_int; i++) {</a>
<a name="ln4960">    if (alist == &amp;global_alist &amp;&amp; i == global_alist.al_ga.ga_len - 1) {</a>
<a name="ln4961">      arg_had_last = true;</a>
<a name="ln4962">    }</a>
<a name="ln4963">    if (opened[i] &gt; 0) {</a>
<a name="ln4964">      // Move the already present window to below the current window</a>
<a name="ln4965">      if (curwin-&gt;w_arg_idx != i) {</a>
<a name="ln4966">        FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {</a>
<a name="ln4967">          if (wp-&gt;w_arg_idx == i) {</a>
<a name="ln4968">            if (keep_tabs) {</a>
<a name="ln4969">              new_curwin = wp;</a>
<a name="ln4970">              new_curtab = curtab;</a>
<a name="ln4971">            } else {</a>
<a name="ln4972">              win_move_after(wp, curwin);</a>
<a name="ln4973">            }</a>
<a name="ln4974">            break;</a>
<a name="ln4975">          }</a>
<a name="ln4976">        }</a>
<a name="ln4977">      }</a>
<a name="ln4978">    } else if (split_ret == OK) {</a>
<a name="ln4979">      // trigger events for tab drop</a>
<a name="ln4980">      if (tab_drop_empty_window &amp;&amp; i == count - 1) {</a>
<a name="ln4981">        autocmd_no_enter--;</a>
<a name="ln4982">      }</a>
<a name="ln4983">      if (!use_firstwin) {              // split current window</a>
<a name="ln4984">        p_ea_save = p_ea;</a>
<a name="ln4985">        p_ea = true;                    // use space from all windows</a>
<a name="ln4986">        split_ret = win_split(0, WSP_ROOM | WSP_BELOW);</a>
<a name="ln4987">        p_ea = p_ea_save;</a>
<a name="ln4988">        if (split_ret == FAIL) {</a>
<a name="ln4989">          continue;</a>
<a name="ln4990">        }</a>
<a name="ln4991">      } else {      // first window: do autocmd for leaving this buffer</a>
<a name="ln4992">        autocmd_no_leave--;</a>
<a name="ln4993">      }</a>
<a name="ln4994"> </a>
<a name="ln4995">      /*</a>
<a name="ln4996">       * edit file &quot;i&quot;</a>
<a name="ln4997">       */</a>
<a name="ln4998">      curwin-&gt;w_arg_idx = i;</a>
<a name="ln4999">      if (i == 0) {</a>
<a name="ln5000">        new_curwin = curwin;</a>
<a name="ln5001">        new_curtab = curtab;</a>
<a name="ln5002">      }</a>
<a name="ln5003">      (void)do_ecmd(0, alist_name(&amp;AARGLIST(alist)[i]), NULL, NULL, ECMD_ONE,</a>
<a name="ln5004">                    ((buf_hide(curwin-&gt;w_buffer)</a>
<a name="ln5005">                      || bufIsChanged(curwin-&gt;w_buffer))</a>
<a name="ln5006">                     ? ECMD_HIDE : 0) + ECMD_OLDBUF,</a>
<a name="ln5007">                    curwin);</a>
<a name="ln5008">      if (tab_drop_empty_window &amp;&amp; i == count - 1) {</a>
<a name="ln5009">        autocmd_no_enter++;</a>
<a name="ln5010">      }</a>
<a name="ln5011">      if (use_firstwin) {</a>
<a name="ln5012">        autocmd_no_leave++;</a>
<a name="ln5013">      }</a>
<a name="ln5014">      use_firstwin = false;</a>
<a name="ln5015">    }</a>
<a name="ln5016">    os_breakcheck();</a>
<a name="ln5017"> </a>
<a name="ln5018">    // When &quot;:tab&quot; was used open a new tab for a new window repeatedly.</a>
<a name="ln5019">    if (had_tab &gt; 0 &amp;&amp; tabpage_index(NULL) &lt;= p_tpm) {</a>
<a name="ln5020">      cmdmod.tab = 9999;</a>
<a name="ln5021">    }</a>
<a name="ln5022">  }</a>
<a name="ln5023"> </a>
<a name="ln5024">  // Remove the &quot;lock&quot; on the argument list.</a>
<a name="ln5025">  alist_unlink(alist);</a>
<a name="ln5026"> </a>
<a name="ln5027">  autocmd_no_enter--;</a>
<a name="ln5028">  // restore last referenced tabpage's curwin</a>
<a name="ln5029">  if (last_curtab != new_curtab) {</a>
<a name="ln5030">    if (valid_tabpage(last_curtab)) {</a>
<a name="ln5031">      goto_tabpage_tp(last_curtab, true, true);</a>
<a name="ln5032">    }</a>
<a name="ln5033">    if (win_valid(last_curwin)) {</a>
<a name="ln5034">      win_enter(last_curwin, false);</a>
<a name="ln5035">    }</a>
<a name="ln5036">  }</a>
<a name="ln5037">  // to window with first arg</a>
<a name="ln5038">  if (valid_tabpage(new_curtab)) {</a>
<a name="ln5039">    goto_tabpage_tp(new_curtab, true, true);</a>
<a name="ln5040">  }</a>
<a name="ln5041">  if (win_valid(new_curwin)) {</a>
<a name="ln5042">    win_enter(new_curwin, false);</a>
<a name="ln5043">  }</a>
<a name="ln5044"> </a>
<a name="ln5045">  autocmd_no_leave--;</a>
<a name="ln5046">  xfree(opened);</a>
<a name="ln5047">}</a>
<a name="ln5048"> </a>
<a name="ln5049">// Return TRUE if &quot;buf&quot; is a prompt buffer.</a>
<a name="ln5050">int bt_prompt(buf_T *buf)</a>
<a name="ln5051">{</a>
<a name="ln5052">    return buf != NULL &amp;&amp; buf-&gt;b_p_bt[0] == 'p';</a>
<a name="ln5053">}</a>
<a name="ln5054"> </a>
<a name="ln5055">/*</a>
<a name="ln5056"> * Open a window for a number of buffers.</a>
<a name="ln5057"> */</a>
<a name="ln5058">void ex_buffer_all(exarg_T *eap)</a>
<a name="ln5059">{</a>
<a name="ln5060">  buf_T       *buf;</a>
<a name="ln5061">  win_T       *wp, *wpnext;</a>
<a name="ln5062">  int split_ret = OK;</a>
<a name="ln5063">  bool p_ea_save;</a>
<a name="ln5064">  int open_wins = 0;</a>
<a name="ln5065">  int r;</a>
<a name="ln5066">  long count;                   // Maximum number of windows to open.</a>
<a name="ln5067">  int all;                      // When true also load inactive buffers.</a>
<a name="ln5068">  int had_tab = cmdmod.tab;</a>
<a name="ln5069">  tabpage_T   *tpnext;</a>
<a name="ln5070"> </a>
<a name="ln5071">  if (eap-&gt;addr_count == 0) {   // make as many windows as possible</a>
<a name="ln5072">    count = 9999;</a>
<a name="ln5073">  } else {</a>
<a name="ln5074">    count = eap-&gt;line2;         // make as many windows as specified</a>
<a name="ln5075">  }</a>
<a name="ln5076">  if (eap-&gt;cmdidx == CMD_unhide || eap-&gt;cmdidx == CMD_sunhide) {</a>
<a name="ln5077">    all = false;</a>
<a name="ln5078">  } else {</a>
<a name="ln5079">    all = true;</a>
<a name="ln5080">  }</a>
<a name="ln5081"> </a>
<a name="ln5082">  setpcmark();</a>
<a name="ln5083"> </a>
<a name="ln5084"> </a>
<a name="ln5085">  /*</a>
<a name="ln5086">   * Close superfluous windows (two windows for the same buffer).</a>
<a name="ln5087">   * Also close windows that are not full-width.</a>
<a name="ln5088">   */</a>
<a name="ln5089">  if (had_tab &gt; 0) {</a>
<a name="ln5090">    goto_tabpage_tp(first_tabpage, true, true);</a>
<a name="ln5091">  }</a>
<a name="ln5092">  for (;; ) {</a>
<a name="ln5093">    tpnext = curtab-&gt;tp_next;</a>
<a name="ln5094">    for (wp = firstwin; wp != NULL; wp = wpnext) {</a>
<a name="ln5095">      wpnext = wp-&gt;w_next;</a>
<a name="ln5096">      if ((wp-&gt;w_buffer-&gt;b_nwindows &gt; 1</a>
<a name="ln5097">           || ((cmdmod.split &amp; WSP_VERT)</a>
<a name="ln5098">               ? wp-&gt;w_height + wp-&gt;w_status_height &lt; Rows - p_ch</a>
<a name="ln5099">               - tabline_height()</a>
<a name="ln5100">               : wp-&gt;w_width != Columns)</a>
<a name="ln5101">           || (had_tab &gt; 0 &amp;&amp; wp != firstwin))</a>
<a name="ln5102">          &amp;&amp; !ONE_WINDOW</a>
<a name="ln5103">          &amp;&amp; !(wp-&gt;w_closing || wp-&gt;w_buffer-&gt;b_locked &gt; 0)</a>
<a name="ln5104">          ) {</a>
<a name="ln5105">        win_close(wp, false);</a>
<a name="ln5106">        wpnext = firstwin;              // just in case an autocommand does</a>
<a name="ln5107">                                        // something strange with windows</a>
<a name="ln5108">        tpnext = first_tabpage;         // start all over...</a>
<a name="ln5109">        open_wins = 0;</a>
<a name="ln5110">      } else {</a>
<a name="ln5111">        open_wins++;</a>
<a name="ln5112">      }</a>
<a name="ln5113">    }</a>
<a name="ln5114"> </a>
<a name="ln5115">    // Without the &quot;:tab&quot; modifier only do the current tab page.</a>
<a name="ln5116">    if (had_tab == 0 || tpnext == NULL) {</a>
<a name="ln5117">      break;</a>
<a name="ln5118">    }</a>
<a name="ln5119">    goto_tabpage_tp(tpnext, true, true);</a>
<a name="ln5120">  }</a>
<a name="ln5121"> </a>
<a name="ln5122">  //</a>
<a name="ln5123">  // Go through the buffer list.  When a buffer doesn't have a window yet,</a>
<a name="ln5124">  // open one.  Otherwise move the window to the right position.</a>
<a name="ln5125">  // Watch out for autocommands that delete buffers or windows!</a>
<a name="ln5126">  //</a>
<a name="ln5127">  // Don't execute Win/Buf Enter/Leave autocommands here.</a>
<a name="ln5128">  autocmd_no_enter++;</a>
<a name="ln5129">  win_enter(lastwin, false);</a>
<a name="ln5130">  autocmd_no_leave++;</a>
<a name="ln5131">  for (buf = firstbuf; buf != NULL &amp;&amp; open_wins &lt; count; buf = buf-&gt;b_next) {</a>
<a name="ln5132">    // Check if this buffer needs a window</a>
<a name="ln5133">    if ((!all &amp;&amp; buf-&gt;b_ml.ml_mfp == NULL) || !buf-&gt;b_p_bl) {</a>
<a name="ln5134">      continue;</a>
<a name="ln5135">    }</a>
<a name="ln5136"> </a>
<a name="ln5137">    if (had_tab != 0) {</a>
<a name="ln5138">      // With the &quot;:tab&quot; modifier don't move the window.</a>
<a name="ln5139">      if (buf-&gt;b_nwindows &gt; 0) {</a>
<a name="ln5140">        wp = lastwin;               // buffer has a window, skip it</a>
<a name="ln5141">      } else {</a>
<a name="ln5142">        wp = NULL;</a>
<a name="ln5143">      }</a>
<a name="ln5144">    } else {</a>
<a name="ln5145">      // Check if this buffer already has a window</a>
<a name="ln5146">      for (wp = firstwin; wp != NULL; wp = wp-&gt;w_next) {</a>
<a name="ln5147">        if (wp-&gt;w_buffer == buf) {</a>
<a name="ln5148">          break;</a>
<a name="ln5149">        }</a>
<a name="ln5150">      }</a>
<a name="ln5151">      // If the buffer already has a window, move it</a>
<a name="ln5152">      if (wp != NULL) {</a>
<a name="ln5153">        win_move_after(wp, curwin);</a>
<a name="ln5154">      }</a>
<a name="ln5155">    }</a>
<a name="ln5156"> </a>
<a name="ln5157">    if (wp == NULL &amp;&amp; split_ret == OK) {</a>
<a name="ln5158">      bufref_T bufref;</a>
<a name="ln5159">      set_bufref(&amp;bufref, buf);</a>
<a name="ln5160">      // Split the window and put the buffer in it.</a>
<a name="ln5161">      p_ea_save = p_ea;</a>
<a name="ln5162">      p_ea = true;                      // use space from all windows</a>
<a name="ln5163">      split_ret = win_split(0, WSP_ROOM | WSP_BELOW);</a>
<a name="ln5164">      open_wins++;</a>
<a name="ln5165">      p_ea = p_ea_save;</a>
<a name="ln5166">      if (split_ret == FAIL) {</a>
<a name="ln5167">        continue;</a>
<a name="ln5168">      }</a>
<a name="ln5169"> </a>
<a name="ln5170">      // Open the buffer in this window.</a>
<a name="ln5171">      swap_exists_action = SEA_DIALOG;</a>
<a name="ln5172">      set_curbuf(buf, DOBUF_GOTO);</a>
<a name="ln5173">      if (!bufref_valid(&amp;bufref)) {</a>
<a name="ln5174">        // Autocommands deleted the buffer.</a>
<a name="ln5175">        swap_exists_action = SEA_NONE;</a>
<a name="ln5176">        break;</a>
<a name="ln5177">      }</a>
<a name="ln5178">      if (swap_exists_action == SEA_QUIT) {</a>
<a name="ln5179">        cleanup_T cs;</a>
<a name="ln5180"> </a>
<a name="ln5181">        // Reset the error/interrupt/exception state here so that</a>
<a name="ln5182">        // aborting() returns false when closing a window.</a>
<a name="ln5183">        enter_cleanup(&amp;cs);</a>
<a name="ln5184"> </a>
<a name="ln5185">        // User selected Quit at ATTENTION prompt; close this window.</a>
<a name="ln5186">        win_close(curwin, true);</a>
<a name="ln5187">        open_wins--;</a>
<a name="ln5188">        swap_exists_action = SEA_NONE;</a>
<a name="ln5189">        swap_exists_did_quit = true;</a>
<a name="ln5190"> </a>
<a name="ln5191">        /* Restore the error/interrupt/exception state if not</a>
<a name="ln5192">         * discarded by a new aborting error, interrupt, or uncaught</a>
<a name="ln5193">         * exception. */</a>
<a name="ln5194">        leave_cleanup(&amp;cs);</a>
<a name="ln5195">      } else</a>
<a name="ln5196">        handle_swap_exists(NULL);</a>
<a name="ln5197">    }</a>
<a name="ln5198"> </a>
<a name="ln5199">    os_breakcheck();</a>
<a name="ln5200">    if (got_int) {</a>
<a name="ln5201">      (void)vgetc();            // only break the file loading, not the rest</a>
<a name="ln5202">      break;</a>
<a name="ln5203">    }</a>
<a name="ln5204">    // Autocommands deleted the buffer or aborted script processing!!!</a>
<a name="ln5205">    if (aborting()) {</a>
<a name="ln5206">      break;</a>
<a name="ln5207">    }</a>
<a name="ln5208">    // When &quot;:tab&quot; was used open a new tab for a new window repeatedly.</a>
<a name="ln5209">    if (had_tab &gt; 0 &amp;&amp; tabpage_index(NULL) &lt;= p_tpm) {</a>
<a name="ln5210">      cmdmod.tab = 9999;</a>
<a name="ln5211">    }</a>
<a name="ln5212">  }</a>
<a name="ln5213">  autocmd_no_enter--;</a>
<a name="ln5214">  win_enter(firstwin, false);           // back to first window</a>
<a name="ln5215">  autocmd_no_leave--;</a>
<a name="ln5216"> </a>
<a name="ln5217">  /*</a>
<a name="ln5218">   * Close superfluous windows.</a>
<a name="ln5219">   */</a>
<a name="ln5220">  for (wp = lastwin; open_wins &gt; count; ) {</a>
<a name="ln5221">    r = (buf_hide(wp-&gt;w_buffer) || !bufIsChanged(wp-&gt;w_buffer)</a>
<a name="ln5222">         || autowrite(wp-&gt;w_buffer, false) == OK);</a>
<a name="ln5223">    if (!win_valid(wp)) {</a>
<a name="ln5224">      // BufWrite Autocommands made the window invalid, start over</a>
<a name="ln5225">      wp = lastwin;</a>
<a name="ln5226">    } else if (r) {</a>
<a name="ln5227">      win_close(wp, !buf_hide(wp-&gt;w_buffer));</a>
<a name="ln5228">      open_wins--;</a>
<a name="ln5229">      wp = lastwin;</a>
<a name="ln5230">    } else {</a>
<a name="ln5231">      wp = wp-&gt;w_prev;</a>
<a name="ln5232">      if (wp == NULL) {</a>
<a name="ln5233">        break;</a>
<a name="ln5234">      }</a>
<a name="ln5235">    }</a>
<a name="ln5236">  }</a>
<a name="ln5237">}</a>
<a name="ln5238"> </a>
<a name="ln5239"> </a>
<a name="ln5240"> </a>
<a name="ln5241">/*</a>
<a name="ln5242"> * do_modelines() - process mode lines for the current file</a>
<a name="ln5243"> *</a>
<a name="ln5244"> * &quot;flags&quot; can be:</a>
<a name="ln5245"> * OPT_WINONLY	    only set options local to window</a>
<a name="ln5246"> * OPT_NOWIN	    don't set options local to window</a>
<a name="ln5247"> *</a>
<a name="ln5248"> * Returns immediately if the &quot;ml&quot; option isn't set.</a>
<a name="ln5249"> */</a>
<a name="ln5250">void do_modelines(int flags)</a>
<a name="ln5251">{</a>
<a name="ln5252">  linenr_T lnum;</a>
<a name="ln5253">  int nmlines;</a>
<a name="ln5254">  static int entered = 0;</a>
<a name="ln5255"> </a>
<a name="ln5256">  if (!curbuf-&gt;b_p_ml || (nmlines = (int)p_mls) == 0) {</a>
<a name="ln5257">    return;</a>
<a name="ln5258">  }</a>
<a name="ln5259"> </a>
<a name="ln5260">  /* Disallow recursive entry here.  Can happen when executing a modeline</a>
<a name="ln5261">   * triggers an autocommand, which reloads modelines with a &quot;:do&quot;. */</a>
<a name="ln5262">  if (entered) {</a>
<a name="ln5263">    return;</a>
<a name="ln5264">  }</a>
<a name="ln5265"> </a>
<a name="ln5266">  entered++;</a>
<a name="ln5267">  for (lnum = 1; lnum &lt;= curbuf-&gt;b_ml.ml_line_count &amp;&amp; lnum &lt;= nmlines;</a>
<a name="ln5268">       lnum++) {</a>
<a name="ln5269">    if (chk_modeline(lnum, flags) == FAIL) {</a>
<a name="ln5270">      nmlines = 0;</a>
<a name="ln5271">    }</a>
<a name="ln5272">  }</a>
<a name="ln5273"> </a>
<a name="ln5274">  for (lnum = curbuf-&gt;b_ml.ml_line_count; lnum &gt; 0 &amp;&amp; lnum &gt; nmlines</a>
<a name="ln5275">       &amp;&amp; lnum &gt; curbuf-&gt;b_ml.ml_line_count - nmlines; lnum--) {</a>
<a name="ln5276">    if (chk_modeline(lnum, flags) == FAIL) {</a>
<a name="ln5277">      nmlines = 0;</a>
<a name="ln5278">    }</a>
<a name="ln5279">  }</a>
<a name="ln5280">  entered--;</a>
<a name="ln5281">}</a>
<a name="ln5282"> </a>
<a name="ln5283">/*</a>
<a name="ln5284"> * chk_modeline() - check a single line for a mode string</a>
<a name="ln5285"> * Return FAIL if an error encountered.</a>
<a name="ln5286"> */</a>
<a name="ln5287">static int</a>
<a name="ln5288">chk_modeline(</a>
<a name="ln5289">    linenr_T lnum,</a>
<a name="ln5290">    int flags                      // Same as for do_modelines().</a>
<a name="ln5291">)</a>
<a name="ln5292">{</a>
<a name="ln5293">  char_u      *s;</a>
<a name="ln5294">  char_u      *e;</a>
<a name="ln5295">  char_u      *linecopy;                // local copy of any modeline found</a>
<a name="ln5296">  int prev;</a>
<a name="ln5297">  intmax_t vers;</a>
<a name="ln5298">  int end;</a>
<a name="ln5299">  int retval = OK;</a>
<a name="ln5300">  char_u      *save_sourcing_name;</a>
<a name="ln5301">  linenr_T save_sourcing_lnum;</a>
<a name="ln5302"> </a>
<a name="ln5303">  prev = -1;</a>
<a name="ln5304">  for (s = ml_get(lnum); *s != NUL; s++) {</a>
<a name="ln5305">    if (prev == -1 || ascii_isspace(prev)) {</a>
<a name="ln5306">      if ((prev != -1 &amp;&amp; STRNCMP(s, &quot;ex:&quot;, (size_t)3) == 0)</a>
<a name="ln5307">          || STRNCMP(s, &quot;vi:&quot;, (size_t)3) == 0)</a>
<a name="ln5308">        break;</a>
<a name="ln5309">      // Accept both &quot;vim&quot; and &quot;Vim&quot;.</a>
<a name="ln5310">      if ((s[0] == 'v' || s[0] == 'V') &amp;&amp; s[1] == 'i' &amp;&amp; s[2] == 'm') {</a>
<a name="ln5311">        if (s[3] == '&lt;' || s[3] == '=' || s[3] == '&gt;') {</a>
<a name="ln5312">          e = s + 4;</a>
<a name="ln5313">        } else {</a>
<a name="ln5314">          e = s + 3;</a>
<a name="ln5315">        }</a>
<a name="ln5316">        if (!try_getdigits(&amp;e, &amp;vers)) {</a>
<a name="ln5317">          continue;</a>
<a name="ln5318">        }</a>
<a name="ln5319"> </a>
<a name="ln5320">        if (*e == ':'</a>
<a name="ln5321">            &amp;&amp; (s[0] != 'V'</a>
<a name="ln5322">                || STRNCMP(skipwhite(e + 1), &quot;set&quot;, 3) == 0)</a>
<a name="ln5323">            &amp;&amp; (s[3] == ':'</a>
<a name="ln5324">                || (VIM_VERSION_100 &gt;= vers &amp;&amp; isdigit(s[3]))</a>
<a name="ln5325">                || (VIM_VERSION_100 &lt; vers &amp;&amp; s[3] == '&lt;')</a>
<a name="ln5326">                || (VIM_VERSION_100 &gt; vers &amp;&amp; s[3] == '&gt;')</a>
<a name="ln5327">                || (VIM_VERSION_100 == vers &amp;&amp; s[3] == '='))) {</a>
<a name="ln5328">          break;</a>
<a name="ln5329">        }</a>
<a name="ln5330">      }</a>
<a name="ln5331">    }</a>
<a name="ln5332">    prev = *s;</a>
<a name="ln5333">  }</a>
<a name="ln5334"> </a>
<a name="ln5335">  if (!*s) {</a>
<a name="ln5336">    return retval;</a>
<a name="ln5337">  }</a>
<a name="ln5338"> </a>
<a name="ln5339">  do {                                // skip over &quot;ex:&quot;, &quot;vi:&quot; or &quot;vim:&quot;</a>
<a name="ln5340">    s++;</a>
<a name="ln5341">  } while (s[-1] != ':');</a>
<a name="ln5342"> </a>
<a name="ln5343">  s = linecopy = vim_strsave(s);      // copy the line, it will change</a>
<a name="ln5344"> </a>
<a name="ln5345">  save_sourcing_lnum = sourcing_lnum;</a>
<a name="ln5346">  save_sourcing_name = sourcing_name;</a>
<a name="ln5347">  sourcing_lnum = lnum;               // prepare for emsg()</a>
<a name="ln5348">  sourcing_name = (char_u *)&quot;modelines&quot;;</a>
<a name="ln5349"> </a>
<a name="ln5350">  end = false;</a>
<a name="ln5351">  while (end == false) {</a>
<a name="ln5352">    s = skipwhite(s);</a>
<a name="ln5353">    if (*s == NUL) {</a>
<a name="ln5354">      break;</a>
<a name="ln5355">    }</a>
<a name="ln5356"> </a>
<a name="ln5357">    /*</a>
<a name="ln5358">     * Find end of set command: ':' or end of line.</a>
<a name="ln5359">     * Skip over &quot;\:&quot;, replacing it with &quot;:&quot;.</a>
<a name="ln5360">     */</a>
<a name="ln5361">    for (e = s; *e != ':' &amp;&amp; *e != NUL; e++) {</a>
<a name="ln5362">      if (e[0] == '\\' &amp;&amp; e[1] == ':') {</a>
<a name="ln5363">        STRMOVE(e, e + 1);</a>
<a name="ln5364">      }</a>
<a name="ln5365">    }</a>
<a name="ln5366">    if (*e == NUL) {</a>
<a name="ln5367">      end = true;</a>
<a name="ln5368">    }</a>
<a name="ln5369"> </a>
<a name="ln5370">    /*</a>
<a name="ln5371">     * If there is a &quot;set&quot; command, require a terminating ':' and</a>
<a name="ln5372">     * ignore the stuff after the ':'.</a>
<a name="ln5373">     * &quot;vi:set opt opt opt: foo&quot; -- foo not interpreted</a>
<a name="ln5374">     * &quot;vi:opt opt opt: foo&quot; -- foo interpreted</a>
<a name="ln5375">     * Accept &quot;se&quot; for compatibility with Elvis.</a>
<a name="ln5376">     */</a>
<a name="ln5377">    if (STRNCMP(s, &quot;set &quot;, (size_t)4) == 0</a>
<a name="ln5378">        || STRNCMP(s, &quot;se &quot;, (size_t)3) == 0) {</a>
<a name="ln5379">      if (*e != ':') {                // no terminating ':'?</a>
<a name="ln5380">        break;</a>
<a name="ln5381">      }</a>
<a name="ln5382">      end = true;</a>
<a name="ln5383">      s = vim_strchr(s, ' ') + 1;</a>
<a name="ln5384">    }</a>
<a name="ln5385">    *e = NUL;                         // truncate the set command</a>
<a name="ln5386"> </a>
<a name="ln5387">    if (*s != NUL) {                  // skip over an empty &quot;::&quot;</a>
<a name="ln5388">      const int secure_save = secure;</a>
<a name="ln5389">      const sctx_T save_current_sctx = current_sctx;</a>
<a name="ln5390">      current_sctx.sc_sid = SID_MODELINE;</a>
<a name="ln5391">      current_sctx.sc_seq = 0;</a>
<a name="ln5392">      current_sctx.sc_lnum = 0;</a>
<a name="ln5393">      // Make sure no risky things are executed as a side effect.</a>
<a name="ln5394">      secure = 1;</a>
<a name="ln5395"> </a>
<a name="ln5396">      retval = do_set(s, OPT_MODELINE | OPT_LOCAL | flags);</a>
<a name="ln5397"> </a>
<a name="ln5398">      secure = secure_save;</a>
<a name="ln5399">      current_sctx = save_current_sctx;</a>
<a name="ln5400">      if (retval == FAIL) {                   // stop if error found</a>
<a name="ln5401">        break;</a>
<a name="ln5402">      }</a>
<a name="ln5403">    }</a>
<a name="ln5404">    s = e + 1;                        // advance to next part</a>
<a name="ln5405">  }</a>
<a name="ln5406"> </a>
<a name="ln5407">  sourcing_lnum = save_sourcing_lnum;</a>
<a name="ln5408">  sourcing_name = save_sourcing_name;</a>
<a name="ln5409"> </a>
<a name="ln5410">  xfree(linecopy);</a>
<a name="ln5411"> </a>
<a name="ln5412">  return retval;</a>
<a name="ln5413">}</a>
<a name="ln5414"> </a>
<a name="ln5415">// Return true if &quot;buf&quot; is a help buffer.</a>
<a name="ln5416">bool bt_help(const buf_T *const buf)</a>
<a name="ln5417">  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln5418">{</a>
<a name="ln5419">  return buf != NULL &amp;&amp; buf-&gt;b_help;</a>
<a name="ln5420">}</a>
<a name="ln5421"> </a>
<a name="ln5422">// Return true if &quot;buf&quot; is a normal buffer, 'buftype' is empty.</a>
<a name="ln5423">bool bt_normal(const buf_T *const buf)</a>
<a name="ln5424">  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln5425">{</a>
<a name="ln5426">  return buf != NULL &amp;&amp; buf-&gt;b_p_bt[0] == NUL;</a>
<a name="ln5427">}</a>
<a name="ln5428"> </a>
<a name="ln5429">// Return true if &quot;buf&quot; is the quickfix buffer.</a>
<a name="ln5430">bool bt_quickfix(const buf_T *const buf)</a>
<a name="ln5431">  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln5432">{</a>
<a name="ln5433">  return buf != NULL &amp;&amp; buf-&gt;b_p_bt[0] == 'q';</a>
<a name="ln5434">}</a>
<a name="ln5435"> </a>
<a name="ln5436">// Return true if &quot;buf&quot; is a terminal buffer.</a>
<a name="ln5437">bool bt_terminal(const buf_T *const buf)</a>
<a name="ln5438">  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln5439">{</a>
<a name="ln5440">  return buf != NULL &amp;&amp; buf-&gt;b_p_bt[0] == 't';</a>
<a name="ln5441">}</a>
<a name="ln5442"> </a>
<a name="ln5443">// Return true if &quot;buf&quot; is a &quot;nofile&quot;, &quot;acwrite&quot;, &quot;terminal&quot; or &quot;prompt&quot;</a>
<a name="ln5444">// buffer.  This means the buffer name is not a file name.</a>
<a name="ln5445">bool bt_nofile(const buf_T *const buf)</a>
<a name="ln5446">  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln5447">{</a>
<a name="ln5448">  return buf != NULL &amp;&amp; ((buf-&gt;b_p_bt[0] == 'n' &amp;&amp; buf-&gt;b_p_bt[2] == 'f')</a>
<a name="ln5449">                         || buf-&gt;b_p_bt[0] == 'a'</a>
<a name="ln5450">                         || buf-&gt;terminal</a>
<a name="ln5451">                         || buf-&gt;b_p_bt[0] == 'p');</a>
<a name="ln5452">}</a>
<a name="ln5453"> </a>
<a name="ln5454">// Return true if &quot;buf&quot; is a &quot;nowrite&quot;, &quot;nofile&quot;, &quot;terminal&quot; or &quot;prompt&quot;</a>
<a name="ln5455">// buffer.</a>
<a name="ln5456">bool bt_dontwrite(const buf_T *const buf)</a>
<a name="ln5457">  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln5458">{</a>
<a name="ln5459">  return buf != NULL &amp;&amp; (buf-&gt;b_p_bt[0] == 'n'</a>
<a name="ln5460">                         || buf-&gt;terminal</a>
<a name="ln5461">                         || buf-&gt;b_p_bt[0] == 'p');</a>
<a name="ln5462">}</a>
<a name="ln5463"> </a>
<a name="ln5464">bool bt_dontwrite_msg(const buf_T *const buf)</a>
<a name="ln5465">  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln5466">{</a>
<a name="ln5467">  if (bt_dontwrite(buf)) {</a>
<a name="ln5468">    EMSG(_(&quot;E382: Cannot write, 'buftype' option is set&quot;));</a>
<a name="ln5469">    return true;</a>
<a name="ln5470">  }</a>
<a name="ln5471">  return false;</a>
<a name="ln5472">}</a>
<a name="ln5473"> </a>
<a name="ln5474">// Return true if the buffer should be hidden, according to 'hidden', &quot;:hide&quot;</a>
<a name="ln5475">// and 'bufhidden'.</a>
<a name="ln5476">bool buf_hide(const buf_T *const buf)</a>
<a name="ln5477">{</a>
<a name="ln5478">  // 'bufhidden' overrules 'hidden' and &quot;:hide&quot;, check it first</a>
<a name="ln5479">  switch (buf-&gt;b_p_bh[0]) {</a>
<a name="ln5480">  case 'u':                         // &quot;unload&quot;</a>
<a name="ln5481">  case 'w':                         // &quot;wipe&quot;</a>
<a name="ln5482">  case 'd': return false;           // &quot;delete&quot;</a>
<a name="ln5483">  case 'h': return true;            // &quot;hide&quot;</a>
<a name="ln5484">  }</a>
<a name="ln5485">  return p_hid || cmdmod.hide;</a>
<a name="ln5486">}</a>
<a name="ln5487"> </a>
<a name="ln5488">/*</a>
<a name="ln5489"> * Return special buffer name.</a>
<a name="ln5490"> * Returns NULL when the buffer has a normal file name.</a>
<a name="ln5491"> */</a>
<a name="ln5492">char_u *buf_spname(buf_T *buf)</a>
<a name="ln5493">{</a>
<a name="ln5494">  if (bt_quickfix(buf)) {</a>
<a name="ln5495">    win_T *win;</a>
<a name="ln5496">    tabpage_T *tp;</a>
<a name="ln5497"> </a>
<a name="ln5498">    // For location list window, w_llist_ref points to the location list.</a>
<a name="ln5499">    // For quickfix window, w_llist_ref is NULL.</a>
<a name="ln5500">    if (find_win_for_buf(buf, &amp;win, &amp;tp) &amp;&amp; win-&gt;w_llist_ref != NULL) {</a>
<a name="ln5501">      return (char_u *)_(msg_loclist);</a>
<a name="ln5502">    } else {</a>
<a name="ln5503">      return (char_u *)_(msg_qflist);</a>
<a name="ln5504">    }</a>
<a name="ln5505">  }</a>
<a name="ln5506">  // There is no _file_ when 'buftype' is &quot;nofile&quot;, b_sfname</a>
<a name="ln5507">  // contains the name as specified by the user.</a>
<a name="ln5508">  if (bt_nofile(buf)) {</a>
<a name="ln5509">    if (buf-&gt;b_fname != NULL) {</a>
<a name="ln5510">      return buf-&gt;b_fname;</a>
<a name="ln5511">    }</a>
<a name="ln5512">    if (bt_prompt(buf)) {</a>
<a name="ln5513">      return (char_u *)_(&quot;[Prompt]&quot;);</a>
<a name="ln5514">    }</a>
<a name="ln5515">    return (char_u *)_(&quot;[Scratch]&quot;);</a>
<a name="ln5516">  }</a>
<a name="ln5517">  if (buf-&gt;b_fname == NULL) {</a>
<a name="ln5518">    return buf_get_fname(buf);</a>
<a name="ln5519">  }</a>
<a name="ln5520">  return NULL;</a>
<a name="ln5521">}</a>
<a name="ln5522"> </a>
<a name="ln5523">/// Find a window for buffer &quot;buf&quot;.</a>
<a name="ln5524">/// If found true is returned and &quot;wp&quot; and &quot;tp&quot; are set to</a>
<a name="ln5525">/// the window and tabpage.</a>
<a name="ln5526">/// If not found, false is returned.</a>
<a name="ln5527">///</a>
<a name="ln5528">/// @param       buf  buffer to find a window for</a>
<a name="ln5529">/// @param[out]  wp   stores the found window</a>
<a name="ln5530">/// @param[out]  tp   stores the found tabpage</a>
<a name="ln5531">///</a>
<a name="ln5532">/// @return true if a window was found for the buffer.</a>
<a name="ln5533">bool find_win_for_buf(buf_T *buf, win_T **wp, tabpage_T **tp)</a>
<a name="ln5534">{</a>
<a name="ln5535">  *wp = NULL;</a>
<a name="ln5536">  *tp = NULL;</a>
<a name="ln5537">  FOR_ALL_TAB_WINDOWS(tp2, wp2) {</a>
<a name="ln5538">    if (wp2-&gt;w_buffer == buf) {</a>
<a name="ln5539">      *tp = tp2;</a>
<a name="ln5540">      *wp = wp2;</a>
<a name="ln5541">      return true;</a>
<a name="ln5542">    }</a>
<a name="ln5543">  }</a>
<a name="ln5544">  return false;</a>
<a name="ln5545">}</a>
<a name="ln5546"> </a>
<a name="ln5547">int buf_signcols(buf_T *buf)</a>
<a name="ln5548">{</a>
<a name="ln5549">    if (!buf-&gt;b_signcols_valid) {</a>
<a name="ln5550">        sign_entry_T *sign;  // a sign in the sign list</a>
<a name="ln5551">        int signcols = 0;</a>
<a name="ln5552">        int linesum = 0;</a>
<a name="ln5553">        linenr_T curline = 0;</a>
<a name="ln5554"> </a>
<a name="ln5555">        FOR_ALL_SIGNS_IN_BUF(buf, sign) {</a>
<a name="ln5556">          if (sign-&gt;se_lnum &gt; curline) {</a>
<a name="ln5557">            if (linesum &gt; signcols) {</a>
<a name="ln5558">              signcols = linesum;</a>
<a name="ln5559">            }</a>
<a name="ln5560">            curline = sign-&gt;se_lnum;</a>
<a name="ln5561">            linesum = 0;</a>
<a name="ln5562">          }</a>
<a name="ln5563">          if (sign-&gt;se_has_text_or_icon) {</a>
<a name="ln5564">            linesum++;</a>
<a name="ln5565">          }</a>
<a name="ln5566">        }</a>
<a name="ln5567">        if (linesum &gt; signcols) {</a>
<a name="ln5568">          signcols = linesum;</a>
<a name="ln5569">        }</a>
<a name="ln5570"> </a>
<a name="ln5571">        // Check if we need to redraw</a>
<a name="ln5572">        if (signcols != buf-&gt;b_signcols) {</a>
<a name="ln5573">            buf-&gt;b_signcols = signcols;</a>
<a name="ln5574">            redraw_buf_later(buf, NOT_VALID);</a>
<a name="ln5575">        }</a>
<a name="ln5576"> </a>
<a name="ln5577">        buf-&gt;b_signcols_valid = true;</a>
<a name="ln5578">    }</a>
<a name="ln5579"> </a>
<a name="ln5580">    return buf-&gt;b_signcols;</a>
<a name="ln5581">}</a>
<a name="ln5582"> </a>
<a name="ln5583">// Get &quot;buf-&gt;b_fname&quot;, use &quot;[No Name]&quot; if it is NULL.</a>
<a name="ln5584">char_u *buf_get_fname(const buf_T *buf)</a>
<a name="ln5585">  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_ALL</a>
<a name="ln5586">{</a>
<a name="ln5587">  if (buf-&gt;b_fname == NULL) {</a>
<a name="ln5588">    return (char_u *)_(&quot;[No Name]&quot;);</a>
<a name="ln5589">  }</a>
<a name="ln5590">  return buf-&gt;b_fname;</a>
<a name="ln5591">}</a>
<a name="ln5592"> </a>
<a name="ln5593">/*</a>
<a name="ln5594"> * Set 'buflisted' for curbuf to &quot;on&quot; and trigger autocommands if it changed.</a>
<a name="ln5595"> */</a>
<a name="ln5596">void set_buflisted(int on)</a>
<a name="ln5597">{</a>
<a name="ln5598">  if (on != curbuf-&gt;b_p_bl) {</a>
<a name="ln5599">    curbuf-&gt;b_p_bl = on;</a>
<a name="ln5600">    if (on) {</a>
<a name="ln5601">      apply_autocmds(EVENT_BUFADD, NULL, NULL, false, curbuf);</a>
<a name="ln5602">    } else {</a>
<a name="ln5603">      apply_autocmds(EVENT_BUFDELETE, NULL, NULL, false, curbuf);</a>
<a name="ln5604">    }</a>
<a name="ln5605">  }</a>
<a name="ln5606">}</a>
<a name="ln5607"> </a>
<a name="ln5608">/// Read the file for &quot;buf&quot; again and check if the contents changed.</a>
<a name="ln5609">/// Return true if it changed or this could not be checked.</a>
<a name="ln5610">///</a>
<a name="ln5611">/// @param  buf  buffer to check</a>
<a name="ln5612">///</a>
<a name="ln5613">/// @return true if the buffer's contents have changed</a>
<a name="ln5614">bool buf_contents_changed(buf_T *buf)</a>
<a name="ln5615">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln5616">{</a>
<a name="ln5617">  bool differ = true;</a>
<a name="ln5618"> </a>
<a name="ln5619">  // Allocate a buffer without putting it in the buffer list.</a>
<a name="ln5620">  buf_T *newbuf = buflist_new(NULL, NULL, (linenr_T)1, BLN_DUMMY);</a>
<a name="ln5621">  if (newbuf == NULL) {</a>
<a name="ln5622">    return true;</a>
<a name="ln5623">  }</a>
<a name="ln5624"> </a>
<a name="ln5625">  // Force the 'fileencoding' and 'fileformat' to be equal.</a>
<a name="ln5626">  exarg_T ea;</a>
<a name="ln5627">  prep_exarg(&amp;ea, buf);</a>
<a name="ln5628"> </a>
<a name="ln5629">  // set curwin/curbuf to buf and save a few things</a>
<a name="ln5630">  aco_save_T aco;</a>
<a name="ln5631">  aucmd_prepbuf(&amp;aco, newbuf);</a>
<a name="ln5632"> </a>
<a name="ln5633">  if (ml_open(curbuf) == OK</a>
<a name="ln5634">      &amp;&amp; readfile(buf-&gt;b_ffname, buf-&gt;b_fname,</a>
<a name="ln5635">                  (linenr_T)0, (linenr_T)0, (linenr_T)MAXLNUM,</a>
<a name="ln5636">                  &amp;ea, READ_NEW | READ_DUMMY) == OK) {</a>
<a name="ln5637">    // compare the two files line by line</a>
<a name="ln5638">    if (buf-&gt;b_ml.ml_line_count == curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln5639">      differ = false;</a>
<a name="ln5640">      for (linenr_T lnum = 1; lnum &lt;= curbuf-&gt;b_ml.ml_line_count; lnum++) {</a>
<a name="ln5641">        if (STRCMP(ml_get_buf(buf, lnum, false), ml_get(lnum)) != 0) {</a>
<a name="ln5642">          differ = true;</a>
<a name="ln5643">          break;</a>
<a name="ln5644">        }</a>
<a name="ln5645">      }</a>
<a name="ln5646">    }</a>
<a name="ln5647">  }</a>
<a name="ln5648">  xfree(ea.cmd);</a>
<a name="ln5649"> </a>
<a name="ln5650">  // restore curwin/curbuf and a few other things</a>
<a name="ln5651">  aucmd_restbuf(&amp;aco);</a>
<a name="ln5652"> </a>
<a name="ln5653">  if (curbuf != newbuf) {  // safety check</a>
<a name="ln5654">    wipe_buffer(newbuf, false);</a>
<a name="ln5655">  }</a>
<a name="ln5656"> </a>
<a name="ln5657">  return differ;</a>
<a name="ln5658">}</a>
<a name="ln5659"> </a>
<a name="ln5660">/*</a>
<a name="ln5661"> * Wipe out a buffer and decrement the last buffer number if it was used for</a>
<a name="ln5662"> * this buffer.  Call this to wipe out a temp buffer that does not contain any</a>
<a name="ln5663"> * marks.</a>
<a name="ln5664"> */</a>
<a name="ln5665">void</a>
<a name="ln5666">wipe_buffer(</a>
<a name="ln5667">    buf_T *buf,</a>
<a name="ln5668">    bool aucmd                  // When true trigger autocommands.</a>
<a name="ln5669">)</a>
<a name="ln5670">{</a>
<a name="ln5671">  if (!aucmd) {</a>
<a name="ln5672">    // Don't trigger BufDelete autocommands here.</a>
<a name="ln5673">    block_autocmds();</a>
<a name="ln5674">  }</a>
<a name="ln5675">  close_buffer(NULL, buf, DOBUF_WIPE, false);</a>
<a name="ln5676">  if (!aucmd) {</a>
<a name="ln5677">    unblock_autocmds();</a>
<a name="ln5678">  }</a>
<a name="ln5679">}</a>
<a name="ln5680"> </a>
<a name="ln5681">/// Creates or switches to a scratch buffer. :h special-buffers</a>
<a name="ln5682">/// Scratch buffer is:</a>
<a name="ln5683">///   - buftype=nofile bufhidden=hide noswapfile</a>
<a name="ln5684">///   - Always considered 'nomodified'</a>
<a name="ln5685">///</a>
<a name="ln5686">/// @param bufnr     Buffer to switch to, or 0 to create a new buffer.</a>
<a name="ln5687">///</a>
<a name="ln5688">/// @see curbufIsChanged()</a>
<a name="ln5689">void buf_open_scratch(handle_T bufnr, char *bufname)</a>
<a name="ln5690">{</a>
<a name="ln5691">  (void)do_ecmd((int)bufnr, NULL, NULL, NULL, ECMD_ONE, ECMD_HIDE, NULL);</a>
<a name="ln5692">  (void)setfname(curbuf, (char_u *)bufname, NULL, true);</a>
<a name="ln5693">  set_option_value(&quot;bh&quot;, 0L, &quot;hide&quot;, OPT_LOCAL);</a>
<a name="ln5694">  set_option_value(&quot;bt&quot;, 0L, &quot;nofile&quot;, OPT_LOCAL);</a>
<a name="ln5695">  set_option_value(&quot;swf&quot;, 0L, NULL, OPT_LOCAL);</a>
<a name="ln5696">  RESET_BINDING(curwin);</a>
<a name="ln5697">}</a>
<a name="ln5698"> </a>

</code></pre>
<div class="balloon" rel="3146"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v681/" target="_blank">V681</a> The language standard does not define an order in which the 'bt_dontwrite' functions will be called during evaluation of arguments.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
