
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>regexp_nfa.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">/*</a>
<a name="ln5"> * NFA regular expression implementation.</a>
<a name="ln6"> *</a>
<a name="ln7"> * This file is included in &quot;regexp.c&quot;.</a>
<a name="ln8"> */</a>
<a name="ln9"> </a>
<a name="ln10">#include &lt;assert.h&gt;</a>
<a name="ln11">#include &lt;inttypes.h&gt;</a>
<a name="ln12">#include &lt;stdbool.h&gt;</a>
<a name="ln13">#include &lt;limits.h&gt;</a>
<a name="ln14"> </a>
<a name="ln15">#include &quot;nvim/ascii.h&quot;</a>
<a name="ln16">#include &quot;nvim/garray.h&quot;</a>
<a name="ln17"> </a>
<a name="ln18">/*</a>
<a name="ln19"> * Logging of NFA engine.</a>
<a name="ln20"> *</a>
<a name="ln21"> * The NFA engine can write four log files:</a>
<a name="ln22"> * - Error log: Contains NFA engine's fatal errors.</a>
<a name="ln23"> * - Dump log: Contains compiled NFA state machine's information.</a>
<a name="ln24"> * - Run log: Contains information of matching procedure.</a>
<a name="ln25"> * - Debug log: Contains detailed information of matching procedure. Can be</a>
<a name="ln26"> *   disabled by undefining NFA_REGEXP_DEBUG_LOG.</a>
<a name="ln27"> * The first one can also be used without debug mode.</a>
<a name="ln28"> * The last three are enabled when compiled as debug mode and individually</a>
<a name="ln29"> * disabled by commenting them out.</a>
<a name="ln30"> * The log files can get quite big!</a>
<a name="ln31"> * Do disable all of this when compiling Vim for debugging, undefine REGEXP_DEBUG in</a>
<a name="ln32"> * regexp.c</a>
<a name="ln33"> */</a>
<a name="ln34">#ifdef REGEXP_DEBUG</a>
<a name="ln35"># define NFA_REGEXP_ERROR_LOG   &quot;nfa_regexp_error.log&quot;</a>
<a name="ln36"># define NFA_REGEXP_DUMP_LOG    &quot;nfa_regexp_dump.log&quot;</a>
<a name="ln37"># define NFA_REGEXP_RUN_LOG     &quot;nfa_regexp_run.log&quot;</a>
<a name="ln38"># define NFA_REGEXP_DEBUG_LOG   &quot;nfa_regexp_debug.log&quot;</a>
<a name="ln39">#endif</a>
<a name="ln40"> </a>
<a name="ln41">/* Added to NFA_ANY - NFA_NUPPER_IC to include a NL. */</a>
<a name="ln42">#define NFA_ADD_NL              31</a>
<a name="ln43"> </a>
<a name="ln44">enum {</a>
<a name="ln45">  NFA_SPLIT = -1024,</a>
<a name="ln46">  NFA_MATCH,</a>
<a name="ln47">  NFA_EMPTY,                        /* matches 0-length */</a>
<a name="ln48"> </a>
<a name="ln49">  NFA_START_COLL,                   /* [abc] start */</a>
<a name="ln50">  NFA_END_COLL,                     /* [abc] end */</a>
<a name="ln51">  NFA_START_NEG_COLL,               /* [^abc] start */</a>
<a name="ln52">  NFA_END_NEG_COLL,                 /* [^abc] end (postfix only) */</a>
<a name="ln53">  NFA_RANGE,                        /* range of the two previous items</a>
<a name="ln54">                                     * (postfix only) */</a>
<a name="ln55">  NFA_RANGE_MIN,                    /* low end of a range  */</a>
<a name="ln56">  NFA_RANGE_MAX,                    /* high end of a range  */</a>
<a name="ln57"> </a>
<a name="ln58">  NFA_CONCAT,                       // concatenate two previous items (postfix</a>
<a name="ln59">                                    // only)</a>
<a name="ln60">  NFA_OR,                           // \| (postfix only)</a>
<a name="ln61">  NFA_STAR,                         // greedy * (postfix only)</a>
<a name="ln62">  NFA_STAR_NONGREEDY,               // non-greedy * (postfix only)</a>
<a name="ln63">  NFA_QUEST,                        // greedy \? (postfix only)</a>
<a name="ln64">  NFA_QUEST_NONGREEDY,              // non-greedy \? (postfix only)</a>
<a name="ln65"> </a>
<a name="ln66">  NFA_BOL,                          /* ^    Begin line */</a>
<a name="ln67">  NFA_EOL,                          /* $    End line */</a>
<a name="ln68">  NFA_BOW,                          /* \&lt;   Begin word */</a>
<a name="ln69">  NFA_EOW,                          /* \&gt;   End word */</a>
<a name="ln70">  NFA_BOF,                          /* \%^  Begin file */</a>
<a name="ln71">  NFA_EOF,                          /* \%$  End file */</a>
<a name="ln72">  NFA_NEWL,</a>
<a name="ln73">  NFA_ZSTART,                       /* Used for \zs */</a>
<a name="ln74">  NFA_ZEND,                         /* Used for \ze */</a>
<a name="ln75">  NFA_NOPEN,                        /* Start of subexpression marked with \%( */</a>
<a name="ln76">  NFA_NCLOSE,                       /* End of subexpr. marked with \%( ... \) */</a>
<a name="ln77">  NFA_START_INVISIBLE,</a>
<a name="ln78">  NFA_START_INVISIBLE_FIRST,</a>
<a name="ln79">  NFA_START_INVISIBLE_NEG,</a>
<a name="ln80">  NFA_START_INVISIBLE_NEG_FIRST,</a>
<a name="ln81">  NFA_START_INVISIBLE_BEFORE,</a>
<a name="ln82">  NFA_START_INVISIBLE_BEFORE_FIRST,</a>
<a name="ln83">  NFA_START_INVISIBLE_BEFORE_NEG,</a>
<a name="ln84">  NFA_START_INVISIBLE_BEFORE_NEG_FIRST,</a>
<a name="ln85">  NFA_START_PATTERN,</a>
<a name="ln86">  NFA_END_INVISIBLE,</a>
<a name="ln87">  NFA_END_INVISIBLE_NEG,</a>
<a name="ln88">  NFA_END_PATTERN,</a>
<a name="ln89">  NFA_COMPOSING,                    /* Next nodes in NFA are part of the</a>
<a name="ln90">                                       composing multibyte char */</a>
<a name="ln91">  NFA_END_COMPOSING,                /* End of a composing char in the NFA */</a>
<a name="ln92">  NFA_ANY_COMPOSING,                // \%C: Any composing characters.</a>
<a name="ln93">  NFA_OPT_CHARS,                    /* \%[abc] */</a>
<a name="ln94"> </a>
<a name="ln95">  /* The following are used only in the postfix form, not in the NFA */</a>
<a name="ln96">  NFA_PREV_ATOM_NO_WIDTH,           /* Used for \@= */</a>
<a name="ln97">  NFA_PREV_ATOM_NO_WIDTH_NEG,       /* Used for \@! */</a>
<a name="ln98">  NFA_PREV_ATOM_JUST_BEFORE,        /* Used for \@&lt;= */</a>
<a name="ln99">  NFA_PREV_ATOM_JUST_BEFORE_NEG,    /* Used for \@&lt;! */</a>
<a name="ln100">  NFA_PREV_ATOM_LIKE_PATTERN,       /* Used for \@&gt; */</a>
<a name="ln101"> </a>
<a name="ln102">  NFA_BACKREF1,                     /* \1 */</a>
<a name="ln103">  NFA_BACKREF2,                     /* \2 */</a>
<a name="ln104">  NFA_BACKREF3,                     /* \3 */</a>
<a name="ln105">  NFA_BACKREF4,                     /* \4 */</a>
<a name="ln106">  NFA_BACKREF5,                     /* \5 */</a>
<a name="ln107">  NFA_BACKREF6,                     /* \6 */</a>
<a name="ln108">  NFA_BACKREF7,                     /* \7 */</a>
<a name="ln109">  NFA_BACKREF8,                     /* \8 */</a>
<a name="ln110">  NFA_BACKREF9,                     /* \9 */</a>
<a name="ln111">  NFA_ZREF1,                        /* \z1 */</a>
<a name="ln112">  NFA_ZREF2,                        /* \z2 */</a>
<a name="ln113">  NFA_ZREF3,                        /* \z3 */</a>
<a name="ln114">  NFA_ZREF4,                        /* \z4 */</a>
<a name="ln115">  NFA_ZREF5,                        /* \z5 */</a>
<a name="ln116">  NFA_ZREF6,                        /* \z6 */</a>
<a name="ln117">  NFA_ZREF7,                        /* \z7 */</a>
<a name="ln118">  NFA_ZREF8,                        /* \z8 */</a>
<a name="ln119">  NFA_ZREF9,                        /* \z9 */</a>
<a name="ln120">  NFA_SKIP,                         /* Skip characters */</a>
<a name="ln121"> </a>
<a name="ln122">  NFA_MOPEN,</a>
<a name="ln123">  NFA_MOPEN1,</a>
<a name="ln124">  NFA_MOPEN2,</a>
<a name="ln125">  NFA_MOPEN3,</a>
<a name="ln126">  NFA_MOPEN4,</a>
<a name="ln127">  NFA_MOPEN5,</a>
<a name="ln128">  NFA_MOPEN6,</a>
<a name="ln129">  NFA_MOPEN7,</a>
<a name="ln130">  NFA_MOPEN8,</a>
<a name="ln131">  NFA_MOPEN9,</a>
<a name="ln132"> </a>
<a name="ln133">  NFA_MCLOSE,</a>
<a name="ln134">  NFA_MCLOSE1,</a>
<a name="ln135">  NFA_MCLOSE2,</a>
<a name="ln136">  NFA_MCLOSE3,</a>
<a name="ln137">  NFA_MCLOSE4,</a>
<a name="ln138">  NFA_MCLOSE5,</a>
<a name="ln139">  NFA_MCLOSE6,</a>
<a name="ln140">  NFA_MCLOSE7,</a>
<a name="ln141">  NFA_MCLOSE8,</a>
<a name="ln142">  NFA_MCLOSE9,</a>
<a name="ln143"> </a>
<a name="ln144">  NFA_ZOPEN,</a>
<a name="ln145">  NFA_ZOPEN1,</a>
<a name="ln146">  NFA_ZOPEN2,</a>
<a name="ln147">  NFA_ZOPEN3,</a>
<a name="ln148">  NFA_ZOPEN4,</a>
<a name="ln149">  NFA_ZOPEN5,</a>
<a name="ln150">  NFA_ZOPEN6,</a>
<a name="ln151">  NFA_ZOPEN7,</a>
<a name="ln152">  NFA_ZOPEN8,</a>
<a name="ln153">  NFA_ZOPEN9,</a>
<a name="ln154"> </a>
<a name="ln155">  NFA_ZCLOSE,</a>
<a name="ln156">  NFA_ZCLOSE1,</a>
<a name="ln157">  NFA_ZCLOSE2,</a>
<a name="ln158">  NFA_ZCLOSE3,</a>
<a name="ln159">  NFA_ZCLOSE4,</a>
<a name="ln160">  NFA_ZCLOSE5,</a>
<a name="ln161">  NFA_ZCLOSE6,</a>
<a name="ln162">  NFA_ZCLOSE7,</a>
<a name="ln163">  NFA_ZCLOSE8,</a>
<a name="ln164">  NFA_ZCLOSE9,</a>
<a name="ln165"> </a>
<a name="ln166">  /* NFA_FIRST_NL */</a>
<a name="ln167">  NFA_ANY,              /*	Match any one character. */</a>
<a name="ln168">  NFA_IDENT,            /*	Match identifier char */</a>
<a name="ln169">  NFA_SIDENT,           /*	Match identifier char but no digit */</a>
<a name="ln170">  NFA_KWORD,            /*	Match keyword char */</a>
<a name="ln171">  NFA_SKWORD,           /*	Match word char but no digit */</a>
<a name="ln172">  NFA_FNAME,            /*	Match file name char */</a>
<a name="ln173">  NFA_SFNAME,           /*	Match file name char but no digit */</a>
<a name="ln174">  NFA_PRINT,            /*	Match printable char */</a>
<a name="ln175">  NFA_SPRINT,           /*	Match printable char but no digit */</a>
<a name="ln176">  NFA_WHITE,            /*	Match whitespace char */</a>
<a name="ln177">  NFA_NWHITE,           /*	Match non-whitespace char */</a>
<a name="ln178">  NFA_DIGIT,            /*	Match digit char */</a>
<a name="ln179">  NFA_NDIGIT,           /*	Match non-digit char */</a>
<a name="ln180">  NFA_HEX,              /*	Match hex char */</a>
<a name="ln181">  NFA_NHEX,             /*	Match non-hex char */</a>
<a name="ln182">  NFA_OCTAL,            /*	Match octal char */</a>
<a name="ln183">  NFA_NOCTAL,           /*	Match non-octal char */</a>
<a name="ln184">  NFA_WORD,             /*	Match word char */</a>
<a name="ln185">  NFA_NWORD,            /*	Match non-word char */</a>
<a name="ln186">  NFA_HEAD,             /*	Match head char */</a>
<a name="ln187">  NFA_NHEAD,            /*	Match non-head char */</a>
<a name="ln188">  NFA_ALPHA,            /*	Match alpha char */</a>
<a name="ln189">  NFA_NALPHA,           /*	Match non-alpha char */</a>
<a name="ln190">  NFA_LOWER,            /*	Match lowercase char */</a>
<a name="ln191">  NFA_NLOWER,           /*	Match non-lowercase char */</a>
<a name="ln192">  NFA_UPPER,            /*	Match uppercase char */</a>
<a name="ln193">  NFA_NUPPER,           /*	Match non-uppercase char */</a>
<a name="ln194">  NFA_LOWER_IC,         /*	Match [a-z] */</a>
<a name="ln195">  NFA_NLOWER_IC,        /*	Match [^a-z] */</a>
<a name="ln196">  NFA_UPPER_IC,         /*	Match [A-Z] */</a>
<a name="ln197">  NFA_NUPPER_IC,        /*	Match [^A-Z] */</a>
<a name="ln198"> </a>
<a name="ln199">  NFA_FIRST_NL = NFA_ANY + NFA_ADD_NL,</a>
<a name="ln200">  NFA_LAST_NL = NFA_NUPPER_IC + NFA_ADD_NL,</a>
<a name="ln201"> </a>
<a name="ln202">  NFA_CURSOR,           /*	Match cursor pos */</a>
<a name="ln203">  NFA_LNUM,             /*	Match line number */</a>
<a name="ln204">  NFA_LNUM_GT,          /*	Match &gt; line number */</a>
<a name="ln205">  NFA_LNUM_LT,          /*	Match &lt; line number */</a>
<a name="ln206">  NFA_COL,              /*	Match cursor column */</a>
<a name="ln207">  NFA_COL_GT,           /*	Match &gt; cursor column */</a>
<a name="ln208">  NFA_COL_LT,           /*	Match &lt; cursor column */</a>
<a name="ln209">  NFA_VCOL,             /*	Match cursor virtual column */</a>
<a name="ln210">  NFA_VCOL_GT,          /*	Match &gt; cursor virtual column */</a>
<a name="ln211">  NFA_VCOL_LT,          /*	Match &lt; cursor virtual column */</a>
<a name="ln212">  NFA_MARK,             /*	Match mark */</a>
<a name="ln213">  NFA_MARK_GT,          /*	Match &gt; mark */</a>
<a name="ln214">  NFA_MARK_LT,          /*	Match &lt; mark */</a>
<a name="ln215">  NFA_VISUAL,           /*	Match Visual area */</a>
<a name="ln216"> </a>
<a name="ln217">  /* Character classes [:alnum:] etc */</a>
<a name="ln218">  NFA_CLASS_ALNUM,</a>
<a name="ln219">  NFA_CLASS_ALPHA,</a>
<a name="ln220">  NFA_CLASS_BLANK,</a>
<a name="ln221">  NFA_CLASS_CNTRL,</a>
<a name="ln222">  NFA_CLASS_DIGIT,</a>
<a name="ln223">  NFA_CLASS_GRAPH,</a>
<a name="ln224">  NFA_CLASS_LOWER,</a>
<a name="ln225">  NFA_CLASS_PRINT,</a>
<a name="ln226">  NFA_CLASS_PUNCT,</a>
<a name="ln227">  NFA_CLASS_SPACE,</a>
<a name="ln228">  NFA_CLASS_UPPER,</a>
<a name="ln229">  NFA_CLASS_XDIGIT,</a>
<a name="ln230">  NFA_CLASS_TAB,</a>
<a name="ln231">  NFA_CLASS_RETURN,</a>
<a name="ln232">  NFA_CLASS_BACKSPACE,</a>
<a name="ln233">  NFA_CLASS_ESCAPE,</a>
<a name="ln234">  NFA_CLASS_IDENT,</a>
<a name="ln235">  NFA_CLASS_KEYWORD,</a>
<a name="ln236">  NFA_CLASS_FNAME,</a>
<a name="ln237">};</a>
<a name="ln238"> </a>
<a name="ln239">/* Keep in sync with classchars. */</a>
<a name="ln240">static int nfa_classcodes[] = {</a>
<a name="ln241">  NFA_ANY, NFA_IDENT, NFA_SIDENT, NFA_KWORD,NFA_SKWORD,</a>
<a name="ln242">  NFA_FNAME, NFA_SFNAME, NFA_PRINT, NFA_SPRINT,</a>
<a name="ln243">  NFA_WHITE, NFA_NWHITE, NFA_DIGIT, NFA_NDIGIT,</a>
<a name="ln244">  NFA_HEX, NFA_NHEX, NFA_OCTAL, NFA_NOCTAL,</a>
<a name="ln245">  NFA_WORD, NFA_NWORD, NFA_HEAD, NFA_NHEAD,</a>
<a name="ln246">  NFA_ALPHA, NFA_NALPHA, NFA_LOWER, NFA_NLOWER,</a>
<a name="ln247">  NFA_UPPER, NFA_NUPPER</a>
<a name="ln248">};</a>
<a name="ln249"> </a>
<a name="ln250">static char_u e_nul_found[] = N_(</a>
<a name="ln251">    &quot;E865: (NFA) Regexp end encountered prematurely&quot;);</a>
<a name="ln252">static char_u e_misplaced[] = N_(&quot;E866: (NFA regexp) Misplaced %c&quot;);</a>
<a name="ln253">static char_u e_ill_char_class[] = N_(</a>
<a name="ln254">    &quot;E877: (NFA regexp) Invalid character class: %&quot; PRId64);</a>
<a name="ln255">static char_u e_value_too_large[] = N_(&quot;E951: \\% value too large&quot;);</a>
<a name="ln256"> </a>
<a name="ln257">/* Since the out pointers in the list are always</a>
<a name="ln258"> * uninitialized, we use the pointers themselves</a>
<a name="ln259"> * as storage for the Ptrlists. */</a>
<a name="ln260">typedef union Ptrlist Ptrlist;</a>
<a name="ln261">union Ptrlist {</a>
<a name="ln262">  Ptrlist     *next;</a>
<a name="ln263">  nfa_state_T *s;</a>
<a name="ln264">};</a>
<a name="ln265"> </a>
<a name="ln266">struct Frag {</a>
<a name="ln267">  nfa_state_T *start;</a>
<a name="ln268">  Ptrlist     *out;</a>
<a name="ln269">};</a>
<a name="ln270">typedef struct Frag Frag_T;</a>
<a name="ln271"> </a>
<a name="ln272">typedef struct {</a>
<a name="ln273">  int in_use;       ///&lt; number of subexpr with useful info</a>
<a name="ln274"> </a>
<a name="ln275">  // When REG_MULTI is true list.multi is used, otherwise list.line.</a>
<a name="ln276">  union {</a>
<a name="ln277">    struct multipos {</a>
<a name="ln278">      linenr_T  start_lnum;</a>
<a name="ln279">      linenr_T  end_lnum;</a>
<a name="ln280">      colnr_T start_col;</a>
<a name="ln281">      colnr_T end_col;</a>
<a name="ln282">    } multi[NSUBEXP];</a>
<a name="ln283">    struct linepos {</a>
<a name="ln284">      char_u      *start;</a>
<a name="ln285">      char_u      *end;</a>
<a name="ln286">    } line[NSUBEXP];</a>
<a name="ln287">  } list;</a>
<a name="ln288">} regsub_T;</a>
<a name="ln289"> </a>
<a name="ln290">typedef struct {</a>
<a name="ln291">  regsub_T norm;      /* \( .. \) matches */</a>
<a name="ln292">  regsub_T synt;      /* \z( .. \) matches */</a>
<a name="ln293">} regsubs_T;</a>
<a name="ln294"> </a>
<a name="ln295">/* nfa_pim_T stores a Postponed Invisible Match. */</a>
<a name="ln296">typedef struct nfa_pim_S nfa_pim_T;</a>
<a name="ln297">struct nfa_pim_S {</a>
<a name="ln298">  int result;                   /* NFA_PIM_*, see below */</a>
<a name="ln299">  nfa_state_T *state;           /* the invisible match start state */</a>
<a name="ln300">  regsubs_T subs;               /* submatch info, only party used */</a>
<a name="ln301">  union {</a>
<a name="ln302">    lpos_T pos;</a>
<a name="ln303">    char_u  *ptr;</a>
<a name="ln304">  } end;                        /* where the match must end */</a>
<a name="ln305">};</a>
<a name="ln306"> </a>
<a name="ln307">/* nfa_thread_T contains execution information of a NFA state */</a>
<a name="ln308">typedef struct {</a>
<a name="ln309">  nfa_state_T *state;</a>
<a name="ln310">  int count;</a>
<a name="ln311">  nfa_pim_T pim;                /* if pim.result != NFA_PIM_UNUSED: postponed</a>
<a name="ln312">                                 * invisible match */</a>
<a name="ln313">  regsubs_T subs;               /* submatch info, only party used */</a>
<a name="ln314">} nfa_thread_T;</a>
<a name="ln315"> </a>
<a name="ln316">// nfa_list_T contains the alternative NFA execution states.</a>
<a name="ln317">typedef struct {</a>
<a name="ln318">  nfa_thread_T    *t;           ///&lt; allocated array of states</a>
<a name="ln319">  int n;                        ///&lt; nr of states currently in &quot;t&quot;</a>
<a name="ln320">  int len;                      ///&lt; max nr of states in &quot;t&quot;</a>
<a name="ln321">  int id;                       ///&lt; ID of the list</a>
<a name="ln322">  int has_pim;                  ///&lt; true when any state has a PIM</a>
<a name="ln323">} nfa_list_T;</a>
<a name="ln324"> </a>
<a name="ln325">// Variables only used in nfa_regcomp() and descendants.</a>
<a name="ln326">static int nfa_re_flags;  ///&lt; re_flags passed to nfa_regcomp().</a>
<a name="ln327">static int *post_start;   ///&lt; holds the postfix form of r.e.</a>
<a name="ln328">static int *post_end;</a>
<a name="ln329">static int *post_ptr;</a>
<a name="ln330"> </a>
<a name="ln331">// Set when the pattern should use the NFA engine.</a>
<a name="ln332">// E.g. [[:upper:]] only allows 8bit characters for BT engine,</a>
<a name="ln333">// while NFA engine handles multibyte characters correctly.</a>
<a name="ln334">static bool wants_nfa;</a>
<a name="ln335"> </a>
<a name="ln336">static int nstate;  ///&lt; Number of states in the NFA. Also used when executing.</a>
<a name="ln337">static int istate;  ///&lt; Index in the state vector, used in alloc_state()</a>
<a name="ln338"> </a>
<a name="ln339">/* If not NULL match must end at this position */</a>
<a name="ln340">static save_se_T *nfa_endp = NULL;</a>
<a name="ln341"> </a>
<a name="ln342">/* 0 for first call to nfa_regmatch(), 1 for recursive call. */</a>
<a name="ln343">static int nfa_ll_index = 0;</a>
<a name="ln344"> </a>
<a name="ln345">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln346"># include &quot;regexp_nfa.c.generated.h&quot;</a>
<a name="ln347">#endif</a>
<a name="ln348"> </a>
<a name="ln349">// Helper functions used when doing re2post() ... regatom() parsing</a>
<a name="ln350">#define EMIT(c) \</a>
<a name="ln351">    do { \</a>
<a name="ln352">      if (post_ptr &gt;= post_end) { \</a>
<a name="ln353">        realloc_post_list(); \</a>
<a name="ln354">      } \</a>
<a name="ln355">      *post_ptr++ = c; \</a>
<a name="ln356">    } while (0)</a>
<a name="ln357"> </a>
<a name="ln358">/*</a>
<a name="ln359"> * Initialize internal variables before NFA compilation.</a>
<a name="ln360"> */</a>
<a name="ln361">static void</a>
<a name="ln362">nfa_regcomp_start (</a>
<a name="ln363">    char_u *expr,</a>
<a name="ln364">    int re_flags                       /* see vim_regcomp() */</a>
<a name="ln365">)</a>
<a name="ln366">{</a>
<a name="ln367">  size_t postfix_size;</a>
<a name="ln368">  size_t nstate_max;</a>
<a name="ln369"> </a>
<a name="ln370">  nstate = 0;</a>
<a name="ln371">  istate = 0;</a>
<a name="ln372">  /* A reasonable estimation for maximum size */</a>
<a name="ln373">  nstate_max = (STRLEN(expr) + 1) * 25;</a>
<a name="ln374"> </a>
<a name="ln375">  /* Some items blow up in size, such as [A-z].  Add more space for that.</a>
<a name="ln376">   * When it is still not enough realloc_post_list() will be used. */</a>
<a name="ln377">  nstate_max += 1000;</a>
<a name="ln378"> </a>
<a name="ln379">  /* Size for postfix representation of expr. */</a>
<a name="ln380">  postfix_size = sizeof(int) * nstate_max;</a>
<a name="ln381"> </a>
<a name="ln382">  post_start = (int *)xmalloc(postfix_size);</a>
<a name="ln383">  post_ptr = post_start;</a>
<a name="ln384">  post_end = post_start + nstate_max;</a>
<a name="ln385">  wants_nfa = false;</a>
<a name="ln386">  rex.nfa_has_zend = false;</a>
<a name="ln387">  rex.nfa_has_backref = false;</a>
<a name="ln388"> </a>
<a name="ln389">  /* shared with BT engine */</a>
<a name="ln390">  regcomp_start(expr, re_flags);</a>
<a name="ln391">}</a>
<a name="ln392"> </a>
<a name="ln393">/*</a>
<a name="ln394"> * Figure out if the NFA state list starts with an anchor, must match at start</a>
<a name="ln395"> * of the line.</a>
<a name="ln396"> */</a>
<a name="ln397">static int nfa_get_reganch(nfa_state_T *start, int depth)</a>
<a name="ln398">{</a>
<a name="ln399">  nfa_state_T *p = start;</a>
<a name="ln400"> </a>
<a name="ln401">  if (depth &gt; 4)</a>
<a name="ln402">    return 0;</a>
<a name="ln403"> </a>
<a name="ln404">  while (p != NULL) {</a>
<a name="ln405">    switch (p-&gt;c) {</a>
<a name="ln406">    case NFA_BOL:</a>
<a name="ln407">    case NFA_BOF:</a>
<a name="ln408">      return 1;           /* yes! */</a>
<a name="ln409"> </a>
<a name="ln410">    case NFA_ZSTART:</a>
<a name="ln411">    case NFA_ZEND:</a>
<a name="ln412">    case NFA_CURSOR:</a>
<a name="ln413">    case NFA_VISUAL:</a>
<a name="ln414"> </a>
<a name="ln415">    case NFA_MOPEN:</a>
<a name="ln416">    case NFA_MOPEN1:</a>
<a name="ln417">    case NFA_MOPEN2:</a>
<a name="ln418">    case NFA_MOPEN3:</a>
<a name="ln419">    case NFA_MOPEN4:</a>
<a name="ln420">    case NFA_MOPEN5:</a>
<a name="ln421">    case NFA_MOPEN6:</a>
<a name="ln422">    case NFA_MOPEN7:</a>
<a name="ln423">    case NFA_MOPEN8:</a>
<a name="ln424">    case NFA_MOPEN9:</a>
<a name="ln425">    case NFA_NOPEN:</a>
<a name="ln426">    case NFA_ZOPEN:</a>
<a name="ln427">    case NFA_ZOPEN1:</a>
<a name="ln428">    case NFA_ZOPEN2:</a>
<a name="ln429">    case NFA_ZOPEN3:</a>
<a name="ln430">    case NFA_ZOPEN4:</a>
<a name="ln431">    case NFA_ZOPEN5:</a>
<a name="ln432">    case NFA_ZOPEN6:</a>
<a name="ln433">    case NFA_ZOPEN7:</a>
<a name="ln434">    case NFA_ZOPEN8:</a>
<a name="ln435">    case NFA_ZOPEN9:</a>
<a name="ln436">      p = p-&gt;out;</a>
<a name="ln437">      break;</a>
<a name="ln438"> </a>
<a name="ln439">    case NFA_SPLIT:</a>
<a name="ln440">      return nfa_get_reganch(p-&gt;out, depth + 1)</a>
<a name="ln441">             &amp;&amp; nfa_get_reganch(p-&gt;out1, depth + 1);</a>
<a name="ln442"> </a>
<a name="ln443">    default:</a>
<a name="ln444">      return 0;           /* noooo */</a>
<a name="ln445">    }</a>
<a name="ln446">  }</a>
<a name="ln447">  return 0;</a>
<a name="ln448">}</a>
<a name="ln449"> </a>
<a name="ln450">/*</a>
<a name="ln451"> * Figure out if the NFA state list starts with a character which must match</a>
<a name="ln452"> * at start of the match.</a>
<a name="ln453"> */</a>
<a name="ln454">static int nfa_get_regstart(nfa_state_T *start, int depth)</a>
<a name="ln455">{</a>
<a name="ln456">  nfa_state_T *p = start;</a>
<a name="ln457"> </a>
<a name="ln458">  if (depth &gt; 4)</a>
<a name="ln459">    return 0;</a>
<a name="ln460"> </a>
<a name="ln461">  while (p != NULL) {</a>
<a name="ln462">    switch (p-&gt;c) {</a>
<a name="ln463">    /* all kinds of zero-width matches */</a>
<a name="ln464">    case NFA_BOL:</a>
<a name="ln465">    case NFA_BOF:</a>
<a name="ln466">    case NFA_BOW:</a>
<a name="ln467">    case NFA_EOW:</a>
<a name="ln468">    case NFA_ZSTART:</a>
<a name="ln469">    case NFA_ZEND:</a>
<a name="ln470">    case NFA_CURSOR:</a>
<a name="ln471">    case NFA_VISUAL:</a>
<a name="ln472">    case NFA_LNUM:</a>
<a name="ln473">    case NFA_LNUM_GT:</a>
<a name="ln474">    case NFA_LNUM_LT:</a>
<a name="ln475">    case NFA_COL:</a>
<a name="ln476">    case NFA_COL_GT:</a>
<a name="ln477">    case NFA_COL_LT:</a>
<a name="ln478">    case NFA_VCOL:</a>
<a name="ln479">    case NFA_VCOL_GT:</a>
<a name="ln480">    case NFA_VCOL_LT:</a>
<a name="ln481">    case NFA_MARK:</a>
<a name="ln482">    case NFA_MARK_GT:</a>
<a name="ln483">    case NFA_MARK_LT:</a>
<a name="ln484"> </a>
<a name="ln485">    case NFA_MOPEN:</a>
<a name="ln486">    case NFA_MOPEN1:</a>
<a name="ln487">    case NFA_MOPEN2:</a>
<a name="ln488">    case NFA_MOPEN3:</a>
<a name="ln489">    case NFA_MOPEN4:</a>
<a name="ln490">    case NFA_MOPEN5:</a>
<a name="ln491">    case NFA_MOPEN6:</a>
<a name="ln492">    case NFA_MOPEN7:</a>
<a name="ln493">    case NFA_MOPEN8:</a>
<a name="ln494">    case NFA_MOPEN9:</a>
<a name="ln495">    case NFA_NOPEN:</a>
<a name="ln496">    case NFA_ZOPEN:</a>
<a name="ln497">    case NFA_ZOPEN1:</a>
<a name="ln498">    case NFA_ZOPEN2:</a>
<a name="ln499">    case NFA_ZOPEN3:</a>
<a name="ln500">    case NFA_ZOPEN4:</a>
<a name="ln501">    case NFA_ZOPEN5:</a>
<a name="ln502">    case NFA_ZOPEN6:</a>
<a name="ln503">    case NFA_ZOPEN7:</a>
<a name="ln504">    case NFA_ZOPEN8:</a>
<a name="ln505">    case NFA_ZOPEN9:</a>
<a name="ln506">      p = p-&gt;out;</a>
<a name="ln507">      break;</a>
<a name="ln508"> </a>
<a name="ln509">    case NFA_SPLIT:</a>
<a name="ln510">    {</a>
<a name="ln511">      int c1 = nfa_get_regstart(p-&gt;out, depth + 1);</a>
<a name="ln512">      int c2 = nfa_get_regstart(p-&gt;out1, depth + 1);</a>
<a name="ln513"> </a>
<a name="ln514">      if (c1 == c2)</a>
<a name="ln515">        return c1;             /* yes! */</a>
<a name="ln516">      return 0;</a>
<a name="ln517">    }</a>
<a name="ln518"> </a>
<a name="ln519">    default:</a>
<a name="ln520">      if (p-&gt;c &gt; 0)</a>
<a name="ln521">        return p-&gt;c;             /* yes! */</a>
<a name="ln522">      return 0;</a>
<a name="ln523">    }</a>
<a name="ln524">  }</a>
<a name="ln525">  return 0;</a>
<a name="ln526">}</a>
<a name="ln527"> </a>
<a name="ln528">/*</a>
<a name="ln529"> * Figure out if the NFA state list contains just literal text and nothing</a>
<a name="ln530"> * else.  If so return a string in allocated memory with what must match after</a>
<a name="ln531"> * regstart.  Otherwise return NULL.</a>
<a name="ln532"> */</a>
<a name="ln533">static char_u *nfa_get_match_text(nfa_state_T *start)</a>
<a name="ln534">{</a>
<a name="ln535">  nfa_state_T *p = start;</a>
<a name="ln536">  int len = 0;</a>
<a name="ln537">  char_u      *ret;</a>
<a name="ln538">  char_u      *s;</a>
<a name="ln539"> </a>
<a name="ln540">  if (p-&gt;c != NFA_MOPEN)</a>
<a name="ln541">    return NULL;     /* just in case */</a>
<a name="ln542">  p = p-&gt;out;</a>
<a name="ln543">  while (p-&gt;c &gt; 0) {</a>
<a name="ln544">    len += MB_CHAR2LEN(p-&gt;c);</a>
<a name="ln545">    p = p-&gt;out;</a>
<a name="ln546">  }</a>
<a name="ln547">  if (p-&gt;c != NFA_MCLOSE || p-&gt;out-&gt;c != NFA_MATCH)</a>
<a name="ln548">    return NULL;</a>
<a name="ln549"> </a>
<a name="ln550">  ret = xmalloc(len);</a>
<a name="ln551">  p = start-&gt;out-&gt;out;     /* skip first char, it goes into regstart */</a>
<a name="ln552">  s = ret;</a>
<a name="ln553">  while (p-&gt;c &gt; 0) {</a>
<a name="ln554">    s += utf_char2bytes(p-&gt;c, s);</a>
<a name="ln555">    p = p-&gt;out;</a>
<a name="ln556">  }</a>
<a name="ln557">  *s = NUL;</a>
<a name="ln558"> </a>
<a name="ln559">  return ret;</a>
<a name="ln560">}</a>
<a name="ln561"> </a>
<a name="ln562">/*</a>
<a name="ln563"> * Allocate more space for post_start.  Called when</a>
<a name="ln564"> * running above the estimated number of states.</a>
<a name="ln565"> */</a>
<a name="ln566">static void realloc_post_list(void)</a>
<a name="ln567">{</a>
<a name="ln568">  // For weird patterns the number of states can be very high. Increasing by</a>
<a name="ln569">  // 50% seems a reasonable compromise between memory use and speed.</a>
<a name="ln570">  const size_t new_max = (post_end - post_start) * 3 / 2;</a>
<a name="ln571">  int *new_start = xrealloc(post_start, new_max * sizeof(int));</a>
<a name="ln572">  post_ptr = new_start + (post_ptr - post_start);</a>
<a name="ln573">  post_end = new_start + new_max;</a>
<a name="ln574">  post_start = new_start;</a>
<a name="ln575">}</a>
<a name="ln576"> </a>
<a name="ln577">/*</a>
<a name="ln578"> * Search between &quot;start&quot; and &quot;end&quot; and try to recognize a</a>
<a name="ln579"> * character class in expanded form. For example [0-9].</a>
<a name="ln580"> * On success, return the id the character class to be emitted.</a>
<a name="ln581"> * On failure, return 0 (=FAIL)</a>
<a name="ln582"> * Start points to the first char of the range, while end should point</a>
<a name="ln583"> * to the closing brace.</a>
<a name="ln584"> * Keep in mind that 'ignorecase' applies at execution time, thus [a-z] may</a>
<a name="ln585"> * need to be interpreted as [a-zA-Z].</a>
<a name="ln586"> */</a>
<a name="ln587">static int nfa_recognize_char_class(char_u *start, char_u *end, int extra_newl)</a>
<a name="ln588">{</a>
<a name="ln589">#   define CLASS_not            0x80</a>
<a name="ln590">#   define CLASS_af             0x40</a>
<a name="ln591">#   define CLASS_AF             0x20</a>
<a name="ln592">#   define CLASS_az             0x10</a>
<a name="ln593">#   define CLASS_AZ             0x08</a>
<a name="ln594">#   define CLASS_o7             0x04</a>
<a name="ln595">#   define CLASS_o9             0x02</a>
<a name="ln596">#   define CLASS_underscore     0x01</a>
<a name="ln597"> </a>
<a name="ln598">  char_u      *p;</a>
<a name="ln599">  int config = 0;</a>
<a name="ln600"> </a>
<a name="ln601">  bool newl = extra_newl == true;</a>
<a name="ln602"> </a>
<a name="ln603">  if (*end != ']')</a>
<a name="ln604">    return FAIL;</a>
<a name="ln605">  p = start;</a>
<a name="ln606">  if (*p == '^') {</a>
<a name="ln607">    config |= CLASS_not;</a>
<a name="ln608">    p++;</a>
<a name="ln609">  }</a>
<a name="ln610"> </a>
<a name="ln611">  while (p &lt; end) {</a>
<a name="ln612">    if (p + 2 &lt; end &amp;&amp; *(p + 1) == '-') {</a>
<a name="ln613">      switch (*p) {</a>
<a name="ln614">      case '0':</a>
<a name="ln615">        if (*(p + 2) == '9') {</a>
<a name="ln616">          config |= CLASS_o9;</a>
<a name="ln617">          break;</a>
<a name="ln618">        } else if (*(p + 2) == '7') {</a>
<a name="ln619">          config |= CLASS_o7;</a>
<a name="ln620">          break;</a>
<a name="ln621">        }</a>
<a name="ln622">        return FAIL;</a>
<a name="ln623">      case 'a':</a>
<a name="ln624">        if (*(p + 2) == 'z') {</a>
<a name="ln625">          config |= CLASS_az;</a>
<a name="ln626">          break;</a>
<a name="ln627">        } else if (*(p + 2) == 'f') {</a>
<a name="ln628">          config |= CLASS_af;</a>
<a name="ln629">          break;</a>
<a name="ln630">        }</a>
<a name="ln631">        return FAIL;</a>
<a name="ln632">      case 'A':</a>
<a name="ln633">        if (*(p + 2) == 'Z') {</a>
<a name="ln634">          config |= CLASS_AZ;</a>
<a name="ln635">          break;</a>
<a name="ln636">        } else if (*(p + 2) == 'F') {</a>
<a name="ln637">          config |= CLASS_AF;</a>
<a name="ln638">          break;</a>
<a name="ln639">        }</a>
<a name="ln640">        return FAIL;</a>
<a name="ln641">      default:</a>
<a name="ln642">        return FAIL;</a>
<a name="ln643">      }</a>
<a name="ln644">      p += 3;</a>
<a name="ln645">    } else if (p + 1 &lt; end &amp;&amp; *p == '\\' &amp;&amp; *(p + 1) == 'n') {</a>
<a name="ln646">      newl = true;</a>
<a name="ln647">      p += 2;</a>
<a name="ln648">    } else if (*p == '_') {</a>
<a name="ln649">      config |= CLASS_underscore;</a>
<a name="ln650">      p++;</a>
<a name="ln651">    } else if (*p == '\n') {</a>
<a name="ln652">      newl = true;</a>
<a name="ln653">      p++;</a>
<a name="ln654">    } else</a>
<a name="ln655">      return FAIL;</a>
<a name="ln656">  }   /* while (p &lt; end) */</a>
<a name="ln657"> </a>
<a name="ln658">  if (p != end)</a>
<a name="ln659">    return FAIL;</a>
<a name="ln660"> </a>
<a name="ln661">  if (newl == true) {</a>
<a name="ln662">    extra_newl = NFA_ADD_NL;</a>
<a name="ln663">  }</a>
<a name="ln664"> </a>
<a name="ln665">  switch (config) {</a>
<a name="ln666">  case CLASS_o9:</a>
<a name="ln667">    return extra_newl + NFA_DIGIT;</a>
<a name="ln668">  case CLASS_not |  CLASS_o9:</a>
<a name="ln669">    return extra_newl + NFA_NDIGIT;</a>
<a name="ln670">  case CLASS_af | CLASS_AF | CLASS_o9:</a>
<a name="ln671">    return extra_newl + NFA_HEX;</a>
<a name="ln672">  case CLASS_not | CLASS_af | CLASS_AF | CLASS_o9:</a>
<a name="ln673">    return extra_newl + NFA_NHEX;</a>
<a name="ln674">  case CLASS_o7:</a>
<a name="ln675">    return extra_newl + NFA_OCTAL;</a>
<a name="ln676">  case CLASS_not | CLASS_o7:</a>
<a name="ln677">    return extra_newl + NFA_NOCTAL;</a>
<a name="ln678">  case CLASS_az | CLASS_AZ | CLASS_o9 | CLASS_underscore:</a>
<a name="ln679">    return extra_newl + NFA_WORD;</a>
<a name="ln680">  case CLASS_not | CLASS_az | CLASS_AZ | CLASS_o9 | CLASS_underscore:</a>
<a name="ln681">    return extra_newl + NFA_NWORD;</a>
<a name="ln682">  case CLASS_az | CLASS_AZ | CLASS_underscore:</a>
<a name="ln683">    return extra_newl + NFA_HEAD;</a>
<a name="ln684">  case CLASS_not | CLASS_az | CLASS_AZ | CLASS_underscore:</a>
<a name="ln685">    return extra_newl + NFA_NHEAD;</a>
<a name="ln686">  case CLASS_az | CLASS_AZ:</a>
<a name="ln687">    return extra_newl + NFA_ALPHA;</a>
<a name="ln688">  case CLASS_not | CLASS_az | CLASS_AZ:</a>
<a name="ln689">    return extra_newl + NFA_NALPHA;</a>
<a name="ln690">  case CLASS_az:</a>
<a name="ln691">    return extra_newl + NFA_LOWER_IC;</a>
<a name="ln692">  case CLASS_not | CLASS_az:</a>
<a name="ln693">    return extra_newl + NFA_NLOWER_IC;</a>
<a name="ln694">  case CLASS_AZ:</a>
<a name="ln695">    return extra_newl + NFA_UPPER_IC;</a>
<a name="ln696">  case CLASS_not | CLASS_AZ:</a>
<a name="ln697">    return extra_newl + NFA_NUPPER_IC;</a>
<a name="ln698">  }</a>
<a name="ln699">  return FAIL;</a>
<a name="ln700">}</a>
<a name="ln701"> </a>
<a name="ln702">/*</a>
<a name="ln703"> * Produce the bytes for equivalence class &quot;c&quot;.</a>
<a name="ln704"> * Currently only handles latin1, latin9 and utf-8.</a>
<a name="ln705"> * Emits bytes in postfix notation: 'a,b,NFA_OR,c,NFA_OR' is</a>
<a name="ln706"> * equivalent to 'a OR b OR c'</a>
<a name="ln707"> *</a>
<a name="ln708"> * NOTE! When changing this function, also update reg_equi_class()</a>
<a name="ln709"> */</a>
<a name="ln710">static void nfa_emit_equi_class(int c)</a>
<a name="ln711">{</a>
<a name="ln712">#define EMIT2(c)   EMIT(c); EMIT(NFA_CONCAT);</a>
<a name="ln713">#define EMITMBC(c) EMIT(c); EMIT(NFA_CONCAT);</a>
<a name="ln714"> </a>
<a name="ln715">  {</a>
<a name="ln716">#define A_grave 0xc0</a>
<a name="ln717">#define A_acute 0xc1</a>
<a name="ln718">#define A_circumflex 0xc2</a>
<a name="ln719">#define A_virguilla 0xc3</a>
<a name="ln720">#define A_diaeresis 0xc4</a>
<a name="ln721">#define A_ring 0xc5</a>
<a name="ln722">#define C_cedilla 0xc7</a>
<a name="ln723">#define E_grave 0xc8</a>
<a name="ln724">#define E_acute 0xc9</a>
<a name="ln725">#define E_circumflex 0xca</a>
<a name="ln726">#define E_diaeresis 0xcb</a>
<a name="ln727">#define I_grave 0xcc</a>
<a name="ln728">#define I_acute 0xcd</a>
<a name="ln729">#define I_circumflex 0xce</a>
<a name="ln730">#define I_diaeresis 0xcf</a>
<a name="ln731">#define N_virguilla 0xd1</a>
<a name="ln732">#define O_grave 0xd2</a>
<a name="ln733">#define O_acute 0xd3</a>
<a name="ln734">#define O_circumflex 0xd4</a>
<a name="ln735">#define O_virguilla 0xd5</a>
<a name="ln736">#define O_diaeresis 0xd6</a>
<a name="ln737">#define O_slash 0xd8</a>
<a name="ln738">#define U_grave 0xd9</a>
<a name="ln739">#define U_acute 0xda</a>
<a name="ln740">#define U_circumflex 0xdb</a>
<a name="ln741">#define U_diaeresis 0xdc</a>
<a name="ln742">#define Y_acute 0xdd</a>
<a name="ln743">#define a_grave 0xe0</a>
<a name="ln744">#define a_acute 0xe1</a>
<a name="ln745">#define a_circumflex 0xe2</a>
<a name="ln746">#define a_virguilla 0xe3</a>
<a name="ln747">#define a_diaeresis 0xe4</a>
<a name="ln748">#define a_ring 0xe5</a>
<a name="ln749">#define c_cedilla 0xe7</a>
<a name="ln750">#define e_grave 0xe8</a>
<a name="ln751">#define e_acute 0xe9</a>
<a name="ln752">#define e_circumflex 0xea</a>
<a name="ln753">#define e_diaeresis 0xeb</a>
<a name="ln754">#define i_grave 0xec</a>
<a name="ln755">#define i_acute 0xed</a>
<a name="ln756">#define i_circumflex 0xee</a>
<a name="ln757">#define i_diaeresis 0xef</a>
<a name="ln758">#define n_virguilla 0xf1</a>
<a name="ln759">#define o_grave 0xf2</a>
<a name="ln760">#define o_acute 0xf3</a>
<a name="ln761">#define o_circumflex 0xf4</a>
<a name="ln762">#define o_virguilla 0xf5</a>
<a name="ln763">#define o_diaeresis 0xf6</a>
<a name="ln764">#define o_slash 0xf8</a>
<a name="ln765">#define u_grave 0xf9</a>
<a name="ln766">#define u_acute 0xfa</a>
<a name="ln767">#define u_circumflex 0xfb</a>
<a name="ln768">#define u_diaeresis 0xfc</a>
<a name="ln769">#define y_acute 0xfd</a>
<a name="ln770">#define y_diaeresis 0xff</a>
<a name="ln771">    switch (c) {</a>
<a name="ln772">    case 'A': case A_grave: case A_acute: case A_circumflex:</a>
<a name="ln773">              case A_virguilla: case A_diaeresis: case A_ring:</a>
<a name="ln774">              CASEMBC(0x100) CASEMBC(0x102) CASEMBC(0x104)</a>
<a name="ln775">              CASEMBC(0x1cd) CASEMBC(0x1de) CASEMBC(0x1e0)</a>
<a name="ln776">              CASEMBC(0x1ea2)</a>
<a name="ln777">      EMIT2('A'); EMIT2(A_grave); EMIT2(A_acute);</a>
<a name="ln778">      EMIT2(A_circumflex); EMIT2(A_virguilla);</a>
<a name="ln779">      EMIT2(A_diaeresis); EMIT2(A_ring);</a>
<a name="ln780">      EMITMBC(0x100) EMITMBC(0x102) EMITMBC(0x104)</a>
<a name="ln781">      EMITMBC(0x1cd) EMITMBC(0x1de) EMITMBC(0x1e0)</a>
<a name="ln782">      EMITMBC(0x1ea2)</a>
<a name="ln783">      return;</a>
<a name="ln784"> </a>
<a name="ln785">    case 'B': CASEMBC(0x1e02) CASEMBC(0x1e06)</a>
<a name="ln786">      EMIT2('B'); EMITMBC(0x1e02) EMITMBC(0x1e06)</a>
<a name="ln787">      return;</a>
<a name="ln788"> </a>
<a name="ln789">    case 'C': case C_cedilla: CASEMBC(0x106) CASEMBC(0x108) CASEMBC(0x10a)</a>
<a name="ln790">              CASEMBC(0x10c)</a>
<a name="ln791">      EMIT2('C'); EMIT2(C_cedilla); EMITMBC(0x106) EMITMBC(0x108)</a>
<a name="ln792">      EMITMBC(0x10a) EMITMBC(0x10c)</a>
<a name="ln793">      return;</a>
<a name="ln794"> </a>
<a name="ln795">    case 'D': CASEMBC(0x10e) CASEMBC(0x110) CASEMBC(0x1e0a)</a>
<a name="ln796">              CASEMBC(0x1e0e) CASEMBC(0x1e10)</a>
<a name="ln797">      EMIT2('D'); EMITMBC(0x10e) EMITMBC(0x110) EMITMBC(0x1e0a)</a>
<a name="ln798">      EMITMBC(0x1e0e) EMITMBC(0x1e10)</a>
<a name="ln799">      return;</a>
<a name="ln800"> </a>
<a name="ln801">    case 'E': case E_grave: case E_acute: case E_circumflex:</a>
<a name="ln802">              case E_diaeresis: CASEMBC(0x112) CASEMBC(0x114)</a>
<a name="ln803">              CASEMBC(0x116) CASEMBC(0x118) CASEMBC(0x11a)</a>
<a name="ln804">              CASEMBC(0x1eba) CASEMBC(0x1ebc)</a>
<a name="ln805">      EMIT2('E'); EMIT2(E_grave); EMIT2(E_acute);</a>
<a name="ln806">      EMIT2(E_circumflex); EMIT2(E_diaeresis);</a>
<a name="ln807">      EMITMBC(0x112) EMITMBC(0x114) EMITMBC(0x116)</a>
<a name="ln808">      EMITMBC(0x118) EMITMBC(0x11a) EMITMBC(0x1eba)</a>
<a name="ln809">      EMITMBC(0x1ebc)</a>
<a name="ln810">      return;</a>
<a name="ln811"> </a>
<a name="ln812">    case 'F': CASEMBC(0x1e1e)</a>
<a name="ln813">      EMIT2('F'); EMITMBC(0x1e1e)</a>
<a name="ln814">      return;</a>
<a name="ln815"> </a>
<a name="ln816">    case 'G': CASEMBC(0x11c) CASEMBC(0x11e) CASEMBC(0x120)</a>
<a name="ln817">              CASEMBC(0x122) CASEMBC(0x1e4) CASEMBC(0x1e6)</a>
<a name="ln818">              CASEMBC(0x1f4) CASEMBC(0x1e20)</a>
<a name="ln819">      EMIT2('G'); EMITMBC(0x11c) EMITMBC(0x11e) EMITMBC(0x120)</a>
<a name="ln820">      EMITMBC(0x122) EMITMBC(0x1e4) EMITMBC(0x1e6)</a>
<a name="ln821">      EMITMBC(0x1f4) EMITMBC(0x1e20)</a>
<a name="ln822">      return;</a>
<a name="ln823"> </a>
<a name="ln824">    case 'H': CASEMBC(0x124) CASEMBC(0x126) CASEMBC(0x1e22)</a>
<a name="ln825">              CASEMBC(0x1e26) CASEMBC(0x1e28)</a>
<a name="ln826">      EMIT2('H'); EMITMBC(0x124) EMITMBC(0x126) EMITMBC(0x1e22)</a>
<a name="ln827">      EMITMBC(0x1e26) EMITMBC(0x1e28)</a>
<a name="ln828">      return;</a>
<a name="ln829"> </a>
<a name="ln830">    case 'I': case I_grave: case I_acute: case I_circumflex:</a>
<a name="ln831">              case I_diaeresis: CASEMBC(0x128) CASEMBC(0x12a)</a>
<a name="ln832">              CASEMBC(0x12c) CASEMBC(0x12e) CASEMBC(0x130)</a>
<a name="ln833">              CASEMBC(0x1cf) CASEMBC(0x1ec8)</a>
<a name="ln834">      EMIT2('I'); EMIT2(I_grave); EMIT2(I_acute);</a>
<a name="ln835">      EMIT2(I_circumflex); EMIT2(I_diaeresis);</a>
<a name="ln836">      EMITMBC(0x128) EMITMBC(0x12a)</a>
<a name="ln837">      EMITMBC(0x12c) EMITMBC(0x12e) EMITMBC(0x130)</a>
<a name="ln838">      EMITMBC(0x1cf) EMITMBC(0x1ec8)</a>
<a name="ln839">      return;</a>
<a name="ln840"> </a>
<a name="ln841">    case 'J': CASEMBC(0x134)</a>
<a name="ln842">      EMIT2('J'); EMITMBC(0x134)</a>
<a name="ln843">      return;</a>
<a name="ln844"> </a>
<a name="ln845">    case 'K': CASEMBC(0x136) CASEMBC(0x1e8) CASEMBC(0x1e30)</a>
<a name="ln846">              CASEMBC(0x1e34)</a>
<a name="ln847">      EMIT2('K'); EMITMBC(0x136) EMITMBC(0x1e8) EMITMBC(0x1e30)</a>
<a name="ln848">      EMITMBC(0x1e34)</a>
<a name="ln849">      return;</a>
<a name="ln850"> </a>
<a name="ln851">    case 'L': CASEMBC(0x139) CASEMBC(0x13b) CASEMBC(0x13d)</a>
<a name="ln852">              CASEMBC(0x13f) CASEMBC(0x141) CASEMBC(0x1e3a)</a>
<a name="ln853">      EMIT2('L'); EMITMBC(0x139) EMITMBC(0x13b) EMITMBC(0x13d)</a>
<a name="ln854">      EMITMBC(0x13f) EMITMBC(0x141) EMITMBC(0x1e3a)</a>
<a name="ln855">      return;</a>
<a name="ln856"> </a>
<a name="ln857">    case 'M': CASEMBC(0x1e3e) CASEMBC(0x1e40)</a>
<a name="ln858">      EMIT2('M'); EMITMBC(0x1e3e) EMITMBC(0x1e40)</a>
<a name="ln859">      return;</a>
<a name="ln860"> </a>
<a name="ln861">    case 'N': case N_virguilla: CASEMBC(0x143) CASEMBC(0x145)</a>
<a name="ln862">              CASEMBC(0x147) CASEMBC(0x1e44) CASEMBC(0x1e48)</a>
<a name="ln863">      EMIT2('N'); EMIT2(N_virguilla);</a>
<a name="ln864">      EMITMBC(0x143) EMITMBC(0x145)</a>
<a name="ln865">      EMITMBC(0x147) EMITMBC(0x1e44) EMITMBC(0x1e48)</a>
<a name="ln866">      return;</a>
<a name="ln867"> </a>
<a name="ln868">    case 'O': case O_grave: case O_acute: case O_circumflex:</a>
<a name="ln869">              case O_virguilla: case O_diaeresis: case O_slash:</a>
<a name="ln870">              CASEMBC(0x14c) CASEMBC(0x14e) CASEMBC(0x150)</a>
<a name="ln871">              CASEMBC(0x1a0) CASEMBC(0x1d1) CASEMBC(0x1ea)</a>
<a name="ln872">              CASEMBC(0x1ec) CASEMBC(0x1ece)</a>
<a name="ln873">      EMIT2('O'); EMIT2(O_grave); EMIT2(O_acute);</a>
<a name="ln874">      EMIT2(O_circumflex); EMIT2(O_virguilla);</a>
<a name="ln875">      EMIT2(O_diaeresis); EMIT2(O_slash);</a>
<a name="ln876">      EMITMBC(0x14c) EMITMBC(0x14e) EMITMBC(0x150)</a>
<a name="ln877">      EMITMBC(0x1a0) EMITMBC(0x1d1) EMITMBC(0x1ea)</a>
<a name="ln878">      EMITMBC(0x1ec) EMITMBC(0x1ece)</a>
<a name="ln879">      return;</a>
<a name="ln880"> </a>
<a name="ln881">    case 'P': case 0x1e54: case 0x1e56:</a>
<a name="ln882">      EMIT2('P'); EMITMBC(0x1e54) EMITMBC(0x1e56)</a>
<a name="ln883">      return;</a>
<a name="ln884"> </a>
<a name="ln885">    case 'R': CASEMBC(0x154) CASEMBC(0x156) CASEMBC(0x158)</a>
<a name="ln886">              CASEMBC(0x1e58) CASEMBC(0x1e5e)</a>
<a name="ln887">      EMIT2('R'); EMITMBC(0x154) EMITMBC(0x156) EMITMBC(0x158)</a>
<a name="ln888">      EMITMBC(0x1e58) EMITMBC(0x1e5e)</a>
<a name="ln889">      return;</a>
<a name="ln890"> </a>
<a name="ln891">    case 'S': CASEMBC(0x15a) CASEMBC(0x15c) CASEMBC(0x15e)</a>
<a name="ln892">              CASEMBC(0x160) CASEMBC(0x1e60)</a>
<a name="ln893">      EMIT2('S'); EMITMBC(0x15a) EMITMBC(0x15c) EMITMBC(0x15e)</a>
<a name="ln894">      EMITMBC(0x160) EMITMBC(0x1e60)</a>
<a name="ln895">      return;</a>
<a name="ln896"> </a>
<a name="ln897">    case 'T': CASEMBC(0x162) CASEMBC(0x164) CASEMBC(0x166)</a>
<a name="ln898">              CASEMBC(0x1e6a) CASEMBC(0x1e6e)</a>
<a name="ln899">      EMIT2('T'); EMITMBC(0x162) EMITMBC(0x164) EMITMBC(0x166)</a>
<a name="ln900">      EMITMBC(0x1e6a) EMITMBC(0x1e6e)</a>
<a name="ln901">      return;</a>
<a name="ln902"> </a>
<a name="ln903">    case 'U': case U_grave: case U_acute: case U_diaeresis:</a>
<a name="ln904">              case U_circumflex: CASEMBC(0x168) CASEMBC(0x16a)</a>
<a name="ln905">              CASEMBC(0x16c) CASEMBC(0x16e) CASEMBC(0x170)</a>
<a name="ln906">              CASEMBC(0x172) CASEMBC(0x1af) CASEMBC(0x1d3)</a>
<a name="ln907">              CASEMBC(0x1ee6)</a>
<a name="ln908">      EMIT2('U'); EMIT2(U_grave); EMIT2(U_acute);</a>
<a name="ln909">      EMIT2(U_diaeresis); EMIT2(U_circumflex);</a>
<a name="ln910">      EMITMBC(0x168) EMITMBC(0x16a)</a>
<a name="ln911">      EMITMBC(0x16c) EMITMBC(0x16e) EMITMBC(0x170)</a>
<a name="ln912">      EMITMBC(0x172) EMITMBC(0x1af) EMITMBC(0x1d3)</a>
<a name="ln913">      EMITMBC(0x1ee6)</a>
<a name="ln914">      return;</a>
<a name="ln915"> </a>
<a name="ln916">    case 'V': CASEMBC(0x1e7c)</a>
<a name="ln917">      EMIT2('V'); EMITMBC(0x1e7c)</a>
<a name="ln918">      return;</a>
<a name="ln919"> </a>
<a name="ln920">    case 'W': CASEMBC(0x174) CASEMBC(0x1e80) CASEMBC(0x1e82)</a>
<a name="ln921">              CASEMBC(0x1e84) CASEMBC(0x1e86)</a>
<a name="ln922">      EMIT2('W'); EMITMBC(0x174) EMITMBC(0x1e80) EMITMBC(0x1e82)</a>
<a name="ln923">      EMITMBC(0x1e84) EMITMBC(0x1e86)</a>
<a name="ln924">      return;</a>
<a name="ln925"> </a>
<a name="ln926">    case 'X': CASEMBC(0x1e8a) CASEMBC(0x1e8c)</a>
<a name="ln927">      EMIT2('X'); EMITMBC(0x1e8a) EMITMBC(0x1e8c)</a>
<a name="ln928">      return;</a>
<a name="ln929"> </a>
<a name="ln930">    case 'Y': case Y_acute: CASEMBC(0x176) CASEMBC(0x178)</a>
<a name="ln931">              CASEMBC(0x1e8e) CASEMBC(0x1ef2) CASEMBC(0x1ef6)</a>
<a name="ln932">              CASEMBC(0x1ef8)</a>
<a name="ln933">      EMIT2('Y'); EMIT2(Y_acute);</a>
<a name="ln934">      EMITMBC(0x176) EMITMBC(0x178)</a>
<a name="ln935">      EMITMBC(0x1e8e) EMITMBC(0x1ef2) EMITMBC(0x1ef6)</a>
<a name="ln936">      EMITMBC(0x1ef8)</a>
<a name="ln937">      return;</a>
<a name="ln938"> </a>
<a name="ln939">    case 'Z': CASEMBC(0x179) CASEMBC(0x17b) CASEMBC(0x17d)</a>
<a name="ln940">              CASEMBC(0x1b5) CASEMBC(0x1e90) CASEMBC(0x1e94)</a>
<a name="ln941">      EMIT2('Z'); EMITMBC(0x179) EMITMBC(0x17b) EMITMBC(0x17d)</a>
<a name="ln942">      EMITMBC(0x1b5) EMITMBC(0x1e90) EMITMBC(0x1e94)</a>
<a name="ln943">      return;</a>
<a name="ln944"> </a>
<a name="ln945">    case 'a': case a_grave: case a_acute: case a_circumflex:</a>
<a name="ln946">              case a_virguilla: case a_diaeresis: case a_ring:</a>
<a name="ln947">              CASEMBC(0x101) CASEMBC(0x103) CASEMBC(0x105)</a>
<a name="ln948">              CASEMBC(0x1ce) CASEMBC(0x1df) CASEMBC(0x1e1)</a>
<a name="ln949">              CASEMBC(0x1ea3)</a>
<a name="ln950">      EMIT2('a'); EMIT2(a_grave); EMIT2(a_acute);</a>
<a name="ln951">      EMIT2(a_circumflex); EMIT2(a_virguilla);</a>
<a name="ln952">      EMIT2(a_diaeresis); EMIT2(a_ring);</a>
<a name="ln953">      EMITMBC(0x101) EMITMBC(0x103) EMITMBC(0x105)</a>
<a name="ln954">      EMITMBC(0x1ce) EMITMBC(0x1df) EMITMBC(0x1e1)</a>
<a name="ln955">      EMITMBC(0x1ea3)</a>
<a name="ln956">      return;</a>
<a name="ln957"> </a>
<a name="ln958">    case 'b': CASEMBC(0x1e03) CASEMBC(0x1e07)</a>
<a name="ln959">      EMIT2('b'); EMITMBC(0x1e03) EMITMBC(0x1e07)</a>
<a name="ln960">      return;</a>
<a name="ln961"> </a>
<a name="ln962">    case 'c': case c_cedilla: CASEMBC(0x107) CASEMBC(0x109)</a>
<a name="ln963">              CASEMBC(0x10b) CASEMBC(0x10d)</a>
<a name="ln964">      EMIT2('c'); EMIT2(c_cedilla);</a>
<a name="ln965">      EMITMBC(0x107) EMITMBC(0x109)</a>
<a name="ln966">      EMITMBC(0x10b) EMITMBC(0x10d)</a>
<a name="ln967">      return;</a>
<a name="ln968"> </a>
<a name="ln969">    case 'd': CASEMBC(0x10f) CASEMBC(0x111) CASEMBC(0x1e0b)</a>
<a name="ln970">              CASEMBC(0x1e0f) CASEMBC(0x1e11)</a>
<a name="ln971">      EMIT2('d'); EMITMBC(0x10f) EMITMBC(0x111) EMITMBC(0x1e0b)</a>
<a name="ln972">      EMITMBC(0x1e0f) EMITMBC(0x1e11)</a>
<a name="ln973">      return;</a>
<a name="ln974"> </a>
<a name="ln975">    case 'e': case e_grave: case e_acute: case e_circumflex:</a>
<a name="ln976">              case e_diaeresis: CASEMBC(0x113) CASEMBC(0x115)</a>
<a name="ln977">              CASEMBC(0x117) CASEMBC(0x119) CASEMBC(0x11b)</a>
<a name="ln978">              CASEMBC(0x1ebb) CASEMBC(0x1ebd)</a>
<a name="ln979">      EMIT2('e'); EMIT2(e_grave); EMIT2(e_acute);</a>
<a name="ln980">      EMIT2(e_circumflex); EMIT2(e_diaeresis);</a>
<a name="ln981">      EMITMBC(0x113) EMITMBC(0x115)</a>
<a name="ln982">      EMITMBC(0x117) EMITMBC(0x119) EMITMBC(0x11b)</a>
<a name="ln983">      EMITMBC(0x1ebb) EMITMBC(0x1ebd)</a>
<a name="ln984">      return;</a>
<a name="ln985"> </a>
<a name="ln986">    case 'f': CASEMBC(0x1e1f)</a>
<a name="ln987">      EMIT2('f'); EMITMBC(0x1e1f)</a>
<a name="ln988">      return;</a>
<a name="ln989"> </a>
<a name="ln990">    case 'g': CASEMBC(0x11d) CASEMBC(0x11f) CASEMBC(0x121)</a>
<a name="ln991">              CASEMBC(0x123) CASEMBC(0x1e5) CASEMBC(0x1e7)</a>
<a name="ln992">              CASEMBC(0x1f5) CASEMBC(0x1e21)</a>
<a name="ln993">      EMIT2('g'); EMITMBC(0x11d) EMITMBC(0x11f) EMITMBC(0x121)</a>
<a name="ln994">      EMITMBC(0x123) EMITMBC(0x1e5) EMITMBC(0x1e7)</a>
<a name="ln995">      EMITMBC(0x1f5) EMITMBC(0x1e21)</a>
<a name="ln996">      return;</a>
<a name="ln997"> </a>
<a name="ln998">    case 'h': CASEMBC(0x125) CASEMBC(0x127) CASEMBC(0x1e23)</a>
<a name="ln999">              CASEMBC(0x1e27) CASEMBC(0x1e29) CASEMBC(0x1e96)</a>
<a name="ln1000">      EMIT2('h'); EMITMBC(0x125) EMITMBC(0x127) EMITMBC(0x1e23)</a>
<a name="ln1001">      EMITMBC(0x1e27) EMITMBC(0x1e29) EMITMBC(0x1e96)</a>
<a name="ln1002">      return;</a>
<a name="ln1003"> </a>
<a name="ln1004">    case 'i': case i_grave: case i_acute: case i_circumflex:</a>
<a name="ln1005">              case i_diaeresis: CASEMBC(0x129) CASEMBC(0x12b)</a>
<a name="ln1006">              CASEMBC(0x12d) CASEMBC(0x12f) CASEMBC(0x1d0)</a>
<a name="ln1007">              CASEMBC(0x1ec9)</a>
<a name="ln1008">      EMIT2('i'); EMIT2(i_grave); EMIT2(i_acute);</a>
<a name="ln1009">      EMIT2(i_circumflex); EMIT2(i_diaeresis);</a>
<a name="ln1010">      EMITMBC(0x129) EMITMBC(0x12b)</a>
<a name="ln1011">      EMITMBC(0x12d) EMITMBC(0x12f) EMITMBC(0x1d0)</a>
<a name="ln1012">      EMITMBC(0x1ec9)</a>
<a name="ln1013">      return;</a>
<a name="ln1014"> </a>
<a name="ln1015">    case 'j': CASEMBC(0x135) CASEMBC(0x1f0)</a>
<a name="ln1016">      EMIT2('j'); EMITMBC(0x135) EMITMBC(0x1f0)</a>
<a name="ln1017">      return;</a>
<a name="ln1018"> </a>
<a name="ln1019">    case 'k': CASEMBC(0x137) CASEMBC(0x1e9) CASEMBC(0x1e31)</a>
<a name="ln1020">              CASEMBC(0x1e35)</a>
<a name="ln1021">      EMIT2('k'); EMITMBC(0x137) EMITMBC(0x1e9) EMITMBC(0x1e31)</a>
<a name="ln1022">      EMITMBC(0x1e35)</a>
<a name="ln1023">      return;</a>
<a name="ln1024"> </a>
<a name="ln1025">    case 'l': CASEMBC(0x13a) CASEMBC(0x13c) CASEMBC(0x13e)</a>
<a name="ln1026">              CASEMBC(0x140) CASEMBC(0x142) CASEMBC(0x1e3b)</a>
<a name="ln1027">      EMIT2('l'); EMITMBC(0x13a) EMITMBC(0x13c) EMITMBC(0x13e)</a>
<a name="ln1028">      EMITMBC(0x140) EMITMBC(0x142) EMITMBC(0x1e3b)</a>
<a name="ln1029">      return;</a>
<a name="ln1030"> </a>
<a name="ln1031">    case 'm': CASEMBC(0x1e3f) CASEMBC(0x1e41)</a>
<a name="ln1032">      EMIT2('m'); EMITMBC(0x1e3f) EMITMBC(0x1e41)</a>
<a name="ln1033">      return;</a>
<a name="ln1034"> </a>
<a name="ln1035">    case 'n': case n_virguilla: CASEMBC(0x144) CASEMBC(0x146)</a>
<a name="ln1036">              CASEMBC(0x148) CASEMBC(0x149) CASEMBC(0x1e45)</a>
<a name="ln1037">              CASEMBC(0x1e49)</a>
<a name="ln1038">      EMIT2('n'); EMIT2(n_virguilla);</a>
<a name="ln1039">      EMITMBC(0x144) EMITMBC(0x146)</a>
<a name="ln1040">      EMITMBC(0x148) EMITMBC(0x149) EMITMBC(0x1e45)</a>
<a name="ln1041">      EMITMBC(0x1e49)</a>
<a name="ln1042">      return;</a>
<a name="ln1043"> </a>
<a name="ln1044">    case 'o': case o_grave: case o_acute: case o_circumflex:</a>
<a name="ln1045">              case o_virguilla: case o_diaeresis: case o_slash:</a>
<a name="ln1046">              CASEMBC(0x14d) CASEMBC(0x14f) CASEMBC(0x151)</a>
<a name="ln1047">              CASEMBC(0x1a1) CASEMBC(0x1d2) CASEMBC(0x1eb)</a>
<a name="ln1048">              CASEMBC(0x1ed) CASEMBC(0x1ecf)</a>
<a name="ln1049">      EMIT2('o'); EMIT2(o_grave); EMIT2(o_acute);</a>
<a name="ln1050">      EMIT2(o_circumflex); EMIT2(o_virguilla);</a>
<a name="ln1051">      EMIT2(o_diaeresis); EMIT2(o_slash);</a>
<a name="ln1052">      EMITMBC(0x14d) EMITMBC(0x14f) EMITMBC(0x151)</a>
<a name="ln1053">      EMITMBC(0x1a1) EMITMBC(0x1d2) EMITMBC(0x1eb)</a>
<a name="ln1054">      EMITMBC(0x1ed) EMITMBC(0x1ecf)</a>
<a name="ln1055">      return;</a>
<a name="ln1056"> </a>
<a name="ln1057">    case 'p': CASEMBC(0x1e55) CASEMBC(0x1e57)</a>
<a name="ln1058">      EMIT2('p'); EMITMBC(0x1e55) EMITMBC(0x1e57)</a>
<a name="ln1059">      return;</a>
<a name="ln1060"> </a>
<a name="ln1061">    case 'r': CASEMBC(0x155) CASEMBC(0x157) CASEMBC(0x159)</a>
<a name="ln1062">              CASEMBC(0x1e59) CASEMBC(0x1e5f)</a>
<a name="ln1063">      EMIT2('r'); EMITMBC(0x155) EMITMBC(0x157) EMITMBC(0x159)</a>
<a name="ln1064">      EMITMBC(0x1e59) EMITMBC(0x1e5f)</a>
<a name="ln1065">      return;</a>
<a name="ln1066"> </a>
<a name="ln1067">    case 's': CASEMBC(0x15b) CASEMBC(0x15d) CASEMBC(0x15f)</a>
<a name="ln1068">              CASEMBC(0x161) CASEMBC(0x1e61)</a>
<a name="ln1069">      EMIT2('s'); EMITMBC(0x15b) EMITMBC(0x15d) EMITMBC(0x15f)</a>
<a name="ln1070">      EMITMBC(0x161) EMITMBC(0x1e61)</a>
<a name="ln1071">      return;</a>
<a name="ln1072"> </a>
<a name="ln1073">    case 't': CASEMBC(0x163) CASEMBC(0x165) CASEMBC(0x167)</a>
<a name="ln1074">              CASEMBC(0x1e6b) CASEMBC(0x1e6f) CASEMBC(0x1e97)</a>
<a name="ln1075">      EMIT2('t'); EMITMBC(0x163) EMITMBC(0x165) EMITMBC(0x167)</a>
<a name="ln1076">      EMITMBC(0x1e6b) EMITMBC(0x1e6f) EMITMBC(0x1e97)</a>
<a name="ln1077">      return;</a>
<a name="ln1078"> </a>
<a name="ln1079">    case 'u': case u_grave: case u_acute: case u_circumflex:</a>
<a name="ln1080">              case u_diaeresis: CASEMBC(0x169) CASEMBC(0x16b)</a>
<a name="ln1081">              CASEMBC(0x16d) CASEMBC(0x16f) CASEMBC(0x171)</a>
<a name="ln1082">              CASEMBC(0x173) CASEMBC(0x1b0) CASEMBC(0x1d4)</a>
<a name="ln1083">              CASEMBC(0x1ee7)</a>
<a name="ln1084">      EMIT2('u'); EMIT2(u_grave); EMIT2(u_acute);</a>
<a name="ln1085">      EMIT2(u_circumflex); EMIT2(u_diaeresis);</a>
<a name="ln1086">      EMITMBC(0x169) EMITMBC(0x16b)</a>
<a name="ln1087">      EMITMBC(0x16d) EMITMBC(0x16f) EMITMBC(0x171)</a>
<a name="ln1088">      EMITMBC(0x173) EMITMBC(0x1b0) EMITMBC(0x1d4)</a>
<a name="ln1089">      EMITMBC(0x1ee7)</a>
<a name="ln1090">      return;</a>
<a name="ln1091"> </a>
<a name="ln1092">    case 'v': CASEMBC(0x1e7d)</a>
<a name="ln1093">      EMIT2('v'); EMITMBC(0x1e7d)</a>
<a name="ln1094">      return;</a>
<a name="ln1095"> </a>
<a name="ln1096">    case 'w': CASEMBC(0x175) CASEMBC(0x1e81) CASEMBC(0x1e83)</a>
<a name="ln1097">              CASEMBC(0x1e85) CASEMBC(0x1e87) CASEMBC(0x1e98)</a>
<a name="ln1098">      EMIT2('w'); EMITMBC(0x175) EMITMBC(0x1e81) EMITMBC(0x1e83)</a>
<a name="ln1099">      EMITMBC(0x1e85) EMITMBC(0x1e87) EMITMBC(0x1e98)</a>
<a name="ln1100">      return;</a>
<a name="ln1101"> </a>
<a name="ln1102">    case 'x': CASEMBC(0x1e8b) CASEMBC(0x1e8d)</a>
<a name="ln1103">      EMIT2('x'); EMITMBC(0x1e8b) EMITMBC(0x1e8d)</a>
<a name="ln1104">      return;</a>
<a name="ln1105"> </a>
<a name="ln1106">    case 'y': case y_acute: case y_diaeresis: CASEMBC(0x177)</a>
<a name="ln1107">              CASEMBC(0x1e8f) CASEMBC(0x1e99) CASEMBC(0x1ef3)</a>
<a name="ln1108">              CASEMBC(0x1ef7) CASEMBC(0x1ef9)</a>
<a name="ln1109">      EMIT2('y'); EMIT2(y_acute); EMIT2(y_diaeresis);</a>
<a name="ln1110">      EMITMBC(0x177)</a>
<a name="ln1111">      EMITMBC(0x1e8f) EMITMBC(0x1e99) EMITMBC(0x1ef3)</a>
<a name="ln1112">      EMITMBC(0x1ef7) EMITMBC(0x1ef9)</a>
<a name="ln1113">      return;</a>
<a name="ln1114"> </a>
<a name="ln1115">    case 'z': CASEMBC(0x17a) CASEMBC(0x17c) CASEMBC(0x17e)</a>
<a name="ln1116">              CASEMBC(0x1b6) CASEMBC(0x1e91) CASEMBC(0x1e95)</a>
<a name="ln1117">      EMIT2('z'); EMITMBC(0x17a) EMITMBC(0x17c) EMITMBC(0x17e)</a>
<a name="ln1118">      EMITMBC(0x1b6) EMITMBC(0x1e91) EMITMBC(0x1e95)</a>
<a name="ln1119">      return;</a>
<a name="ln1120"> </a>
<a name="ln1121">      /* default: character itself */</a>
<a name="ln1122">    }</a>
<a name="ln1123">  }</a>
<a name="ln1124"> </a>
<a name="ln1125">  EMIT2(c);</a>
<a name="ln1126">#undef EMIT2</a>
<a name="ln1127">#undef EMITMBC</a>
<a name="ln1128">}</a>
<a name="ln1129"> </a>
<a name="ln1130">/*</a>
<a name="ln1131"> * Code to parse regular expression.</a>
<a name="ln1132"> *</a>
<a name="ln1133"> * We try to reuse parsing functions in regexp.c to</a>
<a name="ln1134"> * minimize surprise and keep the syntax consistent.</a>
<a name="ln1135"> */</a>
<a name="ln1136"> </a>
<a name="ln1137">/*</a>
<a name="ln1138"> * Parse the lowest level.</a>
<a name="ln1139"> *</a>
<a name="ln1140"> * An atom can be one of a long list of items.  Many atoms match one character</a>
<a name="ln1141"> * in the text.  It is often an ordinary character or a character class.</a>
<a name="ln1142"> * Braces can be used to make a pattern into an atom.  The &quot;\z(\)&quot; construct</a>
<a name="ln1143"> * is only for syntax highlighting.</a>
<a name="ln1144"> *</a>
<a name="ln1145"> * atom    ::=     ordinary-atom</a>
<a name="ln1146"> *     or  \( pattern \)</a>
<a name="ln1147"> *     or  \%( pattern \)</a>
<a name="ln1148"> *     or  \z( pattern \)</a>
<a name="ln1149"> */</a>
<a name="ln1150">static int nfa_regatom(void)</a>
<a name="ln1151">{</a>
<a name="ln1152">  int c;</a>
<a name="ln1153">  int charclass;</a>
<a name="ln1154">  int equiclass;</a>
<a name="ln1155">  int collclass;</a>
<a name="ln1156">  int got_coll_char;</a>
<a name="ln1157">  char_u      *p;</a>
<a name="ln1158">  char_u      *endp;</a>
<a name="ln1159">  char_u      *old_regparse = regparse;</a>
<a name="ln1160">  int extra = 0;</a>
<a name="ln1161">  int emit_range;</a>
<a name="ln1162">  int negated;</a>
<a name="ln1163">  int startc = -1;</a>
<a name="ln1164">  int save_prev_at_start = prev_at_start;</a>
<a name="ln1165"> </a>
<a name="ln1166">  c = getchr();</a>
<a name="ln1167">  switch (c) {</a>
<a name="ln1168">  case NUL:</a>
<a name="ln1169">    EMSG_RET_FAIL(_(e_nul_found));</a>
<a name="ln1170"> </a>
<a name="ln1171">  case Magic('^'):</a>
<a name="ln1172">    EMIT(NFA_BOL);</a>
<a name="ln1173">    break;</a>
<a name="ln1174"> </a>
<a name="ln1175">  case Magic('$'):</a>
<a name="ln1176">    EMIT(NFA_EOL);</a>
<a name="ln1177">    had_eol = true;</a>
<a name="ln1178">    break;</a>
<a name="ln1179"> </a>
<a name="ln1180">  case Magic('&lt;'):</a>
<a name="ln1181">    EMIT(NFA_BOW);</a>
<a name="ln1182">    break;</a>
<a name="ln1183"> </a>
<a name="ln1184">  case Magic('&gt;'):</a>
<a name="ln1185">    EMIT(NFA_EOW);</a>
<a name="ln1186">    break;</a>
<a name="ln1187"> </a>
<a name="ln1188">  case Magic('_'):</a>
<a name="ln1189">    c = no_Magic(getchr());</a>
<a name="ln1190">    if (c == NUL)</a>
<a name="ln1191">      EMSG_RET_FAIL(_(e_nul_found));</a>
<a name="ln1192"> </a>
<a name="ln1193">    if (c == '^') {             /* &quot;\_^&quot; is start-of-line */</a>
<a name="ln1194">      EMIT(NFA_BOL);</a>
<a name="ln1195">      break;</a>
<a name="ln1196">    }</a>
<a name="ln1197">    if (c == '$') {             /* &quot;\_$&quot; is end-of-line */</a>
<a name="ln1198">      EMIT(NFA_EOL);</a>
<a name="ln1199">      had_eol = true;</a>
<a name="ln1200">      break;</a>
<a name="ln1201">    }</a>
<a name="ln1202"> </a>
<a name="ln1203">    extra = NFA_ADD_NL;</a>
<a name="ln1204"> </a>
<a name="ln1205">    /* &quot;\_[&quot; is collection plus newline */</a>
<a name="ln1206">    if (c == '[')</a>
<a name="ln1207">      goto collection;</a>
<a name="ln1208"> </a>
<a name="ln1209">  // &quot;\_x&quot; is character class plus newline</a>
<a name="ln1210">  FALLTHROUGH;</a>
<a name="ln1211"> </a>
<a name="ln1212">  /*</a>
<a name="ln1213">   * Character classes.</a>
<a name="ln1214">   */</a>
<a name="ln1215">  case Magic('.'):</a>
<a name="ln1216">  case Magic('i'):</a>
<a name="ln1217">  case Magic('I'):</a>
<a name="ln1218">  case Magic('k'):</a>
<a name="ln1219">  case Magic('K'):</a>
<a name="ln1220">  case Magic('f'):</a>
<a name="ln1221">  case Magic('F'):</a>
<a name="ln1222">  case Magic('p'):</a>
<a name="ln1223">  case Magic('P'):</a>
<a name="ln1224">  case Magic('s'):</a>
<a name="ln1225">  case Magic('S'):</a>
<a name="ln1226">  case Magic('d'):</a>
<a name="ln1227">  case Magic('D'):</a>
<a name="ln1228">  case Magic('x'):</a>
<a name="ln1229">  case Magic('X'):</a>
<a name="ln1230">  case Magic('o'):</a>
<a name="ln1231">  case Magic('O'):</a>
<a name="ln1232">  case Magic('w'):</a>
<a name="ln1233">  case Magic('W'):</a>
<a name="ln1234">  case Magic('h'):</a>
<a name="ln1235">  case Magic('H'):</a>
<a name="ln1236">  case Magic('a'):</a>
<a name="ln1237">  case Magic('A'):</a>
<a name="ln1238">  case Magic('l'):</a>
<a name="ln1239">  case Magic('L'):</a>
<a name="ln1240">  case Magic('u'):</a>
<a name="ln1241">  case Magic('U'):</a>
<a name="ln1242">    p = vim_strchr(classchars, no_Magic(c));</a>
<a name="ln1243">    if (p == NULL) {</a>
<a name="ln1244">      if (extra == NFA_ADD_NL) {</a>
<a name="ln1245">        EMSGN(_(e_ill_char_class), c);</a>
<a name="ln1246">        rc_did_emsg = true;</a>
<a name="ln1247">        return FAIL;</a>
<a name="ln1248">      }</a>
<a name="ln1249">      IEMSGN(&quot;INTERNAL: Unknown character class char: %&quot; PRId64, c);</a>
<a name="ln1250">      return FAIL;</a>
<a name="ln1251">    }</a>
<a name="ln1252">    // When '.' is followed by a composing char ignore the dot, so that</a>
<a name="ln1253">    // the composing char is matched here.</a>
<a name="ln1254">    if (c == Magic('.') &amp;&amp; utf_iscomposing(peekchr())) {</a>
<a name="ln1255">      old_regparse = regparse;</a>
<a name="ln1256">      c = getchr();</a>
<a name="ln1257">      goto nfa_do_multibyte;</a>
<a name="ln1258">    }</a>
<a name="ln1259">    EMIT(nfa_classcodes[p - classchars]);</a>
<a name="ln1260">    if (extra == NFA_ADD_NL) {</a>
<a name="ln1261">      EMIT(NFA_NEWL);</a>
<a name="ln1262">      EMIT(NFA_OR);</a>
<a name="ln1263">      regflags |= RF_HASNL;</a>
<a name="ln1264">    }</a>
<a name="ln1265">    break;</a>
<a name="ln1266"> </a>
<a name="ln1267">  case Magic('n'):</a>
<a name="ln1268">    if (reg_string) {</a>
<a name="ln1269">      // In a string &quot;\n&quot; matches a newline character.</a>
<a name="ln1270">      EMIT(NL);</a>
<a name="ln1271">    } else {</a>
<a name="ln1272">      // In buffer text &quot;\n&quot; matches the end of a line.</a>
<a name="ln1273">      EMIT(NFA_NEWL);</a>
<a name="ln1274">      regflags |= RF_HASNL;</a>
<a name="ln1275">    }</a>
<a name="ln1276">    break;</a>
<a name="ln1277"> </a>
<a name="ln1278">  case Magic('('):</a>
<a name="ln1279">    if (nfa_reg(REG_PAREN) == FAIL) {</a>
<a name="ln1280">      return FAIL;                  // cascaded error</a>
<a name="ln1281">    }</a>
<a name="ln1282">    break;</a>
<a name="ln1283"> </a>
<a name="ln1284">  case Magic('|'):</a>
<a name="ln1285">  case Magic('&amp;'):</a>
<a name="ln1286">  case Magic(')'):</a>
<a name="ln1287">    EMSGN(_(e_misplaced), no_Magic(c));  // -V1037</a>
<a name="ln1288">    return FAIL;</a>
<a name="ln1289"> </a>
<a name="ln1290">  case Magic('='):</a>
<a name="ln1291">  case Magic('?'):</a>
<a name="ln1292">  case Magic('+'):</a>
<a name="ln1293">  case Magic('@'):</a>
<a name="ln1294">  case Magic('*'):</a>
<a name="ln1295">  case Magic('{'):</a>
<a name="ln1296">    // these should follow an atom, not form an atom</a>
<a name="ln1297">    EMSGN(_(e_misplaced), no_Magic(c));</a>
<a name="ln1298">    return FAIL;</a>
<a name="ln1299"> </a>
<a name="ln1300">  case Magic('~'):</a>
<a name="ln1301">  {</a>
<a name="ln1302">    char_u      *lp;</a>
<a name="ln1303"> </a>
<a name="ln1304">    // Previous substitute pattern.</a>
<a name="ln1305">    // Generated as &quot;\%(pattern\)&quot;.</a>
<a name="ln1306">    if (reg_prev_sub == NULL) {</a>
<a name="ln1307">      EMSG(_(e_nopresub));</a>
<a name="ln1308">      return FAIL;</a>
<a name="ln1309">    }</a>
<a name="ln1310">    for (lp = reg_prev_sub; *lp != NUL; MB_CPTR_ADV(lp)) {</a>
<a name="ln1311">      EMIT(PTR2CHAR(lp));</a>
<a name="ln1312">      if (lp != reg_prev_sub)</a>
<a name="ln1313">        EMIT(NFA_CONCAT);</a>
<a name="ln1314">    }</a>
<a name="ln1315">    EMIT(NFA_NOPEN);</a>
<a name="ln1316">    break;</a>
<a name="ln1317">  }</a>
<a name="ln1318"> </a>
<a name="ln1319">  case Magic('1'):</a>
<a name="ln1320">  case Magic('2'):</a>
<a name="ln1321">  case Magic('3'):</a>
<a name="ln1322">  case Magic('4'):</a>
<a name="ln1323">  case Magic('5'):</a>
<a name="ln1324">  case Magic('6'):</a>
<a name="ln1325">  case Magic('7'):</a>
<a name="ln1326">  case Magic('8'):</a>
<a name="ln1327">  case Magic('9'):</a>
<a name="ln1328">    {</a>
<a name="ln1329">      int refnum = no_Magic(c) - '1';</a>
<a name="ln1330"> </a>
<a name="ln1331">      if (!seen_endbrace(refnum + 1)) {</a>
<a name="ln1332">          return FAIL;</a>
<a name="ln1333">      }</a>
<a name="ln1334">      EMIT(NFA_BACKREF1 + refnum);</a>
<a name="ln1335">      rex.nfa_has_backref = true;</a>
<a name="ln1336">    }</a>
<a name="ln1337">    break;</a>
<a name="ln1338"> </a>
<a name="ln1339">  case Magic('z'):</a>
<a name="ln1340">    c = no_Magic(getchr());</a>
<a name="ln1341">    switch (c) {</a>
<a name="ln1342">    case 's':</a>
<a name="ln1343">      EMIT(NFA_ZSTART);</a>
<a name="ln1344">      if (!re_mult_next(&quot;\\zs&quot;)) {</a>
<a name="ln1345">        return false;</a>
<a name="ln1346">      }</a>
<a name="ln1347">      break;</a>
<a name="ln1348">    case 'e':</a>
<a name="ln1349">      EMIT(NFA_ZEND);</a>
<a name="ln1350">      rex.nfa_has_zend = true;</a>
<a name="ln1351">      if (!re_mult_next(&quot;\\zs&quot;)) {</a>
<a name="ln1352">        return false;</a>
<a name="ln1353">      }</a>
<a name="ln1354">      break;</a>
<a name="ln1355">    case '1':</a>
<a name="ln1356">    case '2':</a>
<a name="ln1357">    case '3':</a>
<a name="ln1358">    case '4':</a>
<a name="ln1359">    case '5':</a>
<a name="ln1360">    case '6':</a>
<a name="ln1361">    case '7':</a>
<a name="ln1362">    case '8':</a>
<a name="ln1363">    case '9':</a>
<a name="ln1364">      // \z1...\z9</a>
<a name="ln1365">      if ((reg_do_extmatch &amp; REX_USE) == 0) {</a>
<a name="ln1366">        EMSG_RET_FAIL(_(e_z1_not_allowed));</a>
<a name="ln1367">      }</a>
<a name="ln1368">      EMIT(NFA_ZREF1 + (no_Magic(c) - '1'));</a>
<a name="ln1369">      // No need to set rex.nfa_has_backref, the sub-matches don't</a>
<a name="ln1370">      // change when \z1 .. \z9 matches or not.</a>
<a name="ln1371">      re_has_z = REX_USE;</a>
<a name="ln1372">      break;</a>
<a name="ln1373">    case '(':</a>
<a name="ln1374">      // \z(</a>
<a name="ln1375">      if (reg_do_extmatch != REX_SET) {</a>
<a name="ln1376">        EMSG_RET_FAIL(_(e_z_not_allowed));</a>
<a name="ln1377">      }</a>
<a name="ln1378">      if (nfa_reg(REG_ZPAREN) == FAIL) {</a>
<a name="ln1379">        return FAIL;                        // cascaded error</a>
<a name="ln1380">      }</a>
<a name="ln1381">      re_has_z = REX_SET;</a>
<a name="ln1382">      break;</a>
<a name="ln1383">    default:</a>
<a name="ln1384">      emsgf(_(&quot;E867: (NFA) Unknown operator '\\z%c'&quot;),</a>
<a name="ln1385">            no_Magic(c));</a>
<a name="ln1386">      return FAIL;</a>
<a name="ln1387">    }</a>
<a name="ln1388">    break;</a>
<a name="ln1389"> </a>
<a name="ln1390">  case Magic('%'):</a>
<a name="ln1391">    c = no_Magic(getchr());</a>
<a name="ln1392">    switch (c) {</a>
<a name="ln1393">    /* () without a back reference */</a>
<a name="ln1394">    case '(':</a>
<a name="ln1395">      if (nfa_reg(REG_NPAREN) == FAIL)</a>
<a name="ln1396">        return FAIL;</a>
<a name="ln1397">      EMIT(NFA_NOPEN);</a>
<a name="ln1398">      break;</a>
<a name="ln1399"> </a>
<a name="ln1400">    case 'd':               /* %d123 decimal */</a>
<a name="ln1401">    case 'o':               /* %o123 octal */</a>
<a name="ln1402">    case 'x':               /* %xab hex 2 */</a>
<a name="ln1403">    case 'u':               /* %uabcd hex 4 */</a>
<a name="ln1404">    case 'U':               /* %U1234abcd hex 8 */</a>
<a name="ln1405">    {</a>
<a name="ln1406">      int64_t nr;</a>
<a name="ln1407"> </a>
<a name="ln1408">      switch (c) {</a>
<a name="ln1409">      case 'd': nr = getdecchrs(); break;</a>
<a name="ln1410">      case 'o': nr = getoctchrs(); break;</a>
<a name="ln1411">      case 'x': nr = gethexchrs(2); break;</a>
<a name="ln1412">      case 'u': nr = gethexchrs(4); break;</a>
<a name="ln1413">      case 'U': nr = gethexchrs(8); break;</a>
<a name="ln1414">      default:  nr = -1; break;</a>
<a name="ln1415">      }</a>
<a name="ln1416"> </a>
<a name="ln1417">      if (nr &lt; 0 || nr &gt; INT_MAX) {</a>
<a name="ln1418">        EMSG2_RET_FAIL(_(&quot;E678: Invalid character after %s%%[dxouU]&quot;),</a>
<a name="ln1419">                       reg_magic == MAGIC_ALL);</a>
<a name="ln1420">      }</a>
<a name="ln1421">      // A NUL is stored in the text as NL</a>
<a name="ln1422">      // TODO(vim): what if a composing character follows?</a>
<a name="ln1423">      EMIT(nr == 0 ? 0x0a : nr);</a>
<a name="ln1424">    }</a>
<a name="ln1425">    break;</a>
<a name="ln1426"> </a>
<a name="ln1427">    /* Catch \%^ and \%$ regardless of where they appear in the</a>
<a name="ln1428">     * pattern -- regardless of whether or not it makes sense. */</a>
<a name="ln1429">    case '^':</a>
<a name="ln1430">      EMIT(NFA_BOF);</a>
<a name="ln1431">      break;</a>
<a name="ln1432"> </a>
<a name="ln1433">    case '$':</a>
<a name="ln1434">      EMIT(NFA_EOF);</a>
<a name="ln1435">      break;</a>
<a name="ln1436"> </a>
<a name="ln1437">    case '#':</a>
<a name="ln1438">      EMIT(NFA_CURSOR);</a>
<a name="ln1439">      break;</a>
<a name="ln1440"> </a>
<a name="ln1441">    case 'V':</a>
<a name="ln1442">      EMIT(NFA_VISUAL);</a>
<a name="ln1443">      break;</a>
<a name="ln1444"> </a>
<a name="ln1445">    case 'C':</a>
<a name="ln1446">      EMIT(NFA_ANY_COMPOSING);</a>
<a name="ln1447">      break;</a>
<a name="ln1448"> </a>
<a name="ln1449">    case '[':</a>
<a name="ln1450">    {</a>
<a name="ln1451">      int n;</a>
<a name="ln1452"> </a>
<a name="ln1453">      /* \%[abc] */</a>
<a name="ln1454">      for (n = 0; (c = peekchr()) != ']'; ++n) {</a>
<a name="ln1455">        if (c == NUL)</a>
<a name="ln1456">          EMSG2_RET_FAIL(_(e_missing_sb),</a>
<a name="ln1457">              reg_magic == MAGIC_ALL);</a>
<a name="ln1458">        /* recursive call! */</a>
<a name="ln1459">        if (nfa_regatom() == FAIL)</a>
<a name="ln1460">          return FAIL;</a>
<a name="ln1461">      }</a>
<a name="ln1462">      (void)getchr();  // get the ]</a>
<a name="ln1463">      if (n == 0) {</a>
<a name="ln1464">        EMSG2_RET_FAIL(_(e_empty_sb), reg_magic == MAGIC_ALL);</a>
<a name="ln1465">      }</a>
<a name="ln1466">      EMIT(NFA_OPT_CHARS);</a>
<a name="ln1467">      EMIT(n);</a>
<a name="ln1468"> </a>
<a name="ln1469">      /* Emit as &quot;\%(\%[abc]\)&quot; to be able to handle</a>
<a name="ln1470">       * &quot;\%[abc]*&quot; which would cause the empty string to be</a>
<a name="ln1471">       * matched an unlimited number of times. NFA_NOPEN is</a>
<a name="ln1472">       * added only once at a position, while NFA_SPLIT is</a>
<a name="ln1473">       * added multiple times.  This is more efficient than</a>
<a name="ln1474">       * not allowing NFA_SPLIT multiple times, it is used</a>
<a name="ln1475">       * a lot. */</a>
<a name="ln1476">      EMIT(NFA_NOPEN);</a>
<a name="ln1477">      break;</a>
<a name="ln1478">    }</a>
<a name="ln1479"> </a>
<a name="ln1480">    default:</a>
<a name="ln1481">    {</a>
<a name="ln1482">      int64_t n = 0;</a>
<a name="ln1483">      const int cmp = c;</a>
<a name="ln1484"> </a>
<a name="ln1485">      if (c == '&lt;' || c == '&gt;')</a>
<a name="ln1486">        c = getchr();</a>
<a name="ln1487">      while (ascii_isdigit(c)) {</a>
<a name="ln1488">        if (n &gt; (INT32_MAX - (c - '0')) / 10) {</a>
<a name="ln1489">          // overflow.</a>
<a name="ln1490">          EMSG(_(e_value_too_large));</a>
<a name="ln1491">          return FAIL;</a>
<a name="ln1492">        }</a>
<a name="ln1493">        n = n * 10 + (c - '0');</a>
<a name="ln1494">        c = getchr();</a>
<a name="ln1495">      }</a>
<a name="ln1496">      if (c == 'l' || c == 'c' || c == 'v') {</a>
<a name="ln1497">        int32_t limit = INT32_MAX;</a>
<a name="ln1498"> </a>
<a name="ln1499">        if (c == 'l') {</a>
<a name="ln1500">          // \%{n}l  \%{n}&lt;l  \%{n}&gt;l</a>
<a name="ln1501">          EMIT(cmp == '&lt;' ? NFA_LNUM_LT :</a>
<a name="ln1502">               cmp == '&gt;' ? NFA_LNUM_GT : NFA_LNUM);</a>
<a name="ln1503">          if (save_prev_at_start) {</a>
<a name="ln1504">            at_start = true;</a>
<a name="ln1505">          }</a>
<a name="ln1506">        } else if (c == 'c') {</a>
<a name="ln1507">          // \%{n}c  \%{n}&lt;c  \%{n}&gt;c</a>
<a name="ln1508">          EMIT(cmp == '&lt;' ? NFA_COL_LT :</a>
<a name="ln1509">               cmp == '&gt;' ? NFA_COL_GT : NFA_COL);</a>
<a name="ln1510">        } else {</a>
<a name="ln1511">          // \%{n}v  \%{n}&lt;v  \%{n}&gt;v</a>
<a name="ln1512">          EMIT(cmp == '&lt;' ? NFA_VCOL_LT :</a>
<a name="ln1513">               cmp == '&gt;' ? NFA_VCOL_GT : NFA_VCOL);</a>
<a name="ln1514">          limit = INT32_MAX / MB_MAXBYTES;</a>
<a name="ln1515">        }</a>
<a name="ln1516">        if (n &gt;= limit) {</a>
<a name="ln1517">          EMSG(_(e_value_too_large));</a>
<a name="ln1518">          return FAIL;</a>
<a name="ln1519">        }</a>
<a name="ln1520">        EMIT((int)n);</a>
<a name="ln1521">        break;</a>
<a name="ln1522">      } else if (c == '\'' &amp;&amp; n == 0) {</a>
<a name="ln1523">        /* \%'m  \%&lt;'m  \%&gt;'m  */</a>
<a name="ln1524">        EMIT(cmp == '&lt;' ? NFA_MARK_LT :</a>
<a name="ln1525">            cmp == '&gt;' ? NFA_MARK_GT : NFA_MARK);</a>
<a name="ln1526">        EMIT(getchr());</a>
<a name="ln1527">        break;</a>
<a name="ln1528">      }</a>
<a name="ln1529">    }</a>
<a name="ln1530">      emsgf(_(&quot;E867: (NFA) Unknown operator '\\%%%c'&quot;),</a>
<a name="ln1531">            no_Magic(c));</a>
<a name="ln1532">      return FAIL;</a>
<a name="ln1533">    }</a>
<a name="ln1534">    break;</a>
<a name="ln1535"> </a>
<a name="ln1536">  case Magic('['):</a>
<a name="ln1537">collection:</a>
<a name="ln1538">    /*</a>
<a name="ln1539">     * [abc]  uses NFA_START_COLL - NFA_END_COLL</a>
<a name="ln1540">     * [^abc] uses NFA_START_NEG_COLL - NFA_END_NEG_COLL</a>
<a name="ln1541">     * Each character is produced as a regular state, using</a>
<a name="ln1542">     * NFA_CONCAT to bind them together.</a>
<a name="ln1543">     * Besides normal characters there can be:</a>
<a name="ln1544">     * - character classes  NFA_CLASS_*</a>
<a name="ln1545">     * - ranges, two characters followed by NFA_RANGE.</a>
<a name="ln1546">     */</a>
<a name="ln1547"> </a>
<a name="ln1548">    p = regparse;</a>
<a name="ln1549">    endp = skip_anyof(p);</a>
<a name="ln1550">    if (*endp == ']') {</a>
<a name="ln1551">      /*</a>
<a name="ln1552">       * Try to reverse engineer character classes. For example,</a>
<a name="ln1553">       * recognize that [0-9] stands for \d and [A-Za-z_] for \h,</a>
<a name="ln1554">       * and perform the necessary substitutions in the NFA.</a>
<a name="ln1555">       */</a>
<a name="ln1556">      int result = nfa_recognize_char_class(regparse, endp,</a>
<a name="ln1557">                                            extra == NFA_ADD_NL);</a>
<a name="ln1558">      if (result != FAIL) {</a>
<a name="ln1559">        if (result &gt;= NFA_FIRST_NL &amp;&amp; result &lt;= NFA_LAST_NL) {</a>
<a name="ln1560">          EMIT(result - NFA_ADD_NL);</a>
<a name="ln1561">          EMIT(NFA_NEWL);</a>
<a name="ln1562">          EMIT(NFA_OR);</a>
<a name="ln1563">        } else</a>
<a name="ln1564">          EMIT(result);</a>
<a name="ln1565">        regparse = endp;</a>
<a name="ln1566">        MB_PTR_ADV(regparse);</a>
<a name="ln1567">        return OK;</a>
<a name="ln1568">      }</a>
<a name="ln1569">      /*</a>
<a name="ln1570">       * Failed to recognize a character class. Use the simple</a>
<a name="ln1571">       * version that turns [abc] into 'a' OR 'b' OR 'c'</a>
<a name="ln1572">       */</a>
<a name="ln1573">      startc = -1;</a>
<a name="ln1574">      negated = false;</a>
<a name="ln1575">      if (*regparse == '^') {                           // negated range</a>
<a name="ln1576">        negated = true;</a>
<a name="ln1577">        MB_PTR_ADV(regparse);</a>
<a name="ln1578">        EMIT(NFA_START_NEG_COLL);</a>
<a name="ln1579">      } else</a>
<a name="ln1580">        EMIT(NFA_START_COLL);</a>
<a name="ln1581">      if (*regparse == '-') {</a>
<a name="ln1582">        startc = '-';</a>
<a name="ln1583">        EMIT(startc);</a>
<a name="ln1584">        EMIT(NFA_CONCAT);</a>
<a name="ln1585">        MB_PTR_ADV(regparse);</a>
<a name="ln1586">      }</a>
<a name="ln1587">      // Emit the OR branches for each character in the []</a>
<a name="ln1588">      emit_range = false;</a>
<a name="ln1589">      while (regparse &lt; endp) {</a>
<a name="ln1590">        int oldstartc = startc;</a>
<a name="ln1591">        startc = -1;</a>
<a name="ln1592">        got_coll_char = false;</a>
<a name="ln1593">        if (*regparse == '[') {</a>
<a name="ln1594">          /* Check for [: :], [= =], [. .] */</a>
<a name="ln1595">          equiclass = collclass = 0;</a>
<a name="ln1596">          charclass = get_char_class(&amp;regparse);</a>
<a name="ln1597">          if (charclass == CLASS_NONE) {</a>
<a name="ln1598">            equiclass = get_equi_class(&amp;regparse);</a>
<a name="ln1599">            if (equiclass == 0)</a>
<a name="ln1600">              collclass = get_coll_element(&amp;regparse);</a>
<a name="ln1601">          }</a>
<a name="ln1602"> </a>
<a name="ln1603">          /* Character class like [:alpha:]  */</a>
<a name="ln1604">          if (charclass != CLASS_NONE) {</a>
<a name="ln1605">            switch (charclass) {</a>
<a name="ln1606">            case CLASS_ALNUM:</a>
<a name="ln1607">              EMIT(NFA_CLASS_ALNUM);</a>
<a name="ln1608">              break;</a>
<a name="ln1609">            case CLASS_ALPHA:</a>
<a name="ln1610">              EMIT(NFA_CLASS_ALPHA);</a>
<a name="ln1611">              break;</a>
<a name="ln1612">            case CLASS_BLANK:</a>
<a name="ln1613">              EMIT(NFA_CLASS_BLANK);</a>
<a name="ln1614">              break;</a>
<a name="ln1615">            case CLASS_CNTRL:</a>
<a name="ln1616">              EMIT(NFA_CLASS_CNTRL);</a>
<a name="ln1617">              break;</a>
<a name="ln1618">            case CLASS_DIGIT:</a>
<a name="ln1619">              EMIT(NFA_CLASS_DIGIT);</a>
<a name="ln1620">              break;</a>
<a name="ln1621">            case CLASS_GRAPH:</a>
<a name="ln1622">              EMIT(NFA_CLASS_GRAPH);</a>
<a name="ln1623">              break;</a>
<a name="ln1624">            case CLASS_LOWER:</a>
<a name="ln1625">              wants_nfa = true;</a>
<a name="ln1626">              EMIT(NFA_CLASS_LOWER);</a>
<a name="ln1627">              break;</a>
<a name="ln1628">            case CLASS_PRINT:</a>
<a name="ln1629">              EMIT(NFA_CLASS_PRINT);</a>
<a name="ln1630">              break;</a>
<a name="ln1631">            case CLASS_PUNCT:</a>
<a name="ln1632">              EMIT(NFA_CLASS_PUNCT);</a>
<a name="ln1633">              break;</a>
<a name="ln1634">            case CLASS_SPACE:</a>
<a name="ln1635">              EMIT(NFA_CLASS_SPACE);</a>
<a name="ln1636">              break;</a>
<a name="ln1637">            case CLASS_UPPER:</a>
<a name="ln1638">              wants_nfa = true;</a>
<a name="ln1639">              EMIT(NFA_CLASS_UPPER);</a>
<a name="ln1640">              break;</a>
<a name="ln1641">            case CLASS_XDIGIT:</a>
<a name="ln1642">              EMIT(NFA_CLASS_XDIGIT);</a>
<a name="ln1643">              break;</a>
<a name="ln1644">            case CLASS_TAB:</a>
<a name="ln1645">              EMIT(NFA_CLASS_TAB);</a>
<a name="ln1646">              break;</a>
<a name="ln1647">            case CLASS_RETURN:</a>
<a name="ln1648">              EMIT(NFA_CLASS_RETURN);</a>
<a name="ln1649">              break;</a>
<a name="ln1650">            case CLASS_BACKSPACE:</a>
<a name="ln1651">              EMIT(NFA_CLASS_BACKSPACE);</a>
<a name="ln1652">              break;</a>
<a name="ln1653">            case CLASS_ESCAPE:</a>
<a name="ln1654">              EMIT(NFA_CLASS_ESCAPE);</a>
<a name="ln1655">              break;</a>
<a name="ln1656">            case CLASS_IDENT:</a>
<a name="ln1657">              EMIT(NFA_CLASS_IDENT);</a>
<a name="ln1658">              break;</a>
<a name="ln1659">            case CLASS_KEYWORD:</a>
<a name="ln1660">              EMIT(NFA_CLASS_KEYWORD);</a>
<a name="ln1661">              break;</a>
<a name="ln1662">            case CLASS_FNAME:</a>
<a name="ln1663">              EMIT(NFA_CLASS_FNAME);</a>
<a name="ln1664">              break;</a>
<a name="ln1665">            }</a>
<a name="ln1666">            EMIT(NFA_CONCAT);</a>
<a name="ln1667">            continue;</a>
<a name="ln1668">          }</a>
<a name="ln1669">          /* Try equivalence class [=a=] and the like */</a>
<a name="ln1670">          if (equiclass != 0) {</a>
<a name="ln1671">            nfa_emit_equi_class(equiclass);</a>
<a name="ln1672">            continue;</a>
<a name="ln1673">          }</a>
<a name="ln1674">          /* Try collating class like [. .]  */</a>
<a name="ln1675">          if (collclass != 0) {</a>
<a name="ln1676">            startc = collclass;                  /* allow [.a.]-x as a range */</a>
<a name="ln1677">            /* Will emit the proper atom at the end of the</a>
<a name="ln1678">             * while loop. */</a>
<a name="ln1679">          }</a>
<a name="ln1680">        }</a>
<a name="ln1681">        /* Try a range like 'a-x' or '\t-z'. Also allows '-' as a</a>
<a name="ln1682">         * start character. */</a>
<a name="ln1683">        if (*regparse == '-' &amp;&amp; oldstartc != -1) {</a>
<a name="ln1684">          emit_range = true;</a>
<a name="ln1685">          startc = oldstartc;</a>
<a name="ln1686">          MB_PTR_ADV(regparse);</a>
<a name="ln1687">          continue;                         // reading the end of the range</a>
<a name="ln1688">        }</a>
<a name="ln1689"> </a>
<a name="ln1690">        /* Now handle simple and escaped characters.</a>
<a name="ln1691">         * Only &quot;\]&quot;, &quot;\^&quot;, &quot;\]&quot; and &quot;\\&quot; are special in Vi.  Vim</a>
<a name="ln1692">         * accepts &quot;\t&quot;, &quot;\e&quot;, etc., but only when the 'l' flag in</a>
<a name="ln1693">         * 'cpoptions' is not included.</a>
<a name="ln1694">         */</a>
<a name="ln1695">        if (*regparse == '\\'</a>
<a name="ln1696">            &amp;&amp; regparse + 1 &lt;= endp</a>
<a name="ln1697">            &amp;&amp; (vim_strchr(REGEXP_INRANGE, regparse[1]) != NULL</a>
<a name="ln1698">                || (!reg_cpo_lit</a>
<a name="ln1699">                    &amp;&amp; vim_strchr(REGEXP_ABBR, regparse[1])</a>
<a name="ln1700">                    != NULL)</a>
<a name="ln1701">                )</a>
<a name="ln1702">            ) {</a>
<a name="ln1703">          MB_PTR_ADV(regparse);</a>
<a name="ln1704"> </a>
<a name="ln1705">          if (*regparse == 'n') {</a>
<a name="ln1706">            startc = (reg_string || emit_range || regparse[1] == '-')</a>
<a name="ln1707">              ? NL : NFA_NEWL;</a>
<a name="ln1708">          } else if  (*regparse == 'd'</a>
<a name="ln1709">                      || *regparse == 'o'</a>
<a name="ln1710">                      || *regparse == 'x'</a>
<a name="ln1711">                      || *regparse == 'u'</a>
<a name="ln1712">                      || *regparse == 'U'</a>
<a name="ln1713">                      ) {</a>
<a name="ln1714">            // TODO(RE): This needs more testing</a>
<a name="ln1715">            startc = coll_get_char();</a>
<a name="ln1716">            got_coll_char = true;</a>
<a name="ln1717">            MB_PTR_BACK(old_regparse, regparse);</a>
<a name="ln1718">          } else {</a>
<a name="ln1719">            /* \r,\t,\e,\b */</a>
<a name="ln1720">            startc = backslash_trans(*regparse);</a>
<a name="ln1721">          }</a>
<a name="ln1722">        }</a>
<a name="ln1723"> </a>
<a name="ln1724">        /* Normal printable char */</a>
<a name="ln1725">        if (startc == -1)</a>
<a name="ln1726">          startc = PTR2CHAR(regparse);</a>
<a name="ln1727"> </a>
<a name="ln1728">        /* Previous char was '-', so this char is end of range. */</a>
<a name="ln1729">        if (emit_range) {</a>
<a name="ln1730">          int endc = startc;</a>
<a name="ln1731">          startc = oldstartc;</a>
<a name="ln1732">          if (startc &gt; endc) {</a>
<a name="ln1733">            EMSG_RET_FAIL(_(e_reverse_range));</a>
<a name="ln1734">          }</a>
<a name="ln1735"> </a>
<a name="ln1736">          if (endc &gt; startc + 2) {</a>
<a name="ln1737">            /* Emit a range instead of the sequence of</a>
<a name="ln1738">             * individual characters. */</a>
<a name="ln1739">            if (startc == 0)</a>
<a name="ln1740">              /* \x00 is translated to \x0a, start at \x01. */</a>
<a name="ln1741">              EMIT(1);</a>
<a name="ln1742">            else</a>
<a name="ln1743">              --post_ptr;                   /* remove NFA_CONCAT */</a>
<a name="ln1744">            EMIT(endc);</a>
<a name="ln1745">            EMIT(NFA_RANGE);</a>
<a name="ln1746">            EMIT(NFA_CONCAT);</a>
<a name="ln1747">          } else if ((*mb_char2len)(startc) &gt; 1</a>
<a name="ln1748">                     || (*mb_char2len)(endc) &gt; 1) {</a>
<a name="ln1749">            // Emit the characters in the range.</a>
<a name="ln1750">            // &quot;startc&quot; was already emitted, so skip it.</a>
<a name="ln1751">            for (c = startc + 1; c &lt;= endc; c++) {</a>
<a name="ln1752">              EMIT(c);</a>
<a name="ln1753">              EMIT(NFA_CONCAT);</a>
<a name="ln1754">            }</a>
<a name="ln1755">          } else {</a>
<a name="ln1756">            /* Emit the range. &quot;startc&quot; was already emitted, so</a>
<a name="ln1757">             * skip it. */</a>
<a name="ln1758">            for (c = startc + 1; c &lt;= endc; c++) {</a>
<a name="ln1759">              EMIT(c);</a>
<a name="ln1760">              EMIT(NFA_CONCAT);</a>
<a name="ln1761">            }</a>
<a name="ln1762">          }</a>
<a name="ln1763">          emit_range = false;</a>
<a name="ln1764">          startc = -1;</a>
<a name="ln1765">        } else {</a>
<a name="ln1766">          /* This char (startc) is not part of a range. Just</a>
<a name="ln1767">           * emit it.</a>
<a name="ln1768">           * Normally, simply emit startc. But if we get char</a>
<a name="ln1769">           * code=0 from a collating char, then replace it with</a>
<a name="ln1770">           * 0x0a.</a>
<a name="ln1771">           * This is needed to completely mimic the behaviour of</a>
<a name="ln1772">           * the backtracking engine. */</a>
<a name="ln1773">          if (startc == NFA_NEWL) {</a>
<a name="ln1774">            /* Line break can't be matched as part of the</a>
<a name="ln1775">             * collection, add an OR below. But not for negated</a>
<a name="ln1776">             * range. */</a>
<a name="ln1777">            if (!negated)</a>
<a name="ln1778">              extra = NFA_ADD_NL;</a>
<a name="ln1779">          } else {</a>
<a name="ln1780">            if (got_coll_char == true &amp;&amp; startc == 0) {</a>
<a name="ln1781">              EMIT(0x0a);</a>
<a name="ln1782">            } else {</a>
<a name="ln1783">              EMIT(startc);</a>
<a name="ln1784">            }</a>
<a name="ln1785">            EMIT(NFA_CONCAT);</a>
<a name="ln1786">          }</a>
<a name="ln1787">        }</a>
<a name="ln1788"> </a>
<a name="ln1789">        MB_PTR_ADV(regparse);</a>
<a name="ln1790">      }           // while (p &lt; endp)</a>
<a name="ln1791"> </a>
<a name="ln1792">      MB_PTR_BACK(old_regparse, regparse);</a>
<a name="ln1793">      if (*regparse == '-') {               // if last, '-' is just a char</a>
<a name="ln1794">        EMIT('-');</a>
<a name="ln1795">        EMIT(NFA_CONCAT);</a>
<a name="ln1796">      }</a>
<a name="ln1797"> </a>
<a name="ln1798">      /* skip the trailing ] */</a>
<a name="ln1799">      regparse = endp;</a>
<a name="ln1800">      MB_PTR_ADV(regparse);</a>
<a name="ln1801"> </a>
<a name="ln1802">      // Mark end of the collection.</a>
<a name="ln1803">      if (negated == true) {</a>
<a name="ln1804">        EMIT(NFA_END_NEG_COLL);</a>
<a name="ln1805">      } else {</a>
<a name="ln1806">        EMIT(NFA_END_COLL);</a>
<a name="ln1807">      }</a>
<a name="ln1808"> </a>
<a name="ln1809">      // \_[] also matches \n but it's not negated</a>
<a name="ln1810">      if (extra == NFA_ADD_NL) {</a>
<a name="ln1811">        EMIT(reg_string ? NL : NFA_NEWL);</a>
<a name="ln1812">        EMIT(NFA_OR);</a>
<a name="ln1813">      }</a>
<a name="ln1814"> </a>
<a name="ln1815">      return OK;</a>
<a name="ln1816">    }         /* if exists closing ] */</a>
<a name="ln1817"> </a>
<a name="ln1818">    if (reg_strict)</a>
<a name="ln1819">      EMSG_RET_FAIL(_(e_missingbracket));</a>
<a name="ln1820">    FALLTHROUGH;</a>
<a name="ln1821"> </a>
<a name="ln1822">  default:</a>
<a name="ln1823">  {</a>
<a name="ln1824">    int plen;</a>
<a name="ln1825"> </a>
<a name="ln1826">nfa_do_multibyte:</a>
<a name="ln1827">    // plen is length of current char with composing chars</a>
<a name="ln1828">    if ((*mb_char2len)(c) != (plen = utfc_ptr2len(old_regparse))</a>
<a name="ln1829">        || utf_iscomposing(c)) {</a>
<a name="ln1830">      int i = 0;</a>
<a name="ln1831"> </a>
<a name="ln1832">      /* A base character plus composing characters, or just one</a>
<a name="ln1833">       * or more composing characters.</a>
<a name="ln1834">       * This requires creating a separate atom as if enclosing</a>
<a name="ln1835">       * the characters in (), where NFA_COMPOSING is the ( and</a>
<a name="ln1836">       * NFA_END_COMPOSING is the ). Note that right now we are</a>
<a name="ln1837">       * building the postfix form, not the NFA itself;</a>
<a name="ln1838">       * a composing char could be: a, b, c, NFA_COMPOSING</a>
<a name="ln1839">       * where 'b' and 'c' are chars with codes &gt; 256. */</a>
<a name="ln1840">      for (;; ) {</a>
<a name="ln1841">        EMIT(c);</a>
<a name="ln1842">        if (i &gt; 0)</a>
<a name="ln1843">          EMIT(NFA_CONCAT);</a>
<a name="ln1844">        if ((i += utf_char2len(c)) &gt;= plen)</a>
<a name="ln1845">          break;</a>
<a name="ln1846">        c = utf_ptr2char(old_regparse + i);</a>
<a name="ln1847">      }</a>
<a name="ln1848">      EMIT(NFA_COMPOSING);</a>
<a name="ln1849">      regparse = old_regparse + plen;</a>
<a name="ln1850">    } else {</a>
<a name="ln1851">      c = no_Magic(c);</a>
<a name="ln1852">      EMIT(c);</a>
<a name="ln1853">    }</a>
<a name="ln1854">    return OK;</a>
<a name="ln1855">  }</a>
<a name="ln1856">  }</a>
<a name="ln1857"> </a>
<a name="ln1858">  return OK;</a>
<a name="ln1859">}</a>
<a name="ln1860"> </a>
<a name="ln1861">/*</a>
<a name="ln1862"> * Parse something followed by possible [*+=].</a>
<a name="ln1863"> *</a>
<a name="ln1864"> * A piece is an atom, possibly followed by a multi, an indication of how many</a>
<a name="ln1865"> * times the atom can be matched.  Example: &quot;a*&quot; matches any sequence of &quot;a&quot;</a>
<a name="ln1866"> * characters: &quot;&quot;, &quot;a&quot;, &quot;aa&quot;, etc.</a>
<a name="ln1867"> *</a>
<a name="ln1868"> * piece   ::=	    atom</a>
<a name="ln1869"> *	or  atom  multi</a>
<a name="ln1870"> */</a>
<a name="ln1871">static int nfa_regpiece(void)</a>
<a name="ln1872">{</a>
<a name="ln1873">  int i;</a>
<a name="ln1874">  int op;</a>
<a name="ln1875">  int ret;</a>
<a name="ln1876">  long minval, maxval;</a>
<a name="ln1877">  bool greedy = true;  // Braces are prefixed with '-' ?</a>
<a name="ln1878">  parse_state_T old_state;</a>
<a name="ln1879">  parse_state_T new_state;</a>
<a name="ln1880">  int64_t c2;</a>
<a name="ln1881">  int old_post_pos;</a>
<a name="ln1882">  int my_post_start;</a>
<a name="ln1883">  int quest;</a>
<a name="ln1884"> </a>
<a name="ln1885">  /* Save the current parse state, so that we can use it if &lt;atom&gt;{m,n} is</a>
<a name="ln1886">   * next. */</a>
<a name="ln1887">  save_parse_state(&amp;old_state);</a>
<a name="ln1888"> </a>
<a name="ln1889">  /* store current pos in the postfix form, for \{m,n} involving 0s */</a>
<a name="ln1890">  my_post_start = (int)(post_ptr - post_start);</a>
<a name="ln1891"> </a>
<a name="ln1892">  ret = nfa_regatom();</a>
<a name="ln1893">  if (ret == FAIL)</a>
<a name="ln1894">    return FAIL;            /* cascaded error */</a>
<a name="ln1895"> </a>
<a name="ln1896">  op = peekchr();</a>
<a name="ln1897">  if (re_multi_type(op) == NOT_MULTI)</a>
<a name="ln1898">    return OK;</a>
<a name="ln1899"> </a>
<a name="ln1900">  skipchr();</a>
<a name="ln1901">  switch (op) {</a>
<a name="ln1902">  case Magic('*'):</a>
<a name="ln1903">    EMIT(NFA_STAR);</a>
<a name="ln1904">    break;</a>
<a name="ln1905"> </a>
<a name="ln1906">  case Magic('+'):</a>
<a name="ln1907">    /*</a>
<a name="ln1908">     * Trick: Normally, (a*)\+ would match the whole input &quot;aaa&quot;.  The</a>
<a name="ln1909">     * first and only submatch would be &quot;aaa&quot;. But the backtracking</a>
<a name="ln1910">     * engine interprets the plus as &quot;try matching one more time&quot;, and</a>
<a name="ln1911">     * a* matches a second time at the end of the input, the empty</a>
<a name="ln1912">     * string.</a>
<a name="ln1913">     * The submatch will be the empty string.</a>
<a name="ln1914">     *</a>
<a name="ln1915">     * In order to be consistent with the old engine, we replace</a>
<a name="ln1916">     * &lt;atom&gt;+ with &lt;atom&gt;&lt;atom&gt;*</a>
<a name="ln1917">     */</a>
<a name="ln1918">    restore_parse_state(&amp;old_state);</a>
<a name="ln1919">    curchr = -1;</a>
<a name="ln1920">    if (nfa_regatom() == FAIL)</a>
<a name="ln1921">      return FAIL;</a>
<a name="ln1922">    EMIT(NFA_STAR);</a>
<a name="ln1923">    EMIT(NFA_CONCAT);</a>
<a name="ln1924">    skipchr();                  /* skip the \+	*/</a>
<a name="ln1925">    break;</a>
<a name="ln1926"> </a>
<a name="ln1927">  case Magic('@'):</a>
<a name="ln1928">    c2 = getdecchrs();</a>
<a name="ln1929">    op = no_Magic(getchr());</a>
<a name="ln1930">    i = 0;</a>
<a name="ln1931">    switch(op) {</a>
<a name="ln1932">    case '=':</a>
<a name="ln1933">      /* \@= */</a>
<a name="ln1934">      i = NFA_PREV_ATOM_NO_WIDTH;</a>
<a name="ln1935">      break;</a>
<a name="ln1936">    case '!':</a>
<a name="ln1937">      /* \@! */</a>
<a name="ln1938">      i = NFA_PREV_ATOM_NO_WIDTH_NEG;</a>
<a name="ln1939">      break;</a>
<a name="ln1940">    case '&lt;':</a>
<a name="ln1941">      op = no_Magic(getchr());</a>
<a name="ln1942">      if (op == '=')</a>
<a name="ln1943">        /* \@&lt;= */</a>
<a name="ln1944">        i = NFA_PREV_ATOM_JUST_BEFORE;</a>
<a name="ln1945">      else if (op == '!')</a>
<a name="ln1946">        /* \@&lt;! */</a>
<a name="ln1947">        i = NFA_PREV_ATOM_JUST_BEFORE_NEG;</a>
<a name="ln1948">      break;</a>
<a name="ln1949">    case '&gt;':</a>
<a name="ln1950">      /* \@&gt;  */</a>
<a name="ln1951">      i = NFA_PREV_ATOM_LIKE_PATTERN;</a>
<a name="ln1952">      break;</a>
<a name="ln1953">    }</a>
<a name="ln1954">    if (i == 0) {</a>
<a name="ln1955">      emsgf(_(&quot;E869: (NFA) Unknown operator '\\@%c'&quot;), op);</a>
<a name="ln1956">      return FAIL;</a>
<a name="ln1957">    }</a>
<a name="ln1958">    EMIT(i);</a>
<a name="ln1959">    if (i == NFA_PREV_ATOM_JUST_BEFORE</a>
<a name="ln1960">        || i == NFA_PREV_ATOM_JUST_BEFORE_NEG)</a>
<a name="ln1961">      EMIT(c2);</a>
<a name="ln1962">    break;</a>
<a name="ln1963"> </a>
<a name="ln1964">  case Magic('?'):</a>
<a name="ln1965">  case Magic('='):</a>
<a name="ln1966">    EMIT(NFA_QUEST);</a>
<a name="ln1967">    break;</a>
<a name="ln1968"> </a>
<a name="ln1969">  case Magic('{'):</a>
<a name="ln1970">    /* a{2,5} will expand to 'aaa?a?a?'</a>
<a name="ln1971">     * a{-1,3} will expand to 'aa??a??', where ?? is the nongreedy</a>
<a name="ln1972">     * version of '?'</a>
<a name="ln1973">     * \v(ab){2,3} will expand to '(ab)(ab)(ab)?', where all the</a>
<a name="ln1974">     * parenthesis have the same id</a>
<a name="ln1975">     */</a>
<a name="ln1976"> </a>
<a name="ln1977">    greedy = true;</a>
<a name="ln1978">    c2 = peekchr();</a>
<a name="ln1979">    if (c2 == '-' || c2 == Magic('-')) {</a>
<a name="ln1980">      skipchr();</a>
<a name="ln1981">      greedy = false;</a>
<a name="ln1982">    }</a>
<a name="ln1983">    if (!read_limits(&amp;minval, &amp;maxval))</a>
<a name="ln1984">      EMSG_RET_FAIL(_(&quot;E870: (NFA regexp) Error reading repetition limits&quot;));</a>
<a name="ln1985"> </a>
<a name="ln1986">    /*  &lt;atom&gt;{0,inf}, &lt;atom&gt;{0,} and &lt;atom&gt;{}  are equivalent to</a>
<a name="ln1987">     *  &lt;atom&gt;*  */</a>
<a name="ln1988">    if (minval == 0 &amp;&amp; maxval == MAX_LIMIT) {</a>
<a name="ln1989">      if (greedy)</a>
<a name="ln1990">        /* \{}, \{0,} */</a>
<a name="ln1991">        EMIT(NFA_STAR);</a>
<a name="ln1992">      else</a>
<a name="ln1993">        /* \{-}, \{-0,} */</a>
<a name="ln1994">        EMIT(NFA_STAR_NONGREEDY);</a>
<a name="ln1995">      break;</a>
<a name="ln1996">    }</a>
<a name="ln1997"> </a>
<a name="ln1998">    /* Special case: x{0} or x{-0} */</a>
<a name="ln1999">    if (maxval == 0) {</a>
<a name="ln2000">      /* Ignore result of previous call to nfa_regatom() */</a>
<a name="ln2001">      post_ptr = post_start + my_post_start;</a>
<a name="ln2002">      /* NFA_EMPTY is 0-length and works everywhere */</a>
<a name="ln2003">      EMIT(NFA_EMPTY);</a>
<a name="ln2004">      return OK;</a>
<a name="ln2005">    }</a>
<a name="ln2006"> </a>
<a name="ln2007">    // The engine is very inefficient (uses too many states) when the</a>
<a name="ln2008">    // maximum is much larger than the minimum and when the maximum is</a>
<a name="ln2009">    // large.  However, when maxval is MAX_LIMIT, it is okay, as this</a>
<a name="ln2010">    // will emit NFA_STAR.</a>
<a name="ln2011">    // Bail out if we can use the other engine, but only, when the</a>
<a name="ln2012">    // pattern does not need the NFA engine like (e.g. [[:upper:]]\{2,\}</a>
<a name="ln2013">    // does not work with with characters &gt; 8 bit with the BT engine)</a>
<a name="ln2014">    if ((nfa_re_flags &amp; RE_AUTO)</a>
<a name="ln2015">        &amp;&amp; (maxval &gt; 500 || maxval &gt; minval + 200)</a>
<a name="ln2016">        &amp;&amp; (maxval != MAX_LIMIT &amp;&amp; minval &lt; 200)</a>
<a name="ln2017">        &amp;&amp; !wants_nfa) {</a>
<a name="ln2018">      return FAIL;</a>
<a name="ln2019">    }</a>
<a name="ln2020"> </a>
<a name="ln2021">    /* Ignore previous call to nfa_regatom() */</a>
<a name="ln2022">    post_ptr = post_start + my_post_start;</a>
<a name="ln2023">    /* Save parse state after the repeated atom and the \{} */</a>
<a name="ln2024">    save_parse_state(&amp;new_state);</a>
<a name="ln2025"> </a>
<a name="ln2026">    quest = (greedy == true ? NFA_QUEST : NFA_QUEST_NONGREEDY);</a>
<a name="ln2027">    for (i = 0; i &lt; maxval; i++) {</a>
<a name="ln2028">      /* Goto beginning of the repeated atom */</a>
<a name="ln2029">      restore_parse_state(&amp;old_state);</a>
<a name="ln2030">      old_post_pos = (int)(post_ptr - post_start);</a>
<a name="ln2031">      if (nfa_regatom() == FAIL)</a>
<a name="ln2032">        return FAIL;</a>
<a name="ln2033">      /* after &quot;minval&quot; times, atoms are optional */</a>
<a name="ln2034">      if (i + 1 &gt; minval) {</a>
<a name="ln2035">        if (maxval == MAX_LIMIT) {</a>
<a name="ln2036">          if (greedy)</a>
<a name="ln2037">            EMIT(NFA_STAR);</a>
<a name="ln2038">          else</a>
<a name="ln2039">            EMIT(NFA_STAR_NONGREEDY);</a>
<a name="ln2040">        } else</a>
<a name="ln2041">          EMIT(quest);</a>
<a name="ln2042">      }</a>
<a name="ln2043">      if (old_post_pos != my_post_start)</a>
<a name="ln2044">        EMIT(NFA_CONCAT);</a>
<a name="ln2045">      if (i + 1 &gt; minval &amp;&amp; maxval == MAX_LIMIT)</a>
<a name="ln2046">        break;</a>
<a name="ln2047">    }</a>
<a name="ln2048"> </a>
<a name="ln2049">    /* Go to just after the repeated atom and the \{} */</a>
<a name="ln2050">    restore_parse_state(&amp;new_state);</a>
<a name="ln2051">    curchr = -1;</a>
<a name="ln2052"> </a>
<a name="ln2053">    break;</a>
<a name="ln2054"> </a>
<a name="ln2055"> </a>
<a name="ln2056">  default:</a>
<a name="ln2057">    break;</a>
<a name="ln2058">  }     /* end switch */</a>
<a name="ln2059"> </a>
<a name="ln2060">  if (re_multi_type(peekchr()) != NOT_MULTI) {</a>
<a name="ln2061">    // Can't have a multi follow a multi.</a>
<a name="ln2062">    EMSG_RET_FAIL(_(&quot;E871: (NFA regexp) Can't have a multi follow a multi&quot;));</a>
<a name="ln2063">  }</a>
<a name="ln2064"> </a>
<a name="ln2065">  return OK;</a>
<a name="ln2066">}</a>
<a name="ln2067"> </a>
<a name="ln2068">/*</a>
<a name="ln2069"> * Parse one or more pieces, concatenated.  It matches a match for the</a>
<a name="ln2070"> * first piece, followed by a match for the second piece, etc.  Example:</a>
<a name="ln2071"> * &quot;f[0-9]b&quot;, first matches &quot;f&quot;, then a digit and then &quot;b&quot;.</a>
<a name="ln2072"> *</a>
<a name="ln2073"> * concat  ::=	    piece</a>
<a name="ln2074"> *	or  piece piece</a>
<a name="ln2075"> *	or  piece piece piece</a>
<a name="ln2076"> *	etc.</a>
<a name="ln2077"> */</a>
<a name="ln2078">static int nfa_regconcat(void)</a>
<a name="ln2079">{</a>
<a name="ln2080">  bool cont = true;</a>
<a name="ln2081">  bool first = true;</a>
<a name="ln2082"> </a>
<a name="ln2083">  while (cont) {</a>
<a name="ln2084">    switch (peekchr()) {</a>
<a name="ln2085">    case NUL:</a>
<a name="ln2086">    case Magic('|'):</a>
<a name="ln2087">    case Magic('&amp;'):</a>
<a name="ln2088">    case Magic(')'):</a>
<a name="ln2089">      cont = false;</a>
<a name="ln2090">      break;</a>
<a name="ln2091"> </a>
<a name="ln2092">    case Magic('Z'):</a>
<a name="ln2093">      regflags |= RF_ICOMBINE;</a>
<a name="ln2094">      skipchr_keepstart();</a>
<a name="ln2095">      break;</a>
<a name="ln2096">    case Magic('c'):</a>
<a name="ln2097">      regflags |= RF_ICASE;</a>
<a name="ln2098">      skipchr_keepstart();</a>
<a name="ln2099">      break;</a>
<a name="ln2100">    case Magic('C'):</a>
<a name="ln2101">      regflags |= RF_NOICASE;</a>
<a name="ln2102">      skipchr_keepstart();</a>
<a name="ln2103">      break;</a>
<a name="ln2104">    case Magic('v'):</a>
<a name="ln2105">      reg_magic = MAGIC_ALL;</a>
<a name="ln2106">      skipchr_keepstart();</a>
<a name="ln2107">      curchr = -1;</a>
<a name="ln2108">      break;</a>
<a name="ln2109">    case Magic('m'):</a>
<a name="ln2110">      reg_magic = MAGIC_ON;</a>
<a name="ln2111">      skipchr_keepstart();</a>
<a name="ln2112">      curchr = -1;</a>
<a name="ln2113">      break;</a>
<a name="ln2114">    case Magic('M'):</a>
<a name="ln2115">      reg_magic = MAGIC_OFF;</a>
<a name="ln2116">      skipchr_keepstart();</a>
<a name="ln2117">      curchr = -1;</a>
<a name="ln2118">      break;</a>
<a name="ln2119">    case Magic('V'):</a>
<a name="ln2120">      reg_magic = MAGIC_NONE;</a>
<a name="ln2121">      skipchr_keepstart();</a>
<a name="ln2122">      curchr = -1;</a>
<a name="ln2123">      break;</a>
<a name="ln2124"> </a>
<a name="ln2125">    default:</a>
<a name="ln2126">      if (nfa_regpiece() == FAIL) {</a>
<a name="ln2127">        return FAIL;</a>
<a name="ln2128">      }</a>
<a name="ln2129">      if (first == false) {</a>
<a name="ln2130">        EMIT(NFA_CONCAT);</a>
<a name="ln2131">      } else {</a>
<a name="ln2132">        first = false;</a>
<a name="ln2133">      }</a>
<a name="ln2134">      break;</a>
<a name="ln2135">    }</a>
<a name="ln2136">  }</a>
<a name="ln2137"> </a>
<a name="ln2138">  return OK;</a>
<a name="ln2139">}</a>
<a name="ln2140"> </a>
<a name="ln2141">/*</a>
<a name="ln2142"> * Parse a branch, one or more concats, separated by &quot;\&amp;&quot;.  It matches the</a>
<a name="ln2143"> * last concat, but only if all the preceding concats also match at the same</a>
<a name="ln2144"> * position.  Examples:</a>
<a name="ln2145"> *      &quot;foobeep\&amp;...&quot; matches &quot;foo&quot; in &quot;foobeep&quot;.</a>
<a name="ln2146"> *      &quot;.*Peter\&amp;.*Bob&quot; matches in a line containing both &quot;Peter&quot; and &quot;Bob&quot;</a>
<a name="ln2147"> *</a>
<a name="ln2148"> * branch ::=	    concat</a>
<a name="ln2149"> *		or  concat \&amp; concat</a>
<a name="ln2150"> *		or  concat \&amp; concat \&amp; concat</a>
<a name="ln2151"> *		etc.</a>
<a name="ln2152"> */</a>
<a name="ln2153">static int nfa_regbranch(void)</a>
<a name="ln2154">{</a>
<a name="ln2155">  int old_post_pos;</a>
<a name="ln2156"> </a>
<a name="ln2157">  old_post_pos = (int)(post_ptr - post_start);</a>
<a name="ln2158"> </a>
<a name="ln2159">  /* First branch, possibly the only one */</a>
<a name="ln2160">  if (nfa_regconcat() == FAIL)</a>
<a name="ln2161">    return FAIL;</a>
<a name="ln2162"> </a>
<a name="ln2163">  // Try next concats</a>
<a name="ln2164">  while (peekchr() == Magic('&amp;')) {</a>
<a name="ln2165">    skipchr();</a>
<a name="ln2166">    // if concat is empty do emit a node</a>
<a name="ln2167">    if (old_post_pos == (int)(post_ptr - post_start)) {</a>
<a name="ln2168">      EMIT(NFA_EMPTY);</a>
<a name="ln2169">    }</a>
<a name="ln2170">    EMIT(NFA_NOPEN);</a>
<a name="ln2171">    EMIT(NFA_PREV_ATOM_NO_WIDTH);</a>
<a name="ln2172">    old_post_pos = (int)(post_ptr - post_start);</a>
<a name="ln2173">    if (nfa_regconcat() == FAIL)</a>
<a name="ln2174">      return FAIL;</a>
<a name="ln2175">    /* if concat is empty do emit a node */</a>
<a name="ln2176">    if (old_post_pos == (int)(post_ptr - post_start))</a>
<a name="ln2177">      EMIT(NFA_EMPTY);</a>
<a name="ln2178">    EMIT(NFA_CONCAT);</a>
<a name="ln2179">  }</a>
<a name="ln2180"> </a>
<a name="ln2181">  /* if a branch is empty, emit one node for it */</a>
<a name="ln2182">  if (old_post_pos == (int)(post_ptr - post_start))</a>
<a name="ln2183">    EMIT(NFA_EMPTY);</a>
<a name="ln2184"> </a>
<a name="ln2185">  return OK;</a>
<a name="ln2186">}</a>
<a name="ln2187"> </a>
<a name="ln2188">/*</a>
<a name="ln2189"> *  Parse a pattern, one or more branches, separated by &quot;\|&quot;.  It matches</a>
<a name="ln2190"> *  anything that matches one of the branches.  Example: &quot;foo\|beep&quot; matches</a>
<a name="ln2191"> *  &quot;foo&quot; and matches &quot;beep&quot;.  If more than one branch matches, the first one</a>
<a name="ln2192"> *  is used.</a>
<a name="ln2193"> *</a>
<a name="ln2194"> *  pattern ::=	    branch</a>
<a name="ln2195"> *	or  branch \| branch</a>
<a name="ln2196"> *	or  branch \| branch \| branch</a>
<a name="ln2197"> *	etc.</a>
<a name="ln2198"> */</a>
<a name="ln2199">static int </a>
<a name="ln2200">nfa_reg (</a>
<a name="ln2201">    int paren              /* REG_NOPAREN, REG_PAREN, REG_NPAREN or REG_ZPAREN */</a>
<a name="ln2202">)</a>
<a name="ln2203">{</a>
<a name="ln2204">  int parno = 0;</a>
<a name="ln2205"> </a>
<a name="ln2206">  if (paren == REG_PAREN) {</a>
<a name="ln2207">    if (regnpar &gt;= NSUBEXP)     /* Too many `(' */</a>
<a name="ln2208">      EMSG_RET_FAIL(_(&quot;E872: (NFA regexp) Too many '('&quot;));</a>
<a name="ln2209">    parno = regnpar++;</a>
<a name="ln2210">  } else if (paren == REG_ZPAREN) {</a>
<a name="ln2211">    /* Make a ZOPEN node. */</a>
<a name="ln2212">    if (regnzpar &gt;= NSUBEXP)</a>
<a name="ln2213">      EMSG_RET_FAIL(_(&quot;E879: (NFA regexp) Too many \\z(&quot;));</a>
<a name="ln2214">    parno = regnzpar++;</a>
<a name="ln2215">  }</a>
<a name="ln2216"> </a>
<a name="ln2217">  if (nfa_regbranch() == FAIL)</a>
<a name="ln2218">    return FAIL;            /* cascaded error */</a>
<a name="ln2219"> </a>
<a name="ln2220">  while (peekchr() == Magic('|')) {</a>
<a name="ln2221">    skipchr();</a>
<a name="ln2222">    if (nfa_regbranch() == FAIL)</a>
<a name="ln2223">      return FAIL;          /* cascaded error */</a>
<a name="ln2224">    EMIT(NFA_OR);</a>
<a name="ln2225">  }</a>
<a name="ln2226"> </a>
<a name="ln2227">  /* Check for proper termination. */</a>
<a name="ln2228">  if (paren != REG_NOPAREN &amp;&amp; getchr() != Magic(')')) {</a>
<a name="ln2229">    if (paren == REG_NPAREN)</a>
<a name="ln2230">      EMSG2_RET_FAIL(_(e_unmatchedpp), reg_magic == MAGIC_ALL);</a>
<a name="ln2231">    else</a>
<a name="ln2232">      EMSG2_RET_FAIL(_(e_unmatchedp), reg_magic == MAGIC_ALL);</a>
<a name="ln2233">  } else if (paren == REG_NOPAREN &amp;&amp; peekchr() != NUL) {</a>
<a name="ln2234">    if (peekchr() == Magic(')'))</a>
<a name="ln2235">      EMSG2_RET_FAIL(_(e_unmatchedpar), reg_magic == MAGIC_ALL);</a>
<a name="ln2236">    else</a>
<a name="ln2237">      EMSG_RET_FAIL(_(&quot;E873: (NFA regexp) proper termination error&quot;));</a>
<a name="ln2238">  }</a>
<a name="ln2239">  // Here we set the flag allowing back references to this set of</a>
<a name="ln2240">  // parentheses.</a>
<a name="ln2241">  if (paren == REG_PAREN) {</a>
<a name="ln2242">    had_endbrace[parno] = true;  // have seen the close paren</a>
<a name="ln2243">    EMIT(NFA_MOPEN + parno);</a>
<a name="ln2244">  } else if (paren == REG_ZPAREN) {</a>
<a name="ln2245">    EMIT(NFA_ZOPEN + parno);</a>
<a name="ln2246">  }</a>
<a name="ln2247"> </a>
<a name="ln2248">  return OK;</a>
<a name="ln2249">}</a>
<a name="ln2250"> </a>
<a name="ln2251">#ifdef REGEXP_DEBUG</a>
<a name="ln2252">static char_u code[50];</a>
<a name="ln2253"> </a>
<a name="ln2254">static void nfa_set_code(int c)</a>
<a name="ln2255">{</a>
<a name="ln2256">  int addnl = false;</a>
<a name="ln2257"> </a>
<a name="ln2258">  if (c &gt;= NFA_FIRST_NL &amp;&amp; c &lt;= NFA_LAST_NL) {</a>
<a name="ln2259">    addnl = true;</a>
<a name="ln2260">    c -= NFA_ADD_NL;</a>
<a name="ln2261">  }</a>
<a name="ln2262"> </a>
<a name="ln2263">  STRCPY(code, &quot;&quot;);</a>
<a name="ln2264">  switch (c) {</a>
<a name="ln2265">  case NFA_MATCH:     STRCPY(code, &quot;NFA_MATCH &quot;); break;</a>
<a name="ln2266">  case NFA_SPLIT:     STRCPY(code, &quot;NFA_SPLIT &quot;); break;</a>
<a name="ln2267">  case NFA_CONCAT:    STRCPY(code, &quot;NFA_CONCAT &quot;); break;</a>
<a name="ln2268">  case NFA_NEWL:      STRCPY(code, &quot;NFA_NEWL &quot;); break;</a>
<a name="ln2269">  case NFA_ZSTART:    STRCPY(code, &quot;NFA_ZSTART&quot;); break;</a>
<a name="ln2270">  case NFA_ZEND:      STRCPY(code, &quot;NFA_ZEND&quot;); break;</a>
<a name="ln2271"> </a>
<a name="ln2272">  case NFA_BACKREF1:  STRCPY(code, &quot;NFA_BACKREF1&quot;); break;</a>
<a name="ln2273">  case NFA_BACKREF2:  STRCPY(code, &quot;NFA_BACKREF2&quot;); break;</a>
<a name="ln2274">  case NFA_BACKREF3:  STRCPY(code, &quot;NFA_BACKREF3&quot;); break;</a>
<a name="ln2275">  case NFA_BACKREF4:  STRCPY(code, &quot;NFA_BACKREF4&quot;); break;</a>
<a name="ln2276">  case NFA_BACKREF5:  STRCPY(code, &quot;NFA_BACKREF5&quot;); break;</a>
<a name="ln2277">  case NFA_BACKREF6:  STRCPY(code, &quot;NFA_BACKREF6&quot;); break;</a>
<a name="ln2278">  case NFA_BACKREF7:  STRCPY(code, &quot;NFA_BACKREF7&quot;); break;</a>
<a name="ln2279">  case NFA_BACKREF8:  STRCPY(code, &quot;NFA_BACKREF8&quot;); break;</a>
<a name="ln2280">  case NFA_BACKREF9:  STRCPY(code, &quot;NFA_BACKREF9&quot;); break;</a>
<a name="ln2281">  case NFA_ZREF1:     STRCPY(code, &quot;NFA_ZREF1&quot;); break;</a>
<a name="ln2282">  case NFA_ZREF2:     STRCPY(code, &quot;NFA_ZREF2&quot;); break;</a>
<a name="ln2283">  case NFA_ZREF3:     STRCPY(code, &quot;NFA_ZREF3&quot;); break;</a>
<a name="ln2284">  case NFA_ZREF4:     STRCPY(code, &quot;NFA_ZREF4&quot;); break;</a>
<a name="ln2285">  case NFA_ZREF5:     STRCPY(code, &quot;NFA_ZREF5&quot;); break;</a>
<a name="ln2286">  case NFA_ZREF6:     STRCPY(code, &quot;NFA_ZREF6&quot;); break;</a>
<a name="ln2287">  case NFA_ZREF7:     STRCPY(code, &quot;NFA_ZREF7&quot;); break;</a>
<a name="ln2288">  case NFA_ZREF8:     STRCPY(code, &quot;NFA_ZREF8&quot;); break;</a>
<a name="ln2289">  case NFA_ZREF9:     STRCPY(code, &quot;NFA_ZREF9&quot;); break;</a>
<a name="ln2290">  case NFA_SKIP:      STRCPY(code, &quot;NFA_SKIP&quot;); break;</a>
<a name="ln2291"> </a>
<a name="ln2292">  case NFA_PREV_ATOM_NO_WIDTH:</a>
<a name="ln2293">    STRCPY(code, &quot;NFA_PREV_ATOM_NO_WIDTH&quot;); break;</a>
<a name="ln2294">  case NFA_PREV_ATOM_NO_WIDTH_NEG:</a>
<a name="ln2295">    STRCPY(code, &quot;NFA_PREV_ATOM_NO_WIDTH_NEG&quot;); break;</a>
<a name="ln2296">  case NFA_PREV_ATOM_JUST_BEFORE:</a>
<a name="ln2297">    STRCPY(code, &quot;NFA_PREV_ATOM_JUST_BEFORE&quot;); break;</a>
<a name="ln2298">  case NFA_PREV_ATOM_JUST_BEFORE_NEG:</a>
<a name="ln2299">    STRCPY(code, &quot;NFA_PREV_ATOM_JUST_BEFORE_NEG&quot;); break;</a>
<a name="ln2300">  case NFA_PREV_ATOM_LIKE_PATTERN:</a>
<a name="ln2301">    STRCPY(code, &quot;NFA_PREV_ATOM_LIKE_PATTERN&quot;); break;</a>
<a name="ln2302"> </a>
<a name="ln2303">  case NFA_NOPEN:             STRCPY(code, &quot;NFA_NOPEN&quot;); break;</a>
<a name="ln2304">  case NFA_NCLOSE:            STRCPY(code, &quot;NFA_NCLOSE&quot;); break;</a>
<a name="ln2305">  case NFA_START_INVISIBLE:   STRCPY(code, &quot;NFA_START_INVISIBLE&quot;); break;</a>
<a name="ln2306">  case NFA_START_INVISIBLE_FIRST:</a>
<a name="ln2307">    STRCPY(code, &quot;NFA_START_INVISIBLE_FIRST&quot;); break;</a>
<a name="ln2308">  case NFA_START_INVISIBLE_NEG:</a>
<a name="ln2309">    STRCPY(code, &quot;NFA_START_INVISIBLE_NEG&quot;); break;</a>
<a name="ln2310">  case NFA_START_INVISIBLE_NEG_FIRST:</a>
<a name="ln2311">    STRCPY(code, &quot;NFA_START_INVISIBLE_NEG_FIRST&quot;); break;</a>
<a name="ln2312">  case NFA_START_INVISIBLE_BEFORE:</a>
<a name="ln2313">    STRCPY(code, &quot;NFA_START_INVISIBLE_BEFORE&quot;); break;</a>
<a name="ln2314">  case NFA_START_INVISIBLE_BEFORE_FIRST:</a>
<a name="ln2315">    STRCPY(code, &quot;NFA_START_INVISIBLE_BEFORE_FIRST&quot;); break;</a>
<a name="ln2316">  case NFA_START_INVISIBLE_BEFORE_NEG:</a>
<a name="ln2317">    STRCPY(code, &quot;NFA_START_INVISIBLE_BEFORE_NEG&quot;); break;</a>
<a name="ln2318">  case NFA_START_INVISIBLE_BEFORE_NEG_FIRST:</a>
<a name="ln2319">    STRCPY(code, &quot;NFA_START_INVISIBLE_BEFORE_NEG_FIRST&quot;); break;</a>
<a name="ln2320">  case NFA_START_PATTERN:   STRCPY(code, &quot;NFA_START_PATTERN&quot;); break;</a>
<a name="ln2321">  case NFA_END_INVISIBLE:     STRCPY(code, &quot;NFA_END_INVISIBLE&quot;); break;</a>
<a name="ln2322">  case NFA_END_INVISIBLE_NEG: STRCPY(code, &quot;NFA_END_INVISIBLE_NEG&quot;); break;</a>
<a name="ln2323">  case NFA_END_PATTERN:       STRCPY(code, &quot;NFA_END_PATTERN&quot;); break;</a>
<a name="ln2324"> </a>
<a name="ln2325">  case NFA_COMPOSING:         STRCPY(code, &quot;NFA_COMPOSING&quot;); break;</a>
<a name="ln2326">  case NFA_END_COMPOSING:     STRCPY(code, &quot;NFA_END_COMPOSING&quot;); break;</a>
<a name="ln2327">  case NFA_OPT_CHARS:         STRCPY(code, &quot;NFA_OPT_CHARS&quot;); break;</a>
<a name="ln2328"> </a>
<a name="ln2329">  case NFA_MOPEN:</a>
<a name="ln2330">  case NFA_MOPEN1:</a>
<a name="ln2331">  case NFA_MOPEN2:</a>
<a name="ln2332">  case NFA_MOPEN3:</a>
<a name="ln2333">  case NFA_MOPEN4:</a>
<a name="ln2334">  case NFA_MOPEN5:</a>
<a name="ln2335">  case NFA_MOPEN6:</a>
<a name="ln2336">  case NFA_MOPEN7:</a>
<a name="ln2337">  case NFA_MOPEN8:</a>
<a name="ln2338">  case NFA_MOPEN9:</a>
<a name="ln2339">    STRCPY(code, &quot;NFA_MOPEN(x)&quot;);</a>
<a name="ln2340">    code[10] = c - NFA_MOPEN + '0';</a>
<a name="ln2341">    break;</a>
<a name="ln2342">  case NFA_MCLOSE:</a>
<a name="ln2343">  case NFA_MCLOSE1:</a>
<a name="ln2344">  case NFA_MCLOSE2:</a>
<a name="ln2345">  case NFA_MCLOSE3:</a>
<a name="ln2346">  case NFA_MCLOSE4:</a>
<a name="ln2347">  case NFA_MCLOSE5:</a>
<a name="ln2348">  case NFA_MCLOSE6:</a>
<a name="ln2349">  case NFA_MCLOSE7:</a>
<a name="ln2350">  case NFA_MCLOSE8:</a>
<a name="ln2351">  case NFA_MCLOSE9:</a>
<a name="ln2352">    STRCPY(code, &quot;NFA_MCLOSE(x)&quot;);</a>
<a name="ln2353">    code[11] = c - NFA_MCLOSE + '0';</a>
<a name="ln2354">    break;</a>
<a name="ln2355">  case NFA_ZOPEN:</a>
<a name="ln2356">  case NFA_ZOPEN1:</a>
<a name="ln2357">  case NFA_ZOPEN2:</a>
<a name="ln2358">  case NFA_ZOPEN3:</a>
<a name="ln2359">  case NFA_ZOPEN4:</a>
<a name="ln2360">  case NFA_ZOPEN5:</a>
<a name="ln2361">  case NFA_ZOPEN6:</a>
<a name="ln2362">  case NFA_ZOPEN7:</a>
<a name="ln2363">  case NFA_ZOPEN8:</a>
<a name="ln2364">  case NFA_ZOPEN9:</a>
<a name="ln2365">    STRCPY(code, &quot;NFA_ZOPEN(x)&quot;);</a>
<a name="ln2366">    code[10] = c - NFA_ZOPEN + '0';</a>
<a name="ln2367">    break;</a>
<a name="ln2368">  case NFA_ZCLOSE:</a>
<a name="ln2369">  case NFA_ZCLOSE1:</a>
<a name="ln2370">  case NFA_ZCLOSE2:</a>
<a name="ln2371">  case NFA_ZCLOSE3:</a>
<a name="ln2372">  case NFA_ZCLOSE4:</a>
<a name="ln2373">  case NFA_ZCLOSE5:</a>
<a name="ln2374">  case NFA_ZCLOSE6:</a>
<a name="ln2375">  case NFA_ZCLOSE7:</a>
<a name="ln2376">  case NFA_ZCLOSE8:</a>
<a name="ln2377">  case NFA_ZCLOSE9:</a>
<a name="ln2378">    STRCPY(code, &quot;NFA_ZCLOSE(x)&quot;);</a>
<a name="ln2379">    code[11] = c - NFA_ZCLOSE + '0';</a>
<a name="ln2380">    break;</a>
<a name="ln2381">  case NFA_EOL:           STRCPY(code, &quot;NFA_EOL &quot;); break;</a>
<a name="ln2382">  case NFA_BOL:           STRCPY(code, &quot;NFA_BOL &quot;); break;</a>
<a name="ln2383">  case NFA_EOW:           STRCPY(code, &quot;NFA_EOW &quot;); break;</a>
<a name="ln2384">  case NFA_BOW:           STRCPY(code, &quot;NFA_BOW &quot;); break;</a>
<a name="ln2385">  case NFA_EOF:           STRCPY(code, &quot;NFA_EOF &quot;); break;</a>
<a name="ln2386">  case NFA_BOF:           STRCPY(code, &quot;NFA_BOF &quot;); break;</a>
<a name="ln2387">  case NFA_LNUM:          STRCPY(code, &quot;NFA_LNUM &quot;); break;</a>
<a name="ln2388">  case NFA_LNUM_GT:       STRCPY(code, &quot;NFA_LNUM_GT &quot;); break;</a>
<a name="ln2389">  case NFA_LNUM_LT:       STRCPY(code, &quot;NFA_LNUM_LT &quot;); break;</a>
<a name="ln2390">  case NFA_COL:           STRCPY(code, &quot;NFA_COL &quot;); break;</a>
<a name="ln2391">  case NFA_COL_GT:        STRCPY(code, &quot;NFA_COL_GT &quot;); break;</a>
<a name="ln2392">  case NFA_COL_LT:        STRCPY(code, &quot;NFA_COL_LT &quot;); break;</a>
<a name="ln2393">  case NFA_VCOL:          STRCPY(code, &quot;NFA_VCOL &quot;); break;</a>
<a name="ln2394">  case NFA_VCOL_GT:       STRCPY(code, &quot;NFA_VCOL_GT &quot;); break;</a>
<a name="ln2395">  case NFA_VCOL_LT:       STRCPY(code, &quot;NFA_VCOL_LT &quot;); break;</a>
<a name="ln2396">  case NFA_MARK:          STRCPY(code, &quot;NFA_MARK &quot;); break;</a>
<a name="ln2397">  case NFA_MARK_GT:       STRCPY(code, &quot;NFA_MARK_GT &quot;); break;</a>
<a name="ln2398">  case NFA_MARK_LT:       STRCPY(code, &quot;NFA_MARK_LT &quot;); break;</a>
<a name="ln2399">  case NFA_CURSOR:        STRCPY(code, &quot;NFA_CURSOR &quot;); break;</a>
<a name="ln2400">  case NFA_VISUAL:        STRCPY(code, &quot;NFA_VISUAL &quot;); break;</a>
<a name="ln2401">  case NFA_ANY_COMPOSING: STRCPY(code, &quot;NFA_ANY_COMPOSING &quot;); break;</a>
<a name="ln2402"> </a>
<a name="ln2403">  case NFA_STAR:          STRCPY(code, &quot;NFA_STAR &quot;); break;</a>
<a name="ln2404">  case NFA_STAR_NONGREEDY: STRCPY(code, &quot;NFA_STAR_NONGREEDY &quot;); break;</a>
<a name="ln2405">  case NFA_QUEST:         STRCPY(code, &quot;NFA_QUEST&quot;); break;</a>
<a name="ln2406">  case NFA_QUEST_NONGREEDY: STRCPY(code, &quot;NFA_QUEST_NON_GREEDY&quot;); break;</a>
<a name="ln2407">  case NFA_EMPTY:         STRCPY(code, &quot;NFA_EMPTY&quot;); break;</a>
<a name="ln2408">  case NFA_OR:            STRCPY(code, &quot;NFA_OR&quot;); break;</a>
<a name="ln2409"> </a>
<a name="ln2410">  case NFA_START_COLL:    STRCPY(code, &quot;NFA_START_COLL&quot;); break;</a>
<a name="ln2411">  case NFA_END_COLL:      STRCPY(code, &quot;NFA_END_COLL&quot;); break;</a>
<a name="ln2412">  case NFA_START_NEG_COLL: STRCPY(code, &quot;NFA_START_NEG_COLL&quot;); break;</a>
<a name="ln2413">  case NFA_END_NEG_COLL:  STRCPY(code, &quot;NFA_END_NEG_COLL&quot;); break;</a>
<a name="ln2414">  case NFA_RANGE:         STRCPY(code, &quot;NFA_RANGE&quot;); break;</a>
<a name="ln2415">  case NFA_RANGE_MIN:     STRCPY(code, &quot;NFA_RANGE_MIN&quot;); break;</a>
<a name="ln2416">  case NFA_RANGE_MAX:     STRCPY(code, &quot;NFA_RANGE_MAX&quot;); break;</a>
<a name="ln2417"> </a>
<a name="ln2418">  case NFA_CLASS_ALNUM:   STRCPY(code, &quot;NFA_CLASS_ALNUM&quot;); break;</a>
<a name="ln2419">  case NFA_CLASS_ALPHA:   STRCPY(code, &quot;NFA_CLASS_ALPHA&quot;); break;</a>
<a name="ln2420">  case NFA_CLASS_BLANK:   STRCPY(code, &quot;NFA_CLASS_BLANK&quot;); break;</a>
<a name="ln2421">  case NFA_CLASS_CNTRL:   STRCPY(code, &quot;NFA_CLASS_CNTRL&quot;); break;</a>
<a name="ln2422">  case NFA_CLASS_DIGIT:   STRCPY(code, &quot;NFA_CLASS_DIGIT&quot;); break;</a>
<a name="ln2423">  case NFA_CLASS_GRAPH:   STRCPY(code, &quot;NFA_CLASS_GRAPH&quot;); break;</a>
<a name="ln2424">  case NFA_CLASS_LOWER:   STRCPY(code, &quot;NFA_CLASS_LOWER&quot;); break;</a>
<a name="ln2425">  case NFA_CLASS_PRINT:   STRCPY(code, &quot;NFA_CLASS_PRINT&quot;); break;</a>
<a name="ln2426">  case NFA_CLASS_PUNCT:   STRCPY(code, &quot;NFA_CLASS_PUNCT&quot;); break;</a>
<a name="ln2427">  case NFA_CLASS_SPACE:   STRCPY(code, &quot;NFA_CLASS_SPACE&quot;); break;</a>
<a name="ln2428">  case NFA_CLASS_UPPER:   STRCPY(code, &quot;NFA_CLASS_UPPER&quot;); break;</a>
<a name="ln2429">  case NFA_CLASS_XDIGIT:  STRCPY(code, &quot;NFA_CLASS_XDIGIT&quot;); break;</a>
<a name="ln2430">  case NFA_CLASS_TAB:     STRCPY(code, &quot;NFA_CLASS_TAB&quot;); break;</a>
<a name="ln2431">  case NFA_CLASS_RETURN:  STRCPY(code, &quot;NFA_CLASS_RETURN&quot;); break;</a>
<a name="ln2432">  case NFA_CLASS_BACKSPACE:   STRCPY(code, &quot;NFA_CLASS_BACKSPACE&quot;); break;</a>
<a name="ln2433">  case NFA_CLASS_ESCAPE:  STRCPY(code, &quot;NFA_CLASS_ESCAPE&quot;); break;</a>
<a name="ln2434">  case NFA_CLASS_IDENT:   STRCPY(code, &quot;NFA_CLASS_IDENT&quot;); break;</a>
<a name="ln2435">  case NFA_CLASS_KEYWORD: STRCPY(code, &quot;NFA_CLASS_KEYWORD&quot;); break;</a>
<a name="ln2436">  case NFA_CLASS_FNAME:   STRCPY(code, &quot;NFA_CLASS_FNAME&quot;); break;</a>
<a name="ln2437"> </a>
<a name="ln2438">  case NFA_ANY:   STRCPY(code, &quot;NFA_ANY&quot;); break;</a>
<a name="ln2439">  case NFA_IDENT: STRCPY(code, &quot;NFA_IDENT&quot;); break;</a>
<a name="ln2440">  case NFA_SIDENT: STRCPY(code, &quot;NFA_SIDENT&quot;); break;</a>
<a name="ln2441">  case NFA_KWORD: STRCPY(code, &quot;NFA_KWORD&quot;); break;</a>
<a name="ln2442">  case NFA_SKWORD: STRCPY(code, &quot;NFA_SKWORD&quot;); break;</a>
<a name="ln2443">  case NFA_FNAME: STRCPY(code, &quot;NFA_FNAME&quot;); break;</a>
<a name="ln2444">  case NFA_SFNAME: STRCPY(code, &quot;NFA_SFNAME&quot;); break;</a>
<a name="ln2445">  case NFA_PRINT: STRCPY(code, &quot;NFA_PRINT&quot;); break;</a>
<a name="ln2446">  case NFA_SPRINT: STRCPY(code, &quot;NFA_SPRINT&quot;); break;</a>
<a name="ln2447">  case NFA_WHITE: STRCPY(code, &quot;NFA_WHITE&quot;); break;</a>
<a name="ln2448">  case NFA_NWHITE: STRCPY(code, &quot;NFA_NWHITE&quot;); break;</a>
<a name="ln2449">  case NFA_DIGIT: STRCPY(code, &quot;NFA_DIGIT&quot;); break;</a>
<a name="ln2450">  case NFA_NDIGIT: STRCPY(code, &quot;NFA_NDIGIT&quot;); break;</a>
<a name="ln2451">  case NFA_HEX:   STRCPY(code, &quot;NFA_HEX&quot;); break;</a>
<a name="ln2452">  case NFA_NHEX:  STRCPY(code, &quot;NFA_NHEX&quot;); break;</a>
<a name="ln2453">  case NFA_OCTAL: STRCPY(code, &quot;NFA_OCTAL&quot;); break;</a>
<a name="ln2454">  case NFA_NOCTAL: STRCPY(code, &quot;NFA_NOCTAL&quot;); break;</a>
<a name="ln2455">  case NFA_WORD:  STRCPY(code, &quot;NFA_WORD&quot;); break;</a>
<a name="ln2456">  case NFA_NWORD: STRCPY(code, &quot;NFA_NWORD&quot;); break;</a>
<a name="ln2457">  case NFA_HEAD:  STRCPY(code, &quot;NFA_HEAD&quot;); break;</a>
<a name="ln2458">  case NFA_NHEAD: STRCPY(code, &quot;NFA_NHEAD&quot;); break;</a>
<a name="ln2459">  case NFA_ALPHA: STRCPY(code, &quot;NFA_ALPHA&quot;); break;</a>
<a name="ln2460">  case NFA_NALPHA: STRCPY(code, &quot;NFA_NALPHA&quot;); break;</a>
<a name="ln2461">  case NFA_LOWER: STRCPY(code, &quot;NFA_LOWER&quot;); break;</a>
<a name="ln2462">  case NFA_NLOWER: STRCPY(code, &quot;NFA_NLOWER&quot;); break;</a>
<a name="ln2463">  case NFA_UPPER: STRCPY(code, &quot;NFA_UPPER&quot;); break;</a>
<a name="ln2464">  case NFA_NUPPER: STRCPY(code, &quot;NFA_NUPPER&quot;); break;</a>
<a name="ln2465">  case NFA_LOWER_IC:  STRCPY(code, &quot;NFA_LOWER_IC&quot;); break;</a>
<a name="ln2466">  case NFA_NLOWER_IC: STRCPY(code, &quot;NFA_NLOWER_IC&quot;); break;</a>
<a name="ln2467">  case NFA_UPPER_IC:  STRCPY(code, &quot;NFA_UPPER_IC&quot;); break;</a>
<a name="ln2468">  case NFA_NUPPER_IC: STRCPY(code, &quot;NFA_NUPPER_IC&quot;); break;</a>
<a name="ln2469"> </a>
<a name="ln2470">  default:</a>
<a name="ln2471">    STRCPY(code, &quot;CHAR(x)&quot;);</a>
<a name="ln2472">    code[5] = c;</a>
<a name="ln2473">  }</a>
<a name="ln2474"> </a>
<a name="ln2475">  if (addnl == true) {</a>
<a name="ln2476">    STRCAT(code, &quot; + NEWLINE &quot;);</a>
<a name="ln2477">  }</a>
<a name="ln2478">}</a>
<a name="ln2479"> </a>
<a name="ln2480">static FILE *log_fd;</a>
<a name="ln2481">static char_u e_log_open_failed[] = N_(</a>
<a name="ln2482">    &quot;Could not open temporary log file for writing, displaying on stderr... &quot;);</a>
<a name="ln2483"> </a>
<a name="ln2484">/*</a>
<a name="ln2485"> * Print the postfix notation of the current regexp.</a>
<a name="ln2486"> */</a>
<a name="ln2487">static void nfa_postfix_dump(char_u *expr, int retval)</a>
<a name="ln2488">{</a>
<a name="ln2489">  int *p;</a>
<a name="ln2490">  FILE *f;</a>
<a name="ln2491"> </a>
<a name="ln2492">  f = fopen(NFA_REGEXP_DUMP_LOG, &quot;a&quot;);</a>
<a name="ln2493">  if (f != NULL) {</a>
<a name="ln2494">    fprintf(f, &quot;\n-------------------------\n&quot;);</a>
<a name="ln2495">    if (retval == FAIL) {</a>
<a name="ln2496">      fprintf(f, &quot;&gt;&gt;&gt; NFA engine failed... \n&quot;);</a>
<a name="ln2497">    } else if (retval == OK) {</a>
<a name="ln2498">      fprintf(f, &quot;&gt;&gt;&gt; NFA engine succeeded !\n&quot;);</a>
<a name="ln2499">    }</a>
<a name="ln2500">    fprintf(f, &quot;Regexp: \&quot;%s\&quot;\nPostfix notation (char): \&quot;&quot;, expr);</a>
<a name="ln2501">    for (p = post_start; *p &amp;&amp; p &lt; post_ptr; p++) {</a>
<a name="ln2502">      nfa_set_code(*p);</a>
<a name="ln2503">      fprintf(f, &quot;%s, &quot;, code);</a>
<a name="ln2504">    }</a>
<a name="ln2505">    fprintf(f, &quot;\&quot;\nPostfix notation (int): &quot;);</a>
<a name="ln2506">    for (p = post_start; *p &amp;&amp; p &lt; post_ptr; p++)</a>
<a name="ln2507">      fprintf(f, &quot;%d &quot;, *p);</a>
<a name="ln2508">    fprintf(f, &quot;\n\n&quot;);</a>
<a name="ln2509">    fclose(f);</a>
<a name="ln2510">  }</a>
<a name="ln2511">}</a>
<a name="ln2512"> </a>
<a name="ln2513">/*</a>
<a name="ln2514"> * Print the NFA starting with a root node &quot;state&quot;.</a>
<a name="ln2515"> */</a>
<a name="ln2516">static void nfa_print_state(FILE *debugf, nfa_state_T *state)</a>
<a name="ln2517">{</a>
<a name="ln2518">  garray_T indent;</a>
<a name="ln2519"> </a>
<a name="ln2520">  ga_init(&amp;indent, 1, 64);</a>
<a name="ln2521">  ga_append(&amp;indent, '\0');</a>
<a name="ln2522">  nfa_print_state2(debugf, state, &amp;indent);</a>
<a name="ln2523">  ga_clear(&amp;indent);</a>
<a name="ln2524">}</a>
<a name="ln2525"> </a>
<a name="ln2526">static void nfa_print_state2(FILE *debugf, nfa_state_T *state, garray_T *indent)</a>
<a name="ln2527">{</a>
<a name="ln2528">  char_u  *p;</a>
<a name="ln2529"> </a>
<a name="ln2530">  if (state == NULL)</a>
<a name="ln2531">    return;</a>
<a name="ln2532"> </a>
<a name="ln2533">  fprintf(debugf, &quot;(%2d)&quot;, abs(state-&gt;id));</a>
<a name="ln2534"> </a>
<a name="ln2535">  /* Output indent */</a>
<a name="ln2536">  p = (char_u *)indent-&gt;ga_data;</a>
<a name="ln2537">  if (indent-&gt;ga_len &gt;= 3) {</a>
<a name="ln2538">    int last = indent-&gt;ga_len - 3;</a>
<a name="ln2539">    char_u save[2];</a>
<a name="ln2540"> </a>
<a name="ln2541">    STRNCPY(save, &amp;p[last], 2);</a>
<a name="ln2542">    STRNCPY(&amp;p[last], &quot;+-&quot;, 2);</a>
<a name="ln2543">    fprintf(debugf, &quot; %s&quot;, p);</a>
<a name="ln2544">    STRNCPY(&amp;p[last], save, 2);</a>
<a name="ln2545">  } else</a>
<a name="ln2546">    fprintf(debugf, &quot; %s&quot;, p);</a>
<a name="ln2547"> </a>
<a name="ln2548">  nfa_set_code(state-&gt;c);</a>
<a name="ln2549">  fprintf(debugf, &quot;%s (%d) (id=%d) val=%d\n&quot;,</a>
<a name="ln2550">      code,</a>
<a name="ln2551">      state-&gt;c,</a>
<a name="ln2552">      abs(state-&gt;id),</a>
<a name="ln2553">      state-&gt;val);</a>
<a name="ln2554">  if (state-&gt;id &lt; 0)</a>
<a name="ln2555">    return;</a>
<a name="ln2556"> </a>
<a name="ln2557">  state-&gt;id = abs(state-&gt;id) * -1;</a>
<a name="ln2558"> </a>
<a name="ln2559">  /* grow indent for state-&gt;out */</a>
<a name="ln2560">  indent-&gt;ga_len -= 1;</a>
<a name="ln2561">  if (state-&gt;out1)</a>
<a name="ln2562">    ga_concat(indent, (char_u *)&quot;| &quot;);</a>
<a name="ln2563">  else</a>
<a name="ln2564">    ga_concat(indent, (char_u *)&quot;  &quot;);</a>
<a name="ln2565">  ga_append(indent, '\0');</a>
<a name="ln2566"> </a>
<a name="ln2567">  nfa_print_state2(debugf, state-&gt;out, indent);</a>
<a name="ln2568"> </a>
<a name="ln2569">  /* replace last part of indent for state-&gt;out1 */</a>
<a name="ln2570">  indent-&gt;ga_len -= 3;</a>
<a name="ln2571">  ga_concat(indent, (char_u *)&quot;  &quot;);</a>
<a name="ln2572">  ga_append(indent, '\0');</a>
<a name="ln2573"> </a>
<a name="ln2574">  nfa_print_state2(debugf, state-&gt;out1, indent);</a>
<a name="ln2575"> </a>
<a name="ln2576">  /* shrink indent */</a>
<a name="ln2577">  indent-&gt;ga_len -= 3;</a>
<a name="ln2578">  ga_append(indent, '\0');</a>
<a name="ln2579">}</a>
<a name="ln2580"> </a>
<a name="ln2581">/*</a>
<a name="ln2582"> * Print the NFA state machine.</a>
<a name="ln2583"> */</a>
<a name="ln2584">static void nfa_dump(nfa_regprog_T *prog)</a>
<a name="ln2585">{</a>
<a name="ln2586">  FILE *debugf = fopen(NFA_REGEXP_DUMP_LOG, &quot;a&quot;);</a>
<a name="ln2587"> </a>
<a name="ln2588">  if (debugf != NULL) {</a>
<a name="ln2589">    nfa_print_state(debugf, prog-&gt;start);</a>
<a name="ln2590"> </a>
<a name="ln2591">    if (prog-&gt;reganch)</a>
<a name="ln2592">      fprintf(debugf, &quot;reganch: %d\n&quot;, prog-&gt;reganch);</a>
<a name="ln2593">    if (prog-&gt;regstart != NUL)</a>
<a name="ln2594">      fprintf(debugf, &quot;regstart: %c (decimal: %d)\n&quot;,</a>
<a name="ln2595">          prog-&gt;regstart, prog-&gt;regstart);</a>
<a name="ln2596">    if (prog-&gt;match_text != NULL)</a>
<a name="ln2597">      fprintf(debugf, &quot;match_text: \&quot;%s\&quot;\n&quot;, prog-&gt;match_text);</a>
<a name="ln2598"> </a>
<a name="ln2599">    fclose(debugf);</a>
<a name="ln2600">  }</a>
<a name="ln2601">}</a>
<a name="ln2602">#endif      /* REGEXP_DEBUG */</a>
<a name="ln2603"> </a>
<a name="ln2604">/*</a>
<a name="ln2605"> * Parse r.e. @expr and convert it into postfix form.</a>
<a name="ln2606"> * Return the postfix string on success, NULL otherwise.</a>
<a name="ln2607"> */</a>
<a name="ln2608">static int *re2post(void)</a>
<a name="ln2609">{</a>
<a name="ln2610">  if (nfa_reg(REG_NOPAREN) == FAIL)</a>
<a name="ln2611">    return NULL;</a>
<a name="ln2612">  EMIT(NFA_MOPEN);</a>
<a name="ln2613">  return post_start;</a>
<a name="ln2614">}</a>
<a name="ln2615"> </a>
<a name="ln2616">/* NB. Some of the code below is inspired by Russ's. */</a>
<a name="ln2617"> </a>
<a name="ln2618">/*</a>
<a name="ln2619"> * Represents an NFA state plus zero or one or two arrows exiting.</a>
<a name="ln2620"> * if c == MATCH, no arrows out; matching state.</a>
<a name="ln2621"> * If c == SPLIT, unlabeled arrows to out and out1 (if != NULL).</a>
<a name="ln2622"> * If c &lt; 256, labeled arrow with character c to out.</a>
<a name="ln2623"> */</a>
<a name="ln2624"> </a>
<a name="ln2625">static nfa_state_T      *state_ptr; /* points to nfa_prog-&gt;state */</a>
<a name="ln2626"> </a>
<a name="ln2627">/*</a>
<a name="ln2628"> * Allocate and initialize nfa_state_T.</a>
<a name="ln2629"> */</a>
<a name="ln2630">static nfa_state_T *alloc_state(int c, nfa_state_T *out, nfa_state_T *out1)</a>
<a name="ln2631">{</a>
<a name="ln2632">  nfa_state_T *s;</a>
<a name="ln2633"> </a>
<a name="ln2634">  if (istate &gt;= nstate)</a>
<a name="ln2635">    return NULL;</a>
<a name="ln2636"> </a>
<a name="ln2637">  s = &amp;state_ptr[istate++];</a>
<a name="ln2638"> </a>
<a name="ln2639">  s-&gt;c    = c;</a>
<a name="ln2640">  s-&gt;out  = out;</a>
<a name="ln2641">  s-&gt;out1 = out1;</a>
<a name="ln2642">  s-&gt;val  = 0;</a>
<a name="ln2643"> </a>
<a name="ln2644">  s-&gt;id   = istate;</a>
<a name="ln2645">  s-&gt;lastlist[0] = 0;</a>
<a name="ln2646">  s-&gt;lastlist[1] = 0;</a>
<a name="ln2647"> </a>
<a name="ln2648">  return s;</a>
<a name="ln2649">}</a>
<a name="ln2650"> </a>
<a name="ln2651">/*</a>
<a name="ln2652"> * A partially built NFA without the matching state filled in.</a>
<a name="ln2653"> * Frag_T.start points at the start state.</a>
<a name="ln2654"> * Frag_T.out is a list of places that need to be set to the</a>
<a name="ln2655"> * next state for this fragment.</a>
<a name="ln2656"> */</a>
<a name="ln2657"> </a>
<a name="ln2658"> </a>
<a name="ln2659">/*</a>
<a name="ln2660"> * Initialize a Frag_T struct and return it.</a>
<a name="ln2661"> */</a>
<a name="ln2662">static Frag_T frag(nfa_state_T *start, Ptrlist *out)</a>
<a name="ln2663">{</a>
<a name="ln2664">  Frag_T n;</a>
<a name="ln2665"> </a>
<a name="ln2666">  n.start = start;</a>
<a name="ln2667">  n.out = out;</a>
<a name="ln2668">  return n;</a>
<a name="ln2669">}</a>
<a name="ln2670"> </a>
<a name="ln2671">/*</a>
<a name="ln2672"> * Create singleton list containing just outp.</a>
<a name="ln2673"> */</a>
<a name="ln2674">static Ptrlist *list1(nfa_state_T **outp)</a>
<a name="ln2675">{</a>
<a name="ln2676">  Ptrlist *l;</a>
<a name="ln2677"> </a>
<a name="ln2678">  l = (Ptrlist *)outp;</a>
<a name="ln2679">  l-&gt;next = NULL;</a>
<a name="ln2680">  return l;</a>
<a name="ln2681">}</a>
<a name="ln2682"> </a>
<a name="ln2683">/*</a>
<a name="ln2684"> * Patch the list of states at out to point to start.</a>
<a name="ln2685"> */</a>
<a name="ln2686">static void patch(Ptrlist *l, nfa_state_T *s)</a>
<a name="ln2687">{</a>
<a name="ln2688">  Ptrlist *next;</a>
<a name="ln2689"> </a>
<a name="ln2690">  for (; l; l = next) {</a>
<a name="ln2691">    next = l-&gt;next;</a>
<a name="ln2692">    l-&gt;s = s;</a>
<a name="ln2693">  }</a>
<a name="ln2694">}</a>
<a name="ln2695"> </a>
<a name="ln2696"> </a>
<a name="ln2697">/*</a>
<a name="ln2698"> * Join the two lists l1 and l2, returning the combination.</a>
<a name="ln2699"> */</a>
<a name="ln2700">static Ptrlist *append(Ptrlist *l1, Ptrlist *l2)</a>
<a name="ln2701">{</a>
<a name="ln2702">  Ptrlist *oldl1;</a>
<a name="ln2703"> </a>
<a name="ln2704">  oldl1 = l1;</a>
<a name="ln2705">  while (l1-&gt;next)</a>
<a name="ln2706">    l1 = l1-&gt;next;</a>
<a name="ln2707">  l1-&gt;next = l2;</a>
<a name="ln2708">  return oldl1;</a>
<a name="ln2709">}</a>
<a name="ln2710"> </a>
<a name="ln2711">/*</a>
<a name="ln2712"> * Stack used for transforming postfix form into NFA.</a>
<a name="ln2713"> */</a>
<a name="ln2714">static Frag_T empty;</a>
<a name="ln2715"> </a>
<a name="ln2716">static void st_error(int *postfix, int *end, int *p)</a>
<a name="ln2717">{</a>
<a name="ln2718">#ifdef NFA_REGEXP_ERROR_LOG</a>
<a name="ln2719">  FILE *df;</a>
<a name="ln2720">  int *p2;</a>
<a name="ln2721"> </a>
<a name="ln2722">  df = fopen(NFA_REGEXP_ERROR_LOG, &quot;a&quot;);</a>
<a name="ln2723">  if (df) {</a>
<a name="ln2724">    fprintf(df, &quot;Error popping the stack!\n&quot;);</a>
<a name="ln2725">#ifdef REGEXP_DEBUG</a>
<a name="ln2726">    fprintf(df, &quot;Current regexp is \&quot;%s\&quot;\n&quot;, nfa_regengine.expr);</a>
<a name="ln2727">#endif</a>
<a name="ln2728">    fprintf(df, &quot;Postfix form is: &quot;);</a>
<a name="ln2729">#ifdef REGEXP_DEBUG</a>
<a name="ln2730">    for (p2 = postfix; p2 &lt; end; p2++) {</a>
<a name="ln2731">      nfa_set_code(*p2);</a>
<a name="ln2732">      fprintf(df, &quot;%s, &quot;, code);</a>
<a name="ln2733">    }</a>
<a name="ln2734">    nfa_set_code(*p);</a>
<a name="ln2735">    fprintf(df, &quot;\nCurrent position is: &quot;);</a>
<a name="ln2736">    for (p2 = postfix; p2 &lt;= p; p2++) {</a>
<a name="ln2737">      nfa_set_code(*p2);</a>
<a name="ln2738">      fprintf(df, &quot;%s, &quot;, code);</a>
<a name="ln2739">    }</a>
<a name="ln2740">#else</a>
<a name="ln2741">    for (p2 = postfix; p2 &lt; end; p2++) {</a>
<a name="ln2742">      fprintf(df, &quot;%d, &quot;, *p2);</a>
<a name="ln2743">    }</a>
<a name="ln2744">    fprintf(df, &quot;\nCurrent position is: &quot;);</a>
<a name="ln2745">    for (p2 = postfix; p2 &lt;= p; p2++) {</a>
<a name="ln2746">      fprintf(df, &quot;%d, &quot;, *p2);</a>
<a name="ln2747">    }</a>
<a name="ln2748">#endif</a>
<a name="ln2749">    fprintf(df, &quot;\n--------------------------\n&quot;);</a>
<a name="ln2750">    fclose(df);</a>
<a name="ln2751">  }</a>
<a name="ln2752">#endif</a>
<a name="ln2753">  EMSG(_(&quot;E874: (NFA) Could not pop the stack!&quot;));</a>
<a name="ln2754">}</a>
<a name="ln2755"> </a>
<a name="ln2756">/*</a>
<a name="ln2757"> * Push an item onto the stack.</a>
<a name="ln2758"> */</a>
<a name="ln2759">static void st_push(Frag_T s, Frag_T **p, Frag_T *stack_end)</a>
<a name="ln2760">{</a>
<a name="ln2761">  Frag_T *stackp = *p;</a>
<a name="ln2762"> </a>
<a name="ln2763">  if (stackp &gt;= stack_end)</a>
<a name="ln2764">    return;</a>
<a name="ln2765">  *stackp = s;</a>
<a name="ln2766">  *p = *p + 1;</a>
<a name="ln2767">}</a>
<a name="ln2768"> </a>
<a name="ln2769">/*</a>
<a name="ln2770"> * Pop an item from the stack.</a>
<a name="ln2771"> */</a>
<a name="ln2772">static Frag_T st_pop(Frag_T **p, Frag_T *stack)</a>
<a name="ln2773">{</a>
<a name="ln2774">  Frag_T *stackp;</a>
<a name="ln2775"> </a>
<a name="ln2776">  *p = *p - 1;</a>
<a name="ln2777">  stackp = *p;</a>
<a name="ln2778">  if (stackp &lt; stack)</a>
<a name="ln2779">    return empty;</a>
<a name="ln2780">  return **p;</a>
<a name="ln2781">}</a>
<a name="ln2782"> </a>
<a name="ln2783">/*</a>
<a name="ln2784"> * Estimate the maximum byte length of anything matching &quot;state&quot;.</a>
<a name="ln2785"> * When unknown or unlimited return -1.</a>
<a name="ln2786"> */</a>
<a name="ln2787">static int nfa_max_width(nfa_state_T *startstate, int depth)</a>
<a name="ln2788">{</a>
<a name="ln2789">  int l, r;</a>
<a name="ln2790">  nfa_state_T     *state = startstate;</a>
<a name="ln2791">  int len = 0;</a>
<a name="ln2792"> </a>
<a name="ln2793">  /* detect looping in a NFA_SPLIT */</a>
<a name="ln2794">  if (depth &gt; 4)</a>
<a name="ln2795">    return -1;</a>
<a name="ln2796"> </a>
<a name="ln2797">  while (state != NULL) {</a>
<a name="ln2798">    switch (state-&gt;c) {</a>
<a name="ln2799">    case NFA_END_INVISIBLE:</a>
<a name="ln2800">    case NFA_END_INVISIBLE_NEG:</a>
<a name="ln2801">      /* the end, return what we have */</a>
<a name="ln2802">      return len;</a>
<a name="ln2803"> </a>
<a name="ln2804">    case NFA_SPLIT:</a>
<a name="ln2805">      /* two alternatives, use the maximum */</a>
<a name="ln2806">      l = nfa_max_width(state-&gt;out, depth + 1);</a>
<a name="ln2807">      r = nfa_max_width(state-&gt;out1, depth + 1);</a>
<a name="ln2808">      if (l &lt; 0 || r &lt; 0)</a>
<a name="ln2809">        return -1;</a>
<a name="ln2810">      return len + (l &gt; r ? l : r);</a>
<a name="ln2811"> </a>
<a name="ln2812">    case NFA_ANY:</a>
<a name="ln2813">    case NFA_START_COLL:</a>
<a name="ln2814">    case NFA_START_NEG_COLL:</a>
<a name="ln2815">      // Matches some character, including composing chars.</a>
<a name="ln2816">      len += MB_MAXBYTES;</a>
<a name="ln2817">      if (state-&gt;c != NFA_ANY) {</a>
<a name="ln2818">        // Skip over the characters.</a>
<a name="ln2819">        state = state-&gt;out1-&gt;out;</a>
<a name="ln2820">        continue;</a>
<a name="ln2821">      }</a>
<a name="ln2822">      break;</a>
<a name="ln2823"> </a>
<a name="ln2824">    case NFA_DIGIT:</a>
<a name="ln2825">    case NFA_WHITE:</a>
<a name="ln2826">    case NFA_HEX:</a>
<a name="ln2827">    case NFA_OCTAL:</a>
<a name="ln2828">      /* ascii */</a>
<a name="ln2829">      ++len;</a>
<a name="ln2830">      break;</a>
<a name="ln2831"> </a>
<a name="ln2832">    case NFA_IDENT:</a>
<a name="ln2833">    case NFA_SIDENT:</a>
<a name="ln2834">    case NFA_KWORD:</a>
<a name="ln2835">    case NFA_SKWORD:</a>
<a name="ln2836">    case NFA_FNAME:</a>
<a name="ln2837">    case NFA_SFNAME:</a>
<a name="ln2838">    case NFA_PRINT:</a>
<a name="ln2839">    case NFA_SPRINT:</a>
<a name="ln2840">    case NFA_NWHITE:</a>
<a name="ln2841">    case NFA_NDIGIT:</a>
<a name="ln2842">    case NFA_NHEX:</a>
<a name="ln2843">    case NFA_NOCTAL:</a>
<a name="ln2844">    case NFA_WORD:</a>
<a name="ln2845">    case NFA_NWORD:</a>
<a name="ln2846">    case NFA_HEAD:</a>
<a name="ln2847">    case NFA_NHEAD:</a>
<a name="ln2848">    case NFA_ALPHA:</a>
<a name="ln2849">    case NFA_NALPHA:</a>
<a name="ln2850">    case NFA_LOWER:</a>
<a name="ln2851">    case NFA_NLOWER:</a>
<a name="ln2852">    case NFA_UPPER:</a>
<a name="ln2853">    case NFA_NUPPER:</a>
<a name="ln2854">    case NFA_LOWER_IC:</a>
<a name="ln2855">    case NFA_NLOWER_IC:</a>
<a name="ln2856">    case NFA_UPPER_IC:</a>
<a name="ln2857">    case NFA_NUPPER_IC:</a>
<a name="ln2858">    case NFA_ANY_COMPOSING:</a>
<a name="ln2859">      // possibly non-ascii</a>
<a name="ln2860">      len += 3;</a>
<a name="ln2861">      break;</a>
<a name="ln2862"> </a>
<a name="ln2863">    case NFA_START_INVISIBLE:</a>
<a name="ln2864">    case NFA_START_INVISIBLE_NEG:</a>
<a name="ln2865">    case NFA_START_INVISIBLE_BEFORE:</a>
<a name="ln2866">    case NFA_START_INVISIBLE_BEFORE_NEG:</a>
<a name="ln2867">      /* zero-width, out1 points to the END state */</a>
<a name="ln2868">      state = state-&gt;out1-&gt;out;</a>
<a name="ln2869">      continue;</a>
<a name="ln2870"> </a>
<a name="ln2871">    case NFA_BACKREF1:</a>
<a name="ln2872">    case NFA_BACKREF2:</a>
<a name="ln2873">    case NFA_BACKREF3:</a>
<a name="ln2874">    case NFA_BACKREF4:</a>
<a name="ln2875">    case NFA_BACKREF5:</a>
<a name="ln2876">    case NFA_BACKREF6:</a>
<a name="ln2877">    case NFA_BACKREF7:</a>
<a name="ln2878">    case NFA_BACKREF8:</a>
<a name="ln2879">    case NFA_BACKREF9:</a>
<a name="ln2880">    case NFA_ZREF1:</a>
<a name="ln2881">    case NFA_ZREF2:</a>
<a name="ln2882">    case NFA_ZREF3:</a>
<a name="ln2883">    case NFA_ZREF4:</a>
<a name="ln2884">    case NFA_ZREF5:</a>
<a name="ln2885">    case NFA_ZREF6:</a>
<a name="ln2886">    case NFA_ZREF7:</a>
<a name="ln2887">    case NFA_ZREF8:</a>
<a name="ln2888">    case NFA_ZREF9:</a>
<a name="ln2889">    case NFA_NEWL:</a>
<a name="ln2890">    case NFA_SKIP:</a>
<a name="ln2891">      /* unknown width */</a>
<a name="ln2892">      return -1;</a>
<a name="ln2893"> </a>
<a name="ln2894">    case NFA_BOL:</a>
<a name="ln2895">    case NFA_EOL:</a>
<a name="ln2896">    case NFA_BOF:</a>
<a name="ln2897">    case NFA_EOF:</a>
<a name="ln2898">    case NFA_BOW:</a>
<a name="ln2899">    case NFA_EOW:</a>
<a name="ln2900">    case NFA_MOPEN:</a>
<a name="ln2901">    case NFA_MOPEN1:</a>
<a name="ln2902">    case NFA_MOPEN2:</a>
<a name="ln2903">    case NFA_MOPEN3:</a>
<a name="ln2904">    case NFA_MOPEN4:</a>
<a name="ln2905">    case NFA_MOPEN5:</a>
<a name="ln2906">    case NFA_MOPEN6:</a>
<a name="ln2907">    case NFA_MOPEN7:</a>
<a name="ln2908">    case NFA_MOPEN8:</a>
<a name="ln2909">    case NFA_MOPEN9:</a>
<a name="ln2910">    case NFA_ZOPEN:</a>
<a name="ln2911">    case NFA_ZOPEN1:</a>
<a name="ln2912">    case NFA_ZOPEN2:</a>
<a name="ln2913">    case NFA_ZOPEN3:</a>
<a name="ln2914">    case NFA_ZOPEN4:</a>
<a name="ln2915">    case NFA_ZOPEN5:</a>
<a name="ln2916">    case NFA_ZOPEN6:</a>
<a name="ln2917">    case NFA_ZOPEN7:</a>
<a name="ln2918">    case NFA_ZOPEN8:</a>
<a name="ln2919">    case NFA_ZOPEN9:</a>
<a name="ln2920">    case NFA_ZCLOSE:</a>
<a name="ln2921">    case NFA_ZCLOSE1:</a>
<a name="ln2922">    case NFA_ZCLOSE2:</a>
<a name="ln2923">    case NFA_ZCLOSE3:</a>
<a name="ln2924">    case NFA_ZCLOSE4:</a>
<a name="ln2925">    case NFA_ZCLOSE5:</a>
<a name="ln2926">    case NFA_ZCLOSE6:</a>
<a name="ln2927">    case NFA_ZCLOSE7:</a>
<a name="ln2928">    case NFA_ZCLOSE8:</a>
<a name="ln2929">    case NFA_ZCLOSE9:</a>
<a name="ln2930">    case NFA_MCLOSE:</a>
<a name="ln2931">    case NFA_MCLOSE1:</a>
<a name="ln2932">    case NFA_MCLOSE2:</a>
<a name="ln2933">    case NFA_MCLOSE3:</a>
<a name="ln2934">    case NFA_MCLOSE4:</a>
<a name="ln2935">    case NFA_MCLOSE5:</a>
<a name="ln2936">    case NFA_MCLOSE6:</a>
<a name="ln2937">    case NFA_MCLOSE7:</a>
<a name="ln2938">    case NFA_MCLOSE8:</a>
<a name="ln2939">    case NFA_MCLOSE9:</a>
<a name="ln2940">    case NFA_NOPEN:</a>
<a name="ln2941">    case NFA_NCLOSE:</a>
<a name="ln2942"> </a>
<a name="ln2943">    case NFA_LNUM_GT:</a>
<a name="ln2944">    case NFA_LNUM_LT:</a>
<a name="ln2945">    case NFA_COL_GT:</a>
<a name="ln2946">    case NFA_COL_LT:</a>
<a name="ln2947">    case NFA_VCOL_GT:</a>
<a name="ln2948">    case NFA_VCOL_LT:</a>
<a name="ln2949">    case NFA_MARK_GT:</a>
<a name="ln2950">    case NFA_MARK_LT:</a>
<a name="ln2951">    case NFA_VISUAL:</a>
<a name="ln2952">    case NFA_LNUM:</a>
<a name="ln2953">    case NFA_CURSOR:</a>
<a name="ln2954">    case NFA_COL:</a>
<a name="ln2955">    case NFA_VCOL:</a>
<a name="ln2956">    case NFA_MARK:</a>
<a name="ln2957"> </a>
<a name="ln2958">    case NFA_ZSTART:</a>
<a name="ln2959">    case NFA_ZEND:</a>
<a name="ln2960">    case NFA_OPT_CHARS:</a>
<a name="ln2961">    case NFA_EMPTY:</a>
<a name="ln2962">    case NFA_START_PATTERN:</a>
<a name="ln2963">    case NFA_END_PATTERN:</a>
<a name="ln2964">    case NFA_COMPOSING:</a>
<a name="ln2965">    case NFA_END_COMPOSING:</a>
<a name="ln2966">      /* zero-width */</a>
<a name="ln2967">      break;</a>
<a name="ln2968"> </a>
<a name="ln2969">    default:</a>
<a name="ln2970">      if (state-&gt;c &lt; 0)</a>
<a name="ln2971">        /* don't know what this is */</a>
<a name="ln2972">        return -1;</a>
<a name="ln2973">      /* normal character */</a>
<a name="ln2974">      len += MB_CHAR2LEN(state-&gt;c);</a>
<a name="ln2975">      break;</a>
<a name="ln2976">    }</a>
<a name="ln2977"> </a>
<a name="ln2978">    /* normal way to continue */</a>
<a name="ln2979">    state = state-&gt;out;</a>
<a name="ln2980">  }</a>
<a name="ln2981"> </a>
<a name="ln2982">  /* unrecognized, &quot;cannot happen&quot; */</a>
<a name="ln2983">  return -1;</a>
<a name="ln2984">}</a>
<a name="ln2985"> </a>
<a name="ln2986">/*</a>
<a name="ln2987"> * Convert a postfix form into its equivalent NFA.</a>
<a name="ln2988"> * Return the NFA start state on success, NULL otherwise.</a>
<a name="ln2989"> */</a>
<a name="ln2990">static nfa_state_T *post2nfa(int *postfix, int *end, int nfa_calc_size)</a>
<a name="ln2991">{</a>
<a name="ln2992">  int         *p;</a>
<a name="ln2993">  int mopen;</a>
<a name="ln2994">  int mclose;</a>
<a name="ln2995">  Frag_T      *stack = NULL;</a>
<a name="ln2996">  Frag_T      *stackp = NULL;</a>
<a name="ln2997">  Frag_T      *stack_end = NULL;</a>
<a name="ln2998">  Frag_T e1;</a>
<a name="ln2999">  Frag_T e2;</a>
<a name="ln3000">  Frag_T e;</a>
<a name="ln3001">  nfa_state_T *s;</a>
<a name="ln3002">  nfa_state_T *s1;</a>
<a name="ln3003">  nfa_state_T *matchstate;</a>
<a name="ln3004">  nfa_state_T *ret = NULL;</a>
<a name="ln3005"> </a>
<a name="ln3006">  if (postfix == NULL)</a>
<a name="ln3007">    return NULL;</a>
<a name="ln3008"> </a>
<a name="ln3009">#define PUSH(s)     st_push((s), &amp;stackp, stack_end)</a>
<a name="ln3010">#define POP()       st_pop(&amp;stackp, stack); \</a>
<a name="ln3011">  if (stackp &lt; stack) { \</a>
<a name="ln3012">    st_error(postfix, end, p); \</a>
<a name="ln3013">    xfree(stack); \</a>
<a name="ln3014">    return NULL; \</a>
<a name="ln3015">  }</a>
<a name="ln3016"> </a>
<a name="ln3017">  if (nfa_calc_size == false) {</a>
<a name="ln3018">    // Allocate space for the stack. Max states on the stack: &quot;nstate&quot;.</a>
<a name="ln3019">    stack = xmalloc((nstate + 1) * sizeof(Frag_T));</a>
<a name="ln3020">    stackp = stack;</a>
<a name="ln3021">    stack_end = stack + (nstate + 1);</a>
<a name="ln3022">  }</a>
<a name="ln3023"> </a>
<a name="ln3024">  for (p = postfix; p &lt; end; ++p) {</a>
<a name="ln3025">    switch (*p) {</a>
<a name="ln3026">    case NFA_CONCAT:</a>
<a name="ln3027">      // Concatenation.</a>
<a name="ln3028">      // Pay attention: this operator does not exist in the r.e. itself</a>
<a name="ln3029">      // (it is implicit, really).  It is added when r.e. is translated</a>
<a name="ln3030">      // to postfix form in re2post().</a>
<a name="ln3031">      if (nfa_calc_size == true) {</a>
<a name="ln3032">        // nstate += 0;</a>
<a name="ln3033">        break;</a>
<a name="ln3034">      }</a>
<a name="ln3035">      e2 = POP();</a>
<a name="ln3036">      e1 = POP();</a>
<a name="ln3037">      patch(e1.out, e2.start);</a>
<a name="ln3038">      PUSH(frag(e1.start, e2.out));</a>
<a name="ln3039">      break;</a>
<a name="ln3040"> </a>
<a name="ln3041">    case NFA_OR:</a>
<a name="ln3042">      // Alternation</a>
<a name="ln3043">      if (nfa_calc_size == true) {</a>
<a name="ln3044">        nstate++;</a>
<a name="ln3045">        break;</a>
<a name="ln3046">      }</a>
<a name="ln3047">      e2 = POP();</a>
<a name="ln3048">      e1 = POP();</a>
<a name="ln3049">      s = alloc_state(NFA_SPLIT, e1.start, e2.start);</a>
<a name="ln3050">      if (s == NULL)</a>
<a name="ln3051">        goto theend;</a>
<a name="ln3052">      PUSH(frag(s, append(e1.out, e2.out)));</a>
<a name="ln3053">      break;</a>
<a name="ln3054"> </a>
<a name="ln3055">    case NFA_STAR:</a>
<a name="ln3056">      // Zero or more, prefer more</a>
<a name="ln3057">      if (nfa_calc_size == true) {</a>
<a name="ln3058">        nstate++;</a>
<a name="ln3059">        break;</a>
<a name="ln3060">      }</a>
<a name="ln3061">      e = POP();</a>
<a name="ln3062">      s = alloc_state(NFA_SPLIT, e.start, NULL);</a>
<a name="ln3063">      if (s == NULL)</a>
<a name="ln3064">        goto theend;</a>
<a name="ln3065">      patch(e.out, s);</a>
<a name="ln3066">      PUSH(frag(s, list1(&amp;s-&gt;out1)));</a>
<a name="ln3067">      break;</a>
<a name="ln3068"> </a>
<a name="ln3069">    case NFA_STAR_NONGREEDY:</a>
<a name="ln3070">      // Zero or more, prefer zero</a>
<a name="ln3071">      if (nfa_calc_size == true) {</a>
<a name="ln3072">        nstate++;</a>
<a name="ln3073">        break;</a>
<a name="ln3074">      }</a>
<a name="ln3075">      e = POP();</a>
<a name="ln3076">      s = alloc_state(NFA_SPLIT, NULL, e.start);</a>
<a name="ln3077">      if (s == NULL)</a>
<a name="ln3078">        goto theend;</a>
<a name="ln3079">      patch(e.out, s);</a>
<a name="ln3080">      PUSH(frag(s, list1(&amp;s-&gt;out)));</a>
<a name="ln3081">      break;</a>
<a name="ln3082"> </a>
<a name="ln3083">    case NFA_QUEST:</a>
<a name="ln3084">      // one or zero atoms=&gt; greedy match</a>
<a name="ln3085">      if (nfa_calc_size == true) {</a>
<a name="ln3086">        nstate++;</a>
<a name="ln3087">        break;</a>
<a name="ln3088">      }</a>
<a name="ln3089">      e = POP();</a>
<a name="ln3090">      s = alloc_state(NFA_SPLIT, e.start, NULL);</a>
<a name="ln3091">      if (s == NULL)</a>
<a name="ln3092">        goto theend;</a>
<a name="ln3093">      PUSH(frag(s, append(e.out, list1(&amp;s-&gt;out1))));</a>
<a name="ln3094">      break;</a>
<a name="ln3095"> </a>
<a name="ln3096">    case NFA_QUEST_NONGREEDY:</a>
<a name="ln3097">      // zero or one atoms =&gt; non-greedy match</a>
<a name="ln3098">      if (nfa_calc_size == true) {</a>
<a name="ln3099">        nstate++;</a>
<a name="ln3100">        break;</a>
<a name="ln3101">      }</a>
<a name="ln3102">      e = POP();</a>
<a name="ln3103">      s = alloc_state(NFA_SPLIT, NULL, e.start);</a>
<a name="ln3104">      if (s == NULL)</a>
<a name="ln3105">        goto theend;</a>
<a name="ln3106">      PUSH(frag(s, append(e.out, list1(&amp;s-&gt;out))));</a>
<a name="ln3107">      break;</a>
<a name="ln3108"> </a>
<a name="ln3109">    case NFA_END_COLL:</a>
<a name="ln3110">    case NFA_END_NEG_COLL:</a>
<a name="ln3111">      /* On the stack is the sequence starting with NFA_START_COLL or</a>
<a name="ln3112">       * NFA_START_NEG_COLL and all possible characters. Patch it to</a>
<a name="ln3113">       * add the output to the start. */</a>
<a name="ln3114">      if (nfa_calc_size == true) {</a>
<a name="ln3115">        nstate++;</a>
<a name="ln3116">        break;</a>
<a name="ln3117">      }</a>
<a name="ln3118">      e = POP();</a>
<a name="ln3119">      s = alloc_state(NFA_END_COLL, NULL, NULL);</a>
<a name="ln3120">      if (s == NULL)</a>
<a name="ln3121">        goto theend;</a>
<a name="ln3122">      patch(e.out, s);</a>
<a name="ln3123">      e.start-&gt;out1 = s;</a>
<a name="ln3124">      PUSH(frag(e.start, list1(&amp;s-&gt;out)));</a>
<a name="ln3125">      break;</a>
<a name="ln3126"> </a>
<a name="ln3127">    case NFA_RANGE:</a>
<a name="ln3128">      // Before this are two characters, the low and high end of a</a>
<a name="ln3129">      // range.  Turn them into two states with MIN and MAX.</a>
<a name="ln3130">      if (nfa_calc_size == true) {</a>
<a name="ln3131">        // nstate += 0;</a>
<a name="ln3132">        break;</a>
<a name="ln3133">      }</a>
<a name="ln3134">      e2 = POP();</a>
<a name="ln3135">      e1 = POP();</a>
<a name="ln3136">      e2.start-&gt;val = e2.start-&gt;c;</a>
<a name="ln3137">      e2.start-&gt;c = NFA_RANGE_MAX;</a>
<a name="ln3138">      e1.start-&gt;val = e1.start-&gt;c;</a>
<a name="ln3139">      e1.start-&gt;c = NFA_RANGE_MIN;</a>
<a name="ln3140">      patch(e1.out, e2.start);</a>
<a name="ln3141">      PUSH(frag(e1.start, e2.out));</a>
<a name="ln3142">      break;</a>
<a name="ln3143"> </a>
<a name="ln3144">    case NFA_EMPTY:</a>
<a name="ln3145">      // 0-length, used in a repetition with max/min count of 0</a>
<a name="ln3146">      if (nfa_calc_size == true) {</a>
<a name="ln3147">        nstate++;</a>
<a name="ln3148">        break;</a>
<a name="ln3149">      }</a>
<a name="ln3150">      s = alloc_state(NFA_EMPTY, NULL, NULL);</a>
<a name="ln3151">      if (s == NULL)</a>
<a name="ln3152">        goto theend;</a>
<a name="ln3153">      PUSH(frag(s, list1(&amp;s-&gt;out)));</a>
<a name="ln3154">      break;</a>
<a name="ln3155"> </a>
<a name="ln3156">    case NFA_OPT_CHARS:</a>
<a name="ln3157">    {</a>
<a name="ln3158">      int n;</a>
<a name="ln3159"> </a>
<a name="ln3160">      // \%[abc] implemented as:</a>
<a name="ln3161">      //    NFA_SPLIT</a>
<a name="ln3162">      //    +-CHAR(a)</a>
<a name="ln3163">      //    | +-NFA_SPLIT</a>
<a name="ln3164">      //    |   +-CHAR(b)</a>
<a name="ln3165">      //    |   | +-NFA_SPLIT</a>
<a name="ln3166">      //    |   |   +-CHAR(c)</a>
<a name="ln3167">      //    |   |   | +-next</a>
<a name="ln3168">      //    |   |   +- next</a>
<a name="ln3169">      //    |   +- next</a>
<a name="ln3170">      //    +- next</a>
<a name="ln3171">      n = *++p;  // get number of characters</a>
<a name="ln3172">      if (nfa_calc_size == true) {</a>
<a name="ln3173">        nstate += n;</a>
<a name="ln3174">        break;</a>
<a name="ln3175">      }</a>
<a name="ln3176">      s = NULL;       /* avoid compiler warning */</a>
<a name="ln3177">      e1.out = NULL;       /* stores list with out1's */</a>
<a name="ln3178">      s1 = NULL;       /* previous NFA_SPLIT to connect to */</a>
<a name="ln3179">      while (n-- &gt; 0) {</a>
<a name="ln3180">        e = POP();         /* get character */</a>
<a name="ln3181">        s = alloc_state(NFA_SPLIT, e.start, NULL);</a>
<a name="ln3182">        if (s == NULL)</a>
<a name="ln3183">          goto theend;</a>
<a name="ln3184">        if (e1.out == NULL)</a>
<a name="ln3185">          e1 = e;</a>
<a name="ln3186">        patch(e.out, s1);</a>
<a name="ln3187">        append(e1.out, list1(&amp;s-&gt;out1));</a>
<a name="ln3188">        s1 = s;</a>
<a name="ln3189">      }</a>
<a name="ln3190">      PUSH(frag(s, e1.out));</a>
<a name="ln3191">      break;</a>
<a name="ln3192">    }</a>
<a name="ln3193"> </a>
<a name="ln3194">    case NFA_PREV_ATOM_NO_WIDTH:</a>
<a name="ln3195">    case NFA_PREV_ATOM_NO_WIDTH_NEG:</a>
<a name="ln3196">    case NFA_PREV_ATOM_JUST_BEFORE:</a>
<a name="ln3197">    case NFA_PREV_ATOM_JUST_BEFORE_NEG:</a>
<a name="ln3198">    case NFA_PREV_ATOM_LIKE_PATTERN:</a>
<a name="ln3199">    {</a>
<a name="ln3200">      int before = (*p == NFA_PREV_ATOM_JUST_BEFORE</a>
<a name="ln3201">                    || *p == NFA_PREV_ATOM_JUST_BEFORE_NEG);</a>
<a name="ln3202">      int pattern = (*p == NFA_PREV_ATOM_LIKE_PATTERN);</a>
<a name="ln3203">      int start_state;</a>
<a name="ln3204">      int end_state;</a>
<a name="ln3205">      int n = 0;</a>
<a name="ln3206">      nfa_state_T *zend;</a>
<a name="ln3207">      nfa_state_T *skip;</a>
<a name="ln3208"> </a>
<a name="ln3209">      switch (*p) {</a>
<a name="ln3210">      case NFA_PREV_ATOM_NO_WIDTH:</a>
<a name="ln3211">        start_state = NFA_START_INVISIBLE;</a>
<a name="ln3212">        end_state = NFA_END_INVISIBLE;</a>
<a name="ln3213">        break;</a>
<a name="ln3214">      case NFA_PREV_ATOM_NO_WIDTH_NEG:</a>
<a name="ln3215">        start_state = NFA_START_INVISIBLE_NEG;</a>
<a name="ln3216">        end_state = NFA_END_INVISIBLE_NEG;</a>
<a name="ln3217">        break;</a>
<a name="ln3218">      case NFA_PREV_ATOM_JUST_BEFORE:</a>
<a name="ln3219">        start_state = NFA_START_INVISIBLE_BEFORE;</a>
<a name="ln3220">        end_state = NFA_END_INVISIBLE;</a>
<a name="ln3221">        break;</a>
<a name="ln3222">      case NFA_PREV_ATOM_JUST_BEFORE_NEG:</a>
<a name="ln3223">        start_state = NFA_START_INVISIBLE_BEFORE_NEG;</a>
<a name="ln3224">        end_state = NFA_END_INVISIBLE_NEG;</a>
<a name="ln3225">        break;</a>
<a name="ln3226">      default:           /* NFA_PREV_ATOM_LIKE_PATTERN: */</a>
<a name="ln3227">        start_state = NFA_START_PATTERN;</a>
<a name="ln3228">        end_state = NFA_END_PATTERN;</a>
<a name="ln3229">        break;</a>
<a name="ln3230">      }</a>
<a name="ln3231"> </a>
<a name="ln3232">      if (before)</a>
<a name="ln3233">        n = *++p;         /* get the count */</a>
<a name="ln3234"> </a>
<a name="ln3235">      /* The \@= operator: match the preceding atom with zero width.</a>
<a name="ln3236">       * The \@! operator: no match for the preceding atom.</a>
<a name="ln3237">       * The \@&lt;= operator: match for the preceding atom.</a>
<a name="ln3238">       * The \@&lt;! operator: no match for the preceding atom.</a>
<a name="ln3239">       * Surrounds the preceding atom with START_INVISIBLE and</a>
<a name="ln3240">       * END_INVISIBLE, similarly to MOPEN. */</a>
<a name="ln3241"> </a>
<a name="ln3242">      if (nfa_calc_size == true) {</a>
<a name="ln3243">        nstate += pattern ? 4 : 2;</a>
<a name="ln3244">        break;</a>
<a name="ln3245">      }</a>
<a name="ln3246">      e = POP();</a>
<a name="ln3247">      s1 = alloc_state(end_state, NULL, NULL);</a>
<a name="ln3248">      if (s1 == NULL)</a>
<a name="ln3249">        goto theend;</a>
<a name="ln3250"> </a>
<a name="ln3251">      s = alloc_state(start_state, e.start, s1);</a>
<a name="ln3252">      if (s == NULL)</a>
<a name="ln3253">        goto theend;</a>
<a name="ln3254">      if (pattern) {</a>
<a name="ln3255">        /* NFA_ZEND -&gt; NFA_END_PATTERN -&gt; NFA_SKIP -&gt; what follows. */</a>
<a name="ln3256">        skip = alloc_state(NFA_SKIP, NULL, NULL);</a>
<a name="ln3257">        if (skip == NULL) {</a>
<a name="ln3258">          goto theend;</a>
<a name="ln3259">        }</a>
<a name="ln3260">        zend = alloc_state(NFA_ZEND, s1, NULL);</a>
<a name="ln3261">        if (zend == NULL) {</a>
<a name="ln3262">          goto theend;</a>
<a name="ln3263">        }</a>
<a name="ln3264">        s1-&gt;out= skip;</a>
<a name="ln3265">        patch(e.out, zend);</a>
<a name="ln3266">        PUSH(frag(s, list1(&amp;skip-&gt;out)));</a>
<a name="ln3267">      } else {</a>
<a name="ln3268">        patch(e.out, s1);</a>
<a name="ln3269">        PUSH(frag(s, list1(&amp;s1-&gt;out)));</a>
<a name="ln3270">        if (before) {</a>
<a name="ln3271">          if (n &lt;= 0)</a>
<a name="ln3272">            /* See if we can guess the maximum width, it avoids a</a>
<a name="ln3273">             * lot of pointless tries. */</a>
<a name="ln3274">            n = nfa_max_width(e.start, 0);</a>
<a name="ln3275">          s-&gt;val = n;           /* store the count */</a>
<a name="ln3276">        }</a>
<a name="ln3277">      }</a>
<a name="ln3278">      break;</a>
<a name="ln3279">    }</a>
<a name="ln3280"> </a>
<a name="ln3281">    case NFA_COMPOSING:         // char with composing char</a>
<a name="ln3282">      FALLTHROUGH;</a>
<a name="ln3283"> </a>
<a name="ln3284">    case NFA_MOPEN:     /* \( \) Submatch */</a>
<a name="ln3285">    case NFA_MOPEN1:</a>
<a name="ln3286">    case NFA_MOPEN2:</a>
<a name="ln3287">    case NFA_MOPEN3:</a>
<a name="ln3288">    case NFA_MOPEN4:</a>
<a name="ln3289">    case NFA_MOPEN5:</a>
<a name="ln3290">    case NFA_MOPEN6:</a>
<a name="ln3291">    case NFA_MOPEN7:</a>
<a name="ln3292">    case NFA_MOPEN8:</a>
<a name="ln3293">    case NFA_MOPEN9:</a>
<a name="ln3294">    case NFA_ZOPEN:     /* \z( \) Submatch */</a>
<a name="ln3295">    case NFA_ZOPEN1:</a>
<a name="ln3296">    case NFA_ZOPEN2:</a>
<a name="ln3297">    case NFA_ZOPEN3:</a>
<a name="ln3298">    case NFA_ZOPEN4:</a>
<a name="ln3299">    case NFA_ZOPEN5:</a>
<a name="ln3300">    case NFA_ZOPEN6:</a>
<a name="ln3301">    case NFA_ZOPEN7:</a>
<a name="ln3302">    case NFA_ZOPEN8:</a>
<a name="ln3303">    case NFA_ZOPEN9:</a>
<a name="ln3304">    case NFA_NOPEN:     // \%( \) &quot;Invisible Submatch&quot;</a>
<a name="ln3305">      if (nfa_calc_size == true) {</a>
<a name="ln3306">        nstate += 2;</a>
<a name="ln3307">        break;</a>
<a name="ln3308">      }</a>
<a name="ln3309"> </a>
<a name="ln3310">      mopen = *p;</a>
<a name="ln3311">      switch (*p) {</a>
<a name="ln3312">      case NFA_NOPEN: mclose = NFA_NCLOSE; break;</a>
<a name="ln3313">      case NFA_ZOPEN: mclose = NFA_ZCLOSE; break;</a>
<a name="ln3314">      case NFA_ZOPEN1: mclose = NFA_ZCLOSE1; break;</a>
<a name="ln3315">      case NFA_ZOPEN2: mclose = NFA_ZCLOSE2; break;</a>
<a name="ln3316">      case NFA_ZOPEN3: mclose = NFA_ZCLOSE3; break;</a>
<a name="ln3317">      case NFA_ZOPEN4: mclose = NFA_ZCLOSE4; break;</a>
<a name="ln3318">      case NFA_ZOPEN5: mclose = NFA_ZCLOSE5; break;</a>
<a name="ln3319">      case NFA_ZOPEN6: mclose = NFA_ZCLOSE6; break;</a>
<a name="ln3320">      case NFA_ZOPEN7: mclose = NFA_ZCLOSE7; break;</a>
<a name="ln3321">      case NFA_ZOPEN8: mclose = NFA_ZCLOSE8; break;</a>
<a name="ln3322">      case NFA_ZOPEN9: mclose = NFA_ZCLOSE9; break;</a>
<a name="ln3323">      case NFA_COMPOSING: mclose = NFA_END_COMPOSING; break;</a>
<a name="ln3324">      default:</a>
<a name="ln3325">        /* NFA_MOPEN, NFA_MOPEN1 .. NFA_MOPEN9 */</a>
<a name="ln3326">        mclose = *p + NSUBEXP;</a>
<a name="ln3327">        break;</a>
<a name="ln3328">      }</a>
<a name="ln3329"> </a>
<a name="ln3330">      /* Allow &quot;NFA_MOPEN&quot; as a valid postfix representation for</a>
<a name="ln3331">       * the empty regexp &quot;&quot;. In this case, the NFA will be</a>
<a name="ln3332">       * NFA_MOPEN -&gt; NFA_MCLOSE. Note that this also allows</a>
<a name="ln3333">       * empty groups of parenthesis, and empty mbyte chars */</a>
<a name="ln3334">      if (stackp == stack) {</a>
<a name="ln3335">        s = alloc_state(mopen, NULL, NULL);</a>
<a name="ln3336">        if (s == NULL)</a>
<a name="ln3337">          goto theend;</a>
<a name="ln3338">        s1 = alloc_state(mclose, NULL, NULL);</a>
<a name="ln3339">        if (s1 == NULL)</a>
<a name="ln3340">          goto theend;</a>
<a name="ln3341">        patch(list1(&amp;s-&gt;out), s1);</a>
<a name="ln3342">        PUSH(frag(s, list1(&amp;s1-&gt;out)));</a>
<a name="ln3343">        break;</a>
<a name="ln3344">      }</a>
<a name="ln3345"> </a>
<a name="ln3346">      /* At least one node was emitted before NFA_MOPEN, so</a>
<a name="ln3347">       * at least one node will be between NFA_MOPEN and NFA_MCLOSE */</a>
<a name="ln3348">      e = POP();</a>
<a name="ln3349">      s = alloc_state(mopen, e.start, NULL);         /* `(' */</a>
<a name="ln3350">      if (s == NULL)</a>
<a name="ln3351">        goto theend;</a>
<a name="ln3352"> </a>
<a name="ln3353">      s1 = alloc_state(mclose, NULL, NULL);         /* `)' */</a>
<a name="ln3354">      if (s1 == NULL)</a>
<a name="ln3355">        goto theend;</a>
<a name="ln3356">      patch(e.out, s1);</a>
<a name="ln3357"> </a>
<a name="ln3358">      if (mopen == NFA_COMPOSING)</a>
<a name="ln3359">        /* COMPOSING-&gt;out1 = END_COMPOSING */</a>
<a name="ln3360">        patch(list1(&amp;s-&gt;out1), s1);</a>
<a name="ln3361"> </a>
<a name="ln3362">      PUSH(frag(s, list1(&amp;s1-&gt;out)));</a>
<a name="ln3363">      break;</a>
<a name="ln3364"> </a>
<a name="ln3365">    case NFA_BACKREF1:</a>
<a name="ln3366">    case NFA_BACKREF2:</a>
<a name="ln3367">    case NFA_BACKREF3:</a>
<a name="ln3368">    case NFA_BACKREF4:</a>
<a name="ln3369">    case NFA_BACKREF5:</a>
<a name="ln3370">    case NFA_BACKREF6:</a>
<a name="ln3371">    case NFA_BACKREF7:</a>
<a name="ln3372">    case NFA_BACKREF8:</a>
<a name="ln3373">    case NFA_BACKREF9:</a>
<a name="ln3374">    case NFA_ZREF1:</a>
<a name="ln3375">    case NFA_ZREF2:</a>
<a name="ln3376">    case NFA_ZREF3:</a>
<a name="ln3377">    case NFA_ZREF4:</a>
<a name="ln3378">    case NFA_ZREF5:</a>
<a name="ln3379">    case NFA_ZREF6:</a>
<a name="ln3380">    case NFA_ZREF7:</a>
<a name="ln3381">    case NFA_ZREF8:</a>
<a name="ln3382">    case NFA_ZREF9:</a>
<a name="ln3383">      if (nfa_calc_size == true) {</a>
<a name="ln3384">        nstate += 2;</a>
<a name="ln3385">        break;</a>
<a name="ln3386">      }</a>
<a name="ln3387">      s = alloc_state(*p, NULL, NULL);</a>
<a name="ln3388">      if (s == NULL)</a>
<a name="ln3389">        goto theend;</a>
<a name="ln3390">      s1 = alloc_state(NFA_SKIP, NULL, NULL);</a>
<a name="ln3391">      if (s1 == NULL)</a>
<a name="ln3392">        goto theend;</a>
<a name="ln3393">      patch(list1(&amp;s-&gt;out), s1);</a>
<a name="ln3394">      PUSH(frag(s, list1(&amp;s1-&gt;out)));</a>
<a name="ln3395">      break;</a>
<a name="ln3396"> </a>
<a name="ln3397">    case NFA_LNUM:</a>
<a name="ln3398">    case NFA_LNUM_GT:</a>
<a name="ln3399">    case NFA_LNUM_LT:</a>
<a name="ln3400">    case NFA_VCOL:</a>
<a name="ln3401">    case NFA_VCOL_GT:</a>
<a name="ln3402">    case NFA_VCOL_LT:</a>
<a name="ln3403">    case NFA_COL:</a>
<a name="ln3404">    case NFA_COL_GT:</a>
<a name="ln3405">    case NFA_COL_LT:</a>
<a name="ln3406">    case NFA_MARK:</a>
<a name="ln3407">    case NFA_MARK_GT:</a>
<a name="ln3408">    case NFA_MARK_LT:</a>
<a name="ln3409">    {</a>
<a name="ln3410">      int n = *++p;       /* lnum, col or mark name */</a>
<a name="ln3411"> </a>
<a name="ln3412">      if (nfa_calc_size == true) {</a>
<a name="ln3413">        nstate += 1;</a>
<a name="ln3414">        break;</a>
<a name="ln3415">      }</a>
<a name="ln3416">      s = alloc_state(p[-1], NULL, NULL);</a>
<a name="ln3417">      if (s == NULL)</a>
<a name="ln3418">        goto theend;</a>
<a name="ln3419">      s-&gt;val = n;</a>
<a name="ln3420">      PUSH(frag(s, list1(&amp;s-&gt;out)));</a>
<a name="ln3421">      break;</a>
<a name="ln3422">    }</a>
<a name="ln3423"> </a>
<a name="ln3424">    case NFA_ZSTART:</a>
<a name="ln3425">    case NFA_ZEND:</a>
<a name="ln3426">    default:</a>
<a name="ln3427">      // Operands</a>
<a name="ln3428">      if (nfa_calc_size == true) {</a>
<a name="ln3429">        nstate++;</a>
<a name="ln3430">        break;</a>
<a name="ln3431">      }</a>
<a name="ln3432">      s = alloc_state(*p, NULL, NULL);</a>
<a name="ln3433">      if (s == NULL)</a>
<a name="ln3434">        goto theend;</a>
<a name="ln3435">      PUSH(frag(s, list1(&amp;s-&gt;out)));</a>
<a name="ln3436">      break;</a>
<a name="ln3437"> </a>
<a name="ln3438">    }     /* switch(*p) */</a>
<a name="ln3439"> </a>
<a name="ln3440">  }   /* for(p = postfix; *p; ++p) */</a>
<a name="ln3441"> </a>
<a name="ln3442">  if (nfa_calc_size == true) {</a>
<a name="ln3443">    nstate++;</a>
<a name="ln3444">    goto theend;        /* Return value when counting size is ignored anyway */</a>
<a name="ln3445">  }</a>
<a name="ln3446"> </a>
<a name="ln3447">  e = POP();</a>
<a name="ln3448">  if (stackp != stack) {</a>
<a name="ln3449">    xfree(stack);</a>
<a name="ln3450">    EMSG_RET_NULL(_(&quot;E875: (NFA regexp) (While converting from postfix to NFA),&quot;</a>
<a name="ln3451">                    &quot;too many states left on stack&quot;));</a>
<a name="ln3452">  }</a>
<a name="ln3453"> </a>
<a name="ln3454">  if (istate &gt;= nstate) {</a>
<a name="ln3455">    xfree(stack);</a>
<a name="ln3456">    EMSG_RET_NULL(_(&quot;E876: (NFA regexp) &quot;</a>
<a name="ln3457">                    &quot;Not enough space to store the whole NFA &quot;));</a>
<a name="ln3458">  }</a>
<a name="ln3459"> </a>
<a name="ln3460">  matchstate = &amp;state_ptr[istate++];   /* the match state */</a>
<a name="ln3461">  matchstate-&gt;c = NFA_MATCH;</a>
<a name="ln3462">  matchstate-&gt;out = matchstate-&gt;out1 = NULL;</a>
<a name="ln3463">  matchstate-&gt;id = 0;</a>
<a name="ln3464"> </a>
<a name="ln3465">  patch(e.out, matchstate);</a>
<a name="ln3466">  ret = e.start;</a>
<a name="ln3467"> </a>
<a name="ln3468">theend:</a>
<a name="ln3469">  xfree(stack);</a>
<a name="ln3470">  return ret;</a>
<a name="ln3471"> </a>
<a name="ln3472">#undef POP1</a>
<a name="ln3473">#undef PUSH1</a>
<a name="ln3474">#undef POP2</a>
<a name="ln3475">#undef PUSH2</a>
<a name="ln3476">#undef POP</a>
<a name="ln3477">#undef PUSH</a>
<a name="ln3478">}</a>
<a name="ln3479"> </a>
<a name="ln3480">/*</a>
<a name="ln3481"> * After building the NFA program, inspect it to add optimization hints.</a>
<a name="ln3482"> */</a>
<a name="ln3483">static void nfa_postprocess(nfa_regprog_T *prog)</a>
<a name="ln3484">{</a>
<a name="ln3485">  int i;</a>
<a name="ln3486">  int c;</a>
<a name="ln3487"> </a>
<a name="ln3488">  for (i = 0; i &lt; prog-&gt;nstate; ++i) {</a>
<a name="ln3489">    c = prog-&gt;state[i].c;</a>
<a name="ln3490">    if (c == NFA_START_INVISIBLE</a>
<a name="ln3491">        || c == NFA_START_INVISIBLE_NEG</a>
<a name="ln3492">        || c == NFA_START_INVISIBLE_BEFORE</a>
<a name="ln3493">        || c == NFA_START_INVISIBLE_BEFORE_NEG) {</a>
<a name="ln3494">      int directly;</a>
<a name="ln3495"> </a>
<a name="ln3496">      // Do it directly when what follows is possibly the end of the</a>
<a name="ln3497">      // match.</a>
<a name="ln3498">      if (match_follows(prog-&gt;state[i].out1-&gt;out, 0)) {</a>
<a name="ln3499">        directly = true;</a>
<a name="ln3500">      } else {</a>
<a name="ln3501">        int ch_invisible = failure_chance(prog-&gt;state[i].out, 0);</a>
<a name="ln3502">        int ch_follows = failure_chance(prog-&gt;state[i].out1-&gt;out, 0);</a>
<a name="ln3503"> </a>
<a name="ln3504">        /* Postpone when the invisible match is expensive or has a</a>
<a name="ln3505">         * lower chance of failing. */</a>
<a name="ln3506">        if (c == NFA_START_INVISIBLE_BEFORE</a>
<a name="ln3507">            || c == NFA_START_INVISIBLE_BEFORE_NEG) {</a>
<a name="ln3508">          /* &quot;before&quot; matches are very expensive when</a>
<a name="ln3509">           * unbounded, always prefer what follows then,</a>
<a name="ln3510">           * unless what follows will always match.</a>
<a name="ln3511">           * Otherwise strongly prefer what follows. */</a>
<a name="ln3512">          if (prog-&gt;state[i].val &lt;= 0 &amp;&amp; ch_follows &gt; 0) {</a>
<a name="ln3513">            directly = false;</a>
<a name="ln3514">          } else {</a>
<a name="ln3515">            directly = ch_follows * 10 &lt; ch_invisible;</a>
<a name="ln3516">          }</a>
<a name="ln3517">        } else {</a>
<a name="ln3518">          /* normal invisible, first do the one with the</a>
<a name="ln3519">           * highest failure chance */</a>
<a name="ln3520">          directly = ch_follows &lt; ch_invisible;</a>
<a name="ln3521">        }</a>
<a name="ln3522">      }</a>
<a name="ln3523">      if (directly)</a>
<a name="ln3524">        /* switch to the _FIRST state */</a>
<a name="ln3525">        ++prog-&gt;state[i].c;</a>
<a name="ln3526">    }</a>
<a name="ln3527">  }</a>
<a name="ln3528">}</a>
<a name="ln3529"> </a>
<a name="ln3530">/****************************************************************</a>
<a name="ln3531">* NFA execution code.</a>
<a name="ln3532">****************************************************************/</a>
<a name="ln3533"> </a>
<a name="ln3534">/* Values for done in nfa_pim_T. */</a>
<a name="ln3535">#define NFA_PIM_UNUSED   0      /* pim not used */</a>
<a name="ln3536">#define NFA_PIM_TODO     1      /* pim not done yet */</a>
<a name="ln3537">#define NFA_PIM_MATCH    2      /* pim executed, matches */</a>
<a name="ln3538">#define NFA_PIM_NOMATCH  3      /* pim executed, no match */</a>
<a name="ln3539"> </a>
<a name="ln3540"> </a>
<a name="ln3541">#ifdef REGEXP_DEBUG</a>
<a name="ln3542">static void log_subsexpr(regsubs_T *subs)</a>
<a name="ln3543">{</a>
<a name="ln3544">  log_subexpr(&amp;subs-&gt;norm);</a>
<a name="ln3545">  if (rex.nfa_has_zsubexpr) {</a>
<a name="ln3546">    log_subexpr(&amp;subs-&gt;synt);</a>
<a name="ln3547">  }</a>
<a name="ln3548">}</a>
<a name="ln3549"> </a>
<a name="ln3550">static void log_subexpr(regsub_T *sub)</a>
<a name="ln3551">{</a>
<a name="ln3552">  int j;</a>
<a name="ln3553"> </a>
<a name="ln3554">  for (j = 0; j &lt; sub-&gt;in_use; j++)</a>
<a name="ln3555">    if (REG_MULTI)</a>
<a name="ln3556">      fprintf(log_fd, &quot;*** group %d, start: c=%d, l=%d, end: c=%d, l=%d\n&quot;,</a>
<a name="ln3557">          j,</a>
<a name="ln3558">          sub-&gt;list.multi[j].start_col,</a>
<a name="ln3559">          (int)sub-&gt;list.multi[j].start_lnum,</a>
<a name="ln3560">          sub-&gt;list.multi[j].end_col,</a>
<a name="ln3561">          (int)sub-&gt;list.multi[j].end_lnum);</a>
<a name="ln3562">    else {</a>
<a name="ln3563">      char *s = (char *)sub-&gt;list.line[j].start;</a>
<a name="ln3564">      char *e = (char *)sub-&gt;list.line[j].end;</a>
<a name="ln3565"> </a>
<a name="ln3566">      fprintf(log_fd, &quot;*** group %d, start: \&quot;%s\&quot;, end: \&quot;%s\&quot;\n&quot;,</a>
<a name="ln3567">          j,</a>
<a name="ln3568">          s == NULL ? &quot;NULL&quot; : s,</a>
<a name="ln3569">          e == NULL ? &quot;NULL&quot; : e);</a>
<a name="ln3570">    }</a>
<a name="ln3571">}</a>
<a name="ln3572"> </a>
<a name="ln3573">static char *pim_info(const nfa_pim_T *pim)</a>
<a name="ln3574">{</a>
<a name="ln3575">  static char buf[30];</a>
<a name="ln3576"> </a>
<a name="ln3577">  if (pim == NULL || pim-&gt;result == NFA_PIM_UNUSED) {</a>
<a name="ln3578">    buf[0] = NUL;</a>
<a name="ln3579">  } else {</a>
<a name="ln3580">    snprintf(buf, sizeof(buf), &quot; PIM col %d&quot;,</a>
<a name="ln3581">             REG_MULTI</a>
<a name="ln3582">             ? (int)pim-&gt;end.pos.col</a>
<a name="ln3583">             : (int)(pim-&gt;end.ptr - rex.input));</a>
<a name="ln3584">  }</a>
<a name="ln3585">  return buf;</a>
<a name="ln3586">}</a>
<a name="ln3587"> </a>
<a name="ln3588">#endif</a>
<a name="ln3589"> </a>
<a name="ln3590">// Used during execution: whether a match has been found.</a>
<a name="ln3591">static int nfa_match;</a>
<a name="ln3592">static proftime_T *nfa_time_limit;</a>
<a name="ln3593">static int *nfa_timed_out;</a>
<a name="ln3594">static int nfa_time_count;</a>
<a name="ln3595"> </a>
<a name="ln3596">// Copy postponed invisible match info from &quot;from&quot; to &quot;to&quot;.</a>
<a name="ln3597">static void copy_pim(nfa_pim_T *to, nfa_pim_T *from)</a>
<a name="ln3598">{</a>
<a name="ln3599">  to-&gt;result = from-&gt;result;</a>
<a name="ln3600">  to-&gt;state = from-&gt;state;</a>
<a name="ln3601">  copy_sub(&amp;to-&gt;subs.norm, &amp;from-&gt;subs.norm);</a>
<a name="ln3602">  if (rex.nfa_has_zsubexpr) {</a>
<a name="ln3603">    copy_sub(&amp;to-&gt;subs.synt, &amp;from-&gt;subs.synt);</a>
<a name="ln3604">  }</a>
<a name="ln3605">  to-&gt;end = from-&gt;end;</a>
<a name="ln3606">}</a>
<a name="ln3607"> </a>
<a name="ln3608">static void clear_sub(regsub_T *sub)</a>
<a name="ln3609">{</a>
<a name="ln3610">  if (REG_MULTI) {</a>
<a name="ln3611">    // Use 0xff to set lnum to -1</a>
<a name="ln3612">    memset(sub-&gt;list.multi, 0xff,</a>
<a name="ln3613">           sizeof(struct multipos) * rex.nfa_nsubexpr);</a>
<a name="ln3614">  } else {</a>
<a name="ln3615">    memset(sub-&gt;list.line, 0, sizeof(struct linepos) * rex.nfa_nsubexpr);</a>
<a name="ln3616">  }</a>
<a name="ln3617">  sub-&gt;in_use = 0;</a>
<a name="ln3618">}</a>
<a name="ln3619"> </a>
<a name="ln3620">/*</a>
<a name="ln3621"> * Copy the submatches from &quot;from&quot; to &quot;to&quot;.</a>
<a name="ln3622"> */</a>
<a name="ln3623">static void copy_sub(regsub_T *to, regsub_T *from)</a>
<a name="ln3624">{</a>
<a name="ln3625">  to-&gt;in_use = from-&gt;in_use;</a>
<a name="ln3626">  if (from-&gt;in_use &gt; 0) {</a>
<a name="ln3627">    /* Copy the match start and end positions. */</a>
<a name="ln3628">    if (REG_MULTI)</a>
<a name="ln3629">      memmove(&amp;to-&gt;list.multi[0],</a>
<a name="ln3630">          &amp;from-&gt;list.multi[0],</a>
<a name="ln3631">          sizeof(struct multipos) * from-&gt;in_use);</a>
<a name="ln3632">    else</a>
<a name="ln3633">      memmove(&amp;to-&gt;list.line[0],</a>
<a name="ln3634">          &amp;from-&gt;list.line[0],</a>
<a name="ln3635">          sizeof(struct linepos) * from-&gt;in_use);</a>
<a name="ln3636">  }</a>
<a name="ln3637">}</a>
<a name="ln3638"> </a>
<a name="ln3639">/*</a>
<a name="ln3640"> * Like copy_sub() but exclude the main match.</a>
<a name="ln3641"> */</a>
<a name="ln3642">static void copy_sub_off(regsub_T *to, regsub_T *from)</a>
<a name="ln3643">{</a>
<a name="ln3644">  if (to-&gt;in_use &lt; from-&gt;in_use)</a>
<a name="ln3645">    to-&gt;in_use = from-&gt;in_use;</a>
<a name="ln3646">  if (from-&gt;in_use &gt; 1) {</a>
<a name="ln3647">    /* Copy the match start and end positions. */</a>
<a name="ln3648">    if (REG_MULTI)</a>
<a name="ln3649">      memmove(&amp;to-&gt;list.multi[1],</a>
<a name="ln3650">          &amp;from-&gt;list.multi[1],</a>
<a name="ln3651">          sizeof(struct multipos) * (from-&gt;in_use - 1));</a>
<a name="ln3652">    else</a>
<a name="ln3653">      memmove(&amp;to-&gt;list.line[1],</a>
<a name="ln3654">          &amp;from-&gt;list.line[1],</a>
<a name="ln3655">          sizeof(struct linepos) * (from-&gt;in_use - 1));</a>
<a name="ln3656">  }</a>
<a name="ln3657">}</a>
<a name="ln3658"> </a>
<a name="ln3659">/*</a>
<a name="ln3660"> * Like copy_sub() but only do the end of the main match if \ze is present.</a>
<a name="ln3661"> */</a>
<a name="ln3662">static void copy_ze_off(regsub_T *to, regsub_T *from)</a>
<a name="ln3663">{</a>
<a name="ln3664">  if (rex.nfa_has_zend) {</a>
<a name="ln3665">    if (REG_MULTI) {</a>
<a name="ln3666">      if (from-&gt;list.multi[0].end_lnum &gt;= 0){</a>
<a name="ln3667">        to-&gt;list.multi[0].end_lnum = from-&gt;list.multi[0].end_lnum;</a>
<a name="ln3668">        to-&gt;list.multi[0].end_col = from-&gt;list.multi[0].end_col;</a>
<a name="ln3669">      }</a>
<a name="ln3670">    } else {</a>
<a name="ln3671">      if (from-&gt;list.line[0].end != NULL)</a>
<a name="ln3672">        to-&gt;list.line[0].end = from-&gt;list.line[0].end;</a>
<a name="ln3673">    }</a>
<a name="ln3674">  }</a>
<a name="ln3675">}</a>
<a name="ln3676"> </a>
<a name="ln3677">// Return true if &quot;sub1&quot; and &quot;sub2&quot; have the same start positions.</a>
<a name="ln3678">// When using back-references also check the end position.</a>
<a name="ln3679">static bool sub_equal(regsub_T *sub1, regsub_T *sub2)</a>
<a name="ln3680">{</a>
<a name="ln3681">  int i;</a>
<a name="ln3682">  int todo;</a>
<a name="ln3683">  linenr_T s1;</a>
<a name="ln3684">  linenr_T s2;</a>
<a name="ln3685">  char_u      *sp1;</a>
<a name="ln3686">  char_u      *sp2;</a>
<a name="ln3687"> </a>
<a name="ln3688">  todo = sub1-&gt;in_use &gt; sub2-&gt;in_use ? sub1-&gt;in_use : sub2-&gt;in_use;</a>
<a name="ln3689">  if (REG_MULTI) {</a>
<a name="ln3690">    for (i = 0; i &lt; todo; i++) {</a>
<a name="ln3691">      if (i &lt; sub1-&gt;in_use) {</a>
<a name="ln3692">        s1 = sub1-&gt;list.multi[i].start_lnum;</a>
<a name="ln3693">      } else {</a>
<a name="ln3694">        s1 = -1;</a>
<a name="ln3695">      }</a>
<a name="ln3696">      if (i &lt; sub2-&gt;in_use) {</a>
<a name="ln3697">        s2 = sub2-&gt;list.multi[i].start_lnum;</a>
<a name="ln3698">      } else {</a>
<a name="ln3699">        s2 = -1;</a>
<a name="ln3700">      }</a>
<a name="ln3701">      if (s1 != s2) {</a>
<a name="ln3702">        return false;</a>
<a name="ln3703">      }</a>
<a name="ln3704">      if (s1 != -1 &amp;&amp; sub1-&gt;list.multi[i].start_col</a>
<a name="ln3705">          != sub2-&gt;list.multi[i].start_col) {</a>
<a name="ln3706">        return false;</a>
<a name="ln3707">      }</a>
<a name="ln3708">      if (rex.nfa_has_backref) {</a>
<a name="ln3709">        if (i &lt; sub1-&gt;in_use) {</a>
<a name="ln3710">          s1 = sub1-&gt;list.multi[i].end_lnum;</a>
<a name="ln3711">        } else {</a>
<a name="ln3712">          s1 = -1;</a>
<a name="ln3713">        }</a>
<a name="ln3714">        if (i &lt; sub2-&gt;in_use) {</a>
<a name="ln3715">          s2 = sub2-&gt;list.multi[i].end_lnum;</a>
<a name="ln3716">        } else {</a>
<a name="ln3717">          s2 = -1;</a>
<a name="ln3718">        }</a>
<a name="ln3719">        if (s1 != s2) {</a>
<a name="ln3720">          return false;</a>
<a name="ln3721">        }</a>
<a name="ln3722">        if (s1 != -1</a>
<a name="ln3723">            &amp;&amp; sub1-&gt;list.multi[i].end_col != sub2-&gt;list.multi[i].end_col) {</a>
<a name="ln3724">          return false;</a>
<a name="ln3725">        }</a>
<a name="ln3726">      }</a>
<a name="ln3727">    }</a>
<a name="ln3728">  } else {</a>
<a name="ln3729">    for (i = 0; i &lt; todo; i++) {</a>
<a name="ln3730">      if (i &lt; sub1-&gt;in_use) {</a>
<a name="ln3731">        sp1 = sub1-&gt;list.line[i].start;</a>
<a name="ln3732">      } else {</a>
<a name="ln3733">        sp1 = NULL;</a>
<a name="ln3734">      }</a>
<a name="ln3735">      if (i &lt; sub2-&gt;in_use) {</a>
<a name="ln3736">        sp2 = sub2-&gt;list.line[i].start;</a>
<a name="ln3737">      } else {</a>
<a name="ln3738">        sp2 = NULL;</a>
<a name="ln3739">      }</a>
<a name="ln3740">      if (sp1 != sp2) {</a>
<a name="ln3741">        return false;</a>
<a name="ln3742">      }</a>
<a name="ln3743">      if (rex.nfa_has_backref) {</a>
<a name="ln3744">        if (i &lt; sub1-&gt;in_use) {</a>
<a name="ln3745">          sp1 = sub1-&gt;list.line[i].end;</a>
<a name="ln3746">        } else {</a>
<a name="ln3747">          sp1 = NULL;</a>
<a name="ln3748">        }</a>
<a name="ln3749">        if (i &lt; sub2-&gt;in_use) {</a>
<a name="ln3750">          sp2 = sub2-&gt;list.line[i].end;</a>
<a name="ln3751">        } else {</a>
<a name="ln3752">          sp2 = NULL;</a>
<a name="ln3753">        }</a>
<a name="ln3754">        if (sp1 != sp2) {</a>
<a name="ln3755">          return false;</a>
<a name="ln3756">        }</a>
<a name="ln3757">      }</a>
<a name="ln3758">    }</a>
<a name="ln3759">  }</a>
<a name="ln3760"> </a>
<a name="ln3761">  return true;</a>
<a name="ln3762">}</a>
<a name="ln3763"> </a>
<a name="ln3764">#ifdef REGEXP_DEBUG</a>
<a name="ln3765">static void report_state(char *action,</a>
<a name="ln3766">    regsub_T *sub,</a>
<a name="ln3767">    nfa_state_T *state,</a>
<a name="ln3768">    int lid,</a>
<a name="ln3769">    nfa_pim_T *pim) {</a>
<a name="ln3770">  int col;</a>
<a name="ln3771"> </a>
<a name="ln3772">  if (sub-&gt;in_use &lt;= 0) {</a>
<a name="ln3773">    col = -1;</a>
<a name="ln3774">  } else if (REG_MULTI) {</a>
<a name="ln3775">    col = sub-&gt;list.multi[0].start_col;</a>
<a name="ln3776">  } else {</a>
<a name="ln3777">    col = (int)(sub-&gt;list.line[0].start - rex.line);</a>
<a name="ln3778">  }</a>
<a name="ln3779">  nfa_set_code(state-&gt;c);</a>
<a name="ln3780">  fprintf(log_fd, &quot;&gt; %s state %d to list %d. char %d: %s (start col %d)%s\n&quot;,</a>
<a name="ln3781">          action, abs(state-&gt;id), lid, state-&gt;c, code, col,</a>
<a name="ln3782">          pim_info(pim));</a>
<a name="ln3783">}</a>
<a name="ln3784"> </a>
<a name="ln3785">#endif</a>
<a name="ln3786"> </a>
<a name="ln3787">// Return true if the same state is already in list &quot;l&quot; with the same</a>
<a name="ln3788">// positions as &quot;subs&quot;.</a>
<a name="ln3789">static bool has_state_with_pos(</a>
<a name="ln3790">    nfa_list_T *l,        // runtime state list</a>
<a name="ln3791">    nfa_state_T *state,   // state to update</a>
<a name="ln3792">    regsubs_T *subs,      // pointers to subexpressions</a>
<a name="ln3793">    nfa_pim_T *pim        // postponed match or NULL</a>
<a name="ln3794">)</a>
<a name="ln3795">  FUNC_ATTR_NONNULL_ARG(1, 2, 3)</a>
<a name="ln3796">{</a>
<a name="ln3797">  for (int i = 0; i &lt; l-&gt;n; i++) {</a>
<a name="ln3798">    nfa_thread_T *thread = &amp;l-&gt;t[i];</a>
<a name="ln3799">    if (thread-&gt;state-&gt;id == state-&gt;id</a>
<a name="ln3800">        &amp;&amp; sub_equal(&amp;thread-&gt;subs.norm, &amp;subs-&gt;norm)</a>
<a name="ln3801">        &amp;&amp; (!rex.nfa_has_zsubexpr</a>
<a name="ln3802">            || sub_equal(&amp;thread-&gt;subs.synt, &amp;subs-&gt;synt))</a>
<a name="ln3803">        &amp;&amp; pim_equal(&amp;thread-&gt;pim, pim)) {</a>
<a name="ln3804">      return true;</a>
<a name="ln3805">    }</a>
<a name="ln3806">  }</a>
<a name="ln3807">  return false;</a>
<a name="ln3808">}</a>
<a name="ln3809"> </a>
<a name="ln3810">// Return true if &quot;one&quot; and &quot;two&quot; are equal.  That includes when both are not</a>
<a name="ln3811">// set.</a>
<a name="ln3812">static bool pim_equal(const nfa_pim_T *one, const nfa_pim_T *two)</a>
<a name="ln3813">{</a>
<a name="ln3814">  const bool one_unused = (one == NULL || one-&gt;result == NFA_PIM_UNUSED);</a>
<a name="ln3815">  const bool two_unused = (two == NULL || two-&gt;result == NFA_PIM_UNUSED);</a>
<a name="ln3816"> </a>
<a name="ln3817">  if (one_unused) {</a>
<a name="ln3818">    // one is unused: equal when two is also unused</a>
<a name="ln3819">    return two_unused;</a>
<a name="ln3820">  }</a>
<a name="ln3821">  if (two_unused) {</a>
<a name="ln3822">    // one is used and two is not: not equal</a>
<a name="ln3823">    return false;</a>
<a name="ln3824">  }</a>
<a name="ln3825">  // compare the state id</a>
<a name="ln3826">  if (one-&gt;state-&gt;id != two-&gt;state-&gt;id) {</a>
<a name="ln3827">    return false;</a>
<a name="ln3828">  }</a>
<a name="ln3829">  // compare the position</a>
<a name="ln3830">  if (REG_MULTI) {</a>
<a name="ln3831">    return one-&gt;end.pos.lnum == two-&gt;end.pos.lnum</a>
<a name="ln3832">           &amp;&amp; one-&gt;end.pos.col == two-&gt;end.pos.col;</a>
<a name="ln3833">  }</a>
<a name="ln3834">  return one-&gt;end.ptr == two-&gt;end.ptr;</a>
<a name="ln3835">}</a>
<a name="ln3836"> </a>
<a name="ln3837">// Return true if &quot;state&quot; leads to a NFA_MATCH without advancing the input.</a>
<a name="ln3838">static bool match_follows(const nfa_state_T *startstate, int depth)</a>
<a name="ln3839">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln3840">{</a>
<a name="ln3841">  const nfa_state_T *state = startstate;</a>
<a name="ln3842"> </a>
<a name="ln3843">  // avoid too much recursion</a>
<a name="ln3844">  if (depth &gt; 10) {</a>
<a name="ln3845">    return false;</a>
<a name="ln3846">  }</a>
<a name="ln3847">  while (state != NULL) {</a>
<a name="ln3848">    switch (state-&gt;c) {</a>
<a name="ln3849">    case NFA_MATCH:</a>
<a name="ln3850">    case NFA_MCLOSE:</a>
<a name="ln3851">    case NFA_END_INVISIBLE:</a>
<a name="ln3852">    case NFA_END_INVISIBLE_NEG:</a>
<a name="ln3853">    case NFA_END_PATTERN:</a>
<a name="ln3854">      return true;</a>
<a name="ln3855"> </a>
<a name="ln3856">    case NFA_SPLIT:</a>
<a name="ln3857">      return match_follows(state-&gt;out, depth + 1)</a>
<a name="ln3858">             || match_follows(state-&gt;out1, depth + 1);</a>
<a name="ln3859"> </a>
<a name="ln3860">    case NFA_START_INVISIBLE:</a>
<a name="ln3861">    case NFA_START_INVISIBLE_FIRST:</a>
<a name="ln3862">    case NFA_START_INVISIBLE_BEFORE:</a>
<a name="ln3863">    case NFA_START_INVISIBLE_BEFORE_FIRST:</a>
<a name="ln3864">    case NFA_START_INVISIBLE_NEG:</a>
<a name="ln3865">    case NFA_START_INVISIBLE_NEG_FIRST:</a>
<a name="ln3866">    case NFA_START_INVISIBLE_BEFORE_NEG:</a>
<a name="ln3867">    case NFA_START_INVISIBLE_BEFORE_NEG_FIRST:</a>
<a name="ln3868">    case NFA_COMPOSING:</a>
<a name="ln3869">      /* skip ahead to next state */</a>
<a name="ln3870">      state = state-&gt;out1-&gt;out;</a>
<a name="ln3871">      continue;</a>
<a name="ln3872"> </a>
<a name="ln3873">    case NFA_ANY:</a>
<a name="ln3874">    case NFA_ANY_COMPOSING:</a>
<a name="ln3875">    case NFA_IDENT:</a>
<a name="ln3876">    case NFA_SIDENT:</a>
<a name="ln3877">    case NFA_KWORD:</a>
<a name="ln3878">    case NFA_SKWORD:</a>
<a name="ln3879">    case NFA_FNAME:</a>
<a name="ln3880">    case NFA_SFNAME:</a>
<a name="ln3881">    case NFA_PRINT:</a>
<a name="ln3882">    case NFA_SPRINT:</a>
<a name="ln3883">    case NFA_WHITE:</a>
<a name="ln3884">    case NFA_NWHITE:</a>
<a name="ln3885">    case NFA_DIGIT:</a>
<a name="ln3886">    case NFA_NDIGIT:</a>
<a name="ln3887">    case NFA_HEX:</a>
<a name="ln3888">    case NFA_NHEX:</a>
<a name="ln3889">    case NFA_OCTAL:</a>
<a name="ln3890">    case NFA_NOCTAL:</a>
<a name="ln3891">    case NFA_WORD:</a>
<a name="ln3892">    case NFA_NWORD:</a>
<a name="ln3893">    case NFA_HEAD:</a>
<a name="ln3894">    case NFA_NHEAD:</a>
<a name="ln3895">    case NFA_ALPHA:</a>
<a name="ln3896">    case NFA_NALPHA:</a>
<a name="ln3897">    case NFA_LOWER:</a>
<a name="ln3898">    case NFA_NLOWER:</a>
<a name="ln3899">    case NFA_UPPER:</a>
<a name="ln3900">    case NFA_NUPPER:</a>
<a name="ln3901">    case NFA_LOWER_IC:</a>
<a name="ln3902">    case NFA_NLOWER_IC:</a>
<a name="ln3903">    case NFA_UPPER_IC:</a>
<a name="ln3904">    case NFA_NUPPER_IC:</a>
<a name="ln3905">    case NFA_START_COLL:</a>
<a name="ln3906">    case NFA_START_NEG_COLL:</a>
<a name="ln3907">    case NFA_NEWL:</a>
<a name="ln3908">      // state will advance input</a>
<a name="ln3909">      return false;</a>
<a name="ln3910"> </a>
<a name="ln3911">    default:</a>
<a name="ln3912">      if (state-&gt;c &gt; 0) {</a>
<a name="ln3913">        // state will advance input</a>
<a name="ln3914">        return false;</a>
<a name="ln3915">      }</a>
<a name="ln3916">      // Others: zero-width or possibly zero-width, might still find</a>
<a name="ln3917">      // a match at the same position, keep looking.</a>
<a name="ln3918">      break;</a>
<a name="ln3919">    }</a>
<a name="ln3920">    state = state-&gt;out;</a>
<a name="ln3921">  }</a>
<a name="ln3922">  return false;</a>
<a name="ln3923">}</a>
<a name="ln3924"> </a>
<a name="ln3925"> </a>
<a name="ln3926">// Return true if &quot;state&quot; is already in list &quot;l&quot;.</a>
<a name="ln3927">static bool state_in_list(</a>
<a name="ln3928">    nfa_list_T *l,        // runtime state list</a>
<a name="ln3929">    nfa_state_T *state,   // state to update</a>
<a name="ln3930">    regsubs_T *subs       // pointers to subexpressions</a>
<a name="ln3931">)</a>
<a name="ln3932">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln3933">{</a>
<a name="ln3934">  if (state-&gt;lastlist[nfa_ll_index] == l-&gt;id) {</a>
<a name="ln3935">    if (!rex.nfa_has_backref || has_state_with_pos(l, state, subs, NULL)) {</a>
<a name="ln3936">      return true;</a>
<a name="ln3937">    }</a>
<a name="ln3938">  }</a>
<a name="ln3939">  return false;</a>
<a name="ln3940">}</a>
<a name="ln3941"> </a>
<a name="ln3942">// Offset used for &quot;off&quot; by addstate_here().</a>
<a name="ln3943">#define ADDSTATE_HERE_OFFSET 10</a>
<a name="ln3944"> </a>
<a name="ln3945">// Add &quot;state&quot; and possibly what follows to state list &quot;.&quot;.</a>
<a name="ln3946">// Returns &quot;subs_arg&quot;, possibly copied into temp_subs.</a>
<a name="ln3947">// Returns NULL when recursiveness is too deep.</a>
<a name="ln3948">static regsubs_T *addstate(</a>
<a name="ln3949">    nfa_list_T *l,        // runtime state list</a>
<a name="ln3950">    nfa_state_T *state,   // state to update</a>
<a name="ln3951">    regsubs_T *subs_arg,  // pointers to subexpressions</a>
<a name="ln3952">    nfa_pim_T *pim,       // postponed look-behind match</a>
<a name="ln3953">    int off_arg)          // byte offset, when -1 go to next line</a>
<a name="ln3954">  FUNC_ATTR_NONNULL_ARG(1, 2) FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln3955">{</a>
<a name="ln3956">  int subidx;</a>
<a name="ln3957">  int off = off_arg;</a>
<a name="ln3958">  int add_here = false;</a>
<a name="ln3959">  int listindex = 0;</a>
<a name="ln3960">  int k;</a>
<a name="ln3961">  int found = false;</a>
<a name="ln3962">  nfa_thread_T        *thread;</a>
<a name="ln3963">  struct multipos     save_multipos;</a>
<a name="ln3964">  int save_in_use;</a>
<a name="ln3965">  char_u              *save_ptr;</a>
<a name="ln3966">  int i;</a>
<a name="ln3967">  regsub_T            *sub;</a>
<a name="ln3968">  regsubs_T           *subs = subs_arg;</a>
<a name="ln3969">  static regsubs_T temp_subs;</a>
<a name="ln3970">#ifdef REGEXP_DEBUG</a>
<a name="ln3971">  int did_print = false;</a>
<a name="ln3972">#endif</a>
<a name="ln3973">  static int depth = 0;</a>
<a name="ln3974"> </a>
<a name="ln3975">  // This function is called recursively.  When the depth is too much we run</a>
<a name="ln3976">  // out of stack and crash, limit recursiveness here.</a>
<a name="ln3977">  if (++depth &gt;= 5000 || subs == NULL) {</a>
<a name="ln3978">    depth--;</a>
<a name="ln3979">    return NULL;</a>
<a name="ln3980">  }</a>
<a name="ln3981"> </a>
<a name="ln3982">  if (off_arg &lt;= -ADDSTATE_HERE_OFFSET) {</a>
<a name="ln3983">    add_here = true;</a>
<a name="ln3984">    off = 0;</a>
<a name="ln3985">    listindex = -(off_arg + ADDSTATE_HERE_OFFSET);</a>
<a name="ln3986">  }</a>
<a name="ln3987"> </a>
<a name="ln3988">  switch (state-&gt;c) {</a>
<a name="ln3989">  case NFA_NCLOSE:</a>
<a name="ln3990">  case NFA_MCLOSE:</a>
<a name="ln3991">  case NFA_MCLOSE1:</a>
<a name="ln3992">  case NFA_MCLOSE2:</a>
<a name="ln3993">  case NFA_MCLOSE3:</a>
<a name="ln3994">  case NFA_MCLOSE4:</a>
<a name="ln3995">  case NFA_MCLOSE5:</a>
<a name="ln3996">  case NFA_MCLOSE6:</a>
<a name="ln3997">  case NFA_MCLOSE7:</a>
<a name="ln3998">  case NFA_MCLOSE8:</a>
<a name="ln3999">  case NFA_MCLOSE9:</a>
<a name="ln4000">  case NFA_ZCLOSE:</a>
<a name="ln4001">  case NFA_ZCLOSE1:</a>
<a name="ln4002">  case NFA_ZCLOSE2:</a>
<a name="ln4003">  case NFA_ZCLOSE3:</a>
<a name="ln4004">  case NFA_ZCLOSE4:</a>
<a name="ln4005">  case NFA_ZCLOSE5:</a>
<a name="ln4006">  case NFA_ZCLOSE6:</a>
<a name="ln4007">  case NFA_ZCLOSE7:</a>
<a name="ln4008">  case NFA_ZCLOSE8:</a>
<a name="ln4009">  case NFA_ZCLOSE9:</a>
<a name="ln4010">  case NFA_MOPEN:</a>
<a name="ln4011">  case NFA_ZEND:</a>
<a name="ln4012">  case NFA_SPLIT:</a>
<a name="ln4013">  case NFA_EMPTY:</a>
<a name="ln4014">    /* These nodes are not added themselves but their &quot;out&quot; and/or</a>
<a name="ln4015">     * &quot;out1&quot; may be added below.  */</a>
<a name="ln4016">    break;</a>
<a name="ln4017"> </a>
<a name="ln4018">  case NFA_BOL:</a>
<a name="ln4019">  case NFA_BOF:</a>
<a name="ln4020">    // &quot;^&quot; won't match past end-of-line, don't bother trying.</a>
<a name="ln4021">    // Except when at the end of the line, or when we are going to the</a>
<a name="ln4022">    // next line for a look-behind match.</a>
<a name="ln4023">    if (rex.input &gt; rex.line</a>
<a name="ln4024">        &amp;&amp; *rex.input != NUL</a>
<a name="ln4025">        &amp;&amp; (nfa_endp == NULL</a>
<a name="ln4026">            || !REG_MULTI</a>
<a name="ln4027">            || rex.lnum == nfa_endp-&gt;se_u.pos.lnum)) {</a>
<a name="ln4028">      goto skip_add;</a>
<a name="ln4029">    }</a>
<a name="ln4030">    FALLTHROUGH;</a>
<a name="ln4031"> </a>
<a name="ln4032">  case NFA_MOPEN1:</a>
<a name="ln4033">  case NFA_MOPEN2:</a>
<a name="ln4034">  case NFA_MOPEN3:</a>
<a name="ln4035">  case NFA_MOPEN4:</a>
<a name="ln4036">  case NFA_MOPEN5:</a>
<a name="ln4037">  case NFA_MOPEN6:</a>
<a name="ln4038">  case NFA_MOPEN7:</a>
<a name="ln4039">  case NFA_MOPEN8:</a>
<a name="ln4040">  case NFA_MOPEN9:</a>
<a name="ln4041">  case NFA_ZOPEN:</a>
<a name="ln4042">  case NFA_ZOPEN1:</a>
<a name="ln4043">  case NFA_ZOPEN2:</a>
<a name="ln4044">  case NFA_ZOPEN3:</a>
<a name="ln4045">  case NFA_ZOPEN4:</a>
<a name="ln4046">  case NFA_ZOPEN5:</a>
<a name="ln4047">  case NFA_ZOPEN6:</a>
<a name="ln4048">  case NFA_ZOPEN7:</a>
<a name="ln4049">  case NFA_ZOPEN8:</a>
<a name="ln4050">  case NFA_ZOPEN9:</a>
<a name="ln4051">  case NFA_NOPEN:</a>
<a name="ln4052">  case NFA_ZSTART:</a>
<a name="ln4053">  /* These nodes need to be added so that we can bail out when it</a>
<a name="ln4054">   * was added to this list before at the same position to avoid an</a>
<a name="ln4055">   * endless loop for &quot;\(\)*&quot; */</a>
<a name="ln4056"> </a>
<a name="ln4057">  default:</a>
<a name="ln4058">    if (state-&gt;lastlist[nfa_ll_index] == l-&gt;id &amp;&amp; state-&gt;c != NFA_SKIP) {</a>
<a name="ln4059">      /* This state is already in the list, don't add it again,</a>
<a name="ln4060">       * unless it is an MOPEN that is used for a backreference or</a>
<a name="ln4061">       * when there is a PIM. For NFA_MATCH check the position,</a>
<a name="ln4062">       * lower position is preferred. */</a>
<a name="ln4063">      if (!rex.nfa_has_backref &amp;&amp; pim == NULL &amp;&amp; !l-&gt;has_pim</a>
<a name="ln4064">          &amp;&amp; state-&gt;c != NFA_MATCH) {</a>
<a name="ln4065"> </a>
<a name="ln4066">        /* When called from addstate_here() do insert before</a>
<a name="ln4067">         * existing states. */</a>
<a name="ln4068">        if (add_here) {</a>
<a name="ln4069">          for (k = 0; k &lt; l-&gt;n &amp;&amp; k &lt; listindex; ++k) {</a>
<a name="ln4070">            if (l-&gt;t[k].state-&gt;id == state-&gt;id) {</a>
<a name="ln4071">              found = true;</a>
<a name="ln4072">              break;</a>
<a name="ln4073">            }</a>
<a name="ln4074">          }</a>
<a name="ln4075">        }</a>
<a name="ln4076"> </a>
<a name="ln4077">        if (!add_here || found) {</a>
<a name="ln4078">skip_add:</a>
<a name="ln4079">#ifdef REGEXP_DEBUG</a>
<a name="ln4080">          nfa_set_code(state-&gt;c);</a>
<a name="ln4081">          fprintf(log_fd, &quot;&gt; Not adding state %d to list %d. char %d: %s pim: %s has_pim: %d found: %d\n&quot;,</a>
<a name="ln4082">                  abs(state-&gt;id), l-&gt;id, state-&gt;c, code,</a>
<a name="ln4083">                  pim == NULL ? &quot;NULL&quot; : &quot;yes&quot;, l-&gt;has_pim, found);</a>
<a name="ln4084">#endif</a>
<a name="ln4085">        depth--;</a>
<a name="ln4086">        return subs;</a>
<a name="ln4087">        }</a>
<a name="ln4088">      }</a>
<a name="ln4089"> </a>
<a name="ln4090">      /* Do not add the state again when it exists with the same</a>
<a name="ln4091">       * positions. */</a>
<a name="ln4092">      if (has_state_with_pos(l, state, subs, pim))</a>
<a name="ln4093">        goto skip_add;</a>
<a name="ln4094">    }</a>
<a name="ln4095"> </a>
<a name="ln4096">    // When there are backreferences or PIMs the number of states may</a>
<a name="ln4097">    // be (a lot) bigger than anticipated.</a>
<a name="ln4098">    if (l-&gt;n == l-&gt;len) {</a>
<a name="ln4099">      const int newlen = l-&gt;len * 3 / 2 + 50;</a>
<a name="ln4100">      const size_t newsize = newlen * sizeof(nfa_thread_T);</a>
<a name="ln4101"> </a>
<a name="ln4102">      if ((long)(newsize &gt;&gt; 10) &gt;= p_mmp) {</a>
<a name="ln4103">        EMSG(_(e_maxmempat));</a>
<a name="ln4104">        depth--;</a>
<a name="ln4105">        return NULL;</a>
<a name="ln4106">      }</a>
<a name="ln4107">      if (subs != &amp;temp_subs) {</a>
<a name="ln4108">        // &quot;subs&quot; may point into the current array, need to make a</a>
<a name="ln4109">        // copy before it becomes invalid.</a>
<a name="ln4110">        copy_sub(&amp;temp_subs.norm, &amp;subs-&gt;norm);</a>
<a name="ln4111">        if (rex.nfa_has_zsubexpr) {</a>
<a name="ln4112">          copy_sub(&amp;temp_subs.synt, &amp;subs-&gt;synt);</a>
<a name="ln4113">        }</a>
<a name="ln4114">        subs = &amp;temp_subs;</a>
<a name="ln4115">      }</a>
<a name="ln4116"> </a>
<a name="ln4117">      nfa_thread_T *const newt = xrealloc(l-&gt;t, newsize);</a>
<a name="ln4118">      l-&gt;t = newt;</a>
<a name="ln4119">      l-&gt;len = newlen;</a>
<a name="ln4120">    }</a>
<a name="ln4121"> </a>
<a name="ln4122">    /* add the state to the list */</a>
<a name="ln4123">    state-&gt;lastlist[nfa_ll_index] = l-&gt;id;</a>
<a name="ln4124">    thread = &amp;l-&gt;t[l-&gt;n++];</a>
<a name="ln4125">    thread-&gt;state = state;</a>
<a name="ln4126">    if (pim == NULL)</a>
<a name="ln4127">      thread-&gt;pim.result = NFA_PIM_UNUSED;</a>
<a name="ln4128">    else {</a>
<a name="ln4129">      copy_pim(&amp;thread-&gt;pim, pim);</a>
<a name="ln4130">      l-&gt;has_pim = true;</a>
<a name="ln4131">    }</a>
<a name="ln4132">    copy_sub(&amp;thread-&gt;subs.norm, &amp;subs-&gt;norm);</a>
<a name="ln4133">    if (rex.nfa_has_zsubexpr) {</a>
<a name="ln4134">      copy_sub(&amp;thread-&gt;subs.synt, &amp;subs-&gt;synt);</a>
<a name="ln4135">    }</a>
<a name="ln4136">#ifdef REGEXP_DEBUG</a>
<a name="ln4137">    report_state(&quot;Adding&quot;, &amp;thread-&gt;subs.norm, state, l-&gt;id, pim);</a>
<a name="ln4138">    did_print = true;</a>
<a name="ln4139">#endif</a>
<a name="ln4140">  }</a>
<a name="ln4141"> </a>
<a name="ln4142">#ifdef REGEXP_DEBUG</a>
<a name="ln4143">  if (!did_print)</a>
<a name="ln4144">    report_state(&quot;Processing&quot;, &amp;subs-&gt;norm, state, l-&gt;id, pim);</a>
<a name="ln4145">#endif</a>
<a name="ln4146">  switch (state-&gt;c) {</a>
<a name="ln4147">  case NFA_MATCH:</a>
<a name="ln4148">    break;</a>
<a name="ln4149"> </a>
<a name="ln4150">  case NFA_SPLIT:</a>
<a name="ln4151">    /* order matters here */</a>
<a name="ln4152">    subs = addstate(l, state-&gt;out, subs, pim, off_arg);</a>
<a name="ln4153">    subs = addstate(l, state-&gt;out1, subs, pim, off_arg);</a>
<a name="ln4154">    break;</a>
<a name="ln4155"> </a>
<a name="ln4156">  case NFA_EMPTY:</a>
<a name="ln4157">  case NFA_NOPEN:</a>
<a name="ln4158">  case NFA_NCLOSE:</a>
<a name="ln4159">    subs = addstate(l, state-&gt;out, subs, pim, off_arg);</a>
<a name="ln4160">    break;</a>
<a name="ln4161"> </a>
<a name="ln4162">  case NFA_MOPEN:</a>
<a name="ln4163">  case NFA_MOPEN1:</a>
<a name="ln4164">  case NFA_MOPEN2:</a>
<a name="ln4165">  case NFA_MOPEN3:</a>
<a name="ln4166">  case NFA_MOPEN4:</a>
<a name="ln4167">  case NFA_MOPEN5:</a>
<a name="ln4168">  case NFA_MOPEN6:</a>
<a name="ln4169">  case NFA_MOPEN7:</a>
<a name="ln4170">  case NFA_MOPEN8:</a>
<a name="ln4171">  case NFA_MOPEN9:</a>
<a name="ln4172">  case NFA_ZOPEN:</a>
<a name="ln4173">  case NFA_ZOPEN1:</a>
<a name="ln4174">  case NFA_ZOPEN2:</a>
<a name="ln4175">  case NFA_ZOPEN3:</a>
<a name="ln4176">  case NFA_ZOPEN4:</a>
<a name="ln4177">  case NFA_ZOPEN5:</a>
<a name="ln4178">  case NFA_ZOPEN6:</a>
<a name="ln4179">  case NFA_ZOPEN7:</a>
<a name="ln4180">  case NFA_ZOPEN8:</a>
<a name="ln4181">  case NFA_ZOPEN9:</a>
<a name="ln4182">  case NFA_ZSTART:</a>
<a name="ln4183">    if (state-&gt;c == NFA_ZSTART) {</a>
<a name="ln4184">      subidx = 0;</a>
<a name="ln4185">      sub = &amp;subs-&gt;norm;</a>
<a name="ln4186">    } else if (state-&gt;c &gt;= NFA_ZOPEN &amp;&amp; state-&gt;c &lt;= NFA_ZOPEN9) {  // -V560</a>
<a name="ln4187">      subidx = state-&gt;c - NFA_ZOPEN;</a>
<a name="ln4188">      sub = &amp;subs-&gt;synt;</a>
<a name="ln4189">    } else {</a>
<a name="ln4190">      subidx = state-&gt;c - NFA_MOPEN;</a>
<a name="ln4191">      sub = &amp;subs-&gt;norm;</a>
<a name="ln4192">    }</a>
<a name="ln4193"> </a>
<a name="ln4194">    /* avoid compiler warnings */</a>
<a name="ln4195">    save_ptr = NULL;</a>
<a name="ln4196">    memset(&amp;save_multipos, 0, sizeof(save_multipos));</a>
<a name="ln4197"> </a>
<a name="ln4198">    /* Set the position (with &quot;off&quot; added) in the subexpression.  Save</a>
<a name="ln4199">     * and restore it when it was in use.  Otherwise fill any gap. */</a>
<a name="ln4200">    if (REG_MULTI) {</a>
<a name="ln4201">      if (subidx &lt; sub-&gt;in_use) {</a>
<a name="ln4202">        save_multipos = sub-&gt;list.multi[subidx];</a>
<a name="ln4203">        save_in_use = -1;</a>
<a name="ln4204">      } else {</a>
<a name="ln4205">        save_in_use = sub-&gt;in_use;</a>
<a name="ln4206">        for (i = sub-&gt;in_use; i &lt; subidx; ++i) {</a>
<a name="ln4207">          sub-&gt;list.multi[i].start_lnum = -1;</a>
<a name="ln4208">          sub-&gt;list.multi[i].end_lnum = -1;</a>
<a name="ln4209">        }</a>
<a name="ln4210">        sub-&gt;in_use = subidx + 1;</a>
<a name="ln4211">      }</a>
<a name="ln4212">      if (off == -1) {</a>
<a name="ln4213">        sub-&gt;list.multi[subidx].start_lnum = rex.lnum + 1;</a>
<a name="ln4214">        sub-&gt;list.multi[subidx].start_col = 0;</a>
<a name="ln4215">      } else {</a>
<a name="ln4216">        sub-&gt;list.multi[subidx].start_lnum = rex.lnum;</a>
<a name="ln4217">        sub-&gt;list.multi[subidx].start_col =</a>
<a name="ln4218">          (colnr_T)(rex.input - rex.line + off);</a>
<a name="ln4219">      }</a>
<a name="ln4220">      sub-&gt;list.multi[subidx].end_lnum = -1;</a>
<a name="ln4221">    } else {</a>
<a name="ln4222">      if (subidx &lt; sub-&gt;in_use) {</a>
<a name="ln4223">        save_ptr = sub-&gt;list.line[subidx].start;</a>
<a name="ln4224">        save_in_use = -1;</a>
<a name="ln4225">      } else {</a>
<a name="ln4226">        save_in_use = sub-&gt;in_use;</a>
<a name="ln4227">        for (i = sub-&gt;in_use; i &lt; subidx; ++i) {</a>
<a name="ln4228">          sub-&gt;list.line[i].start = NULL;</a>
<a name="ln4229">          sub-&gt;list.line[i].end = NULL;</a>
<a name="ln4230">        }</a>
<a name="ln4231">        sub-&gt;in_use = subidx + 1;</a>
<a name="ln4232">      }</a>
<a name="ln4233">      sub-&gt;list.line[subidx].start = rex.input + off;</a>
<a name="ln4234">    }</a>
<a name="ln4235"> </a>
<a name="ln4236">    subs = addstate(l, state-&gt;out, subs, pim, off_arg);</a>
<a name="ln4237">    if (subs == NULL) {</a>
<a name="ln4238">      break;</a>
<a name="ln4239">    }</a>
<a name="ln4240">    // &quot;subs&quot; may have changed, need to set &quot;sub&quot; again.</a>
<a name="ln4241">    if (state-&gt;c &gt;= NFA_ZOPEN &amp;&amp; state-&gt;c &lt;= NFA_ZOPEN9) {  // -V560</a>
<a name="ln4242">      sub = &amp;subs-&gt;synt;</a>
<a name="ln4243">    } else {</a>
<a name="ln4244">      sub = &amp;subs-&gt;norm;</a>
<a name="ln4245">    }</a>
<a name="ln4246"> </a>
<a name="ln4247">    if (save_in_use == -1) {</a>
<a name="ln4248">      if (REG_MULTI) {</a>
<a name="ln4249">        sub-&gt;list.multi[subidx] = save_multipos;</a>
<a name="ln4250">      }</a>
<a name="ln4251">      else</a>
<a name="ln4252">        sub-&gt;list.line[subidx].start = save_ptr;</a>
<a name="ln4253">    } else</a>
<a name="ln4254">      sub-&gt;in_use = save_in_use;</a>
<a name="ln4255">    break;</a>
<a name="ln4256"> </a>
<a name="ln4257">  case NFA_MCLOSE:</a>
<a name="ln4258">    if (rex.nfa_has_zend</a>
<a name="ln4259">        &amp;&amp; (REG_MULTI</a>
<a name="ln4260">            ? subs-&gt;norm.list.multi[0].end_lnum &gt;= 0</a>
<a name="ln4261">            : subs-&gt;norm.list.line[0].end != NULL)) {</a>
<a name="ln4262">      // Do not overwrite the position set by \ze.</a>
<a name="ln4263">      subs = addstate(l, state-&gt;out, subs, pim, off_arg);</a>
<a name="ln4264">      break;</a>
<a name="ln4265">    }</a>
<a name="ln4266">    FALLTHROUGH;</a>
<a name="ln4267">  case NFA_MCLOSE1:</a>
<a name="ln4268">  case NFA_MCLOSE2:</a>
<a name="ln4269">  case NFA_MCLOSE3:</a>
<a name="ln4270">  case NFA_MCLOSE4:</a>
<a name="ln4271">  case NFA_MCLOSE5:</a>
<a name="ln4272">  case NFA_MCLOSE6:</a>
<a name="ln4273">  case NFA_MCLOSE7:</a>
<a name="ln4274">  case NFA_MCLOSE8:</a>
<a name="ln4275">  case NFA_MCLOSE9:</a>
<a name="ln4276">  case NFA_ZCLOSE:</a>
<a name="ln4277">  case NFA_ZCLOSE1:</a>
<a name="ln4278">  case NFA_ZCLOSE2:</a>
<a name="ln4279">  case NFA_ZCLOSE3:</a>
<a name="ln4280">  case NFA_ZCLOSE4:</a>
<a name="ln4281">  case NFA_ZCLOSE5:</a>
<a name="ln4282">  case NFA_ZCLOSE6:</a>
<a name="ln4283">  case NFA_ZCLOSE7:</a>
<a name="ln4284">  case NFA_ZCLOSE8:</a>
<a name="ln4285">  case NFA_ZCLOSE9:</a>
<a name="ln4286">  case NFA_ZEND:</a>
<a name="ln4287">    if (state-&gt;c == NFA_ZEND) {</a>
<a name="ln4288">      subidx = 0;</a>
<a name="ln4289">      sub = &amp;subs-&gt;norm;</a>
<a name="ln4290">    } else if (state-&gt;c &gt;= NFA_ZCLOSE &amp;&amp; state-&gt;c &lt;= NFA_ZCLOSE9) {  // -V560</a>
<a name="ln4291">      subidx = state-&gt;c - NFA_ZCLOSE;</a>
<a name="ln4292">      sub = &amp;subs-&gt;synt;</a>
<a name="ln4293">    } else {</a>
<a name="ln4294">      subidx = state-&gt;c - NFA_MCLOSE;</a>
<a name="ln4295">      sub = &amp;subs-&gt;norm;</a>
<a name="ln4296">    }</a>
<a name="ln4297"> </a>
<a name="ln4298">    /* We don't fill in gaps here, there must have been an MOPEN that</a>
<a name="ln4299">     * has done that. */</a>
<a name="ln4300">    save_in_use = sub-&gt;in_use;</a>
<a name="ln4301">    if (sub-&gt;in_use &lt;= subidx)</a>
<a name="ln4302">      sub-&gt;in_use = subidx + 1;</a>
<a name="ln4303">    if (REG_MULTI) {</a>
<a name="ln4304">      save_multipos = sub-&gt;list.multi[subidx];</a>
<a name="ln4305">      if (off == -1) {</a>
<a name="ln4306">        sub-&gt;list.multi[subidx].end_lnum = rex.lnum + 1;</a>
<a name="ln4307">        sub-&gt;list.multi[subidx].end_col = 0;</a>
<a name="ln4308">      } else {</a>
<a name="ln4309">        sub-&gt;list.multi[subidx].end_lnum = rex.lnum;</a>
<a name="ln4310">        sub-&gt;list.multi[subidx].end_col =</a>
<a name="ln4311">          (colnr_T)(rex.input - rex.line + off);</a>
<a name="ln4312">      }</a>
<a name="ln4313">      /* avoid compiler warnings */</a>
<a name="ln4314">      save_ptr = NULL;</a>
<a name="ln4315">    } else {</a>
<a name="ln4316">      save_ptr = sub-&gt;list.line[subidx].end;</a>
<a name="ln4317">      sub-&gt;list.line[subidx].end = rex.input + off;</a>
<a name="ln4318">      // avoid compiler warnings</a>
<a name="ln4319">      memset(&amp;save_multipos, 0, sizeof(save_multipos));</a>
<a name="ln4320">    }</a>
<a name="ln4321"> </a>
<a name="ln4322">    subs = addstate(l, state-&gt;out, subs, pim, off_arg);</a>
<a name="ln4323">    if (subs == NULL) {</a>
<a name="ln4324">      break;</a>
<a name="ln4325">    }</a>
<a name="ln4326">    // &quot;subs&quot; may have changed, need to set &quot;sub&quot; again.</a>
<a name="ln4327">    if (state-&gt;c &gt;= NFA_ZCLOSE &amp;&amp; state-&gt;c &lt;= NFA_ZCLOSE9) {  // -V560</a>
<a name="ln4328">      sub = &amp;subs-&gt;synt;</a>
<a name="ln4329">    } else {</a>
<a name="ln4330">      sub = &amp;subs-&gt;norm;</a>
<a name="ln4331">    }</a>
<a name="ln4332"> </a>
<a name="ln4333">    if (REG_MULTI) {</a>
<a name="ln4334">      sub-&gt;list.multi[subidx] = save_multipos;</a>
<a name="ln4335">    }</a>
<a name="ln4336">    else</a>
<a name="ln4337">      sub-&gt;list.line[subidx].end = save_ptr;</a>
<a name="ln4338">    sub-&gt;in_use = save_in_use;</a>
<a name="ln4339">    break;</a>
<a name="ln4340">  }</a>
<a name="ln4341">  depth--;</a>
<a name="ln4342">  return subs;</a>
<a name="ln4343">}</a>
<a name="ln4344"> </a>
<a name="ln4345">/*</a>
<a name="ln4346"> * Like addstate(), but the new state(s) are put at position &quot;*ip&quot;.</a>
<a name="ln4347"> * Used for zero-width matches, next state to use is the added one.</a>
<a name="ln4348"> * This makes sure the order of states to be tried does not change, which</a>
<a name="ln4349"> * matters for alternatives.</a>
<a name="ln4350"> */</a>
<a name="ln4351">static regsubs_T *addstate_here(</a>
<a name="ln4352">    nfa_list_T *l,        // runtime state list</a>
<a name="ln4353">    nfa_state_T *state,   // state to update</a>
<a name="ln4354">    regsubs_T *subs,      // pointers to subexpressions</a>
<a name="ln4355">    nfa_pim_T *pim,       // postponed look-behind match</a>
<a name="ln4356">    int *ip</a>
<a name="ln4357">)</a>
<a name="ln4358">  FUNC_ATTR_NONNULL_ARG(1, 2, 5) FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln4359">{</a>
<a name="ln4360">  int tlen = l-&gt;n;</a>
<a name="ln4361">  int count;</a>
<a name="ln4362">  int listidx = *ip;</a>
<a name="ln4363"> </a>
<a name="ln4364">  /* First add the state(s) at the end, so that we know how many there are.</a>
<a name="ln4365">   * Pass the listidx as offset (avoids adding another argument to</a>
<a name="ln4366">   * addstate(). */</a>
<a name="ln4367">  regsubs_T *r = addstate(l, state, subs, pim, -listidx - ADDSTATE_HERE_OFFSET);</a>
<a name="ln4368">  if (r == NULL) {</a>
<a name="ln4369">    return NULL;</a>
<a name="ln4370">  }</a>
<a name="ln4371"> </a>
<a name="ln4372">  // when &quot;*ip&quot; was at the end of the list, nothing to do</a>
<a name="ln4373">  if (listidx + 1 == tlen) {</a>
<a name="ln4374">    return r;</a>
<a name="ln4375">  }</a>
<a name="ln4376"> </a>
<a name="ln4377">  // re-order to put the new state at the current position</a>
<a name="ln4378">  count = l-&gt;n - tlen;</a>
<a name="ln4379">  if (count == 0) {</a>
<a name="ln4380">    return r;  // no state got added</a>
<a name="ln4381">  }</a>
<a name="ln4382">  if (count == 1) {</a>
<a name="ln4383">    // overwrite the current state</a>
<a name="ln4384">    l-&gt;t[listidx] = l-&gt;t[l-&gt;n - 1];</a>
<a name="ln4385">  } else if (count &gt; 1) {</a>
<a name="ln4386">    if (l-&gt;n + count - 1 &gt;= l-&gt;len) {</a>
<a name="ln4387">      /* not enough space to move the new states, reallocate the list</a>
<a name="ln4388">       * and move the states to the right position */</a>
<a name="ln4389">      const int newlen = l-&gt;len * 3 / 2 + 50;</a>
<a name="ln4390">      const size_t newsize = newlen * sizeof(nfa_thread_T);</a>
<a name="ln4391"> </a>
<a name="ln4392">      if ((long)(newsize &gt;&gt; 10) &gt;= p_mmp) {</a>
<a name="ln4393">        EMSG(_(e_maxmempat));</a>
<a name="ln4394">        return NULL;</a>
<a name="ln4395">      }</a>
<a name="ln4396">      nfa_thread_T *const newl = xmalloc(newsize);</a>
<a name="ln4397">      l-&gt;len = newlen;</a>
<a name="ln4398">      memmove(&amp;(newl[0]),</a>
<a name="ln4399">          &amp;(l-&gt;t[0]),</a>
<a name="ln4400">          sizeof(nfa_thread_T) * listidx);</a>
<a name="ln4401">      memmove(&amp;(newl[listidx]),</a>
<a name="ln4402">          &amp;(l-&gt;t[l-&gt;n - count]),</a>
<a name="ln4403">          sizeof(nfa_thread_T) * count);</a>
<a name="ln4404">      memmove(&amp;(newl[listidx + count]),</a>
<a name="ln4405">          &amp;(l-&gt;t[listidx + 1]),</a>
<a name="ln4406">          sizeof(nfa_thread_T) * (l-&gt;n - count - listidx - 1));</a>
<a name="ln4407">      xfree(l-&gt;t);</a>
<a name="ln4408">      l-&gt;t = newl;</a>
<a name="ln4409">    } else {</a>
<a name="ln4410">      /* make space for new states, then move them from the</a>
<a name="ln4411">       * end to the current position */</a>
<a name="ln4412">      memmove(&amp;(l-&gt;t[listidx + count]),</a>
<a name="ln4413">          &amp;(l-&gt;t[listidx + 1]),</a>
<a name="ln4414">          sizeof(nfa_thread_T) * (l-&gt;n - listidx - 1));</a>
<a name="ln4415">      memmove(&amp;(l-&gt;t[listidx]),</a>
<a name="ln4416">          &amp;(l-&gt;t[l-&gt;n - 1]),</a>
<a name="ln4417">          sizeof(nfa_thread_T) * count);</a>
<a name="ln4418">    }</a>
<a name="ln4419">  }</a>
<a name="ln4420">  --l-&gt;n;</a>
<a name="ln4421">  *ip = listidx - 1;</a>
<a name="ln4422"> </a>
<a name="ln4423">  return r;</a>
<a name="ln4424">}</a>
<a name="ln4425"> </a>
<a name="ln4426">/*</a>
<a name="ln4427"> * Check character class &quot;class&quot; against current character c.</a>
<a name="ln4428"> */</a>
<a name="ln4429">static int check_char_class(int class, int c)</a>
<a name="ln4430">{</a>
<a name="ln4431">  switch (class) {</a>
<a name="ln4432">  case NFA_CLASS_ALNUM:</a>
<a name="ln4433">    if (c &gt;= 1 &amp;&amp; c &lt; 128 &amp;&amp; isalnum(c)) {</a>
<a name="ln4434">      return OK;</a>
<a name="ln4435">    }</a>
<a name="ln4436">    break;</a>
<a name="ln4437">  case NFA_CLASS_ALPHA:</a>
<a name="ln4438">    if (c &gt;= 1 &amp;&amp; c &lt; 128 &amp;&amp; isalpha(c)) {</a>
<a name="ln4439">      return OK;</a>
<a name="ln4440">    }</a>
<a name="ln4441">    break;</a>
<a name="ln4442">  case NFA_CLASS_BLANK:</a>
<a name="ln4443">    if (c == ' ' || c == '\t')</a>
<a name="ln4444">      return OK;</a>
<a name="ln4445">    break;</a>
<a name="ln4446">  case NFA_CLASS_CNTRL:</a>
<a name="ln4447">    if (c &gt;= 1 &amp;&amp; c &lt;= 127 &amp;&amp; iscntrl(c)) {</a>
<a name="ln4448">      return OK;</a>
<a name="ln4449">    }</a>
<a name="ln4450">    break;</a>
<a name="ln4451">  case NFA_CLASS_DIGIT:</a>
<a name="ln4452">    if (ascii_isdigit(c))</a>
<a name="ln4453">      return OK;</a>
<a name="ln4454">    break;</a>
<a name="ln4455">  case NFA_CLASS_GRAPH:</a>
<a name="ln4456">    if (c &gt;= 1 &amp;&amp; c &lt;= 127 &amp;&amp; isgraph(c)) {</a>
<a name="ln4457">      return OK;</a>
<a name="ln4458">    }</a>
<a name="ln4459">    break;</a>
<a name="ln4460">  case NFA_CLASS_LOWER:</a>
<a name="ln4461">    if (mb_islower(c) &amp;&amp; c != 170 &amp;&amp; c != 186) {</a>
<a name="ln4462">      return OK;</a>
<a name="ln4463">    }</a>
<a name="ln4464">    break;</a>
<a name="ln4465">  case NFA_CLASS_PRINT:</a>
<a name="ln4466">    if (vim_isprintc(c))</a>
<a name="ln4467">      return OK;</a>
<a name="ln4468">    break;</a>
<a name="ln4469">  case NFA_CLASS_PUNCT:</a>
<a name="ln4470">    if (c &gt;= 1 &amp;&amp; c &lt; 128 &amp;&amp; ispunct(c)) {</a>
<a name="ln4471">      return OK;</a>
<a name="ln4472">    }</a>
<a name="ln4473">    break;</a>
<a name="ln4474">  case NFA_CLASS_SPACE:</a>
<a name="ln4475">    if ((c &gt;= 9 &amp;&amp; c &lt;= 13) || (c == ' '))</a>
<a name="ln4476">      return OK;</a>
<a name="ln4477">    break;</a>
<a name="ln4478">  case NFA_CLASS_UPPER:</a>
<a name="ln4479">    if (mb_isupper(c)) {</a>
<a name="ln4480">      return OK;</a>
<a name="ln4481">    }</a>
<a name="ln4482">    break;</a>
<a name="ln4483">  case NFA_CLASS_XDIGIT:</a>
<a name="ln4484">    if (ascii_isxdigit(c))</a>
<a name="ln4485">      return OK;</a>
<a name="ln4486">    break;</a>
<a name="ln4487">  case NFA_CLASS_TAB:</a>
<a name="ln4488">    if (c == '\t')</a>
<a name="ln4489">      return OK;</a>
<a name="ln4490">    break;</a>
<a name="ln4491">  case NFA_CLASS_RETURN:</a>
<a name="ln4492">    if (c == '\r')</a>
<a name="ln4493">      return OK;</a>
<a name="ln4494">    break;</a>
<a name="ln4495">  case NFA_CLASS_BACKSPACE:</a>
<a name="ln4496">    if (c == '\b')</a>
<a name="ln4497">      return OK;</a>
<a name="ln4498">    break;</a>
<a name="ln4499">  case NFA_CLASS_ESCAPE:</a>
<a name="ln4500">    if (c == ESC) {</a>
<a name="ln4501">      return OK;</a>
<a name="ln4502">    }</a>
<a name="ln4503">    break;</a>
<a name="ln4504">  case NFA_CLASS_IDENT:</a>
<a name="ln4505">    if (vim_isIDc(c)) {</a>
<a name="ln4506">      return OK;</a>
<a name="ln4507">    }</a>
<a name="ln4508">    break;</a>
<a name="ln4509">  case NFA_CLASS_KEYWORD:</a>
<a name="ln4510">    if (reg_iswordc(c)) {</a>
<a name="ln4511">      return OK;</a>
<a name="ln4512">    }</a>
<a name="ln4513">    break;</a>
<a name="ln4514">  case NFA_CLASS_FNAME:</a>
<a name="ln4515">    if (vim_isfilec(c)) {</a>
<a name="ln4516">      return OK;</a>
<a name="ln4517">    }</a>
<a name="ln4518">    break;</a>
<a name="ln4519"> </a>
<a name="ln4520">  default:</a>
<a name="ln4521">    // should not be here :P</a>
<a name="ln4522">    IEMSGN(_(e_ill_char_class), class);</a>
<a name="ln4523">    return FAIL;</a>
<a name="ln4524">  }</a>
<a name="ln4525">  return FAIL;</a>
<a name="ln4526">}</a>
<a name="ln4527"> </a>
<a name="ln4528">/*</a>
<a name="ln4529"> * Check for a match with subexpression &quot;subidx&quot;.</a>
<a name="ln4530"> * Return true if it matches.</a>
<a name="ln4531"> */</a>
<a name="ln4532">static int </a>
<a name="ln4533">match_backref (</a>
<a name="ln4534">    regsub_T *sub,           /* pointers to subexpressions */</a>
<a name="ln4535">    int subidx,</a>
<a name="ln4536">    int *bytelen       /* out: length of match in bytes */</a>
<a name="ln4537">)</a>
<a name="ln4538">{</a>
<a name="ln4539">  int len;</a>
<a name="ln4540"> </a>
<a name="ln4541">  if (sub-&gt;in_use &lt;= subidx) {</a>
<a name="ln4542">retempty:</a>
<a name="ln4543">    /* backref was not set, match an empty string */</a>
<a name="ln4544">    *bytelen = 0;</a>
<a name="ln4545">    return true;</a>
<a name="ln4546">  }</a>
<a name="ln4547"> </a>
<a name="ln4548">  if (REG_MULTI) {</a>
<a name="ln4549">    if (sub-&gt;list.multi[subidx].start_lnum &lt; 0</a>
<a name="ln4550">        || sub-&gt;list.multi[subidx].end_lnum &lt; 0)</a>
<a name="ln4551">      goto retempty;</a>
<a name="ln4552">    if (sub-&gt;list.multi[subidx].start_lnum == rex.lnum</a>
<a name="ln4553">        &amp;&amp; sub-&gt;list.multi[subidx].end_lnum == rex.lnum) {</a>
<a name="ln4554">      len = sub-&gt;list.multi[subidx].end_col</a>
<a name="ln4555">            - sub-&gt;list.multi[subidx].start_col;</a>
<a name="ln4556">      if (cstrncmp(rex.line + sub-&gt;list.multi[subidx].start_col,</a>
<a name="ln4557">                   rex.input, &amp;len) == 0) {</a>
<a name="ln4558">        *bytelen = len;</a>
<a name="ln4559">        return true;</a>
<a name="ln4560">      }</a>
<a name="ln4561">    } else {</a>
<a name="ln4562">      if (match_with_backref(sub-&gt;list.multi[subidx].start_lnum,</a>
<a name="ln4563">                             sub-&gt;list.multi[subidx].start_col,</a>
<a name="ln4564">                             sub-&gt;list.multi[subidx].end_lnum,</a>
<a name="ln4565">                             sub-&gt;list.multi[subidx].end_col,</a>
<a name="ln4566">                             bytelen) == RA_MATCH) {</a>
<a name="ln4567">        return true;</a>
<a name="ln4568">      }</a>
<a name="ln4569">    }</a>
<a name="ln4570">  } else {</a>
<a name="ln4571">    if (sub-&gt;list.line[subidx].start == NULL</a>
<a name="ln4572">        || sub-&gt;list.line[subidx].end == NULL)</a>
<a name="ln4573">      goto retempty;</a>
<a name="ln4574">    len = (int)(sub-&gt;list.line[subidx].end - sub-&gt;list.line[subidx].start);</a>
<a name="ln4575">    if (cstrncmp(sub-&gt;list.line[subidx].start, rex.input, &amp;len) == 0) {</a>
<a name="ln4576">      *bytelen = len;</a>
<a name="ln4577">      return true;</a>
<a name="ln4578">    }</a>
<a name="ln4579">  }</a>
<a name="ln4580">  return false;</a>
<a name="ln4581">}</a>
<a name="ln4582"> </a>
<a name="ln4583"> </a>
<a name="ln4584"> </a>
<a name="ln4585">/*</a>
<a name="ln4586"> * Check for a match with \z subexpression &quot;subidx&quot;.</a>
<a name="ln4587"> * Return true if it matches.</a>
<a name="ln4588"> */</a>
<a name="ln4589">static int </a>
<a name="ln4590">match_zref (</a>
<a name="ln4591">    int subidx,</a>
<a name="ln4592">    int *bytelen       /* out: length of match in bytes */</a>
<a name="ln4593">)</a>
<a name="ln4594">{</a>
<a name="ln4595">  int len;</a>
<a name="ln4596"> </a>
<a name="ln4597">  cleanup_zsubexpr();</a>
<a name="ln4598">  if (re_extmatch_in == NULL || re_extmatch_in-&gt;matches[subidx] == NULL) {</a>
<a name="ln4599">    /* backref was not set, match an empty string */</a>
<a name="ln4600">    *bytelen = 0;</a>
<a name="ln4601">    return true;</a>
<a name="ln4602">  }</a>
<a name="ln4603"> </a>
<a name="ln4604">  len = (int)STRLEN(re_extmatch_in-&gt;matches[subidx]);</a>
<a name="ln4605">  if (cstrncmp(re_extmatch_in-&gt;matches[subidx], rex.input, &amp;len) == 0) {</a>
<a name="ln4606">    *bytelen = len;</a>
<a name="ln4607">    return true;</a>
<a name="ln4608">  }</a>
<a name="ln4609">  return false;</a>
<a name="ln4610">}</a>
<a name="ln4611"> </a>
<a name="ln4612">/*</a>
<a name="ln4613"> * Save list IDs for all NFA states of &quot;prog&quot; into &quot;list&quot;.</a>
<a name="ln4614"> * Also reset the IDs to zero.</a>
<a name="ln4615"> * Only used for the recursive value lastlist[1].</a>
<a name="ln4616"> */</a>
<a name="ln4617">static void nfa_save_listids(nfa_regprog_T *prog, int *list)</a>
<a name="ln4618">{</a>
<a name="ln4619">  int i;</a>
<a name="ln4620">  nfa_state_T     *p;</a>
<a name="ln4621"> </a>
<a name="ln4622">  /* Order in the list is reverse, it's a bit faster that way. */</a>
<a name="ln4623">  p = &amp;prog-&gt;state[0];</a>
<a name="ln4624">  for (i = prog-&gt;nstate; --i &gt;= 0; ) {</a>
<a name="ln4625">    list[i] = p-&gt;lastlist[1];</a>
<a name="ln4626">    p-&gt;lastlist[1] = 0;</a>
<a name="ln4627">    ++p;</a>
<a name="ln4628">  }</a>
<a name="ln4629">}</a>
<a name="ln4630"> </a>
<a name="ln4631">/*</a>
<a name="ln4632"> * Restore list IDs from &quot;list&quot; to all NFA states.</a>
<a name="ln4633"> */</a>
<a name="ln4634">static void nfa_restore_listids(nfa_regprog_T *prog, int *list)</a>
<a name="ln4635">{</a>
<a name="ln4636">  int i;</a>
<a name="ln4637">  nfa_state_T     *p;</a>
<a name="ln4638"> </a>
<a name="ln4639">  p = &amp;prog-&gt;state[0];</a>
<a name="ln4640">  for (i = prog-&gt;nstate; --i &gt;= 0; ) {</a>
<a name="ln4641">    p-&gt;lastlist[1] = list[i];</a>
<a name="ln4642">    ++p;</a>
<a name="ln4643">  }</a>
<a name="ln4644">}</a>
<a name="ln4645"> </a>
<a name="ln4646">static bool nfa_re_num_cmp(uintmax_t val, int op, uintmax_t pos)</a>
<a name="ln4647">{</a>
<a name="ln4648">  if (op == 1) return pos &gt; val;</a>
<a name="ln4649">  if (op == 2) return pos &lt; val;</a>
<a name="ln4650">  return val == pos;</a>
<a name="ln4651">}</a>
<a name="ln4652"> </a>
<a name="ln4653"> </a>
<a name="ln4654">/*</a>
<a name="ln4655"> * Recursively call nfa_regmatch()</a>
<a name="ln4656"> * &quot;pim&quot; is NULL or contains info about a Postponed Invisible Match (start</a>
<a name="ln4657"> * position).</a>
<a name="ln4658"> */</a>
<a name="ln4659">static int recursive_regmatch(</a>
<a name="ln4660">    nfa_state_T *state, nfa_pim_T *pim, nfa_regprog_T *prog,</a>
<a name="ln4661">    regsubs_T *submatch, regsubs_T *m, int **listids, int *listids_len)</a>
<a name="ln4662">  FUNC_ATTR_NONNULL_ARG(1, 3, 5, 6, 7)</a>
<a name="ln4663">{</a>
<a name="ln4664">  const int save_reginput_col = (int)(rex.input - rex.line);</a>
<a name="ln4665">  const int save_reglnum = rex.lnum;</a>
<a name="ln4666">  const int save_nfa_match = nfa_match;</a>
<a name="ln4667">  const int save_nfa_listid = rex.nfa_listid;</a>
<a name="ln4668">  save_se_T *const save_nfa_endp = nfa_endp;</a>
<a name="ln4669">  save_se_T endpos;</a>
<a name="ln4670">  save_se_T   *endposp = NULL;</a>
<a name="ln4671">  int need_restore = false;</a>
<a name="ln4672"> </a>
<a name="ln4673">  if (pim != NULL) {</a>
<a name="ln4674">    // start at the position where the postponed match was</a>
<a name="ln4675">    if (REG_MULTI) {</a>
<a name="ln4676">      rex.input = rex.line + pim-&gt;end.pos.col;</a>
<a name="ln4677">    } else {</a>
<a name="ln4678">      rex.input = pim-&gt;end.ptr;</a>
<a name="ln4679">    }</a>
<a name="ln4680">  }</a>
<a name="ln4681"> </a>
<a name="ln4682">  if (state-&gt;c == NFA_START_INVISIBLE_BEFORE</a>
<a name="ln4683">      || state-&gt;c == NFA_START_INVISIBLE_BEFORE_FIRST</a>
<a name="ln4684">      || state-&gt;c == NFA_START_INVISIBLE_BEFORE_NEG</a>
<a name="ln4685">      || state-&gt;c == NFA_START_INVISIBLE_BEFORE_NEG_FIRST) {</a>
<a name="ln4686">    // The recursive match must end at the current position. When &quot;pim&quot; is</a>
<a name="ln4687">    // not NULL it specifies the current position.</a>
<a name="ln4688">    endposp = &amp;endpos;</a>
<a name="ln4689">    if (REG_MULTI) {</a>
<a name="ln4690">      if (pim == NULL) {</a>
<a name="ln4691">        endpos.se_u.pos.col = (int)(rex.input - rex.line);</a>
<a name="ln4692">        endpos.se_u.pos.lnum = rex.lnum;</a>
<a name="ln4693">      } else {</a>
<a name="ln4694">        endpos.se_u.pos = pim-&gt;end.pos;</a>
<a name="ln4695">      }</a>
<a name="ln4696">    } else {</a>
<a name="ln4697">      if (pim == NULL) {</a>
<a name="ln4698">        endpos.se_u.ptr = rex.input;</a>
<a name="ln4699">      } else {</a>
<a name="ln4700">        endpos.se_u.ptr = pim-&gt;end.ptr;</a>
<a name="ln4701">      }</a>
<a name="ln4702">    }</a>
<a name="ln4703"> </a>
<a name="ln4704">    // Go back the specified number of bytes, or as far as the</a>
<a name="ln4705">    // start of the previous line, to try matching &quot;\@&lt;=&quot; or</a>
<a name="ln4706">    // not matching &quot;\@&lt;!&quot;. This is very inefficient, limit the number of</a>
<a name="ln4707">    // bytes if possible.</a>
<a name="ln4708">    if (state-&gt;val &lt;= 0) {</a>
<a name="ln4709">      if (REG_MULTI) {</a>
<a name="ln4710">        rex.line = reg_getline(--rex.lnum);</a>
<a name="ln4711">        if (rex.line == NULL) {</a>
<a name="ln4712">          // can't go before the first line</a>
<a name="ln4713">          rex.line = reg_getline(++rex.lnum);</a>
<a name="ln4714">        }</a>
<a name="ln4715">      }</a>
<a name="ln4716">      rex.input = rex.line;</a>
<a name="ln4717">    } else {</a>
<a name="ln4718">      if (REG_MULTI &amp;&amp; (int)(rex.input - rex.line) &lt; state-&gt;val) {</a>
<a name="ln4719">        // Not enough bytes in this line, go to end of</a>
<a name="ln4720">        // previous line.</a>
<a name="ln4721">        rex.line = reg_getline(--rex.lnum);</a>
<a name="ln4722">        if (rex.line == NULL) {</a>
<a name="ln4723">          // can't go before the first line</a>
<a name="ln4724">          rex.line = reg_getline(++rex.lnum);</a>
<a name="ln4725">          rex.input = rex.line;</a>
<a name="ln4726">        } else {</a>
<a name="ln4727">          rex.input = rex.line + STRLEN(rex.line);</a>
<a name="ln4728">        }</a>
<a name="ln4729">      }</a>
<a name="ln4730">      if ((int)(rex.input - rex.line) &gt;= state-&gt;val) {</a>
<a name="ln4731">        rex.input -= state-&gt;val;</a>
<a name="ln4732">        rex.input -= utf_head_off(rex.line, rex.input);</a>
<a name="ln4733">      } else {</a>
<a name="ln4734">        rex.input = rex.line;</a>
<a name="ln4735">      }</a>
<a name="ln4736">    }</a>
<a name="ln4737">  }</a>
<a name="ln4738"> </a>
<a name="ln4739">#ifdef REGEXP_DEBUG</a>
<a name="ln4740">  if (log_fd != stderr)</a>
<a name="ln4741">    fclose(log_fd);</a>
<a name="ln4742">  log_fd = NULL;</a>
<a name="ln4743">#endif</a>
<a name="ln4744">  // Have to clear the lastlist field of the NFA nodes, so that</a>
<a name="ln4745">  // nfa_regmatch() and addstate() can run properly after recursion.</a>
<a name="ln4746">  if (nfa_ll_index == 1) {</a>
<a name="ln4747">    // Already calling nfa_regmatch() recursively.  Save the lastlist[1]</a>
<a name="ln4748">    // values and clear them.</a>
<a name="ln4749">    if (*listids == NULL || *listids_len &lt; prog-&gt;nstate) {</a>
<a name="ln4750">      xfree(*listids);</a>
<a name="ln4751">      *listids = xmalloc(sizeof(**listids) * prog-&gt;nstate);</a>
<a name="ln4752">      *listids_len = prog-&gt;nstate;</a>
<a name="ln4753">    }</a>
<a name="ln4754">    nfa_save_listids(prog, *listids);</a>
<a name="ln4755">    need_restore = true;</a>
<a name="ln4756">    // any value of rex.nfa_listid will do</a>
<a name="ln4757">  } else {</a>
<a name="ln4758">    // First recursive nfa_regmatch() call, switch to the second lastlist</a>
<a name="ln4759">    // entry.  Make sure rex.nfa_listid is different from a previous</a>
<a name="ln4760">    // recursive call, because some states may still have this ID.</a>
<a name="ln4761">    nfa_ll_index++;</a>
<a name="ln4762">    if (rex.nfa_listid &lt;= rex.nfa_alt_listid) {</a>
<a name="ln4763">      rex.nfa_listid = rex.nfa_alt_listid;</a>
<a name="ln4764">    }</a>
<a name="ln4765">  }</a>
<a name="ln4766"> </a>
<a name="ln4767">  // Call nfa_regmatch() to check if the current concat matches at this</a>
<a name="ln4768">  // position. The concat ends with the node NFA_END_INVISIBLE</a>
<a name="ln4769">  nfa_endp = endposp;</a>
<a name="ln4770">  const int result = nfa_regmatch(prog, state-&gt;out, submatch, m);</a>
<a name="ln4771"> </a>
<a name="ln4772">  if (need_restore) {</a>
<a name="ln4773">    nfa_restore_listids(prog, *listids);</a>
<a name="ln4774">  } else {</a>
<a name="ln4775">    nfa_ll_index--;</a>
<a name="ln4776">    rex.nfa_alt_listid = rex.nfa_listid;</a>
<a name="ln4777">  }</a>
<a name="ln4778"> </a>
<a name="ln4779">  // restore position in input text</a>
<a name="ln4780">  rex.lnum = save_reglnum;</a>
<a name="ln4781">  if (REG_MULTI) {</a>
<a name="ln4782">    rex.line = reg_getline(rex.lnum);</a>
<a name="ln4783">  }</a>
<a name="ln4784">  rex.input = rex.line + save_reginput_col;</a>
<a name="ln4785">  if (result != NFA_TOO_EXPENSIVE) {</a>
<a name="ln4786">    nfa_match = save_nfa_match;</a>
<a name="ln4787">    rex.nfa_listid = save_nfa_listid;</a>
<a name="ln4788">  }</a>
<a name="ln4789">  nfa_endp = save_nfa_endp;</a>
<a name="ln4790"> </a>
<a name="ln4791">#ifdef REGEXP_DEBUG</a>
<a name="ln4792">  log_fd = fopen(NFA_REGEXP_RUN_LOG, &quot;a&quot;);</a>
<a name="ln4793">  if (log_fd != NULL) {</a>
<a name="ln4794">    fprintf(log_fd, &quot;****************************\n&quot;);</a>
<a name="ln4795">    fprintf(log_fd, &quot;FINISHED RUNNING nfa_regmatch() recursively\n&quot;);</a>
<a name="ln4796">    fprintf(log_fd, &quot;MATCH = %s\n&quot;, !result ? &quot;false&quot; : &quot;OK&quot;);</a>
<a name="ln4797">    fprintf(log_fd, &quot;****************************\n&quot;);</a>
<a name="ln4798">  } else {</a>
<a name="ln4799">    EMSG(_(e_log_open_failed));</a>
<a name="ln4800">    log_fd = stderr;</a>
<a name="ln4801">  }</a>
<a name="ln4802">#endif</a>
<a name="ln4803"> </a>
<a name="ln4804">  return result;</a>
<a name="ln4805">}</a>
<a name="ln4806"> </a>
<a name="ln4807"> </a>
<a name="ln4808">/*</a>
<a name="ln4809"> * Estimate the chance of a match with &quot;state&quot; failing.</a>
<a name="ln4810"> * empty match: 0</a>
<a name="ln4811"> * NFA_ANY: 1</a>
<a name="ln4812"> * specific character: 99</a>
<a name="ln4813"> */</a>
<a name="ln4814">static int failure_chance(nfa_state_T *state, int depth)</a>
<a name="ln4815">{</a>
<a name="ln4816">  int c = state-&gt;c;</a>
<a name="ln4817">  int l, r;</a>
<a name="ln4818"> </a>
<a name="ln4819">  /* detect looping */</a>
<a name="ln4820">  if (depth &gt; 4)</a>
<a name="ln4821">    return 1;</a>
<a name="ln4822"> </a>
<a name="ln4823">  switch (c) {</a>
<a name="ln4824">  case NFA_SPLIT:</a>
<a name="ln4825">    if (state-&gt;out-&gt;c == NFA_SPLIT || state-&gt;out1-&gt;c == NFA_SPLIT)</a>
<a name="ln4826">      /* avoid recursive stuff */</a>
<a name="ln4827">      return 1;</a>
<a name="ln4828">    /* two alternatives, use the lowest failure chance */</a>
<a name="ln4829">    l = failure_chance(state-&gt;out, depth + 1);</a>
<a name="ln4830">    r = failure_chance(state-&gt;out1, depth + 1);</a>
<a name="ln4831">    return l &lt; r ? l : r;</a>
<a name="ln4832"> </a>
<a name="ln4833">  case NFA_ANY:</a>
<a name="ln4834">    /* matches anything, unlikely to fail */</a>
<a name="ln4835">    return 1;</a>
<a name="ln4836"> </a>
<a name="ln4837">  case NFA_MATCH:</a>
<a name="ln4838">  case NFA_MCLOSE:</a>
<a name="ln4839">  case NFA_ANY_COMPOSING:</a>
<a name="ln4840">    /* empty match works always */</a>
<a name="ln4841">    return 0;</a>
<a name="ln4842"> </a>
<a name="ln4843">  case NFA_START_INVISIBLE:</a>
<a name="ln4844">  case NFA_START_INVISIBLE_FIRST:</a>
<a name="ln4845">  case NFA_START_INVISIBLE_NEG:</a>
<a name="ln4846">  case NFA_START_INVISIBLE_NEG_FIRST:</a>
<a name="ln4847">  case NFA_START_INVISIBLE_BEFORE:</a>
<a name="ln4848">  case NFA_START_INVISIBLE_BEFORE_FIRST:</a>
<a name="ln4849">  case NFA_START_INVISIBLE_BEFORE_NEG:</a>
<a name="ln4850">  case NFA_START_INVISIBLE_BEFORE_NEG_FIRST:</a>
<a name="ln4851">  case NFA_START_PATTERN:</a>
<a name="ln4852">    /* recursive regmatch is expensive, use low failure chance */</a>
<a name="ln4853">    return 5;</a>
<a name="ln4854"> </a>
<a name="ln4855">  case NFA_BOL:</a>
<a name="ln4856">  case NFA_EOL:</a>
<a name="ln4857">  case NFA_BOF:</a>
<a name="ln4858">  case NFA_EOF:</a>
<a name="ln4859">  case NFA_NEWL:</a>
<a name="ln4860">    return 99;</a>
<a name="ln4861"> </a>
<a name="ln4862">  case NFA_BOW:</a>
<a name="ln4863">  case NFA_EOW:</a>
<a name="ln4864">    return 90;</a>
<a name="ln4865"> </a>
<a name="ln4866">  case NFA_MOPEN:</a>
<a name="ln4867">  case NFA_MOPEN1:</a>
<a name="ln4868">  case NFA_MOPEN2:</a>
<a name="ln4869">  case NFA_MOPEN3:</a>
<a name="ln4870">  case NFA_MOPEN4:</a>
<a name="ln4871">  case NFA_MOPEN5:</a>
<a name="ln4872">  case NFA_MOPEN6:</a>
<a name="ln4873">  case NFA_MOPEN7:</a>
<a name="ln4874">  case NFA_MOPEN8:</a>
<a name="ln4875">  case NFA_MOPEN9:</a>
<a name="ln4876">  case NFA_ZOPEN:</a>
<a name="ln4877">  case NFA_ZOPEN1:</a>
<a name="ln4878">  case NFA_ZOPEN2:</a>
<a name="ln4879">  case NFA_ZOPEN3:</a>
<a name="ln4880">  case NFA_ZOPEN4:</a>
<a name="ln4881">  case NFA_ZOPEN5:</a>
<a name="ln4882">  case NFA_ZOPEN6:</a>
<a name="ln4883">  case NFA_ZOPEN7:</a>
<a name="ln4884">  case NFA_ZOPEN8:</a>
<a name="ln4885">  case NFA_ZOPEN9:</a>
<a name="ln4886">  case NFA_ZCLOSE:</a>
<a name="ln4887">  case NFA_ZCLOSE1:</a>
<a name="ln4888">  case NFA_ZCLOSE2:</a>
<a name="ln4889">  case NFA_ZCLOSE3:</a>
<a name="ln4890">  case NFA_ZCLOSE4:</a>
<a name="ln4891">  case NFA_ZCLOSE5:</a>
<a name="ln4892">  case NFA_ZCLOSE6:</a>
<a name="ln4893">  case NFA_ZCLOSE7:</a>
<a name="ln4894">  case NFA_ZCLOSE8:</a>
<a name="ln4895">  case NFA_ZCLOSE9:</a>
<a name="ln4896">  case NFA_NOPEN:</a>
<a name="ln4897">  case NFA_MCLOSE1:</a>
<a name="ln4898">  case NFA_MCLOSE2:</a>
<a name="ln4899">  case NFA_MCLOSE3:</a>
<a name="ln4900">  case NFA_MCLOSE4:</a>
<a name="ln4901">  case NFA_MCLOSE5:</a>
<a name="ln4902">  case NFA_MCLOSE6:</a>
<a name="ln4903">  case NFA_MCLOSE7:</a>
<a name="ln4904">  case NFA_MCLOSE8:</a>
<a name="ln4905">  case NFA_MCLOSE9:</a>
<a name="ln4906">  case NFA_NCLOSE:</a>
<a name="ln4907">    return failure_chance(state-&gt;out, depth + 1);</a>
<a name="ln4908"> </a>
<a name="ln4909">  case NFA_BACKREF1:</a>
<a name="ln4910">  case NFA_BACKREF2:</a>
<a name="ln4911">  case NFA_BACKREF3:</a>
<a name="ln4912">  case NFA_BACKREF4:</a>
<a name="ln4913">  case NFA_BACKREF5:</a>
<a name="ln4914">  case NFA_BACKREF6:</a>
<a name="ln4915">  case NFA_BACKREF7:</a>
<a name="ln4916">  case NFA_BACKREF8:</a>
<a name="ln4917">  case NFA_BACKREF9:</a>
<a name="ln4918">  case NFA_ZREF1:</a>
<a name="ln4919">  case NFA_ZREF2:</a>
<a name="ln4920">  case NFA_ZREF3:</a>
<a name="ln4921">  case NFA_ZREF4:</a>
<a name="ln4922">  case NFA_ZREF5:</a>
<a name="ln4923">  case NFA_ZREF6:</a>
<a name="ln4924">  case NFA_ZREF7:</a>
<a name="ln4925">  case NFA_ZREF8:</a>
<a name="ln4926">  case NFA_ZREF9:</a>
<a name="ln4927">    /* backreferences don't match in many places */</a>
<a name="ln4928">    return 94;</a>
<a name="ln4929"> </a>
<a name="ln4930">  case NFA_LNUM_GT:</a>
<a name="ln4931">  case NFA_LNUM_LT:</a>
<a name="ln4932">  case NFA_COL_GT:</a>
<a name="ln4933">  case NFA_COL_LT:</a>
<a name="ln4934">  case NFA_VCOL_GT:</a>
<a name="ln4935">  case NFA_VCOL_LT:</a>
<a name="ln4936">  case NFA_MARK_GT:</a>
<a name="ln4937">  case NFA_MARK_LT:</a>
<a name="ln4938">  case NFA_VISUAL:</a>
<a name="ln4939">    /* before/after positions don't match very often */</a>
<a name="ln4940">    return 85;</a>
<a name="ln4941"> </a>
<a name="ln4942">  case NFA_LNUM:</a>
<a name="ln4943">    return 90;</a>
<a name="ln4944"> </a>
<a name="ln4945">  case NFA_CURSOR:</a>
<a name="ln4946">  case NFA_COL:</a>
<a name="ln4947">  case NFA_VCOL:</a>
<a name="ln4948">  case NFA_MARK:</a>
<a name="ln4949">    /* specific positions rarely match */</a>
<a name="ln4950">    return 98;</a>
<a name="ln4951"> </a>
<a name="ln4952">  case NFA_COMPOSING:</a>
<a name="ln4953">    return 95;</a>
<a name="ln4954"> </a>
<a name="ln4955">  default:</a>
<a name="ln4956">    if (c &gt; 0)</a>
<a name="ln4957">      /* character match fails often */</a>
<a name="ln4958">      return 95;</a>
<a name="ln4959">  }</a>
<a name="ln4960"> </a>
<a name="ln4961">  /* something else, includes character classes */</a>
<a name="ln4962">  return 50;</a>
<a name="ln4963">}</a>
<a name="ln4964"> </a>
<a name="ln4965">/*</a>
<a name="ln4966"> * Skip until the char &quot;c&quot; we know a match must start with.</a>
<a name="ln4967"> */</a>
<a name="ln4968">static int skip_to_start(int c, colnr_T *colp)</a>
<a name="ln4969">{</a>
<a name="ln4970">  const char_u *const s = cstrchr(rex.line + *colp, c);</a>
<a name="ln4971">  if (s == NULL) {</a>
<a name="ln4972">    return FAIL;</a>
<a name="ln4973">  }</a>
<a name="ln4974">  *colp = (int)(s - rex.line);</a>
<a name="ln4975">  return OK;</a>
<a name="ln4976">}</a>
<a name="ln4977"> </a>
<a name="ln4978">/*</a>
<a name="ln4979"> * Check for a match with match_text.</a>
<a name="ln4980"> * Called after skip_to_start() has found regstart.</a>
<a name="ln4981"> * Returns zero for no match, 1 for a match.</a>
<a name="ln4982"> */</a>
<a name="ln4983">static long find_match_text(colnr_T startcol, int regstart, char_u *match_text)</a>
<a name="ln4984">{</a>
<a name="ln4985">#define PTR2LEN(x) utf_ptr2len(x)</a>
<a name="ln4986"> </a>
<a name="ln4987">  colnr_T col = startcol;</a>
<a name="ln4988">  int regstart_len = PTR2LEN(rex.line + startcol);</a>
<a name="ln4989"> </a>
<a name="ln4990">  for (;;) {</a>
<a name="ln4991">    bool match = true;</a>
<a name="ln4992">    char_u *s1 = match_text;</a>
<a name="ln4993">    char_u *s2 = rex.line + col + regstart_len;  // skip regstart</a>
<a name="ln4994">    while (*s1) {</a>
<a name="ln4995">      int c1_len = PTR2LEN(s1);</a>
<a name="ln4996">      int c1 = PTR2CHAR(s1);</a>
<a name="ln4997">      int c2_len = PTR2LEN(s2);</a>
<a name="ln4998">      int c2 = PTR2CHAR(s2);</a>
<a name="ln4999"> </a>
<a name="ln5000">      if ((c1 != c2 &amp;&amp; (!rex.reg_ic || utf_fold(c1) != utf_fold(c2)))</a>
<a name="ln5001">          || c1_len != c2_len) {</a>
<a name="ln5002">        match = false;</a>
<a name="ln5003">        break;</a>
<a name="ln5004">      }</a>
<a name="ln5005">      s1 += c1_len;</a>
<a name="ln5006">      s2 += c2_len;</a>
<a name="ln5007">    }</a>
<a name="ln5008">    if (match</a>
<a name="ln5009">        // check that no composing char follows</a>
<a name="ln5010">        &amp;&amp; !utf_iscomposing(PTR2CHAR(s2))) {</a>
<a name="ln5011">      cleanup_subexpr();</a>
<a name="ln5012">      if (REG_MULTI) {</a>
<a name="ln5013">        rex.reg_startpos[0].lnum = rex.lnum;</a>
<a name="ln5014">        rex.reg_startpos[0].col = col;</a>
<a name="ln5015">        rex.reg_endpos[0].lnum = rex.lnum;</a>
<a name="ln5016">        rex.reg_endpos[0].col = s2 - rex.line;</a>
<a name="ln5017">      } else {</a>
<a name="ln5018">        rex.reg_startp[0] = rex.line + col;</a>
<a name="ln5019">        rex.reg_endp[0] = s2;</a>
<a name="ln5020">      }</a>
<a name="ln5021">      return 1L;</a>
<a name="ln5022">    }</a>
<a name="ln5023"> </a>
<a name="ln5024">    // Try finding regstart after the current match.</a>
<a name="ln5025">    col += regstart_len;  // skip regstart</a>
<a name="ln5026">    if (skip_to_start(regstart, &amp;col) == FAIL) {</a>
<a name="ln5027">      break;</a>
<a name="ln5028">    }</a>
<a name="ln5029">  }</a>
<a name="ln5030">  return 0L;</a>
<a name="ln5031"> </a>
<a name="ln5032">#undef PTR2LEN</a>
<a name="ln5033">}</a>
<a name="ln5034"> </a>
<a name="ln5035">static int nfa_did_time_out(void)</a>
<a name="ln5036">{</a>
<a name="ln5037">  if (nfa_time_limit != NULL &amp;&amp; profile_passed_limit(*nfa_time_limit)) {</a>
<a name="ln5038">    if (nfa_timed_out != NULL) {</a>
<a name="ln5039">      *nfa_timed_out = true;</a>
<a name="ln5040">    }</a>
<a name="ln5041">    return true;</a>
<a name="ln5042">  }</a>
<a name="ln5043">  return false;</a>
<a name="ln5044">}</a>
<a name="ln5045"> </a>
<a name="ln5046">/// Main matching routine.</a>
<a name="ln5047">///</a>
<a name="ln5048">/// Run NFA to determine whether it matches rex.input.</a>
<a name="ln5049">///</a>
<a name="ln5050">/// When &quot;nfa_endp&quot; is not NULL it is a required end-of-match position.</a>
<a name="ln5051">///</a>
<a name="ln5052">/// Return true if there is a match, false if there is no match,</a>
<a name="ln5053">/// NFA_TOO_EXPENSIVE if we end up with too many states.</a>
<a name="ln5054">/// When there is a match &quot;submatch&quot; contains the positions.</a>
<a name="ln5055">///</a>
<a name="ln5056">/// Note: Caller must ensure that: start != NULL.</a>
<a name="ln5057">static int nfa_regmatch(nfa_regprog_T *prog, nfa_state_T *start,</a>
<a name="ln5058">                        regsubs_T *submatch, regsubs_T *m)</a>
<a name="ln5059">  FUNC_ATTR_NONNULL_ARG(1, 2, 4)</a>
<a name="ln5060">{</a>
<a name="ln5061">  int result = false;</a>
<a name="ln5062">  int flag = 0;</a>
<a name="ln5063">  bool go_to_nextline = false;</a>
<a name="ln5064">  nfa_thread_T *t;</a>
<a name="ln5065">  nfa_list_T list[2];</a>
<a name="ln5066">  int listidx;</a>
<a name="ln5067">  nfa_list_T  *thislist;</a>
<a name="ln5068">  nfa_list_T  *nextlist;</a>
<a name="ln5069">  int         *listids = NULL;</a>
<a name="ln5070">  int listids_len = 0;</a>
<a name="ln5071">  nfa_state_T *add_state;</a>
<a name="ln5072">  bool add_here;</a>
<a name="ln5073">  int add_count;</a>
<a name="ln5074">  int add_off = 0;</a>
<a name="ln5075">  int toplevel = start-&gt;c == NFA_MOPEN;</a>
<a name="ln5076">  regsubs_T *r;</a>
<a name="ln5077">#ifdef NFA_REGEXP_DEBUG_LOG</a>
<a name="ln5078">  FILE        *debug = fopen(NFA_REGEXP_DEBUG_LOG, &quot;a&quot;);</a>
<a name="ln5079"> </a>
<a name="ln5080">  if (debug == NULL) {</a>
<a name="ln5081">    EMSG2(&quot;(NFA) COULD NOT OPEN %s!&quot;, NFA_REGEXP_DEBUG_LOG);</a>
<a name="ln5082">    return false;</a>
<a name="ln5083">  }</a>
<a name="ln5084">#endif</a>
<a name="ln5085">  // Some patterns may take a long time to match, especially when using</a>
<a name="ln5086">  // recursive_regmatch(). Allow interrupting them with CTRL-C.</a>
<a name="ln5087">  fast_breakcheck();</a>
<a name="ln5088">  if (got_int) {</a>
<a name="ln5089">#ifdef NFA_REGEXP_DEBUG_LOG</a>
<a name="ln5090">    fclose(debug);</a>
<a name="ln5091">#endif</a>
<a name="ln5092">    return false;</a>
<a name="ln5093">  }</a>
<a name="ln5094">  if (nfa_did_time_out()) {</a>
<a name="ln5095">#ifdef NFA_REGEXP_DEBUG_LOG</a>
<a name="ln5096">    fclose(debug);</a>
<a name="ln5097">#endif</a>
<a name="ln5098">    return false;</a>
<a name="ln5099">  }</a>
<a name="ln5100"> </a>
<a name="ln5101">  nfa_match = false;</a>
<a name="ln5102"> </a>
<a name="ln5103">  // Allocate memory for the lists of nodes.</a>
<a name="ln5104">  size_t size = (prog-&gt;nstate + 1) * sizeof(nfa_thread_T);</a>
<a name="ln5105">  list[0].t = xmalloc(size);</a>
<a name="ln5106">  list[0].len = prog-&gt;nstate + 1;</a>
<a name="ln5107">  list[1].t = xmalloc(size);</a>
<a name="ln5108">  list[1].len = prog-&gt;nstate + 1;</a>
<a name="ln5109"> </a>
<a name="ln5110">#ifdef REGEXP_DEBUG</a>
<a name="ln5111">  log_fd = fopen(NFA_REGEXP_RUN_LOG, &quot;a&quot;);</a>
<a name="ln5112">  if (log_fd != NULL) {</a>
<a name="ln5113">    fprintf(log_fd, &quot;**********************************\n&quot;);</a>
<a name="ln5114">    nfa_set_code(start-&gt;c);</a>
<a name="ln5115">    fprintf(log_fd, &quot; RUNNING nfa_regmatch() starting with state %d, code %s\n&quot;,</a>
<a name="ln5116">        abs(start-&gt;id), code);</a>
<a name="ln5117">    fprintf(log_fd, &quot;**********************************\n&quot;);</a>
<a name="ln5118">  } else {</a>
<a name="ln5119">    EMSG(_(e_log_open_failed));</a>
<a name="ln5120">    log_fd = stderr;</a>
<a name="ln5121">  }</a>
<a name="ln5122">#endif</a>
<a name="ln5123"> </a>
<a name="ln5124">  thislist = &amp;list[0];</a>
<a name="ln5125">  thislist-&gt;n = 0;</a>
<a name="ln5126">  thislist-&gt;has_pim = false;</a>
<a name="ln5127">  nextlist = &amp;list[1];</a>
<a name="ln5128">  nextlist-&gt;n = 0;</a>
<a name="ln5129">  nextlist-&gt;has_pim = false;</a>
<a name="ln5130">#ifdef REGEXP_DEBUG</a>
<a name="ln5131">  fprintf(log_fd, &quot;(---) STARTSTATE first\n&quot;);</a>
<a name="ln5132">#endif</a>
<a name="ln5133">  thislist-&gt;id = rex.nfa_listid + 1;</a>
<a name="ln5134"> </a>
<a name="ln5135">  // Inline optimized code for addstate(thislist, start, m, 0) if we know</a>
<a name="ln5136">  // it's the first MOPEN.</a>
<a name="ln5137">  if (toplevel) {</a>
<a name="ln5138">    if (REG_MULTI) {</a>
<a name="ln5139">      m-&gt;norm.list.multi[0].start_lnum = rex.lnum;</a>
<a name="ln5140">      m-&gt;norm.list.multi[0].start_col = (colnr_T)(rex.input - rex.line);</a>
<a name="ln5141">    } else {</a>
<a name="ln5142">      m-&gt;norm.list.line[0].start = rex.input;</a>
<a name="ln5143">    }</a>
<a name="ln5144">    m-&gt;norm.in_use = 1;</a>
<a name="ln5145">    r = addstate(thislist, start-&gt;out, m, NULL, 0);</a>
<a name="ln5146">  } else {</a>
<a name="ln5147">    r = addstate(thislist, start, m, NULL, 0);</a>
<a name="ln5148">  }</a>
<a name="ln5149">  if (r == NULL) {</a>
<a name="ln5150">    nfa_match = NFA_TOO_EXPENSIVE;</a>
<a name="ln5151">    goto theend;</a>
<a name="ln5152">  }</a>
<a name="ln5153"> </a>
<a name="ln5154">#define ADD_STATE_IF_MATCH(state) \</a>
<a name="ln5155">  if (result) { \</a>
<a name="ln5156">    add_state = state-&gt;out; \</a>
<a name="ln5157">    add_off = clen; \</a>
<a name="ln5158">  }</a>
<a name="ln5159"> </a>
<a name="ln5160">  /*</a>
<a name="ln5161">   * Run for each character.</a>
<a name="ln5162">   */</a>
<a name="ln5163">  for (;; ) {</a>
<a name="ln5164">    int curc = utf_ptr2char(rex.input);</a>
<a name="ln5165">    int clen = utfc_ptr2len(rex.input);</a>
<a name="ln5166">    if (curc == NUL) {</a>
<a name="ln5167">      clen = 0;</a>
<a name="ln5168">      go_to_nextline = false;</a>
<a name="ln5169">    }</a>
<a name="ln5170"> </a>
<a name="ln5171">    /* swap lists */</a>
<a name="ln5172">    thislist = &amp;list[flag];</a>
<a name="ln5173">    nextlist = &amp;list[flag ^= 1];</a>
<a name="ln5174">    nextlist-&gt;n = 0;                // clear nextlist</a>
<a name="ln5175">    nextlist-&gt;has_pim = false;</a>
<a name="ln5176">    rex.nfa_listid++;</a>
<a name="ln5177">    if (prog-&gt;re_engine == AUTOMATIC_ENGINE</a>
<a name="ln5178">        &amp;&amp; (rex.nfa_listid &gt;= NFA_MAX_STATES)) {</a>
<a name="ln5179">      // Too many states, retry with old engine.</a>
<a name="ln5180">      nfa_match = NFA_TOO_EXPENSIVE;</a>
<a name="ln5181">      goto theend;</a>
<a name="ln5182">    }</a>
<a name="ln5183"> </a>
<a name="ln5184">    thislist-&gt;id = rex.nfa_listid;</a>
<a name="ln5185">    nextlist-&gt;id = rex.nfa_listid + 1;</a>
<a name="ln5186"> </a>
<a name="ln5187">#ifdef REGEXP_DEBUG</a>
<a name="ln5188">    fprintf(log_fd, &quot;------------------------------------------\n&quot;);</a>
<a name="ln5189">    fprintf(log_fd, &quot;&gt;&gt;&gt; Reginput is \&quot;%s\&quot;\n&quot;, rex.input);</a>
<a name="ln5190">    fprintf(log_fd,</a>
<a name="ln5191">            &quot;&gt;&gt;&gt; Advanced one character... Current char is %c (code %d) \n&quot;,</a>
<a name="ln5192">            curc,</a>
<a name="ln5193">            (int)curc);</a>
<a name="ln5194">    fprintf(log_fd, &quot;&gt;&gt;&gt; Thislist has %d states available: &quot;, thislist-&gt;n);</a>
<a name="ln5195">    {</a>
<a name="ln5196">      int i;</a>
<a name="ln5197"> </a>
<a name="ln5198">      for (i = 0; i &lt; thislist-&gt;n; i++)</a>
<a name="ln5199">        fprintf(log_fd, &quot;%d  &quot;, abs(thislist-&gt;t[i].state-&gt;id));</a>
<a name="ln5200">    }</a>
<a name="ln5201">    fprintf(log_fd, &quot;\n&quot;);</a>
<a name="ln5202">#endif</a>
<a name="ln5203"> </a>
<a name="ln5204">#ifdef NFA_REGEXP_DEBUG_LOG</a>
<a name="ln5205">    fprintf(debug, &quot;\n-------------------\n&quot;);</a>
<a name="ln5206">#endif</a>
<a name="ln5207">    /*</a>
<a name="ln5208">     * If the state lists are empty we can stop.</a>
<a name="ln5209">     */</a>
<a name="ln5210">    if (thislist-&gt;n == 0)</a>
<a name="ln5211">      break;</a>
<a name="ln5212"> </a>
<a name="ln5213">    // compute nextlist</a>
<a name="ln5214">    for (listidx = 0; listidx &lt; thislist-&gt;n; listidx++) {</a>
<a name="ln5215">      // If the list gets very long there probably is something wrong.</a>
<a name="ln5216">      // At least allow interrupting with CTRL-C.</a>
<a name="ln5217">      fast_breakcheck();</a>
<a name="ln5218">      if (got_int) {</a>
<a name="ln5219">        break;</a>
<a name="ln5220">      }</a>
<a name="ln5221">      if (nfa_time_limit != NULL &amp;&amp; ++nfa_time_count == 20) {</a>
<a name="ln5222">        nfa_time_count = 0;</a>
<a name="ln5223">        if (nfa_did_time_out()) {</a>
<a name="ln5224">          break;</a>
<a name="ln5225">        }</a>
<a name="ln5226">      }</a>
<a name="ln5227">      t = &amp;thislist-&gt;t[listidx];</a>
<a name="ln5228"> </a>
<a name="ln5229">#ifdef NFA_REGEXP_DEBUG_LOG</a>
<a name="ln5230">      nfa_set_code(t-&gt;state-&gt;c);</a>
<a name="ln5231">      fprintf(debug, &quot;%s, &quot;, code);</a>
<a name="ln5232">#endif</a>
<a name="ln5233">#ifdef REGEXP_DEBUG</a>
<a name="ln5234">      {</a>
<a name="ln5235">        int col;</a>
<a name="ln5236"> </a>
<a name="ln5237">        if (t-&gt;subs.norm.in_use &lt;= 0) {</a>
<a name="ln5238">          col = -1;</a>
<a name="ln5239">        } else if (REG_MULTI) {</a>
<a name="ln5240">          col = t-&gt;subs.norm.list.multi[0].start_col;</a>
<a name="ln5241">        } else {</a>
<a name="ln5242">          col = (int)(t-&gt;subs.norm.list.line[0].start - rex.line);</a>
<a name="ln5243">        }</a>
<a name="ln5244">        nfa_set_code(t-&gt;state-&gt;c);</a>
<a name="ln5245">        fprintf(log_fd, &quot;(%d) char %d %s (start col %d)%s... \n&quot;,</a>
<a name="ln5246">                abs(t-&gt;state-&gt;id), (int)t-&gt;state-&gt;c, code, col,</a>
<a name="ln5247">                pim_info(&amp;t-&gt;pim));</a>
<a name="ln5248">      }</a>
<a name="ln5249">#endif</a>
<a name="ln5250"> </a>
<a name="ln5251">      /*</a>
<a name="ln5252">       * Handle the possible codes of the current state.</a>
<a name="ln5253">       * The most important is NFA_MATCH.</a>
<a name="ln5254">       */</a>
<a name="ln5255">      add_state = NULL;</a>
<a name="ln5256">      add_here = false;</a>
<a name="ln5257">      add_count = 0;</a>
<a name="ln5258">      switch (t-&gt;state-&gt;c) {</a>
<a name="ln5259">      case NFA_MATCH:</a>
<a name="ln5260">      {</a>
<a name="ln5261">        // If the match is not at the start of the line, ends before a</a>
<a name="ln5262">        // composing characters and rex.reg_icombine is not set, that</a>
<a name="ln5263">        // is not really a match.</a>
<a name="ln5264">        if (!rex.reg_icombine</a>
<a name="ln5265">            &amp;&amp; rex.input != rex.line</a>
<a name="ln5266">            &amp;&amp; utf_iscomposing(curc)) {</a>
<a name="ln5267">          break;</a>
<a name="ln5268">        }</a>
<a name="ln5269">        nfa_match = true;</a>
<a name="ln5270">        copy_sub(&amp;submatch-&gt;norm, &amp;t-&gt;subs.norm);</a>
<a name="ln5271">        if (rex.nfa_has_zsubexpr) {</a>
<a name="ln5272">          copy_sub(&amp;submatch-&gt;synt, &amp;t-&gt;subs.synt);</a>
<a name="ln5273">        }</a>
<a name="ln5274">#ifdef REGEXP_DEBUG</a>
<a name="ln5275">        log_subsexpr(&amp;t-&gt;subs);</a>
<a name="ln5276">#endif</a>
<a name="ln5277">        // Found the left-most longest match, do not look at any other</a>
<a name="ln5278">        // states at this position.  When the list of states is going</a>
<a name="ln5279">        // to be empty quit without advancing, so that &quot;rex.input&quot; is</a>
<a name="ln5280">        // correct.</a>
<a name="ln5281">        if (nextlist-&gt;n == 0) {</a>
<a name="ln5282">          clen = 0;</a>
<a name="ln5283">        }</a>
<a name="ln5284">        goto nextchar;</a>
<a name="ln5285">      }</a>
<a name="ln5286"> </a>
<a name="ln5287">      case NFA_END_INVISIBLE:</a>
<a name="ln5288">      case NFA_END_INVISIBLE_NEG:</a>
<a name="ln5289">      case NFA_END_PATTERN:</a>
<a name="ln5290">        // This is only encountered after a NFA_START_INVISIBLE or</a>
<a name="ln5291">        // NFA_START_INVISIBLE_BEFORE node.</a>
<a name="ln5292">        // They surround a zero-width group, used with &quot;\@=&quot;, &quot;\&amp;&quot;,</a>
<a name="ln5293">        // &quot;\@!&quot;, &quot;\@&lt;=&quot; and &quot;\@&lt;!&quot;.</a>
<a name="ln5294">        // If we got here, it means that the current &quot;invisible&quot; group</a>
<a name="ln5295">        // finished successfully, so return control to the parent</a>
<a name="ln5296">        // nfa_regmatch().  For a look-behind match only when it ends</a>
<a name="ln5297">        // in the position in &quot;nfa_endp&quot;.</a>
<a name="ln5298">        // Submatches are stored in *m, and used in the parent call.</a>
<a name="ln5299">#ifdef REGEXP_DEBUG</a>
<a name="ln5300">        if (nfa_endp != NULL) {</a>
<a name="ln5301">          if (REG_MULTI) {</a>
<a name="ln5302">            fprintf(log_fd,</a>
<a name="ln5303">                    &quot;Current lnum: %d, endp lnum: %d;&quot;</a>
<a name="ln5304">                    &quot; current col: %d, endp col: %d\n&quot;,</a>
<a name="ln5305">                    (int)rex.lnum,</a>
<a name="ln5306">                    (int)nfa_endp-&gt;se_u.pos.lnum,</a>
<a name="ln5307">                    (int)(rex.input - rex.line),</a>
<a name="ln5308">                    nfa_endp-&gt;se_u.pos.col);</a>
<a name="ln5309">          } else {</a>
<a name="ln5310">            fprintf(log_fd, &quot;Current col: %d, endp col: %d\n&quot;,</a>
<a name="ln5311">                    (int)(rex.input - rex.line),</a>
<a name="ln5312">                    (int)(nfa_endp-&gt;se_u.ptr - rex.input));</a>
<a name="ln5313">          }</a>
<a name="ln5314">        }</a>
<a name="ln5315">#endif</a>
<a name="ln5316">        // If &quot;nfa_endp&quot; is set it's only a match if it ends at</a>
<a name="ln5317">        // &quot;nfa_endp&quot;</a>
<a name="ln5318">        if (nfa_endp != NULL</a>
<a name="ln5319">            &amp;&amp; (REG_MULTI</a>
<a name="ln5320">                ? (rex.lnum != nfa_endp-&gt;se_u.pos.lnum</a>
<a name="ln5321">                   || (int)(rex.input - rex.line) != nfa_endp-&gt;se_u.pos.col)</a>
<a name="ln5322">                : rex.input != nfa_endp-&gt;se_u.ptr)) {</a>
<a name="ln5323">          break;</a>
<a name="ln5324">        }</a>
<a name="ln5325">        // do not set submatches for \@!</a>
<a name="ln5326">        if (t-&gt;state-&gt;c != NFA_END_INVISIBLE_NEG) {</a>
<a name="ln5327">          copy_sub(&amp;m-&gt;norm, &amp;t-&gt;subs.norm);</a>
<a name="ln5328">          if (rex.nfa_has_zsubexpr) {</a>
<a name="ln5329">            copy_sub(&amp;m-&gt;synt, &amp;t-&gt;subs.synt);</a>
<a name="ln5330">          }</a>
<a name="ln5331">        }</a>
<a name="ln5332">#ifdef REGEXP_DEBUG</a>
<a name="ln5333">        fprintf(log_fd, &quot;Match found:\n&quot;);</a>
<a name="ln5334">        log_subsexpr(m);</a>
<a name="ln5335">#endif</a>
<a name="ln5336">        nfa_match = true;</a>
<a name="ln5337">        // See comment above at &quot;goto nextchar&quot;.</a>
<a name="ln5338">        if (nextlist-&gt;n == 0) {</a>
<a name="ln5339">          clen = 0;</a>
<a name="ln5340">        }</a>
<a name="ln5341">        goto nextchar;</a>
<a name="ln5342"> </a>
<a name="ln5343">      case NFA_START_INVISIBLE:</a>
<a name="ln5344">      case NFA_START_INVISIBLE_FIRST:</a>
<a name="ln5345">      case NFA_START_INVISIBLE_NEG:</a>
<a name="ln5346">      case NFA_START_INVISIBLE_NEG_FIRST:</a>
<a name="ln5347">      case NFA_START_INVISIBLE_BEFORE:</a>
<a name="ln5348">      case NFA_START_INVISIBLE_BEFORE_FIRST:</a>
<a name="ln5349">      case NFA_START_INVISIBLE_BEFORE_NEG:</a>
<a name="ln5350">      case NFA_START_INVISIBLE_BEFORE_NEG_FIRST:</a>
<a name="ln5351">      {</a>
<a name="ln5352">#ifdef REGEXP_DEBUG</a>
<a name="ln5353">        fprintf(log_fd, &quot;Failure chance invisible: %d, what follows: %d\n&quot;,</a>
<a name="ln5354">            failure_chance(t-&gt;state-&gt;out, 0),</a>
<a name="ln5355">            failure_chance(t-&gt;state-&gt;out1-&gt;out, 0));</a>
<a name="ln5356">#endif</a>
<a name="ln5357">        // Do it directly if there already is a PIM or when</a>
<a name="ln5358">        // nfa_postprocess() detected it will work better.</a>
<a name="ln5359">        if (t-&gt;pim.result != NFA_PIM_UNUSED</a>
<a name="ln5360">            || t-&gt;state-&gt;c == NFA_START_INVISIBLE_FIRST</a>
<a name="ln5361">            || t-&gt;state-&gt;c == NFA_START_INVISIBLE_NEG_FIRST</a>
<a name="ln5362">            || t-&gt;state-&gt;c == NFA_START_INVISIBLE_BEFORE_FIRST</a>
<a name="ln5363">            || t-&gt;state-&gt;c == NFA_START_INVISIBLE_BEFORE_NEG_FIRST) {</a>
<a name="ln5364">          int in_use = m-&gt;norm.in_use;</a>
<a name="ln5365"> </a>
<a name="ln5366">          // Copy submatch info for the recursive call, opposite</a>
<a name="ln5367">          // of what happens on success below.</a>
<a name="ln5368">          copy_sub_off(&amp;m-&gt;norm, &amp;t-&gt;subs.norm);</a>
<a name="ln5369">          if (rex.nfa_has_zsubexpr) {</a>
<a name="ln5370">            copy_sub_off(&amp;m-&gt;synt, &amp;t-&gt;subs.synt);</a>
<a name="ln5371">          }</a>
<a name="ln5372">          // First try matching the invisible match, then what</a>
<a name="ln5373">          // follows.</a>
<a name="ln5374">          result = recursive_regmatch(t-&gt;state, NULL, prog, submatch, m,</a>
<a name="ln5375">                                      &amp;listids, &amp;listids_len);</a>
<a name="ln5376">          if (result == NFA_TOO_EXPENSIVE) {</a>
<a name="ln5377">            nfa_match = result;</a>
<a name="ln5378">            goto theend;</a>
<a name="ln5379">          }</a>
<a name="ln5380"> </a>
<a name="ln5381">          // for \@! and \@&lt;! it is a match when the result is</a>
<a name="ln5382">          // false</a>
<a name="ln5383">          if (result != (t-&gt;state-&gt;c == NFA_START_INVISIBLE_NEG</a>
<a name="ln5384">                         || t-&gt;state-&gt;c == NFA_START_INVISIBLE_NEG_FIRST</a>
<a name="ln5385">                         || t-&gt;state-&gt;c</a>
<a name="ln5386">                         == NFA_START_INVISIBLE_BEFORE_NEG</a>
<a name="ln5387">                         || t-&gt;state-&gt;c</a>
<a name="ln5388">                         == NFA_START_INVISIBLE_BEFORE_NEG_FIRST)) {</a>
<a name="ln5389">            // Copy submatch info from the recursive call</a>
<a name="ln5390">            copy_sub_off(&amp;t-&gt;subs.norm, &amp;m-&gt;norm);</a>
<a name="ln5391">            if (rex.nfa_has_zsubexpr) {</a>
<a name="ln5392">              copy_sub_off(&amp;t-&gt;subs.synt, &amp;m-&gt;synt);</a>
<a name="ln5393">            }</a>
<a name="ln5394">            // If the pattern has \ze and it matched in the</a>
<a name="ln5395">            // sub pattern, use it.</a>
<a name="ln5396">            copy_ze_off(&amp;t-&gt;subs.norm, &amp;m-&gt;norm);</a>
<a name="ln5397"> </a>
<a name="ln5398">            // t-&gt;state-&gt;out1 is the corresponding</a>
<a name="ln5399">            // END_INVISIBLE node; Add its out to the current</a>
<a name="ln5400">            // list (zero-width match).</a>
<a name="ln5401">            add_here = true;</a>
<a name="ln5402">            add_state = t-&gt;state-&gt;out1-&gt;out;</a>
<a name="ln5403">          }</a>
<a name="ln5404">          m-&gt;norm.in_use = in_use;</a>
<a name="ln5405">        } else {</a>
<a name="ln5406">          nfa_pim_T pim;</a>
<a name="ln5407"> </a>
<a name="ln5408">          // First try matching what follows.  Only if a match</a>
<a name="ln5409">          // is found verify the invisible match matches.  Add a</a>
<a name="ln5410">          // nfa_pim_T to the following states, it contains info</a>
<a name="ln5411">          // about the invisible match.</a>
<a name="ln5412">          pim.state = t-&gt;state;</a>
<a name="ln5413">          pim.result = NFA_PIM_TODO;</a>
<a name="ln5414">          pim.subs.norm.in_use = 0;</a>
<a name="ln5415">          pim.subs.synt.in_use = 0;</a>
<a name="ln5416">          if (REG_MULTI) {</a>
<a name="ln5417">            pim.end.pos.col = (int)(rex.input - rex.line);</a>
<a name="ln5418">            pim.end.pos.lnum = rex.lnum;</a>
<a name="ln5419">          } else {</a>
<a name="ln5420">            pim.end.ptr = rex.input;</a>
<a name="ln5421">          }</a>
<a name="ln5422">          // t-&gt;state-&gt;out1 is the corresponding END_INVISIBLE</a>
<a name="ln5423">          // node; Add its out to the current list (zero-width</a>
<a name="ln5424">          // match).</a>
<a name="ln5425">          if (addstate_here(thislist, t-&gt;state-&gt;out1-&gt;out, &amp;t-&gt;subs,</a>
<a name="ln5426">                            &amp;pim, &amp;listidx) == NULL) {</a>
<a name="ln5427">            nfa_match = NFA_TOO_EXPENSIVE;</a>
<a name="ln5428">            goto theend;</a>
<a name="ln5429">          }</a>
<a name="ln5430">        }</a>
<a name="ln5431">      }</a>
<a name="ln5432">      break;</a>
<a name="ln5433"> </a>
<a name="ln5434">      case NFA_START_PATTERN:</a>
<a name="ln5435">      {</a>
<a name="ln5436">        nfa_state_T *skip = NULL;</a>
<a name="ln5437">#ifdef REGEXP_DEBUG</a>
<a name="ln5438">        int skip_lid = 0;</a>
<a name="ln5439">#endif</a>
<a name="ln5440"> </a>
<a name="ln5441">        // There is no point in trying to match the pattern if the</a>
<a name="ln5442">        // output state is not going to be added to the list.</a>
<a name="ln5443">        if (state_in_list(nextlist, t-&gt;state-&gt;out1-&gt;out, &amp;t-&gt;subs)) {</a>
<a name="ln5444">          skip = t-&gt;state-&gt;out1-&gt;out;</a>
<a name="ln5445">#ifdef REGEXP_DEBUG</a>
<a name="ln5446">          skip_lid = nextlist-&gt;id;</a>
<a name="ln5447">#endif</a>
<a name="ln5448">        } else if (state_in_list(nextlist,</a>
<a name="ln5449">                       t-&gt;state-&gt;out1-&gt;out-&gt;out, &amp;t-&gt;subs)) {</a>
<a name="ln5450">          skip = t-&gt;state-&gt;out1-&gt;out-&gt;out;</a>
<a name="ln5451">#ifdef REGEXP_DEBUG</a>
<a name="ln5452">          skip_lid = nextlist-&gt;id;</a>
<a name="ln5453">#endif</a>
<a name="ln5454">        } else if (state_in_list(thislist,</a>
<a name="ln5455">                       t-&gt;state-&gt;out1-&gt;out-&gt;out, &amp;t-&gt;subs)) {</a>
<a name="ln5456">          skip = t-&gt;state-&gt;out1-&gt;out-&gt;out;</a>
<a name="ln5457">#ifdef REGEXP_DEBUG</a>
<a name="ln5458">          skip_lid = thislist-&gt;id;</a>
<a name="ln5459">#endif</a>
<a name="ln5460">        }</a>
<a name="ln5461">        if (skip != NULL) {</a>
<a name="ln5462">#ifdef REGEXP_DEBUG</a>
<a name="ln5463">          nfa_set_code(skip-&gt;c);</a>
<a name="ln5464">          fprintf(</a>
<a name="ln5465">              log_fd,</a>
<a name="ln5466">              &quot;&gt; Not trying to match pattern, output state %d is already in list %d. char %d: %s\n&quot;,</a>
<a name="ln5467">              abs(skip-&gt;id), skip_lid, skip-&gt;c, code);</a>
<a name="ln5468">#endif</a>
<a name="ln5469">          break;</a>
<a name="ln5470">        }</a>
<a name="ln5471">        // Copy submatch info to the recursive call, opposite of what</a>
<a name="ln5472">        // happens afterwards.</a>
<a name="ln5473">        copy_sub_off(&amp;m-&gt;norm, &amp;t-&gt;subs.norm);</a>
<a name="ln5474">        if (rex.nfa_has_zsubexpr) {</a>
<a name="ln5475">          copy_sub_off(&amp;m-&gt;synt, &amp;t-&gt;subs.synt);</a>
<a name="ln5476">        }</a>
<a name="ln5477"> </a>
<a name="ln5478">        // First try matching the pattern.</a>
<a name="ln5479">        result = recursive_regmatch(t-&gt;state, NULL, prog, submatch, m,</a>
<a name="ln5480">                                    &amp;listids, &amp;listids_len);</a>
<a name="ln5481">        if (result == NFA_TOO_EXPENSIVE) {</a>
<a name="ln5482">          nfa_match = result;</a>
<a name="ln5483">          goto theend;</a>
<a name="ln5484">        }</a>
<a name="ln5485">        if (result) {</a>
<a name="ln5486">          int bytelen;</a>
<a name="ln5487"> </a>
<a name="ln5488">#ifdef REGEXP_DEBUG</a>
<a name="ln5489">          fprintf(log_fd, &quot;NFA_START_PATTERN matches:\n&quot;);</a>
<a name="ln5490">          log_subsexpr(m);</a>
<a name="ln5491">#endif</a>
<a name="ln5492">          // Copy submatch info from the recursive call</a>
<a name="ln5493">          copy_sub_off(&amp;t-&gt;subs.norm, &amp;m-&gt;norm);</a>
<a name="ln5494">          if (rex.nfa_has_zsubexpr) {</a>
<a name="ln5495">            copy_sub_off(&amp;t-&gt;subs.synt, &amp;m-&gt;synt);</a>
<a name="ln5496">          }</a>
<a name="ln5497">          // Now we need to skip over the matched text and then</a>
<a name="ln5498">          // continue with what follows.</a>
<a name="ln5499">          if (REG_MULTI) {</a>
<a name="ln5500">            // TODO(RE): multi-line match</a>
<a name="ln5501">            bytelen = m-&gt;norm.list.multi[0].end_col</a>
<a name="ln5502">                      - (int)(rex.input - rex.line);</a>
<a name="ln5503">          } else {</a>
<a name="ln5504">            bytelen = (int)(m-&gt;norm.list.line[0].end - rex.input);</a>
<a name="ln5505">          }</a>
<a name="ln5506"> </a>
<a name="ln5507">#ifdef REGEXP_DEBUG</a>
<a name="ln5508">          fprintf(log_fd, &quot;NFA_START_PATTERN length: %d\n&quot;, bytelen);</a>
<a name="ln5509">#endif</a>
<a name="ln5510">          if (bytelen == 0) {</a>
<a name="ln5511">            // empty match, output of corresponding</a>
<a name="ln5512">            // NFA_END_PATTERN/NFA_SKIP to be used at current</a>
<a name="ln5513">            // position</a>
<a name="ln5514">            add_here = true;</a>
<a name="ln5515">            add_state = t-&gt;state-&gt;out1-&gt;out-&gt;out;</a>
<a name="ln5516">          } else if (bytelen &lt;= clen) {</a>
<a name="ln5517">            // match current character, output of corresponding</a>
<a name="ln5518">            // NFA_END_PATTERN to be used at next position.</a>
<a name="ln5519">            add_state = t-&gt;state-&gt;out1-&gt;out-&gt;out;</a>
<a name="ln5520">            add_off = clen;</a>
<a name="ln5521">          } else {</a>
<a name="ln5522">            // skip over the matched characters, set character</a>
<a name="ln5523">            // count in NFA_SKIP</a>
<a name="ln5524">            add_state = t-&gt;state-&gt;out1-&gt;out;</a>
<a name="ln5525">            add_off = bytelen;</a>
<a name="ln5526">            add_count = bytelen - clen;</a>
<a name="ln5527">          }</a>
<a name="ln5528">        }</a>
<a name="ln5529">        break;</a>
<a name="ln5530">      }</a>
<a name="ln5531"> </a>
<a name="ln5532">      case NFA_BOL:</a>
<a name="ln5533">        if (rex.input == rex.line) {</a>
<a name="ln5534">          add_here = true;</a>
<a name="ln5535">          add_state = t-&gt;state-&gt;out;</a>
<a name="ln5536">        }</a>
<a name="ln5537">        break;</a>
<a name="ln5538"> </a>
<a name="ln5539">      case NFA_EOL:</a>
<a name="ln5540">        if (curc == NUL) {</a>
<a name="ln5541">          add_here = true;</a>
<a name="ln5542">          add_state = t-&gt;state-&gt;out;</a>
<a name="ln5543">        }</a>
<a name="ln5544">        break;</a>
<a name="ln5545"> </a>
<a name="ln5546">      case NFA_BOW:</a>
<a name="ln5547">        result = true;</a>
<a name="ln5548"> </a>
<a name="ln5549">        if (curc == NUL) {</a>
<a name="ln5550">          result = false;</a>
<a name="ln5551">        } else {</a>
<a name="ln5552">          int this_class;</a>
<a name="ln5553"> </a>
<a name="ln5554">          // Get class of current and previous char (if it exists).</a>
<a name="ln5555">          this_class = mb_get_class_tab(rex.input, rex.reg_buf-&gt;b_chartab);</a>
<a name="ln5556">          if (this_class &lt;= 1) {</a>
<a name="ln5557">            result = false;</a>
<a name="ln5558">          } else if (reg_prev_class() == this_class) {</a>
<a name="ln5559">            result = false;</a>
<a name="ln5560">          }</a>
<a name="ln5561">        }</a>
<a name="ln5562">        if (result) {</a>
<a name="ln5563">          add_here = true;</a>
<a name="ln5564">          add_state = t-&gt;state-&gt;out;</a>
<a name="ln5565">        }</a>
<a name="ln5566">        break;</a>
<a name="ln5567"> </a>
<a name="ln5568">      case NFA_EOW:</a>
<a name="ln5569">        result = true;</a>
<a name="ln5570">        if (rex.input == rex.line) {</a>
<a name="ln5571">          result = false;</a>
<a name="ln5572">        } else {</a>
<a name="ln5573">          int this_class, prev_class;</a>
<a name="ln5574"> </a>
<a name="ln5575">          // Get class of current and previous char (if it exists).</a>
<a name="ln5576">          this_class = mb_get_class_tab(rex.input, rex.reg_buf-&gt;b_chartab);</a>
<a name="ln5577">          prev_class = reg_prev_class();</a>
<a name="ln5578">          if (this_class == prev_class</a>
<a name="ln5579">              || prev_class == 0 || prev_class == 1) {</a>
<a name="ln5580">            result = false;</a>
<a name="ln5581">          }</a>
<a name="ln5582">        }</a>
<a name="ln5583">        if (result) {</a>
<a name="ln5584">          add_here = true;</a>
<a name="ln5585">          add_state = t-&gt;state-&gt;out;</a>
<a name="ln5586">        }</a>
<a name="ln5587">        break;</a>
<a name="ln5588"> </a>
<a name="ln5589">      case NFA_BOF:</a>
<a name="ln5590">        if (rex.lnum == 0 &amp;&amp; rex.input == rex.line</a>
<a name="ln5591">            &amp;&amp; (!REG_MULTI || rex.reg_firstlnum == 1)) {</a>
<a name="ln5592">          add_here = true;</a>
<a name="ln5593">          add_state = t-&gt;state-&gt;out;</a>
<a name="ln5594">        }</a>
<a name="ln5595">        break;</a>
<a name="ln5596"> </a>
<a name="ln5597">      case NFA_EOF:</a>
<a name="ln5598">        if (rex.lnum == rex.reg_maxline &amp;&amp; curc == NUL) {</a>
<a name="ln5599">          add_here = true;</a>
<a name="ln5600">          add_state = t-&gt;state-&gt;out;</a>
<a name="ln5601">        }</a>
<a name="ln5602">        break;</a>
<a name="ln5603"> </a>
<a name="ln5604">      case NFA_COMPOSING:</a>
<a name="ln5605">      {</a>
<a name="ln5606">        int mc = curc;</a>
<a name="ln5607">        int len = 0;</a>
<a name="ln5608">        nfa_state_T *end;</a>
<a name="ln5609">        nfa_state_T *sta;</a>
<a name="ln5610">        int cchars[MAX_MCO];</a>
<a name="ln5611">        int ccount = 0;</a>
<a name="ln5612">        int j;</a>
<a name="ln5613"> </a>
<a name="ln5614">        sta = t-&gt;state-&gt;out;</a>
<a name="ln5615">        len = 0;</a>
<a name="ln5616">        if (utf_iscomposing(sta-&gt;c)) {</a>
<a name="ln5617">          // Only match composing character(s), ignore base</a>
<a name="ln5618">          // character.  Used for &quot;.{composing}&quot; and &quot;{composing}&quot;</a>
<a name="ln5619">          // (no preceding character).</a>
<a name="ln5620">          len += mb_char2len(mc);</a>
<a name="ln5621">        }</a>
<a name="ln5622">        if (rex.reg_icombine &amp;&amp; len == 0) {</a>
<a name="ln5623">          // If \Z was present, then ignore composing characters.</a>
<a name="ln5624">          // When ignoring the base character this always matches.</a>
<a name="ln5625">          if (sta-&gt;c != curc) {</a>
<a name="ln5626">            result = FAIL;</a>
<a name="ln5627">          } else {</a>
<a name="ln5628">            result = OK;</a>
<a name="ln5629">          }</a>
<a name="ln5630">          while (sta-&gt;c != NFA_END_COMPOSING) {</a>
<a name="ln5631">            sta = sta-&gt;out;</a>
<a name="ln5632">          }</a>
<a name="ln5633">        } else if (len &gt; 0 || mc == sta-&gt;c) {</a>
<a name="ln5634">          // Check base character matches first, unless ignored.</a>
<a name="ln5635">          if (len == 0) {</a>
<a name="ln5636">            len += mb_char2len(mc);</a>
<a name="ln5637">            sta = sta-&gt;out;</a>
<a name="ln5638">          }</a>
<a name="ln5639"> </a>
<a name="ln5640">          // We don't care about the order of composing characters.</a>
<a name="ln5641">          // Get them into cchars[] first.</a>
<a name="ln5642">          while (len &lt; clen) {</a>
<a name="ln5643">            mc = utf_ptr2char(rex.input + len);</a>
<a name="ln5644">            cchars[ccount++] = mc;</a>
<a name="ln5645">            len += mb_char2len(mc);</a>
<a name="ln5646">            if (ccount == MAX_MCO)</a>
<a name="ln5647">              break;</a>
<a name="ln5648">          }</a>
<a name="ln5649"> </a>
<a name="ln5650">          // Check that each composing char in the pattern matches a</a>
<a name="ln5651">          // composing char in the text.  We do not check if all</a>
<a name="ln5652">          // composing chars are matched.</a>
<a name="ln5653">          result = OK;</a>
<a name="ln5654">          while (sta-&gt;c != NFA_END_COMPOSING) {</a>
<a name="ln5655">            for (j = 0; j &lt; ccount; ++j)</a>
<a name="ln5656">              if (cchars[j] == sta-&gt;c)</a>
<a name="ln5657">                break;</a>
<a name="ln5658">            if (j == ccount) {</a>
<a name="ln5659">              result = FAIL;</a>
<a name="ln5660">              break;</a>
<a name="ln5661">            }</a>
<a name="ln5662">            sta = sta-&gt;out;</a>
<a name="ln5663">          }</a>
<a name="ln5664">        } else</a>
<a name="ln5665">          result = FAIL;</a>
<a name="ln5666"> </a>
<a name="ln5667">        end = t-&gt;state-&gt;out1;               // NFA_END_COMPOSING</a>
<a name="ln5668">        ADD_STATE_IF_MATCH(end);</a>
<a name="ln5669">        break;</a>
<a name="ln5670">      }</a>
<a name="ln5671"> </a>
<a name="ln5672">      case NFA_NEWL:</a>
<a name="ln5673">        if (curc == NUL &amp;&amp; !rex.reg_line_lbr &amp;&amp; REG_MULTI</a>
<a name="ln5674">            &amp;&amp; rex.lnum &lt;= rex.reg_maxline) {</a>
<a name="ln5675">          go_to_nextline = true;</a>
<a name="ln5676">          // Pass -1 for the offset, which means taking the position</a>
<a name="ln5677">          // at the start of the next line.</a>
<a name="ln5678">          add_state = t-&gt;state-&gt;out;</a>
<a name="ln5679">          add_off = -1;</a>
<a name="ln5680">        } else if (curc == '\n' &amp;&amp; rex.reg_line_lbr) {</a>
<a name="ln5681">          // match \n as if it is an ordinary character</a>
<a name="ln5682">          add_state = t-&gt;state-&gt;out;</a>
<a name="ln5683">          add_off = 1;</a>
<a name="ln5684">        }</a>
<a name="ln5685">        break;</a>
<a name="ln5686"> </a>
<a name="ln5687">      case NFA_START_COLL:</a>
<a name="ln5688">      case NFA_START_NEG_COLL:</a>
<a name="ln5689">      {</a>
<a name="ln5690">        // What follows is a list of characters, until NFA_END_COLL.</a>
<a name="ln5691">        // One of them must match or none of them must match.</a>
<a name="ln5692">        nfa_state_T     *state;</a>
<a name="ln5693">        int result_if_matched;</a>
<a name="ln5694">        int c1, c2;</a>
<a name="ln5695"> </a>
<a name="ln5696">        // Never match EOL. If it's part of the collection it is added</a>
<a name="ln5697">        // as a separate state with an OR.</a>
<a name="ln5698">        if (curc == NUL) {</a>
<a name="ln5699">          break;</a>
<a name="ln5700">        }</a>
<a name="ln5701"> </a>
<a name="ln5702">        state = t-&gt;state-&gt;out;</a>
<a name="ln5703">        result_if_matched = (t-&gt;state-&gt;c == NFA_START_COLL);</a>
<a name="ln5704">        for (;; ) {</a>
<a name="ln5705">          if (state-&gt;c == NFA_END_COLL) {</a>
<a name="ln5706">            result = !result_if_matched;</a>
<a name="ln5707">            break;</a>
<a name="ln5708">          }</a>
<a name="ln5709">          if (state-&gt;c == NFA_RANGE_MIN) {</a>
<a name="ln5710">            c1 = state-&gt;val;</a>
<a name="ln5711">            state = state-&gt;out;             // advance to NFA_RANGE_MAX</a>
<a name="ln5712">            c2 = state-&gt;val;</a>
<a name="ln5713">#ifdef REGEXP_DEBUG</a>
<a name="ln5714">            fprintf(log_fd, &quot;NFA_RANGE_MIN curc=%d c1=%d c2=%d\n&quot;,</a>
<a name="ln5715">                curc, c1, c2);</a>
<a name="ln5716">#endif</a>
<a name="ln5717">            if (curc &gt;= c1 &amp;&amp; curc &lt;= c2) {</a>
<a name="ln5718">              result = result_if_matched;</a>
<a name="ln5719">              break;</a>
<a name="ln5720">            }</a>
<a name="ln5721">            if (rex.reg_ic) {</a>
<a name="ln5722">              int curc_low = utf_fold(curc);</a>
<a name="ln5723">              int done = false;</a>
<a name="ln5724"> </a>
<a name="ln5725">              for (; c1 &lt;= c2; c1++) {</a>
<a name="ln5726">                if (utf_fold(c1) == curc_low) {</a>
<a name="ln5727">                  result = result_if_matched;</a>
<a name="ln5728">                  done = true;</a>
<a name="ln5729">                  break;</a>
<a name="ln5730">                }</a>
<a name="ln5731">              }</a>
<a name="ln5732">              if (done) {</a>
<a name="ln5733">                break;</a>
<a name="ln5734">              }</a>
<a name="ln5735">            }</a>
<a name="ln5736">          } else if (state-&gt;c &lt; 0 ? check_char_class(state-&gt;c, curc)</a>
<a name="ln5737">                     : (curc == state-&gt;c</a>
<a name="ln5738">                        || (rex.reg_ic</a>
<a name="ln5739">                            &amp;&amp; utf_fold(curc) == utf_fold(state-&gt;c)))) {</a>
<a name="ln5740">            result = result_if_matched;</a>
<a name="ln5741">            break;</a>
<a name="ln5742">          }</a>
<a name="ln5743">          state = state-&gt;out;</a>
<a name="ln5744">        }</a>
<a name="ln5745">        if (result) {</a>
<a name="ln5746">          // next state is in out of the NFA_END_COLL, out1 of</a>
<a name="ln5747">          // START points to the END state</a>
<a name="ln5748">          add_state = t-&gt;state-&gt;out1-&gt;out;</a>
<a name="ln5749">          add_off = clen;</a>
<a name="ln5750">        }</a>
<a name="ln5751">        break;</a>
<a name="ln5752">      }</a>
<a name="ln5753"> </a>
<a name="ln5754">      case NFA_ANY:</a>
<a name="ln5755">        // Any char except '\0', (end of input) does not match.</a>
<a name="ln5756">        if (curc &gt; 0) {</a>
<a name="ln5757">          add_state = t-&gt;state-&gt;out;</a>
<a name="ln5758">          add_off = clen;</a>
<a name="ln5759">        }</a>
<a name="ln5760">        break;</a>
<a name="ln5761"> </a>
<a name="ln5762">      case NFA_ANY_COMPOSING:</a>
<a name="ln5763">        // On a composing character skip over it.  Otherwise do</a>
<a name="ln5764">        // nothing.  Always matches.</a>
<a name="ln5765">        if (utf_iscomposing(curc)) {</a>
<a name="ln5766">          add_off = clen;</a>
<a name="ln5767">        } else {</a>
<a name="ln5768">          add_here = true;</a>
<a name="ln5769">          add_off = 0;</a>
<a name="ln5770">        }</a>
<a name="ln5771">        add_state = t-&gt;state-&gt;out;</a>
<a name="ln5772">        break;</a>
<a name="ln5773"> </a>
<a name="ln5774">      // Character classes like \a for alpha, \d for digit etc.</a>
<a name="ln5775">      case NFA_IDENT:           //  \i</a>
<a name="ln5776">        result = vim_isIDc(curc);</a>
<a name="ln5777">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5778">        break;</a>
<a name="ln5779"> </a>
<a name="ln5780">      case NFA_SIDENT:          //  \I</a>
<a name="ln5781">        result = !ascii_isdigit(curc) &amp;&amp; vim_isIDc(curc);</a>
<a name="ln5782">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5783">        break;</a>
<a name="ln5784"> </a>
<a name="ln5785">      case NFA_KWORD:           //  \k</a>
<a name="ln5786">        result = vim_iswordp_buf(rex.input, rex.reg_buf);</a>
<a name="ln5787">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5788">        break;</a>
<a name="ln5789"> </a>
<a name="ln5790">      case NFA_SKWORD:          //  \K</a>
<a name="ln5791">        result = !ascii_isdigit(curc)</a>
<a name="ln5792">                 &amp;&amp; vim_iswordp_buf(rex.input, rex.reg_buf);</a>
<a name="ln5793">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5794">        break;</a>
<a name="ln5795"> </a>
<a name="ln5796">      case NFA_FNAME:           //  \f</a>
<a name="ln5797">        result = vim_isfilec(curc);</a>
<a name="ln5798">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5799">        break;</a>
<a name="ln5800"> </a>
<a name="ln5801">      case NFA_SFNAME:          //  \F</a>
<a name="ln5802">        result = !ascii_isdigit(curc) &amp;&amp; vim_isfilec(curc);</a>
<a name="ln5803">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5804">        break;</a>
<a name="ln5805"> </a>
<a name="ln5806">      case NFA_PRINT:           //  \p</a>
<a name="ln5807">        result = vim_isprintc(PTR2CHAR(rex.input));</a>
<a name="ln5808">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5809">        break;</a>
<a name="ln5810"> </a>
<a name="ln5811">      case NFA_SPRINT:          //  \P</a>
<a name="ln5812">        result = !ascii_isdigit(curc) &amp;&amp; vim_isprintc(PTR2CHAR(rex.input));</a>
<a name="ln5813">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5814">        break;</a>
<a name="ln5815"> </a>
<a name="ln5816">      case NFA_WHITE:           //  \s</a>
<a name="ln5817">        result = ascii_iswhite(curc);</a>
<a name="ln5818">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5819">        break;</a>
<a name="ln5820"> </a>
<a name="ln5821">      case NFA_NWHITE:          //  \S</a>
<a name="ln5822">        result = curc != NUL &amp;&amp; !ascii_iswhite(curc);</a>
<a name="ln5823">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5824">        break;</a>
<a name="ln5825"> </a>
<a name="ln5826">      case NFA_DIGIT:           //  \d</a>
<a name="ln5827">        result = ri_digit(curc);</a>
<a name="ln5828">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5829">        break;</a>
<a name="ln5830"> </a>
<a name="ln5831">      case NFA_NDIGIT:          //  \D</a>
<a name="ln5832">        result = curc != NUL &amp;&amp; !ri_digit(curc);</a>
<a name="ln5833">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5834">        break;</a>
<a name="ln5835"> </a>
<a name="ln5836">      case NFA_HEX:             //  \x</a>
<a name="ln5837">        result = ri_hex(curc);</a>
<a name="ln5838">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5839">        break;</a>
<a name="ln5840"> </a>
<a name="ln5841">      case NFA_NHEX:            //  \X</a>
<a name="ln5842">        result = curc != NUL &amp;&amp; !ri_hex(curc);</a>
<a name="ln5843">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5844">        break;</a>
<a name="ln5845"> </a>
<a name="ln5846">      case NFA_OCTAL:           //  \o</a>
<a name="ln5847">        result = ri_octal(curc);</a>
<a name="ln5848">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5849">        break;</a>
<a name="ln5850"> </a>
<a name="ln5851">      case NFA_NOCTAL:          //  \O</a>
<a name="ln5852">        result = curc != NUL &amp;&amp; !ri_octal(curc);</a>
<a name="ln5853">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5854">        break;</a>
<a name="ln5855"> </a>
<a name="ln5856">      case NFA_WORD:            //  \w</a>
<a name="ln5857">        result = ri_word(curc);</a>
<a name="ln5858">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5859">        break;</a>
<a name="ln5860"> </a>
<a name="ln5861">      case NFA_NWORD:           //  \W</a>
<a name="ln5862">        result = curc != NUL &amp;&amp; !ri_word(curc);</a>
<a name="ln5863">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5864">        break;</a>
<a name="ln5865"> </a>
<a name="ln5866">      case NFA_HEAD:            //  \h</a>
<a name="ln5867">        result = ri_head(curc);</a>
<a name="ln5868">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5869">        break;</a>
<a name="ln5870"> </a>
<a name="ln5871">      case NFA_NHEAD:           //  \H</a>
<a name="ln5872">        result = curc != NUL &amp;&amp; !ri_head(curc);</a>
<a name="ln5873">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5874">        break;</a>
<a name="ln5875"> </a>
<a name="ln5876">      case NFA_ALPHA:           //  \a</a>
<a name="ln5877">        result = ri_alpha(curc);</a>
<a name="ln5878">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5879">        break;</a>
<a name="ln5880"> </a>
<a name="ln5881">      case NFA_NALPHA:          //  \A</a>
<a name="ln5882">        result = curc != NUL &amp;&amp; !ri_alpha(curc);</a>
<a name="ln5883">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5884">        break;</a>
<a name="ln5885"> </a>
<a name="ln5886">      case NFA_LOWER:           //  \l</a>
<a name="ln5887">        result = ri_lower(curc);</a>
<a name="ln5888">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5889">        break;</a>
<a name="ln5890"> </a>
<a name="ln5891">      case NFA_NLOWER:          //  \L</a>
<a name="ln5892">        result = curc != NUL &amp;&amp; !ri_lower(curc);</a>
<a name="ln5893">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5894">        break;</a>
<a name="ln5895"> </a>
<a name="ln5896">      case NFA_UPPER:           //  \u</a>
<a name="ln5897">        result = ri_upper(curc);</a>
<a name="ln5898">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5899">        break;</a>
<a name="ln5900"> </a>
<a name="ln5901">      case NFA_NUPPER:          // \U</a>
<a name="ln5902">        result = curc != NUL &amp;&amp; !ri_upper(curc);</a>
<a name="ln5903">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5904">        break;</a>
<a name="ln5905"> </a>
<a name="ln5906">      case NFA_LOWER_IC:        // [a-z]</a>
<a name="ln5907">        result = ri_lower(curc) || (rex.reg_ic &amp;&amp; ri_upper(curc));</a>
<a name="ln5908">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5909">        break;</a>
<a name="ln5910"> </a>
<a name="ln5911">      case NFA_NLOWER_IC:       // [^a-z]</a>
<a name="ln5912">        result = curc != NUL</a>
<a name="ln5913">                 &amp;&amp; !(ri_lower(curc) || (rex.reg_ic &amp;&amp; ri_upper(curc)));</a>
<a name="ln5914">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5915">        break;</a>
<a name="ln5916"> </a>
<a name="ln5917">      case NFA_UPPER_IC:        // [A-Z]</a>
<a name="ln5918">        result = ri_upper(curc) || (rex.reg_ic &amp;&amp; ri_lower(curc));</a>
<a name="ln5919">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5920">        break;</a>
<a name="ln5921"> </a>
<a name="ln5922">      case NFA_NUPPER_IC:       // [^A-Z]</a>
<a name="ln5923">        result = curc != NUL</a>
<a name="ln5924">                 &amp;&amp; !(ri_upper(curc) || (rex.reg_ic &amp;&amp; ri_lower(curc)));</a>
<a name="ln5925">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5926">        break;</a>
<a name="ln5927"> </a>
<a name="ln5928">      case NFA_BACKREF1:</a>
<a name="ln5929">      case NFA_BACKREF2:</a>
<a name="ln5930">      case NFA_BACKREF3:</a>
<a name="ln5931">      case NFA_BACKREF4:</a>
<a name="ln5932">      case NFA_BACKREF5:</a>
<a name="ln5933">      case NFA_BACKREF6:</a>
<a name="ln5934">      case NFA_BACKREF7:</a>
<a name="ln5935">      case NFA_BACKREF8:</a>
<a name="ln5936">      case NFA_BACKREF9:</a>
<a name="ln5937">      case NFA_ZREF1:</a>
<a name="ln5938">      case NFA_ZREF2:</a>
<a name="ln5939">      case NFA_ZREF3:</a>
<a name="ln5940">      case NFA_ZREF4:</a>
<a name="ln5941">      case NFA_ZREF5:</a>
<a name="ln5942">      case NFA_ZREF6:</a>
<a name="ln5943">      case NFA_ZREF7:</a>
<a name="ln5944">      case NFA_ZREF8:</a>
<a name="ln5945">      case NFA_ZREF9:</a>
<a name="ln5946">        // \1 .. \9  \z1 .. \z9</a>
<a name="ln5947">      {</a>
<a name="ln5948">        int subidx;</a>
<a name="ln5949">        int bytelen;</a>
<a name="ln5950"> </a>
<a name="ln5951">        if (t-&gt;state-&gt;c &lt;= NFA_BACKREF9) {</a>
<a name="ln5952">          subidx = t-&gt;state-&gt;c - NFA_BACKREF1 + 1;</a>
<a name="ln5953">          result = match_backref(&amp;t-&gt;subs.norm, subidx, &amp;bytelen);</a>
<a name="ln5954">        } else {</a>
<a name="ln5955">          subidx = t-&gt;state-&gt;c - NFA_ZREF1 + 1;</a>
<a name="ln5956">          result = match_zref(subidx, &amp;bytelen);</a>
<a name="ln5957">        }</a>
<a name="ln5958"> </a>
<a name="ln5959">        if (result) {</a>
<a name="ln5960">          if (bytelen == 0) {</a>
<a name="ln5961">            // empty match always works, output of NFA_SKIP to be</a>
<a name="ln5962">            // used next</a>
<a name="ln5963">            add_here = true;</a>
<a name="ln5964">            add_state = t-&gt;state-&gt;out-&gt;out;</a>
<a name="ln5965">          } else if (bytelen &lt;= clen) {</a>
<a name="ln5966">            // match current character, jump ahead to out of</a>
<a name="ln5967">            // NFA_SKIP</a>
<a name="ln5968">            add_state = t-&gt;state-&gt;out-&gt;out;</a>
<a name="ln5969">            add_off = clen;</a>
<a name="ln5970">          } else {</a>
<a name="ln5971">            // skip over the matched characters, set character</a>
<a name="ln5972">            // count in NFA_SKIP</a>
<a name="ln5973">            add_state = t-&gt;state-&gt;out;</a>
<a name="ln5974">            add_off = bytelen;</a>
<a name="ln5975">            add_count = bytelen - clen;</a>
<a name="ln5976">          }</a>
<a name="ln5977">        }</a>
<a name="ln5978">        break;</a>
<a name="ln5979">      }</a>
<a name="ln5980">      case NFA_SKIP:</a>
<a name="ln5981">        // character of previous matching \1 .. \9  or \@&gt;</a>
<a name="ln5982">        if (t-&gt;count - clen &lt;= 0) {</a>
<a name="ln5983">          // end of match, go to what follows</a>
<a name="ln5984">          add_state = t-&gt;state-&gt;out;</a>
<a name="ln5985">          add_off = clen;</a>
<a name="ln5986">        } else {</a>
<a name="ln5987">          // add state again with decremented count</a>
<a name="ln5988">          add_state = t-&gt;state;</a>
<a name="ln5989">          add_off = 0;</a>
<a name="ln5990">          add_count = t-&gt;count - clen;</a>
<a name="ln5991">        }</a>
<a name="ln5992">        break;</a>
<a name="ln5993"> </a>
<a name="ln5994">      case NFA_LNUM:</a>
<a name="ln5995">      case NFA_LNUM_GT:</a>
<a name="ln5996">      case NFA_LNUM_LT:</a>
<a name="ln5997">        assert(t-&gt;state-&gt;val &gt;= 0</a>
<a name="ln5998">               &amp;&amp; !((rex.reg_firstlnum &gt; 0</a>
<a name="ln5999">                     &amp;&amp; rex.lnum &gt; LONG_MAX - rex.reg_firstlnum)</a>
<a name="ln6000">                    || (rex.reg_firstlnum &lt; 0</a>
<a name="ln6001">                        &amp;&amp; rex.lnum &lt; LONG_MIN + rex.reg_firstlnum))</a>
<a name="ln6002">               &amp;&amp; rex.lnum + rex.reg_firstlnum &gt;= 0);</a>
<a name="ln6003">        result = (REG_MULTI</a>
<a name="ln6004">                  &amp;&amp; nfa_re_num_cmp((uintmax_t)t-&gt;state-&gt;val,</a>
<a name="ln6005">                                    t-&gt;state-&gt;c - NFA_LNUM,</a>
<a name="ln6006">                                    (uintmax_t)(rex.lnum + rex.reg_firstlnum)));</a>
<a name="ln6007">        if (result) {</a>
<a name="ln6008">          add_here = true;</a>
<a name="ln6009">          add_state = t-&gt;state-&gt;out;</a>
<a name="ln6010">        }</a>
<a name="ln6011">        break;</a>
<a name="ln6012"> </a>
<a name="ln6013">      case NFA_COL:</a>
<a name="ln6014">      case NFA_COL_GT:</a>
<a name="ln6015">      case NFA_COL_LT:</a>
<a name="ln6016">        assert(t-&gt;state-&gt;val &gt;= 0</a>
<a name="ln6017">               &amp;&amp; rex.input &gt;= rex.line</a>
<a name="ln6018">               &amp;&amp; (uintmax_t)(rex.input - rex.line) &lt;= UINTMAX_MAX - 1);</a>
<a name="ln6019">        result = nfa_re_num_cmp((uintmax_t)t-&gt;state-&gt;val,</a>
<a name="ln6020">                                t-&gt;state-&gt;c - NFA_COL,</a>
<a name="ln6021">                                (uintmax_t)(rex.input - rex.line + 1));</a>
<a name="ln6022">        if (result) {</a>
<a name="ln6023">          add_here = true;</a>
<a name="ln6024">          add_state = t-&gt;state-&gt;out;</a>
<a name="ln6025">        }</a>
<a name="ln6026">        break;</a>
<a name="ln6027"> </a>
<a name="ln6028">      case NFA_VCOL:</a>
<a name="ln6029">      case NFA_VCOL_GT:</a>
<a name="ln6030">      case NFA_VCOL_LT:</a>
<a name="ln6031">        {</a>
<a name="ln6032">          int op = t-&gt;state-&gt;c - NFA_VCOL;</a>
<a name="ln6033">          colnr_T col = (colnr_T)(rex.input - rex.line);</a>
<a name="ln6034"> </a>
<a name="ln6035">          // Bail out quickly when there can't be a match, avoid the overhead of</a>
<a name="ln6036">          // win_linetabsize() on long lines.</a>
<a name="ln6037">          if (op != 1 &amp;&amp; col &gt; t-&gt;state-&gt;val * MB_MAXBYTES) {</a>
<a name="ln6038">            break;</a>
<a name="ln6039">          }</a>
<a name="ln6040"> </a>
<a name="ln6041">          result = false;</a>
<a name="ln6042">          win_T *wp = rex.reg_win == NULL ? curwin : rex.reg_win;</a>
<a name="ln6043">          if (op == 1 &amp;&amp; col - 1 &gt; t-&gt;state-&gt;val &amp;&amp; col &gt; 100) {</a>
<a name="ln6044">            long ts = wp-&gt;w_buffer-&gt;b_p_ts;</a>
<a name="ln6045"> </a>
<a name="ln6046">            // Guess that a character won't use more columns than 'tabstop',</a>
<a name="ln6047">            // with a minimum of 4.</a>
<a name="ln6048">            if (ts &lt; 4) {</a>
<a name="ln6049">              ts = 4;</a>
<a name="ln6050">            }</a>
<a name="ln6051">            result = col &gt; t-&gt;state-&gt;val * ts;</a>
<a name="ln6052">          }</a>
<a name="ln6053">          if (!result) {</a>
<a name="ln6054">            uintmax_t lts = win_linetabsize(wp, rex.line, col);</a>
<a name="ln6055">            assert(t-&gt;state-&gt;val &gt;= 0);</a>
<a name="ln6056">            result = nfa_re_num_cmp((uintmax_t)t-&gt;state-&gt;val, op, lts + 1);</a>
<a name="ln6057">          }</a>
<a name="ln6058">          if (result) {</a>
<a name="ln6059">            add_here = true;</a>
<a name="ln6060">            add_state = t-&gt;state-&gt;out;</a>
<a name="ln6061">          }</a>
<a name="ln6062">        }</a>
<a name="ln6063">        break;</a>
<a name="ln6064"> </a>
<a name="ln6065">      case NFA_MARK:</a>
<a name="ln6066">      case NFA_MARK_GT:</a>
<a name="ln6067">      case NFA_MARK_LT:</a>
<a name="ln6068">      {</a>
<a name="ln6069">        pos_T *pos = getmark_buf(rex.reg_buf, t-&gt;state-&gt;val, false);</a>
<a name="ln6070"> </a>
<a name="ln6071">        // Compare the mark position to the match position, if the mark</a>
<a name="ln6072">        // exists and mark is set in reg_buf.</a>
<a name="ln6073">        if (pos != NULL &amp;&amp; pos-&gt;lnum &gt; 0) {</a>
<a name="ln6074">          const colnr_T pos_col = pos-&gt;lnum == rex.lnum + rex.reg_firstlnum</a>
<a name="ln6075">            &amp;&amp; pos-&gt;col == MAXCOL</a>
<a name="ln6076">            ? (colnr_T)STRLEN(reg_getline(pos-&gt;lnum - rex.reg_firstlnum))</a>
<a name="ln6077">            : pos-&gt;col;</a>
<a name="ln6078"> </a>
<a name="ln6079">          result = pos-&gt;lnum == rex.lnum + rex.reg_firstlnum</a>
<a name="ln6080">            ? (pos_col == (colnr_T)(rex.input - rex.line)</a>
<a name="ln6081">               ? t-&gt;state-&gt;c == NFA_MARK</a>
<a name="ln6082">               : (pos_col &lt; (colnr_T)(rex.input - rex.line)</a>
<a name="ln6083">                  ? t-&gt;state-&gt;c == NFA_MARK_GT</a>
<a name="ln6084">                  : t-&gt;state-&gt;c == NFA_MARK_LT))</a>
<a name="ln6085">            : (pos-&gt;lnum &lt; rex.lnum + rex.reg_firstlnum</a>
<a name="ln6086">               ? t-&gt;state-&gt;c == NFA_MARK_GT</a>
<a name="ln6087">               : t-&gt;state-&gt;c == NFA_MARK_LT);</a>
<a name="ln6088">          if (result) {</a>
<a name="ln6089">            add_here = true;</a>
<a name="ln6090">            add_state = t-&gt;state-&gt;out;</a>
<a name="ln6091">          }</a>
<a name="ln6092">        }</a>
<a name="ln6093">        break;</a>
<a name="ln6094">      }</a>
<a name="ln6095"> </a>
<a name="ln6096">      case NFA_CURSOR:</a>
<a name="ln6097">        result = rex.reg_win != NULL</a>
<a name="ln6098">          &amp;&amp; (rex.lnum + rex.reg_firstlnum == rex.reg_win-&gt;w_cursor.lnum)</a>
<a name="ln6099">          &amp;&amp; ((colnr_T)(rex.input - rex.line) == rex.reg_win-&gt;w_cursor.col);</a>
<a name="ln6100">        if (result) {</a>
<a name="ln6101">          add_here = true;</a>
<a name="ln6102">          add_state = t-&gt;state-&gt;out;</a>
<a name="ln6103">        }</a>
<a name="ln6104">        break;</a>
<a name="ln6105"> </a>
<a name="ln6106">      case NFA_VISUAL:</a>
<a name="ln6107">        result = reg_match_visual();</a>
<a name="ln6108">        if (result) {</a>
<a name="ln6109">          add_here = true;</a>
<a name="ln6110">          add_state = t-&gt;state-&gt;out;</a>
<a name="ln6111">        }</a>
<a name="ln6112">        break;</a>
<a name="ln6113"> </a>
<a name="ln6114">      case NFA_MOPEN1:</a>
<a name="ln6115">      case NFA_MOPEN2:</a>
<a name="ln6116">      case NFA_MOPEN3:</a>
<a name="ln6117">      case NFA_MOPEN4:</a>
<a name="ln6118">      case NFA_MOPEN5:</a>
<a name="ln6119">      case NFA_MOPEN6:</a>
<a name="ln6120">      case NFA_MOPEN7:</a>
<a name="ln6121">      case NFA_MOPEN8:</a>
<a name="ln6122">      case NFA_MOPEN9:</a>
<a name="ln6123">      case NFA_ZOPEN:</a>
<a name="ln6124">      case NFA_ZOPEN1:</a>
<a name="ln6125">      case NFA_ZOPEN2:</a>
<a name="ln6126">      case NFA_ZOPEN3:</a>
<a name="ln6127">      case NFA_ZOPEN4:</a>
<a name="ln6128">      case NFA_ZOPEN5:</a>
<a name="ln6129">      case NFA_ZOPEN6:</a>
<a name="ln6130">      case NFA_ZOPEN7:</a>
<a name="ln6131">      case NFA_ZOPEN8:</a>
<a name="ln6132">      case NFA_ZOPEN9:</a>
<a name="ln6133">      case NFA_NOPEN:</a>
<a name="ln6134">      case NFA_ZSTART:</a>
<a name="ln6135">        // These states are only added to be able to bail out when</a>
<a name="ln6136">        // they are added again, nothing is to be done.</a>
<a name="ln6137">        break;</a>
<a name="ln6138"> </a>
<a name="ln6139">      default:          // regular character</a>
<a name="ln6140">      {</a>
<a name="ln6141">        int c = t-&gt;state-&gt;c;</a>
<a name="ln6142"> </a>
<a name="ln6143">#ifdef REGEXP_DEBUG</a>
<a name="ln6144">        if (c &lt; 0) {</a>
<a name="ln6145">          IEMSGN(&quot;INTERNAL: Negative state char: %&quot; PRId64, c);</a>
<a name="ln6146">        }</a>
<a name="ln6147">#endif</a>
<a name="ln6148">        result = (c == curc);</a>
<a name="ln6149"> </a>
<a name="ln6150">        if (!result &amp;&amp; rex.reg_ic) {</a>
<a name="ln6151">          result = utf_fold(c) == utf_fold(curc);</a>
<a name="ln6152">        }</a>
<a name="ln6153"> </a>
<a name="ln6154">        // If rex.reg_icombine is not set only skip over the character</a>
<a name="ln6155">        // itself.  When it is set skip over composing characters.</a>
<a name="ln6156">        if (result &amp;&amp; !rex.reg_icombine) {</a>
<a name="ln6157">          clen = utf_ptr2len(rex.input);</a>
<a name="ln6158">        }</a>
<a name="ln6159"> </a>
<a name="ln6160">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln6161">        break;</a>
<a name="ln6162">      }</a>
<a name="ln6163">      }       // switch (t-&gt;state-&gt;c)</a>
<a name="ln6164"> </a>
<a name="ln6165">      if (add_state != NULL) {</a>
<a name="ln6166">        nfa_pim_T *pim;</a>
<a name="ln6167">        nfa_pim_T pim_copy;</a>
<a name="ln6168"> </a>
<a name="ln6169">        if (t-&gt;pim.result == NFA_PIM_UNUSED)</a>
<a name="ln6170">          pim = NULL;</a>
<a name="ln6171">        else</a>
<a name="ln6172">          pim = &amp;t-&gt;pim;</a>
<a name="ln6173"> </a>
<a name="ln6174">        // Handle the postponed invisible match if the match might end</a>
<a name="ln6175">        // without advancing and before the end of the line.</a>
<a name="ln6176">        if (pim != NULL &amp;&amp; (clen == 0 || match_follows(add_state, 0))) {</a>
<a name="ln6177">          if (pim-&gt;result == NFA_PIM_TODO) {</a>
<a name="ln6178">#ifdef REGEXP_DEBUG</a>
<a name="ln6179">            fprintf(log_fd, &quot;\n&quot;);</a>
<a name="ln6180">            fprintf(log_fd, &quot;==================================\n&quot;);</a>
<a name="ln6181">            fprintf(log_fd, &quot;Postponed recursive nfa_regmatch()\n&quot;);</a>
<a name="ln6182">            fprintf(log_fd, &quot;\n&quot;);</a>
<a name="ln6183">#endif</a>
<a name="ln6184">            result = recursive_regmatch(pim-&gt;state, pim, prog, submatch, m,</a>
<a name="ln6185">                                        &amp;listids, &amp;listids_len);</a>
<a name="ln6186">            pim-&gt;result = result ? NFA_PIM_MATCH : NFA_PIM_NOMATCH;</a>
<a name="ln6187">            // for \@! and \@&lt;! it is a match when the result is</a>
<a name="ln6188">            // false</a>
<a name="ln6189">            if (result != (pim-&gt;state-&gt;c == NFA_START_INVISIBLE_NEG</a>
<a name="ln6190">                           || pim-&gt;state-&gt;c == NFA_START_INVISIBLE_NEG_FIRST</a>
<a name="ln6191">                           || pim-&gt;state-&gt;c</a>
<a name="ln6192">                           == NFA_START_INVISIBLE_BEFORE_NEG</a>
<a name="ln6193">                           || pim-&gt;state-&gt;c</a>
<a name="ln6194">                           == NFA_START_INVISIBLE_BEFORE_NEG_FIRST)) {</a>
<a name="ln6195">              // Copy submatch info from the recursive call</a>
<a name="ln6196">              copy_sub_off(&amp;pim-&gt;subs.norm, &amp;m-&gt;norm);</a>
<a name="ln6197">              if (rex.nfa_has_zsubexpr) {</a>
<a name="ln6198">                copy_sub_off(&amp;pim-&gt;subs.synt, &amp;m-&gt;synt);</a>
<a name="ln6199">              }</a>
<a name="ln6200">            }</a>
<a name="ln6201">          } else {</a>
<a name="ln6202">            result = (pim-&gt;result == NFA_PIM_MATCH);</a>
<a name="ln6203">#ifdef REGEXP_DEBUG</a>
<a name="ln6204">            fprintf(log_fd, &quot;\n&quot;);</a>
<a name="ln6205">            fprintf(</a>
<a name="ln6206">                log_fd,</a>
<a name="ln6207">                &quot;Using previous recursive nfa_regmatch() result, result == %d\n&quot;,</a>
<a name="ln6208">                pim-&gt;result);</a>
<a name="ln6209">            fprintf(log_fd, &quot;MATCH = %s\n&quot;, result ? &quot;OK&quot; : &quot;false&quot;);</a>
<a name="ln6210">            fprintf(log_fd, &quot;\n&quot;);</a>
<a name="ln6211">#endif</a>
<a name="ln6212">          }</a>
<a name="ln6213"> </a>
<a name="ln6214">          // for \@! and \@&lt;! it is a match when result is false</a>
<a name="ln6215">          if (result != (pim-&gt;state-&gt;c == NFA_START_INVISIBLE_NEG</a>
<a name="ln6216">                         || pim-&gt;state-&gt;c == NFA_START_INVISIBLE_NEG_FIRST</a>
<a name="ln6217">                         || pim-&gt;state-&gt;c</a>
<a name="ln6218">                         == NFA_START_INVISIBLE_BEFORE_NEG</a>
<a name="ln6219">                         || pim-&gt;state-&gt;c</a>
<a name="ln6220">                         == NFA_START_INVISIBLE_BEFORE_NEG_FIRST)) {</a>
<a name="ln6221">            // Copy submatch info from the recursive call</a>
<a name="ln6222">            copy_sub_off(&amp;t-&gt;subs.norm, &amp;pim-&gt;subs.norm);</a>
<a name="ln6223">            if (rex.nfa_has_zsubexpr) {</a>
<a name="ln6224">              copy_sub_off(&amp;t-&gt;subs.synt, &amp;pim-&gt;subs.synt);</a>
<a name="ln6225">            }</a>
<a name="ln6226">          } else {</a>
<a name="ln6227">            // look-behind match failed, don't add the state</a>
<a name="ln6228">            continue;</a>
<a name="ln6229">          }</a>
<a name="ln6230"> </a>
<a name="ln6231">          // Postponed invisible match was handled, don't add it to</a>
<a name="ln6232">          // following states.</a>
<a name="ln6233">          pim = NULL;</a>
<a name="ln6234">        }</a>
<a name="ln6235"> </a>
<a name="ln6236">        // If &quot;pim&quot; points into l-&gt;t it will become invalid when</a>
<a name="ln6237">        // adding the state causes the list to be reallocated.  Make a</a>
<a name="ln6238">        // local copy to avoid that.</a>
<a name="ln6239">        if (pim == &amp;t-&gt;pim) {</a>
<a name="ln6240">          copy_pim(&amp;pim_copy, pim);</a>
<a name="ln6241">          pim = &amp;pim_copy;</a>
<a name="ln6242">        }</a>
<a name="ln6243"> </a>
<a name="ln6244">        if (add_here) {</a>
<a name="ln6245">          r = addstate_here(thislist, add_state, &amp;t-&gt;subs, pim, &amp;listidx);</a>
<a name="ln6246">        } else {</a>
<a name="ln6247">          r = addstate(nextlist, add_state, &amp;t-&gt;subs, pim, add_off);</a>
<a name="ln6248">          if (add_count &gt; 0) {</a>
<a name="ln6249">            nextlist-&gt;t[nextlist-&gt;n - 1].count = add_count;</a>
<a name="ln6250">          }</a>
<a name="ln6251">        }</a>
<a name="ln6252">        if (r == NULL) {</a>
<a name="ln6253">          nfa_match = NFA_TOO_EXPENSIVE;</a>
<a name="ln6254">          goto theend;</a>
<a name="ln6255">        }</a>
<a name="ln6256">      }</a>
<a name="ln6257">    }     // for (thislist = thislist; thislist-&gt;state; thislist++)</a>
<a name="ln6258"> </a>
<a name="ln6259">    // Look for the start of a match in the current position by adding the</a>
<a name="ln6260">    // start state to the list of states.</a>
<a name="ln6261">    // The first found match is the leftmost one, thus the order of states</a>
<a name="ln6262">    // matters!</a>
<a name="ln6263">    // Do not add the start state in recursive calls of nfa_regmatch(),</a>
<a name="ln6264">    // because recursive calls should only start in the first position.</a>
<a name="ln6265">    // Unless &quot;nfa_endp&quot; is not NULL, then we match the end position.</a>
<a name="ln6266">    // Also don't start a match past the first line.</a>
<a name="ln6267">    if (!nfa_match</a>
<a name="ln6268">        &amp;&amp; ((toplevel</a>
<a name="ln6269">             &amp;&amp; rex.lnum == 0</a>
<a name="ln6270">             &amp;&amp; clen != 0</a>
<a name="ln6271">             &amp;&amp; (rex.reg_maxcol == 0</a>
<a name="ln6272">                 || (colnr_T)(rex.input - rex.line) &lt; rex.reg_maxcol))</a>
<a name="ln6273">            || (nfa_endp != NULL</a>
<a name="ln6274">                &amp;&amp; (REG_MULTI</a>
<a name="ln6275">                    ? (rex.lnum &lt; nfa_endp-&gt;se_u.pos.lnum</a>
<a name="ln6276">                       || (rex.lnum == nfa_endp-&gt;se_u.pos.lnum</a>
<a name="ln6277">                           &amp;&amp; (int)(rex.input - rex.line)</a>
<a name="ln6278">                           &lt; nfa_endp-&gt;se_u.pos.col))</a>
<a name="ln6279">                    : rex.input &lt; nfa_endp-&gt;se_u.ptr)))) {</a>
<a name="ln6280">#ifdef REGEXP_DEBUG</a>
<a name="ln6281">      fprintf(log_fd, &quot;(---) STARTSTATE\n&quot;);</a>
<a name="ln6282">#endif</a>
<a name="ln6283">      // Inline optimized code for addstate() if we know the state is</a>
<a name="ln6284">      // the first MOPEN.</a>
<a name="ln6285">      if (toplevel) {</a>
<a name="ln6286">        int add = true;</a>
<a name="ln6287"> </a>
<a name="ln6288">        if (prog-&gt;regstart != NUL &amp;&amp; clen != 0) {</a>
<a name="ln6289">          if (nextlist-&gt;n == 0) {</a>
<a name="ln6290">            colnr_T col = (colnr_T)(rex.input - rex.line) + clen;</a>
<a name="ln6291"> </a>
<a name="ln6292">            // Nextlist is empty, we can skip ahead to the</a>
<a name="ln6293">            // character that must appear at the start.</a>
<a name="ln6294">            if (skip_to_start(prog-&gt;regstart, &amp;col) == FAIL) {</a>
<a name="ln6295">              break;</a>
<a name="ln6296">            }</a>
<a name="ln6297">#ifdef REGEXP_DEBUG</a>
<a name="ln6298">            fprintf(log_fd, &quot;  Skipping ahead %d bytes to regstart\n&quot;,</a>
<a name="ln6299">                    col - ((colnr_T)(rex.input - rex.line) + clen));</a>
<a name="ln6300">#endif</a>
<a name="ln6301">            rex.input = rex.line + col - clen;</a>
<a name="ln6302">          } else {</a>
<a name="ln6303">            // Checking if the required start character matches is</a>
<a name="ln6304">            // cheaper than adding a state that won't match.</a>
<a name="ln6305">            const int c = PTR2CHAR(rex.input + clen);</a>
<a name="ln6306">            if (c != prog-&gt;regstart</a>
<a name="ln6307">                &amp;&amp; (!rex.reg_ic</a>
<a name="ln6308">                    || utf_fold(c) != utf_fold(prog-&gt;regstart))) {</a>
<a name="ln6309">#ifdef REGEXP_DEBUG</a>
<a name="ln6310">              fprintf(log_fd,</a>
<a name="ln6311">                  &quot;  Skipping start state, regstart does not match\n&quot;);</a>
<a name="ln6312">#endif</a>
<a name="ln6313">              add = false;</a>
<a name="ln6314">            }</a>
<a name="ln6315">          }</a>
<a name="ln6316">        }</a>
<a name="ln6317"> </a>
<a name="ln6318">        if (add) {</a>
<a name="ln6319">          if (REG_MULTI) {</a>
<a name="ln6320">            m-&gt;norm.list.multi[0].start_col =</a>
<a name="ln6321">              (colnr_T)(rex.input - rex.line) + clen;</a>
<a name="ln6322">          } else {</a>
<a name="ln6323">            m-&gt;norm.list.line[0].start = rex.input + clen;</a>
<a name="ln6324">          }</a>
<a name="ln6325">          if (addstate(nextlist, start-&gt;out, m, NULL, clen) == NULL) {</a>
<a name="ln6326">            nfa_match = NFA_TOO_EXPENSIVE;</a>
<a name="ln6327">            goto theend;</a>
<a name="ln6328">          }</a>
<a name="ln6329">        }</a>
<a name="ln6330">      } else {</a>
<a name="ln6331">        if (addstate(nextlist, start, m, NULL, clen) == NULL) {</a>
<a name="ln6332">          nfa_match = NFA_TOO_EXPENSIVE;</a>
<a name="ln6333">          goto theend;</a>
<a name="ln6334">        }</a>
<a name="ln6335">      }</a>
<a name="ln6336">    }</a>
<a name="ln6337"> </a>
<a name="ln6338">#ifdef REGEXP_DEBUG</a>
<a name="ln6339">    fprintf(log_fd, &quot;&gt;&gt;&gt; Thislist had %d states available: &quot;, thislist-&gt;n);</a>
<a name="ln6340">    {</a>
<a name="ln6341">      int i;</a>
<a name="ln6342"> </a>
<a name="ln6343">      for (i = 0; i &lt; thislist-&gt;n; i++)</a>
<a name="ln6344">        fprintf(log_fd, &quot;%d  &quot;, abs(thislist-&gt;t[i].state-&gt;id));</a>
<a name="ln6345">    }</a>
<a name="ln6346">    fprintf(log_fd, &quot;\n&quot;);</a>
<a name="ln6347">#endif</a>
<a name="ln6348"> </a>
<a name="ln6349">nextchar:</a>
<a name="ln6350">    // Advance to the next character, or advance to the next line, or</a>
<a name="ln6351">    // finish.</a>
<a name="ln6352">    if (clen != 0) {</a>
<a name="ln6353">      rex.input += clen;</a>
<a name="ln6354">    } else if (go_to_nextline || (nfa_endp != NULL &amp;&amp; REG_MULTI</a>
<a name="ln6355">                                  &amp;&amp; rex.lnum &lt; nfa_endp-&gt;se_u.pos.lnum)) {</a>
<a name="ln6356">      reg_nextline();</a>
<a name="ln6357">    } else {</a>
<a name="ln6358">      break;</a>
<a name="ln6359">    }</a>
<a name="ln6360"> </a>
<a name="ln6361">    // Allow interrupting with CTRL-C.</a>
<a name="ln6362">    line_breakcheck();</a>
<a name="ln6363">    if (got_int) {</a>
<a name="ln6364">      break;</a>
<a name="ln6365">    }</a>
<a name="ln6366">    // Check for timeout once every twenty times to avoid overhead.</a>
<a name="ln6367">    if (nfa_time_limit != NULL &amp;&amp; ++nfa_time_count == 20) {</a>
<a name="ln6368">      nfa_time_count = 0;</a>
<a name="ln6369">      if (nfa_did_time_out()) {</a>
<a name="ln6370">        break;</a>
<a name="ln6371">      }</a>
<a name="ln6372">    }</a>
<a name="ln6373">  }</a>
<a name="ln6374"> </a>
<a name="ln6375">#ifdef REGEXP_DEBUG</a>
<a name="ln6376">  if (log_fd != stderr)</a>
<a name="ln6377">    fclose(log_fd);</a>
<a name="ln6378">  log_fd = NULL;</a>
<a name="ln6379">#endif</a>
<a name="ln6380"> </a>
<a name="ln6381">theend:</a>
<a name="ln6382">  // Free memory</a>
<a name="ln6383">  xfree(list[0].t);</a>
<a name="ln6384">  xfree(list[1].t);</a>
<a name="ln6385">  xfree(listids);</a>
<a name="ln6386">#undef ADD_STATE_IF_MATCH</a>
<a name="ln6387">#ifdef NFA_REGEXP_DEBUG_LOG</a>
<a name="ln6388">  fclose(debug);</a>
<a name="ln6389">#endif</a>
<a name="ln6390"> </a>
<a name="ln6391">  return nfa_match;</a>
<a name="ln6392">}</a>
<a name="ln6393"> </a>
<a name="ln6394">// Try match of &quot;prog&quot; with at rex.line[&quot;col&quot;].</a>
<a name="ln6395">// Returns &lt;= 0 for failure, number of lines contained in the match otherwise.</a>
<a name="ln6396">static long nfa_regtry(nfa_regprog_T *prog,</a>
<a name="ln6397">                       colnr_T col,</a>
<a name="ln6398">                       proftime_T *tm,    // timeout limit or NULL</a>
<a name="ln6399">                       int *timed_out)    // flag set on timeout or NULL</a>
<a name="ln6400">{</a>
<a name="ln6401">  int i;</a>
<a name="ln6402">  regsubs_T subs, m;</a>
<a name="ln6403">  nfa_state_T *start = prog-&gt;start;</a>
<a name="ln6404">#ifdef REGEXP_DEBUG</a>
<a name="ln6405">  FILE        *f;</a>
<a name="ln6406">#endif</a>
<a name="ln6407"> </a>
<a name="ln6408">  rex.input = rex.line + col;</a>
<a name="ln6409">  nfa_time_limit = tm;</a>
<a name="ln6410">  nfa_timed_out = timed_out;</a>
<a name="ln6411">  nfa_time_count = 0;</a>
<a name="ln6412"> </a>
<a name="ln6413">#ifdef REGEXP_DEBUG</a>
<a name="ln6414">  f = fopen(NFA_REGEXP_RUN_LOG, &quot;a&quot;);</a>
<a name="ln6415">  if (f != NULL) {</a>
<a name="ln6416">    fprintf(f,</a>
<a name="ln6417">        &quot;\n\n\t=======================================================\n&quot;);</a>
<a name="ln6418">#ifdef REGEXP_DEBUG</a>
<a name="ln6419">    fprintf(f, &quot;\tRegexp is \&quot;%s\&quot;\n&quot;, nfa_regengine.expr);</a>
<a name="ln6420">#endif</a>
<a name="ln6421">    fprintf(f, &quot;\tInput text is \&quot;%s\&quot; \n&quot;, rex.input);</a>
<a name="ln6422">    fprintf(f, &quot;\t=======================================================\n\n&quot;);</a>
<a name="ln6423">    nfa_print_state(f, start);</a>
<a name="ln6424">    fprintf(f, &quot;\n\n&quot;);</a>
<a name="ln6425">    fclose(f);</a>
<a name="ln6426">  } else {</a>
<a name="ln6427">    EMSG(&quot;Could not open temporary log file for writing&quot;);</a>
<a name="ln6428">  }</a>
<a name="ln6429">#endif</a>
<a name="ln6430"> </a>
<a name="ln6431">  clear_sub(&amp;subs.norm);</a>
<a name="ln6432">  clear_sub(&amp;m.norm);</a>
<a name="ln6433">  clear_sub(&amp;subs.synt);</a>
<a name="ln6434">  clear_sub(&amp;m.synt);</a>
<a name="ln6435"> </a>
<a name="ln6436">  int result = nfa_regmatch(prog, start, &amp;subs, &amp;m);</a>
<a name="ln6437">  if (!result) {</a>
<a name="ln6438">    return 0;</a>
<a name="ln6439">  } else if (result == NFA_TOO_EXPENSIVE) {</a>
<a name="ln6440">    return result;</a>
<a name="ln6441">  }</a>
<a name="ln6442"> </a>
<a name="ln6443">  cleanup_subexpr();</a>
<a name="ln6444">  if (REG_MULTI) {</a>
<a name="ln6445">    for (i = 0; i &lt; subs.norm.in_use; i++) {</a>
<a name="ln6446">      rex.reg_startpos[i].lnum = subs.norm.list.multi[i].start_lnum;</a>
<a name="ln6447">      rex.reg_startpos[i].col = subs.norm.list.multi[i].start_col;</a>
<a name="ln6448"> </a>
<a name="ln6449">      rex.reg_endpos[i].lnum = subs.norm.list.multi[i].end_lnum;</a>
<a name="ln6450">      rex.reg_endpos[i].col = subs.norm.list.multi[i].end_col;</a>
<a name="ln6451">    }</a>
<a name="ln6452"> </a>
<a name="ln6453">    if (rex.reg_startpos[0].lnum &lt; 0) {</a>
<a name="ln6454">      rex.reg_startpos[0].lnum = 0;</a>
<a name="ln6455">      rex.reg_startpos[0].col = col;</a>
<a name="ln6456">    }</a>
<a name="ln6457">    if (rex.reg_endpos[0].lnum &lt; 0) {</a>
<a name="ln6458">      // pattern has a \ze but it didn't match, use current end</a>
<a name="ln6459">      rex.reg_endpos[0].lnum = rex.lnum;</a>
<a name="ln6460">      rex.reg_endpos[0].col = (int)(rex.input - rex.line);</a>
<a name="ln6461">    } else {</a>
<a name="ln6462">      // Use line number of &quot;\ze&quot;.</a>
<a name="ln6463">      rex.lnum = rex.reg_endpos[0].lnum;</a>
<a name="ln6464">    }</a>
<a name="ln6465">  } else {</a>
<a name="ln6466">    for (i = 0; i &lt; subs.norm.in_use; i++) {</a>
<a name="ln6467">      rex.reg_startp[i] = subs.norm.list.line[i].start;</a>
<a name="ln6468">      rex.reg_endp[i] = subs.norm.list.line[i].end;</a>
<a name="ln6469">    }</a>
<a name="ln6470"> </a>
<a name="ln6471">    if (rex.reg_startp[0] == NULL) {</a>
<a name="ln6472">      rex.reg_startp[0] = rex.line + col;</a>
<a name="ln6473">    }</a>
<a name="ln6474">    if (rex.reg_endp[0] == NULL) {</a>
<a name="ln6475">      rex.reg_endp[0] = rex.input;</a>
<a name="ln6476">    }</a>
<a name="ln6477">  }</a>
<a name="ln6478"> </a>
<a name="ln6479">  /* Package any found \z(...\) matches for export. Default is none. */</a>
<a name="ln6480">  unref_extmatch(re_extmatch_out);</a>
<a name="ln6481">  re_extmatch_out = NULL;</a>
<a name="ln6482"> </a>
<a name="ln6483">  if (prog-&gt;reghasz == REX_SET) {</a>
<a name="ln6484">    cleanup_zsubexpr();</a>
<a name="ln6485">    re_extmatch_out = make_extmatch();</a>
<a name="ln6486">    // Loop over \z1, \z2, etc.  There is no \z0.</a>
<a name="ln6487">    for (i = 1; i &lt; subs.synt.in_use; i++) {</a>
<a name="ln6488">      if (REG_MULTI) {</a>
<a name="ln6489">        struct multipos *mpos = &amp;subs.synt.list.multi[i];</a>
<a name="ln6490"> </a>
<a name="ln6491">        // Only accept single line matches that are valid.</a>
<a name="ln6492">        if (mpos-&gt;start_lnum &gt;= 0</a>
<a name="ln6493">            &amp;&amp; mpos-&gt;start_lnum == mpos-&gt;end_lnum</a>
<a name="ln6494">            &amp;&amp; mpos-&gt;end_col &gt;= mpos-&gt;start_col) {</a>
<a name="ln6495">          re_extmatch_out-&gt;matches[i] =</a>
<a name="ln6496">            vim_strnsave(reg_getline(mpos-&gt;start_lnum) + mpos-&gt;start_col,</a>
<a name="ln6497">                         mpos-&gt;end_col - mpos-&gt;start_col);</a>
<a name="ln6498">        }</a>
<a name="ln6499">      } else {</a>
<a name="ln6500">        struct linepos *lpos = &amp;subs.synt.list.line[i];</a>
<a name="ln6501"> </a>
<a name="ln6502">        if (lpos-&gt;start != NULL &amp;&amp; lpos-&gt;end != NULL)</a>
<a name="ln6503">          re_extmatch_out-&gt;matches[i] =</a>
<a name="ln6504">            vim_strnsave(lpos-&gt;start, lpos-&gt;end - lpos-&gt;start);</a>
<a name="ln6505">      }</a>
<a name="ln6506">    }</a>
<a name="ln6507">  }</a>
<a name="ln6508"> </a>
<a name="ln6509">  return 1 + rex.lnum;</a>
<a name="ln6510">}</a>
<a name="ln6511"> </a>
<a name="ln6512">/// Match a regexp against a string (&quot;line&quot; points to the string) or multiple</a>
<a name="ln6513">/// lines (if &quot;line&quot; is NULL, use reg_getline()).</a>
<a name="ln6514">///</a>
<a name="ln6515">/// @param line String in which to search or NULL</a>
<a name="ln6516">/// @param startcol Column to start looking for match</a>
<a name="ln6517">/// @param tm Timeout limit or NULL</a>
<a name="ln6518">/// @param timed_out Flag set on timeout or NULL</a>
<a name="ln6519">///</a>
<a name="ln6520">/// @return &lt;= 0 if there is no match and number of lines contained in the</a>
<a name="ln6521">/// match otherwise.</a>
<a name="ln6522">static long nfa_regexec_both(char_u *line, colnr_T startcol,</a>
<a name="ln6523">                             proftime_T *tm, int *timed_out)</a>
<a name="ln6524">{</a>
<a name="ln6525">  nfa_regprog_T   *prog;</a>
<a name="ln6526">  long retval = 0L;</a>
<a name="ln6527">  colnr_T col = startcol;</a>
<a name="ln6528"> </a>
<a name="ln6529">  if (REG_MULTI) {</a>
<a name="ln6530">    prog = (nfa_regprog_T *)rex.reg_mmatch-&gt;regprog;</a>
<a name="ln6531">    line = reg_getline((linenr_T)0);  // relative to the cursor</a>
<a name="ln6532">    rex.reg_startpos = rex.reg_mmatch-&gt;startpos;</a>
<a name="ln6533">    rex.reg_endpos = rex.reg_mmatch-&gt;endpos;</a>
<a name="ln6534">  } else {</a>
<a name="ln6535">    prog = (nfa_regprog_T *)rex.reg_match-&gt;regprog;</a>
<a name="ln6536">    rex.reg_startp = rex.reg_match-&gt;startp;</a>
<a name="ln6537">    rex.reg_endp = rex.reg_match-&gt;endp;</a>
<a name="ln6538">  }</a>
<a name="ln6539"> </a>
<a name="ln6540">  /* Be paranoid... */</a>
<a name="ln6541">  if (prog == NULL || line == NULL) {</a>
<a name="ln6542">    IEMSG(_(e_null));</a>
<a name="ln6543">    goto theend;</a>
<a name="ln6544">  }</a>
<a name="ln6545"> </a>
<a name="ln6546">  // If pattern contains &quot;\c&quot; or &quot;\C&quot;: overrule value of rex.reg_ic</a>
<a name="ln6547">  if (prog-&gt;regflags &amp; RF_ICASE) {</a>
<a name="ln6548">    rex.reg_ic = true;</a>
<a name="ln6549">  } else if (prog-&gt;regflags &amp; RF_NOICASE) {</a>
<a name="ln6550">    rex.reg_ic = false;</a>
<a name="ln6551">  }</a>
<a name="ln6552"> </a>
<a name="ln6553">  // If pattern contains &quot;\Z&quot; overrule value of rex.reg_icombine</a>
<a name="ln6554">  if (prog-&gt;regflags &amp; RF_ICOMBINE) {</a>
<a name="ln6555">    rex.reg_icombine = true;</a>
<a name="ln6556">  }</a>
<a name="ln6557"> </a>
<a name="ln6558">  rex.line = line;</a>
<a name="ln6559">  rex.lnum = 0;  // relative to line</a>
<a name="ln6560"> </a>
<a name="ln6561">  rex.nfa_has_zend = prog-&gt;has_zend;</a>
<a name="ln6562">  rex.nfa_has_backref = prog-&gt;has_backref;</a>
<a name="ln6563">  rex.nfa_nsubexpr = prog-&gt;nsubexp;</a>
<a name="ln6564">  rex.nfa_listid = 1;</a>
<a name="ln6565">  rex.nfa_alt_listid = 2;</a>
<a name="ln6566">#ifdef REGEXP_DEBUG</a>
<a name="ln6567">  nfa_regengine.expr = prog-&gt;pattern;</a>
<a name="ln6568">#endif</a>
<a name="ln6569"> </a>
<a name="ln6570">  if (prog-&gt;reganch &amp;&amp; col &gt; 0)</a>
<a name="ln6571">    return 0L;</a>
<a name="ln6572"> </a>
<a name="ln6573">  rex.need_clear_subexpr = true;</a>
<a name="ln6574">  // Clear the external match subpointers if necessary.</a>
<a name="ln6575">  if (prog-&gt;reghasz == REX_SET) {</a>
<a name="ln6576">    rex.nfa_has_zsubexpr = true;</a>
<a name="ln6577">    rex.need_clear_zsubexpr = true;</a>
<a name="ln6578">  } else {</a>
<a name="ln6579">    rex.nfa_has_zsubexpr = false;</a>
<a name="ln6580">    rex.need_clear_zsubexpr = false;</a>
<a name="ln6581">  }</a>
<a name="ln6582"> </a>
<a name="ln6583">  if (prog-&gt;regstart != NUL) {</a>
<a name="ln6584">    /* Skip ahead until a character we know the match must start with.</a>
<a name="ln6585">     * When there is none there is no match. */</a>
<a name="ln6586">    if (skip_to_start(prog-&gt;regstart, &amp;col) == FAIL)</a>
<a name="ln6587">      return 0L;</a>
<a name="ln6588"> </a>
<a name="ln6589">    // If match_text is set it contains the full text that must match.</a>
<a name="ln6590">    // Nothing else to try. Doesn't handle combining chars well.</a>
<a name="ln6591">    if (prog-&gt;match_text != NULL &amp;&amp; !rex.reg_icombine) {</a>
<a name="ln6592">      return find_match_text(col, prog-&gt;regstart, prog-&gt;match_text);</a>
<a name="ln6593">    }</a>
<a name="ln6594">  }</a>
<a name="ln6595"> </a>
<a name="ln6596">  // If the start column is past the maximum column: no need to try.</a>
<a name="ln6597">  if (rex.reg_maxcol &gt; 0 &amp;&amp; col &gt;= rex.reg_maxcol) {</a>
<a name="ln6598">    goto theend;</a>
<a name="ln6599">  }</a>
<a name="ln6600"> </a>
<a name="ln6601">  // Set the &quot;nstate&quot; used by nfa_regcomp() to zero to trigger an error when</a>
<a name="ln6602">  // it's accidentally used during execution.</a>
<a name="ln6603">  nstate = 0;</a>
<a name="ln6604">  for (int i = 0; i &lt; prog-&gt;nstate; i++) {</a>
<a name="ln6605">    prog-&gt;state[i].id = i;</a>
<a name="ln6606">    prog-&gt;state[i].lastlist[0] = 0;</a>
<a name="ln6607">    prog-&gt;state[i].lastlist[1] = 0;</a>
<a name="ln6608">  }</a>
<a name="ln6609"> </a>
<a name="ln6610">  retval = nfa_regtry(prog, col, tm, timed_out);</a>
<a name="ln6611"> </a>
<a name="ln6612">#ifdef REGEXP_DEBUG</a>
<a name="ln6613">  nfa_regengine.expr = NULL;</a>
<a name="ln6614">#endif</a>
<a name="ln6615"> </a>
<a name="ln6616">theend:</a>
<a name="ln6617">  if (retval &gt; 0) {</a>
<a name="ln6618">    // Make sure the end is never before the start.  Can happen when \zs and</a>
<a name="ln6619">    // \ze are used.</a>
<a name="ln6620">    if (REG_MULTI) {</a>
<a name="ln6621">      const lpos_T *const start = &amp;rex.reg_mmatch-&gt;startpos[0];</a>
<a name="ln6622">      const lpos_T *const end = &amp;rex.reg_mmatch-&gt;endpos[0];</a>
<a name="ln6623"> </a>
<a name="ln6624">      if (end-&gt;lnum &lt; start-&gt;lnum</a>
<a name="ln6625">          || (end-&gt;lnum == start-&gt;lnum &amp;&amp; end-&gt;col &lt; start-&gt;col)) {</a>
<a name="ln6626">        rex.reg_mmatch-&gt;endpos[0] = rex.reg_mmatch-&gt;startpos[0];</a>
<a name="ln6627">      }</a>
<a name="ln6628">    } else {</a>
<a name="ln6629">      if (rex.reg_match-&gt;endp[0] &lt; rex.reg_match-&gt;startp[0]) {</a>
<a name="ln6630">        rex.reg_match-&gt;endp[0] = rex.reg_match-&gt;startp[0];</a>
<a name="ln6631">      }</a>
<a name="ln6632">    }</a>
<a name="ln6633">  }</a>
<a name="ln6634"> </a>
<a name="ln6635">  return retval;</a>
<a name="ln6636">}</a>
<a name="ln6637"> </a>
<a name="ln6638">/*</a>
<a name="ln6639"> * Compile a regular expression into internal code for the NFA matcher.</a>
<a name="ln6640"> * Returns the program in allocated space.  Returns NULL for an error.</a>
<a name="ln6641"> */</a>
<a name="ln6642">static regprog_T *nfa_regcomp(char_u *expr, int re_flags)</a>
<a name="ln6643">{</a>
<a name="ln6644">  nfa_regprog_T       *prog = NULL;</a>
<a name="ln6645">  int                 *postfix;</a>
<a name="ln6646"> </a>
<a name="ln6647">  if (expr == NULL)</a>
<a name="ln6648">    return NULL;</a>
<a name="ln6649"> </a>
<a name="ln6650">#ifdef REGEXP_DEBUG</a>
<a name="ln6651">  nfa_regengine.expr = expr;</a>
<a name="ln6652">#endif</a>
<a name="ln6653">  nfa_re_flags = re_flags;</a>
<a name="ln6654"> </a>
<a name="ln6655">  init_class_tab();</a>
<a name="ln6656"> </a>
<a name="ln6657">  nfa_regcomp_start(expr, re_flags);</a>
<a name="ln6658"> </a>
<a name="ln6659">  // Build postfix form of the regexp. Needed to build the NFA</a>
<a name="ln6660">  // (and count its size).</a>
<a name="ln6661">  postfix = re2post();</a>
<a name="ln6662">  if (postfix == NULL) {</a>
<a name="ln6663">    goto fail;              // Cascaded (syntax?) error</a>
<a name="ln6664">  }</a>
<a name="ln6665"> </a>
<a name="ln6666">  /*</a>
<a name="ln6667">   * In order to build the NFA, we parse the input regexp twice:</a>
<a name="ln6668">   * 1. first pass to count size (so we can allocate space)</a>
<a name="ln6669">   * 2. second to emit code</a>
<a name="ln6670">   */</a>
<a name="ln6671">#ifdef REGEXP_DEBUG</a>
<a name="ln6672">  {</a>
<a name="ln6673">    FILE *f = fopen(NFA_REGEXP_RUN_LOG, &quot;a&quot;);</a>
<a name="ln6674"> </a>
<a name="ln6675">    if (f != NULL) {</a>
<a name="ln6676">      fprintf(f,</a>
<a name="ln6677">              &quot;\n*****************************\n\n\n\n\t&quot;</a>
<a name="ln6678">              &quot;Compiling regexp \&quot;%s\&quot;... hold on !\n&quot;,</a>
<a name="ln6679">              expr);</a>
<a name="ln6680">      fclose(f);</a>
<a name="ln6681">    }</a>
<a name="ln6682">  }</a>
<a name="ln6683">#endif</a>
<a name="ln6684"> </a>
<a name="ln6685">  /*</a>
<a name="ln6686">   * PASS 1</a>
<a name="ln6687">   * Count number of NFA states in &quot;nstate&quot;. Do not build the NFA.</a>
<a name="ln6688">   */</a>
<a name="ln6689">  post2nfa(postfix, post_ptr, true);</a>
<a name="ln6690"> </a>
<a name="ln6691">  /* allocate the regprog with space for the compiled regexp */</a>
<a name="ln6692">  size_t prog_size = sizeof(nfa_regprog_T) + sizeof(nfa_state_T) * (nstate - 1);</a>
<a name="ln6693">  prog = xmalloc(prog_size);</a>
<a name="ln6694">  state_ptr = prog-&gt;state;</a>
<a name="ln6695">  prog-&gt;re_in_use = false;</a>
<a name="ln6696"> </a>
<a name="ln6697">  /*</a>
<a name="ln6698">   * PASS 2</a>
<a name="ln6699">   * Build the NFA</a>
<a name="ln6700">   */</a>
<a name="ln6701">  prog-&gt;start = post2nfa(postfix, post_ptr, false);</a>
<a name="ln6702">  if (prog-&gt;start == NULL) {</a>
<a name="ln6703">    goto fail;</a>
<a name="ln6704">  }</a>
<a name="ln6705">  prog-&gt;regflags = regflags;</a>
<a name="ln6706">  prog-&gt;engine = &amp;nfa_regengine;</a>
<a name="ln6707">  prog-&gt;nstate = nstate;</a>
<a name="ln6708">  prog-&gt;has_zend = rex.nfa_has_zend;</a>
<a name="ln6709">  prog-&gt;has_backref = rex.nfa_has_backref;</a>
<a name="ln6710">  prog-&gt;nsubexp = regnpar;</a>
<a name="ln6711"> </a>
<a name="ln6712">  nfa_postprocess(prog);</a>
<a name="ln6713"> </a>
<a name="ln6714">  prog-&gt;reganch = nfa_get_reganch(prog-&gt;start, 0);</a>
<a name="ln6715">  prog-&gt;regstart = nfa_get_regstart(prog-&gt;start, 0);</a>
<a name="ln6716">  prog-&gt;match_text = nfa_get_match_text(prog-&gt;start);</a>
<a name="ln6717"> </a>
<a name="ln6718">#ifdef REGEXP_DEBUG</a>
<a name="ln6719">  nfa_postfix_dump(expr, OK);</a>
<a name="ln6720">  nfa_dump(prog);</a>
<a name="ln6721">#endif</a>
<a name="ln6722">  /* Remember whether this pattern has any \z specials in it. */</a>
<a name="ln6723">  prog-&gt;reghasz = re_has_z;</a>
<a name="ln6724">  prog-&gt;pattern = vim_strsave(expr);</a>
<a name="ln6725">#ifdef REGEXP_DEBUG</a>
<a name="ln6726">  nfa_regengine.expr = NULL;</a>
<a name="ln6727">#endif</a>
<a name="ln6728"> </a>
<a name="ln6729">out:</a>
<a name="ln6730">  xfree(post_start);</a>
<a name="ln6731">  post_start = post_ptr = post_end = NULL;</a>
<a name="ln6732">  state_ptr = NULL;</a>
<a name="ln6733">  return (regprog_T *)prog;</a>
<a name="ln6734"> </a>
<a name="ln6735">fail:</a>
<a name="ln6736">  XFREE_CLEAR(prog);</a>
<a name="ln6737">#ifdef REGEXP_DEBUG</a>
<a name="ln6738">  nfa_postfix_dump(expr, FAIL);</a>
<a name="ln6739">  nfa_regengine.expr = NULL;</a>
<a name="ln6740">#endif</a>
<a name="ln6741">  goto out;</a>
<a name="ln6742">}</a>
<a name="ln6743"> </a>
<a name="ln6744">/*</a>
<a name="ln6745"> * Free a compiled regexp program, returned by nfa_regcomp().</a>
<a name="ln6746"> */</a>
<a name="ln6747">static void nfa_regfree(regprog_T *prog)</a>
<a name="ln6748">{</a>
<a name="ln6749">  if (prog != NULL) {</a>
<a name="ln6750">    xfree(((nfa_regprog_T *)prog)-&gt;match_text);</a>
<a name="ln6751">    xfree(((nfa_regprog_T *)prog)-&gt;pattern);</a>
<a name="ln6752">    xfree(prog);</a>
<a name="ln6753">  }</a>
<a name="ln6754">}</a>
<a name="ln6755"> </a>
<a name="ln6756">/*</a>
<a name="ln6757"> * Match a regexp against a string.</a>
<a name="ln6758"> * &quot;rmp-&gt;regprog&quot; is a compiled regexp as returned by nfa_regcomp().</a>
<a name="ln6759"> * Uses curbuf for line count and 'iskeyword'.</a>
<a name="ln6760"> * If &quot;line_lbr&quot; is true, consider a &quot;\n&quot; in &quot;line&quot; to be a line break.</a>
<a name="ln6761"> *</a>
<a name="ln6762"> * Returns &lt;= 0 for failure, number of lines contained in the match otherwise.</a>
<a name="ln6763"> */</a>
<a name="ln6764">static int </a>
<a name="ln6765">nfa_regexec_nl (</a>
<a name="ln6766">    regmatch_T *rmp,</a>
<a name="ln6767">    char_u *line,      /* string to match against */</a>
<a name="ln6768">    colnr_T col,       /* column to start looking for match */</a>
<a name="ln6769">    bool line_lbr</a>
<a name="ln6770">)</a>
<a name="ln6771">{</a>
<a name="ln6772">  rex.reg_match = rmp;</a>
<a name="ln6773">  rex.reg_mmatch = NULL;</a>
<a name="ln6774">  rex.reg_maxline = 0;</a>
<a name="ln6775">  rex.reg_line_lbr = line_lbr;</a>
<a name="ln6776">  rex.reg_buf = curbuf;</a>
<a name="ln6777">  rex.reg_win = NULL;</a>
<a name="ln6778">  rex.reg_ic = rmp-&gt;rm_ic;</a>
<a name="ln6779">  rex.reg_icombine = false;</a>
<a name="ln6780">  rex.reg_maxcol = 0;</a>
<a name="ln6781">  return nfa_regexec_both(line, col, NULL, NULL);</a>
<a name="ln6782">}</a>
<a name="ln6783"> </a>
<a name="ln6784">/// Matches a regexp against multiple lines.</a>
<a name="ln6785">/// &quot;rmp-&gt;regprog&quot; is a compiled regexp as returned by vim_regcomp().</a>
<a name="ln6786">/// Uses curbuf for line count and 'iskeyword'.</a>
<a name="ln6787">///</a>
<a name="ln6788">/// @param win Window in which to search or NULL</a>
<a name="ln6789">/// @param buf Buffer in which to search</a>
<a name="ln6790">/// @param lnum Number of line to start looking for match</a>
<a name="ln6791">/// @param col Column to start looking for match</a>
<a name="ln6792">/// @param tm Timeout limit or NULL</a>
<a name="ln6793">/// @param timed_out Flag set on timeout or NULL</a>
<a name="ln6794">///</a>
<a name="ln6795">/// @return &lt;= 0 if there is no match and number of lines contained in the match</a>
<a name="ln6796">/// otherwise.</a>
<a name="ln6797">///</a>
<a name="ln6798">/// @note The body is the same as bt_regexec() except for nfa_regexec_both()</a>
<a name="ln6799">///</a>
<a name="ln6800">/// @warning</a>
<a name="ln6801">/// Match may actually be in another line. e.g.:</a>
<a name="ln6802">/// when r.e. is \nc, cursor is at 'a' and the text buffer looks like</a>
<a name="ln6803">///</a>
<a name="ln6804">/// @par</a>
<a name="ln6805">///</a>
<a name="ln6806">///     +-------------------------+</a>
<a name="ln6807">///     |a                        |</a>
<a name="ln6808">///     |b                        |</a>
<a name="ln6809">///     |c                        |</a>
<a name="ln6810">///     |                         |</a>
<a name="ln6811">///     +-------------------------+</a>
<a name="ln6812">///</a>
<a name="ln6813">/// @par</a>
<a name="ln6814">/// then nfa_regexec_multi() returns 3. while the original vim_regexec_multi()</a>
<a name="ln6815">/// returns 0 and a second call at line 2 will return 2.</a>
<a name="ln6816">///</a>
<a name="ln6817">/// @par</a>
<a name="ln6818">/// FIXME if this behavior is not compatible.</a>
<a name="ln6819">static long nfa_regexec_multi(regmmatch_T *rmp, win_T *win, buf_T *buf,</a>
<a name="ln6820">                              linenr_T lnum, colnr_T col,</a>
<a name="ln6821">                              proftime_T *tm, int *timed_out)</a>
<a name="ln6822">{</a>
<a name="ln6823">  rex.reg_match = NULL;</a>
<a name="ln6824">  rex.reg_mmatch = rmp;</a>
<a name="ln6825">  rex.reg_buf = buf;</a>
<a name="ln6826">  rex.reg_win = win;</a>
<a name="ln6827">  rex.reg_firstlnum = lnum;</a>
<a name="ln6828">  rex.reg_maxline = rex.reg_buf-&gt;b_ml.ml_line_count - lnum;</a>
<a name="ln6829">  rex.reg_line_lbr = false;</a>
<a name="ln6830">  rex.reg_ic = rmp-&gt;rmm_ic;</a>
<a name="ln6831">  rex.reg_icombine = false;</a>
<a name="ln6832">  rex.reg_maxcol = rmp-&gt;rmm_maxcol;</a>
<a name="ln6833"> </a>
<a name="ln6834">  return nfa_regexec_both(NULL, col, tm, timed_out);</a>
<a name="ln6835">}</a>

</code></pre>
<div class="balloon" rel="6189"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1051/" target="_blank">V1051</a> Consider checking for misprints. It's possible that the 'pim->result' should be checked here.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
