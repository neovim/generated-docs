<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta content="IE=edge" http-equiv="X-UA-Compatible">
    <meta content="width=device-width, initial-scale=1" name="viewport">
    <title>Nvim documentation: treesitter</title>
    <link href="https://fonts.googleapis.com/css?family=Lato:400,700,900" rel="stylesheet">
    <link href="/css/normalize.min.css" rel="stylesheet">
    <link href="/css/bootstrap.css" rel="stylesheet">
    <link href="/css/main.css" rel="stylesheet">
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
      <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
    
  </head>
  <body>
    <header class="container">
      <nav class="navbar navbar-expand-lg">
        <div class="container-fluid">
          <a href="/" class="navbar-brand">
            <svg xmlns="http://www.w3.org/2000/svg" style="height: 2.5em" viewBox="0 0 742 214">
              <defs>
                <linearGradient x1="50%" y1="0%" x2="50%" y2="100%" id="a">
                  <stop stop-color="#16B0ED" stop-opacity=".8" offset="0%" />
                  <stop stop-color="#0F59B2" stop-opacity=".837" offset="100%" />
                </linearGradient>
                <linearGradient x1="50%" y1="0%" x2="50%" y2="100%" id="b">
                  <stop stop-color="#7DB643" offset="0%" />
                  <stop stop-color="#367533" offset="100%" />
                </linearGradient>
                <linearGradient x1="50%" y1="0%" x2="50%" y2="100%" id="c">
                  <stop stop-color="#88C649" stop-opacity=".8" offset="0%" />
                  <stop stop-color="#439240" stop-opacity=".84" offset="100%" />
                </linearGradient>
              </defs>
              <g fill="none" fill-rule="evenodd">
                <path
                  d="M.027 45.459L45.224-.173v212.171L.027 166.894V45.459z"
                  fill="url(#a)"
                  transform="translate(1 1)"
                />
                <path
                  d="M129.337 45.89L175.152-.149l-.928 212.146-45.197-45.104.31-121.005z"
                  fill="url(#b)"
                  transform="matrix(-1 0 0 1 305 1)"
                />
                <path
                  d="M45.194-.137L162.7 179.173l-32.882 32.881L12.25 33.141 45.194-.137z"
                  fill="url(#c)"
                  transform="translate(1 1)"
                />
                <path
                  d="M46.234 84.032l-.063 7.063-36.28-53.563 3.36-3.422 32.983 49.922z"
                  fill-opacity=".13"
                  fill="#000"
                />
                <g fill="#444">
                  <path
                    d="M227 154V64.44h4.655c1.55 0 2.445.75 2.685 2.25l.806 13.502c4.058-5.16 8.786-9.316 14.188-12.466 5.4-3.15 11.413-4.726 18.037-4.726 4.893 0 9.205.781 12.935 2.34 3.729 1.561 6.817 3.811 9.264 6.751 2.448 2.942 4.297 6.48 5.55 10.621 1.253 4.14 1.88 8.821 1.88 14.042V154h-8.504V96.754c0-8.402-1.91-14.987-5.729-19.757-3.82-4.771-9.667-7.156-17.544-7.156-5.851 0-11.28 1.516-16.292 4.545-5.013 3.032-9.489 7.187-13.427 12.467V154H227zM350.624 63c5.066 0 9.755.868 14.069 2.605 4.312 1.738 8.052 4.268 11.219 7.592s5.638 7.412 7.419 12.264C385.11 90.313 386 95.883 386 102.17c0 1.318-.195 2.216-.588 2.696-.393.48-1.01.719-1.851.719h-64.966v1.70c0 6.708.784 12.609 2.353 17.7 1.567 5.09 3.8 9.357 6.695 12.802 2.895 3.445 6.393 6.034 10.495 7.771 4.1 1.738 8.686 2.606 13.752 2.606 4.524 0 8.446-.494 11.762-1.483 3.317-.988 6.108-2.097 8.37-3.324 2.261-1.227 4.056-2.336 5.383-3.324 1.326-.988 2.292-1.482 2.895-1.482.784 0 1.388.3 1.81.898l2.352 2.875c-1.448 1.797-3.362 3.475-5.745 5.031-2.383 1.558-5.038 2.891-7.962 3.998-2.926 1.109-6.062 1.991-9.41 2.65a52.21 52.21 0 01-10.088.989c-6.152 0-11.762-1.064-16.828-3.19-5.067-2.125-9.415-5.225-13.043-9.298-3.63-4.074-6.435-9.06-8.415-14.96C310.99 121.655 310 114.9 310 107.294c0-6.408.92-12.323 2.76-17.744 1.84-5.421 4.493-10.093 7.961-14.016 3.467-3.922 7.72-6.991 12.758-9.209C338.513 64.11 344.229 63 350.624 63zm.573 6c-4.696 0-8.904.702-12.623 2.105-3.721 1.404-6.936 3.421-9.65 6.053-2.713 2.631-4.908 5.79-6.586 9.474S319.55 94.439 319 99h60c0-4.679-.672-8.874-2.013-12.588-1.343-3.712-3.232-6.856-5.67-9.43-2.44-2.571-5.367-4.545-8.782-5.92-3.413-1.374-7.192-2.062-11.338-2.062zM435.546 63c6.526 0 12.368 1.093 17.524 3.28 5.154 2.186 9.5 5.286 13.04 9.298 3.538 4.013 6.238 8.85 8.099 14.51 1.861 5.66 2.791 11.994 2.791 19.002 0 7.008-.932 13.327-2.791 18.957-1.861 5.631-4.561 10.452-8.099 14.465-3.54 4.012-7.886 7.097-13.04 9.254-5.156 2.156-10.998 3.234-17.524 3.234-6.529 0-12.369-1.078-17.525-3.234-5.155-2.157-9.517-5.242-13.085-9.254-3.57-4.013-6.285-8.836-8.145-14.465-1.861-5.63-2.791-11.95-2.791-18.957 0-7.008.93-13.342 2.791-19.002 1.861-5.66 4.576-10.496 8.145-14.51 3.568-4.012 7.93-7.112 13.085-9.299C423.177 64.094 429.017 63 435.546 63zm-.501 86c5.341 0 10.006-.918 13.997-2.757 3.99-1.838 7.32-4.474 9.992-7.909 2.67-3.435 4.664-7.576 5.986-12.428 1.317-4.85 1.98-10.288 1.98-16.316 0-5.965-.66-11.389-1.98-16.27-1.322-4.88-3.316-9.053-5.986-12.519-2.67-3.463-6-6.13-9.992-7.999-3.991-1.867-8.657-2.802-13.997-2.802s-10.008.935-13.997 2.802c-3.991 1.87-7.322 4.536-9.992 8-2.671 3.465-4.68 7.637-6.03 12.518-1.35 4.881-2.026 10.305-2.026 16.27 0 6.026.675 11.465 2.025 16.316 1.35 4.852 3.36 8.993 6.031 12.428 2.67 3.435 6 6.07 9.992 7.91 3.99 1.838 8.656 2.756 13.997 2.756z"
                    fill="currentColor"
                  />
                  <path
                    d="M530.57 152h-20.05L474 60h18.35c1.61 0 2.967.39 4.072 1.166 1.103.778 1.865 1.763 2.283 2.959l17.722 49.138a92.762 92.762 0 012.551 8.429c.686 2.751 1.298 5.5 1.835 8.25.537-2.75 1.148-5.499 1.835-8.25a77.713 77.713 0 012.64-8.429l18.171-49.138c.417-1.196 1.164-2.181 2.238-2.96 1.074-.776 2.356-1.165 3.849-1.165H567l-36.43 92zM572 61h23v92h-23zM610 153V60.443h13.624c2.887 0 4.78 1.354 5.682 4.06l1.443 6.856a52.7 52.7 0 015.097-4.962 32.732 32.732 0 015.683-3.879 30.731 30.731 0 016.496-2.57c2.314-.632 4.855-.948 7.624-.948 5.832 0 10.63 1.579 14.39 4.736 3.758 3.157 6.57 7.352 8.434 12.585 1.444-3.068 3.248-5.698 5.413-7.894 2.165-2.194 4.541-3.984 7.127-5.367a32.848 32.848 0 018.254-3.068 39.597 39.597 0 018.796-.992c5.111 0 9.653.783 13.622 2.345 3.97 1.565 7.307 3.849 10.014 6.857 2.706 3.007 4.766 6.675 6.18 11.005C739.29 83.537 740 88.5 740 94.092V153h-22.284V94.092c0-5.894-1.294-10.329-3.878-13.306-2.587-2.977-6.376-4.465-11.368-4.465-2.286 0-4.404.391-6.358 1.172a15.189 15.189 0 00-5.144 3.383c-1.473 1.474-2.631 3.324-3.474 5.548-.842 2.225-1.263 4.781-1.263 7.668V153h-22.37V94.092c0-6.194-1.249-10.704-3.744-13.532-2.497-2.825-6.18-4.24-11.051-4.24-3.19 0-6.18.798-8.976 2.391-2.799 1.593-5.399 3.775-7.804 6.54V153H610zM572 30h23v19h-23z"
                    fill="currentColor"
                    fill-opacity=".8"
                  />
                </g>
              </g>
            </svg>
          </a>
        </div>
      </nav>
    </header>

    <div class="container">
      <h1>Nvim documentation: treesitter</h1>
<A NAME="top"></A>
<A HREF="index.html">main help file</A>

<HR>
<PRE>

*<A NAME="treesitter.txt"></A><B>treesitter.txt</B>*    Nvim


			    NVIM REFERENCE MANUAL



Tree-sitter integration					*<A NAME="treesitter"></A><B>treesitter</B>*

                                      Type |<A HREF="various.html#gO">gO</A>| to see the table of contents.

------------------------------------------------------------------------------

VIM.TREESITTER						*<A NAME="lua-treesitter"></A><B>lua-treesitter</B>*

Nvim integrates the tree-sitter library for incremental parsing of <A HREF="windows.html#buffers">buffers</A>.


                                             *<A NAME="vim.treesitter.language_version"></A><B>vim.treesitter.language_version</B>*
To check which language version is compiled with neovim, the number is stored
within `vim.treesitter.language_version`. This number is not too helpful
unless you are wondering about compatibility between different versions of
compiled grammars.


Parser files						*<A NAME="treesitter-parsers"></A><B>treesitter-parsers</B>*

Parsers are the heart of tree-sitter. They are libraries that tree-sitter will
search for in the `parser` runtime directory.  Currently Nvim does not provide
the tree-sitter parsers, instead these must be built separately, for instance
using the tree-sitter utility. The only exception is a C parser being included
in official builds for <A HREF="testing.html#testing">testing</A> purposes. Parsers are searched for <A HREF="motion.html#as">as</A>
`parser/{lang}.*` in any <A HREF="options.html#'runtimepath'">'runtimepath'</A> directory.
A parser can also be loaded manually using a full path:

<B>    vim.treesitter.require_language("python", "/path/to/python.so")</B>

 Create a parser for a buffer and a given language (if another <A HREF="usr_05.html#plugin">plugin</A> uses the
same buffer/language combination, <A HREF="motion.html#it">it</A> will be safely reused). Use

<B>    parser = vim.treesitter.get_parser(bufnr, lang)</B>

 `bufnr=0` can be used for current buffer. `lang` will default to <A HREF="options.html#'filetype'">'filetype'</A>.
Currently, the parser will be retained for the lifetime of a buffer but this
is subject to change. A <A HREF="usr_05.html#plugin">plugin</A> should keep a reference to the parser object <A HREF="motion.html#as">as</A>
long <A HREF="motion.html#as">as</A> <A HREF="motion.html#it">it</A> wants incremental updates.



Parser methods						*<A NAME="lua-treesitter-parser"></A><B>lua-treesitter-parser</B>*


<A HREF="#tsparser:parse()">tsparser:parse()</A>					*<A NAME="tsparser:parse()"></A><B>tsparser:parse()</B>*
Whenever you need to access the current <A HREF="syntax.html#syntax">syntax</A> tree, parse the buffer:

<B>    tstree = parser:parse()</B>

 This will return a table of immutable trees that represent the current state of the
buffer. When the <A HREF="usr_05.html#plugin">plugin</A> wants to access the state after a (possible) edit
<A HREF="motion.html#it">it</A> should call `parse()` again. If the buffer wasn't edited, the same tree will
be returned again without extra work. If the buffer was parsed before,
incremental parsing will be done of the changed parts.

Note: to use the parser directly inside a |<A HREF="intro.html#nvim_buf_attach">nvim_buf_attach</A>| <A HREF="lua.html#Lua">Lua</A> callback, you
must call `get_parser()` before you <A HREF="intro.html#register">register</A> your callback. But preferably
parsing shouldn't be done directly in the change callback anyway <A HREF="motion.html#as">as</A> they will
be very frequent. Rather a <A HREF="usr_05.html#plugin">plugin</A> that does any kind of analysis on a tree
should use a <A HREF="eval.html#timer">timer</A> to throttle too frequent updates.


tsparser:set_included_regions({region_list})			*<A NAME="tsparser:set_included_regions()"></A><B>tsparser:set_included_regions()</B>*
	Changes the regions the parser should consider. This is used for
	language injection.  {region_list} should be of the form (all zero-based):
<B>	{</B>
<B>		{node1, node2},</B>
<B>		...</B>
<B>	}</B>
 
	`node1` and `node2` are both considered part of the same region and
	will be parsed together with the parser in the same <A HREF="repeat.html#context">context</A>.


Tree methods						*<A NAME="lua-treesitter-tree"></A><B>lua-treesitter-tree</B>*


<A HREF="#tstree:root()">tstree:root()</A>						*<A NAME="tstree:root()"></A><B>tstree:root()</B>*
	Return the root node of this tree.


<A HREF="#tstree:copy()">tstree:copy()</A>						*<A NAME="tstree:copy()"></A><B>tstree:copy()</B>*
	Returns a copy of the `tstree`.



Node methods						*<A NAME="lua-treesitter-node"></A><B>lua-treesitter-node</B>*


<A HREF="#tsnode:parent()">tsnode:parent()</A>						*<A NAME="tsnode:parent()"></A><B>tsnode:parent()</B>*
	Get the node's immediate parent.


<A HREF="#tsnode:iter_children()">tsnode:iter_children()</A>					*<A NAME="tsnode:iter_children()"></A><B>tsnode:iter_children()</B>*
	Iterates over all the direct children of {tsnode}, regardless of
	wether they are named or not.
	Returns the child node plus the eventual field name corresponding to
	this child node.


tsnode:field({name})					*<A NAME="tsnode:field()"></A><B>tsnode:field()</B>*
	Returns a table of the nodes corresponding to the {name} field.


<A HREF="#tsnode:child_count()">tsnode:child_count()</A>					*<A NAME="tsnode:child_count()"></A><B>tsnode:child_count()</B>*
	Get the node's number of children.


tsnode:child({index})					*<A NAME="tsnode:child()"></A><B>tsnode:child()</B>*
	Get the node's child at the given {index}, where zero represents the
	first child.


<A HREF="#tsnode:named_child_count()">tsnode:named_child_count()</A>				*<A NAME="tsnode:named_child_count()"></A><B>tsnode:named_child_count()</B>*
	Get the node's number of named children.


tsnode:named_child({index})				*<A NAME="tsnode:named_child()"></A><B>tsnode:named_child()</B>*
	Get the node's named child at the given {index}, where zero represents
	the first named child.


<A HREF="#tsnode:start()">tsnode:start()</A>						*<A NAME="tsnode:start()"></A><B>tsnode:start()</B>*
	Get the node's start position. Return three values: the row, column
	and total byte <A HREF="intro.html#count">count</A> (all zero-based).


<A HREF="#tsnode:end_()">tsnode:end_()</A>						*<A NAME="tsnode:end_()"></A><B>tsnode:end_()</B>*
	Get the node's end position. Return three values: the row, column
	and total byte <A HREF="intro.html#count">count</A> (all zero-based).


<A HREF="#tsnode:range()">tsnode:range()</A>						*<A NAME="tsnode:range()"></A><B>tsnode:range()</B>*
	Get the range of the node. Return four values: the row, column
	of the start position, then the row, column of the end position.


<A HREF="#tsnode:type()">tsnode:type()</A>						*<A NAME="tsnode:type()"></A><B>tsnode:type()</B>*
	Get the node's type <A HREF="motion.html#as">as</A> a <A HREF="eval.html#string">string</A>.


<A HREF="#tsnode:symbol()">tsnode:symbol()</A>						*<A NAME="tsnode:symbol()"></A><B>tsnode:symbol()</B>*
	Get the node's type <A HREF="motion.html#as">as</A> a numerical id.


<A HREF="#tsnode:named()">tsnode:named()</A>						*<A NAME="tsnode:named()"></A><B>tsnode:named()</B>*
	Check if the node is named. Named nodes correspond to named rules in
	the  grammar, whereas anonymous nodes correspond to <A HREF="eval.html#string">string</A> literals
	in the grammar.


<A HREF="#tsnode:missing()">tsnode:missing()</A>					*<A NAME="tsnode:missing()"></A><B>tsnode:missing()</B>*
	Check if the node is missing. Missing nodes are inserted by the
	parser in order to recover from certain kinds of <A HREF="syntax.html#syntax">syntax</A> <A HREF="message.html#errors">errors</A>.


<A HREF="#tsnode:has_error()">tsnode:has_error()</A>					*<A NAME="tsnode:has_error()"></A><B>tsnode:has_error()</B>*
	Check if the node is a <A HREF="syntax.html#syntax">syntax</A> error or contains any <A HREF="syntax.html#syntax">syntax</A> <A HREF="message.html#errors">errors</A>.


<A HREF="#tsnode:sexpr()">tsnode:sexpr()</A>						*<A NAME="tsnode:sexpr()"></A><B>tsnode:sexpr()</B>*
	Get an S-expression representing the node <A HREF="motion.html#as">as</A> a <A HREF="eval.html#string">string</A>.


<A HREF="#tsnode:id()">tsnode:id()</A>						*<A NAME="tsnode:id()"></A><B>tsnode:id()</B>*
	Get an unique identier for the node inside its own tree.

	No guarantees are made about this identifer's internal representation,
	except for being a primitive <A HREF="lua.html#lua">lua</A> type with value equality (so not a table).
	Presently <A HREF="motion.html#it">it</A> is a (non-printable) <A HREF="eval.html#string">string</A>.

	Note: the id is not guaranteed to be unique for nodes from different
	trees.

tsnode:descendant_for_range({start_row}, {start_col}, {end_row}, {end_col})

							*<A NAME="tsnode:descendant_for_range()"></A><B>tsnode:descendant_for_range()</B>*
	Get the smallest node within this node that spans the given range of
	(row, column) positions

tsnode:named_descendant_for_range({start_row}, {start_col}, {end_row}, {end_col})

							*<A NAME="tsnode:named_descendant_for_range()"></A><B>tsnode:named_descendant_for_range()</B>*
	Get the smallest named node within this node that spans the given
	range of (row, column) positions


Query   						*<A NAME="lua-treesitter-query"></A><B>lua-treesitter-query</B>*

Tree-sitter queries are supported, they are a way to <A HREF="diff.html#do">do</A> pattern-matching over
a tree, using a simple to write lisp-like format. See
https://tree-sitter.github.io/tree-sitter/using-parsers#query-syntax for more
information on how to write queries.

Note: The perdicates listed in the web page above differ from those Neovim
supports. See |<A HREF="#lua-treesitter-predicates">lua-treesitter-predicates</A>| for a complete <A HREF="eval.html#list">list</A> of predicates
supported by Neovim.

A `query` consists of one or more patterns. A `pattern` is defined over node
types in the <A HREF="syntax.html#syntax">syntax</A> tree.  A `match` corresponds to specific elements of the
<A HREF="syntax.html#syntax">syntax</A> tree which match a <A HREF="pattern.html#pattern">pattern</A>. Patterns may optionally define captures
and predicates. A `capture` allows you to associate names with a specific
node in a <A HREF="pattern.html#pattern">pattern</A>. A `predicate` adds arbitrary metadata and conditional data
to a match.


Treesitter Query Predicates				*<A NAME="lua-treesitter-predicates"></A><B>lua-treesitter-predicates</B>*

When <A HREF="editing.html#writing">writing</A> queries for <A HREF="#treesitter">treesitter</A>, one might use `predicates`, that is,
special scheme nodes that are evaluted to verify things on a captured node for
example, the |<A HREF="intro.html#eq?">eq?</A>| predicate :
<B>	((identifier) @foo (#eq? @foo "foo"))</B>

This will only match identifier corresponding to the `&quot;foo&quot;` text.
Here is a <A HREF="eval.html#list">list</A> of built-in predicates :


	`eq?`						*<A NAME="ts-predicate-eq?"></A><B>ts-predicate-eq?</B>*
		This predicate will check text correspondance between nodes or
		strings :
<B>			((identifier) @foo (#eq? @foo "foo"))</B>
<B>			((node1) @left (node2) @right (#eq? @left @right))</B>
 

	`match?`					*<A NAME="ts-predicate-match?"></A><B>ts-predicate-match?</B>*

	`vim-match?`					*<A NAME="ts-predicate-vim-match?"></A><B>ts-predicate-vim-match?</B>*
		This will match if the provived vim regex matches the text
		corresponding to a node :
<B>			((idenfitier) @constant (#match? @constant "^[A-Z_]+$"))</B>
 		Note: the `^` and `$` anchors will respectively match the
			start and end of the node's text.


	`lua-match?`					*<A NAME="ts-predicate-lua-match?"></A><B>ts-predicate-lua-match?</B>*
		This will match the same way than |<A HREF="intro.html#match?">match?</A>| but using <A HREF="lua.html#lua">lua</A>
		regexes.


	`contains?`					*<A NAME="ts-predicate-contains?"></A><B>ts-predicate-contains?</B>*
		Will check if any of the following arguments appears in the
		text corresponding to the node :
<B>			((identifier) @foo (#contains? @foo "foo"))</B>
<B>			((identifier) @foo-bar (#contains @foo-bar "foo" "bar"))</B>
 

	`any-of?`					*<A NAME="ts-predicate-any-of?"></A><B>ts-predicate-any-of?</B>*
		Will check if the text is the same <A HREF="motion.html#as">as</A> any of the following
		This is the recommended way to check if the node matches one
		of many keywords for exemple, <A HREF="motion.html#as">as</A> <A HREF="motion.html#it">it</A> has been optimized for
		this.
		arguments :
<B>			((identifier) @foo (#any-of? @foo "foo" "bar"))</B>
 

							*<A NAME="lua-treesitter-not-predicate"></A><B>lua-treesitter-not-predicate</B>*
Each predicate has a `not-` prefixed predicate that is just the negation of
the predicate.


Treesitter Query Directive				*<A NAME="lua-treesitter-directives"></A><B>lua-treesitter-directives</B>*

Treesitter queries can also contain `directives`. Directives store metadata for a node
or match and perform side effects. for example, the |<A HREF="intro.html#set!">set!</A>| predicate sets metadata on
the match or node :
<B>	((identifier) @foo (#set! "type" "parameter"))</B>

Here is a <A HREF="eval.html#list">list</A> of built-in directives:


	`set!`						*<A NAME="ts-directive-set!"></A><B>ts-directive-set!</B>*
		Sets key/value metadata for a specific node or match :
<B>			((identifier) @foo (#set! @foo "kind" "parameter"))</B>
<B>			((node1) @left (node2) @right (#set! "type" "pair"))</B>
 

	`offset!`					*<A NAME="ts-predicate-offset!"></A><B>ts-predicate-offset!</B>*
		Takes the range of the captured node and applies the offsets
		to it's range :
<B>			((idenfitier) @constant (#offset! @constant 0 1 0 -1))</B>
 		This will generate a range object for the captured node with the
		offsets applied. The arguments are
		`({capture_id}, {start_row}, {start_col}, {end_row}, {end_col}, {key?})`
		The default key is &quot;offset&quot;.


Treesitter <A HREF="syntax.html#syntax">syntax</A> highlighting (WIP)			*<A NAME="lua-treesitter-highlight"></A><B>lua-treesitter-highlight</B>*

NOTE: This is a partially implemented feature, and not usable <A HREF="motion.html#as">as</A> a default
solution yet. What is documented here is a temporary interface intended
for those who want to experiment with this feature and contribute to
its <A HREF="develop.html#development">development</A>.

Highlights are defined in the same query format <A HREF="motion.html#as">as</A> in the tree-sitter highlight
crate, which some limitations and additions. Set a highlight query for a
buffer with this code:

<B>    local query = [[</B>
<B>      "for" @keyword</B>
<B>      "if" @keyword</B>
<B>      "return" @keyword</B>

<B>      (string_literal) @string</B>
<B>      (number_literal) @number</B>
<B>      (comment) @comment</B>

<B>      (preproc_function_def name: (identifier) @function)</B>

<B>      ; ... more definitions</B>
<B>    ]]</B>

<B>    highlighter = vim.treesitter.TSHighlighter.new(query, bufnr, lang)</B>
<B>    -- alternatively, to use the current buffer and its filetype:</B>
<B>    -- highlighter = vim.treesitter.TSHighlighter.new(query)</B>

<B>    -- Don't recreate the highlighter for the same buffer, instead</B>
<B>    -- modify the query like this:</B>
<B>    local query2 = [[ ... ]]</B>
<B>    highlighter:set_query(query2)</B>

As mentioned above the supported predicate is currently only `eq?`. `match?`
predicates behave like matching always fails. As an addition a capture which
begin with an upper-case <A HREF="print.html#letter">letter</A> like `@WarningMsg` will map directly to this
highlight group, if defined. Also if the predicate begins with upper-case and
contains a dot only the part before the first will be interpreted <A HREF="motion.html#as">as</A> the
highlight group. As an example, this warns of a binary <A HREF="eval.html#expression">expression</A> with two
identical identifiers, highlighting both <A HREF="motion.html#as">as</A> YXXYhl-WarningMsg|:

<B>    ((binary_expression left: (identifier) @WarningMsg.left right: (identifier) @WarningMsg.right)</B>
<B>     (eq? @WarningMsg.left @WarningMsg.right))</B>
 

==============================================================================

<A HREF="lua.html#Lua">Lua</A> module: vim.treesitter                               *<A NAME="lua-treesitter-core"></A><B>lua-treesitter-core</B>*


get_parser({bufnr}, {lang}, {opts})                             *<A NAME="get_parser()"></A><B>get_parser()</B>*
                Gets the parser for this bufnr / ft combination.

                If needed this will create the parser. Unconditionnally attach
                the provided callback

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {bufnr}  The buffer the parser should be tied to
                    {lang}   The <A HREF="filetype.html#filetype">filetype</A> of this parser
                    {opts}   Options object to pass to the created language
                             tree

<B><FONT color="#54A23D">                Return: </FONT></B>
                    The parser


get_string_parser({str}, {lang}, {opts})                 *<A NAME="get_string_parser()"></A><B>get_string_parser()</B>*
                Gets a <A HREF="eval.html#string">string</A> parser

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {str}   The <A HREF="eval.html#string">string</A> to parse
                    {lang}  The language of this <A HREF="eval.html#string">string</A>
                    {opts}  Options to pass to the created language tree


==============================================================================

<A HREF="lua.html#Lua">Lua</A> module: vim.treesitter.language                      *<A NAME="treesitter-language"></A><B>treesitter-language</B>*


inspect_language({lang})                                  *<A NAME="inspect_language()"></A><B>inspect_language()</B>*
                Inspects the provided language.

                Inspecting provides some useful informations on the language
                like node names, <A HREF="eval.html#...">...</A>

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {lang}  The language.


require_language({lang}, {path}, {silent})                *<A NAME="require_language()"></A><B>require_language()</B>*
                Asserts that the provided language is installed, and
                optionally provide a path for the parser

                Parsers are searched in the `parser` runtime directory.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {lang}    The language the parser should parse
                    {path}    Optional path the parser is located at
                    {silent}  Don't throw an error if language not found


==============================================================================

<A HREF="lua.html#Lua">Lua</A> module: vim.treesitter.query                            *<A NAME="treesitter-query"></A><B>treesitter-query</B>*


add_directive({name}, {handler}, {force})                    *<A NAME="add_directive()"></A><B>add_directive()</B>*
                Adds a new directive to be used in queries

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {name}     the name of the directive, without leading #
                    {handler}  the handler function to be used signature will
                               be (match, <A HREF="pattern.html#pattern">pattern</A>, bufnr, predicate)


add_predicate({name}, {handler}, {force})                    *<A NAME="add_predicate()"></A><B>add_predicate()</B>*
                Adds a new predicate to be used in queries

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {name}     the name of the predicate, without leading #
                    {handler}  the handler function to be used signature will
                               be (match, <A HREF="pattern.html#pattern">pattern</A>, bufnr, predicate)


get_node_text({node}, {source})                              *<A NAME="get_node_text()"></A><B>get_node_text()</B>*
                Gets the text corresponding to a given node

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {node}     the node
                    {bsource}  The buffer or <A HREF="eval.html#string">string</A> from which the node is
                               extracted


get_query({lang}, {query_name})                                  *<A NAME="get_query()"></A><B>get_query()</B>*
                Returns the runtime query {query_name} for {lang}.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {lang}        The language to use for the query
                    {query_name}  The name of the query (i.e. &quot;highlights&quot;)

<B><FONT color="#54A23D">                Return: </FONT></B>
                    The corresponding query, parsed.


                                                           *<A NAME="get_query_files()"></A><B>get_query_files()</B>*
get_query_files({lang}, {query_name}, {is_included})
                Gets the <A HREF="eval.html#list">list</A> of files used to make up a query

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {lang}         The language
                    {query_name}   The name of the query to load
                    {is_included}  Internal parameter, most of the time left
                                   <A HREF="motion.html#as">as</A> `nil`


<A HREF="#list_predicates()">list_predicates()</A>                                          *<A NAME="list_predicates()"></A><B>list_predicates()</B>*
                TODO: Documentation


parse_query({lang}, {query})                                   *<A NAME="parse_query()"></A><B>parse_query()</B>*
                Parse {query} <A HREF="motion.html#as">as</A> a <A HREF="eval.html#string">string</A>. (If the query is in a file, the
                caller should read the contents into a <A HREF="eval.html#string">string</A> before calling).

                Returns a `Query` (see |<A HREF="#lua-treesitter-query">lua-treesitter-query</A>|) object which
                can be used to search nodes in the <A HREF="syntax.html#syntax">syntax</A> tree for the
                patterns defined in {query} using `iter_*` methods below.

                Exposes `info` and `captures` with additional information about the {query}.
                • `captures` contains the <A HREF="eval.html#list">list</A> of unique capture names defined
                  in {query}. - `info.captures` also points to `captures` .
                • `info.patterns` contains information about predicates.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {lang}   The language
                    {query}  A <A HREF="eval.html#string">string</A> containing the query (s-expr <A HREF="syntax.html#syntax">syntax</A>)

<B><FONT color="#54A23D">                Return: </FONT></B>
                    The query


                                                       *<A NAME="Query:iter_captures()"></A><B>Query:iter_captures()</B>*
Query:iter_captures({self}, {node}, {source}, {start}, {stop})
                Iterate over all captures from all matches inside {node}

                {source} is needed if the query contains predicates, then the
                caller must ensure to use a freshly parsed tree consistent
                with the current text of the buffer (if relevent). {start_row}
                and {end_row} can be used to limit matches inside a row range
                (this is typically used with root node <A HREF="motion.html#as">as</A> the node, <A HREF="insert.html#i">i</A> <A HREF="motion.html#e">e</A> to get
                <A HREF="syntax.html#syntax">syntax</A> highlight matches in the current viewport). When
                omitted the start and end row values are used from the given
                node.

                The iterator returns three values, a numeric id identifying
                the capture, the captured node, and metadata from any
                directives processing the match. The following example shows
                how to get captures by name:


<B>    for id, node, metadata in query:iter_captures(tree:root(), bufnr, first, last) do</B>
<B>      local name = query.captures[id] -- name of the capture in the query</B>
<B>      -- typically useful info about the node:</B>
<B>      local type = node:type() -- type of the captured node</B>
<B>      local row1, col1, row2, col2 = node:range() -- range of the capture</B>
<B>      ... use the info here ...</B>
<B>    end</B>
 

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {node}    The node under which the search will occur
                    {source}  The source buffer or <A HREF="eval.html#string">string</A> to exctract text
                              from
                    {start}   The starting line of the search
                    {stop}    The stopping line of the search (end-exclusive)
                    {self}

<B><FONT color="#54A23D">                Return: </FONT></B>
                    The matching capture id
                    The captured node


                                                        *<A NAME="Query:iter_matches()"></A><B>Query:iter_matches()</B>*
Query:iter_matches({self}, {node}, {source}, {start}, {stop})
                Iterates the matches of <A HREF="eval.html#self">self</A> on a given range.

                Iterate over all matches within a node. The arguments are the
                same <A HREF="motion.html#as">as</A> for |<A HREF="intro.html#query:iter_captures()">query:iter_captures()</A>| but the iterated values
                are different: an (1-based) index of the <A HREF="pattern.html#pattern">pattern</A> in the query,
                a table <A HREF="map.html#mapping">mapping</A> capture indices to nodes, and metadata from
                any directives processing the match. If the query has more
                than one <A HREF="pattern.html#pattern">pattern</A> the capture table might be sparse, and e.g.
                `pairs()` method should be used over `ipairs` . Here an
                example iterating over all captures in every match:


<B>    for pattern, match, metadata in cquery:iter_matches(tree:root(), bufnr, first, last) do</B>
<B>      for id, node in pairs(match) do</B>
<B>        local name = query.captures[id]</B>
<B>        -- `node` was captured by the `name` capture in the match</B>
 

<B>    local node_data = metadata[id] -- Node level metadata</B>
 

<B>        ... use the info here ...</B>
<B>      end</B>
<B>    end</B>
 

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {node}    The node under which the search will occur
                    {source}  The source buffer or <A HREF="eval.html#string">string</A> to search
                    {start}   The starting line of the search
                    {stop}    The stopping line of the search (end-exclusive)
                    {self}

<B><FONT color="#54A23D">                Return: </FONT></B>
                    The matching <A HREF="pattern.html#pattern">pattern</A> id
                    The matching match


set_query({lang}, {query_name}, {text})                          *<A NAME="set_query()"></A><B>set_query()</B>*
                Sets the runtime query {query_name} for {lang}

                This allows users to override any runtime files and/or
                configuration set by plugins.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {lang}        <A HREF="eval.html#string">string</A>: The language to use for the query
                    {query_name}  <A HREF="eval.html#string">string</A>: The name of the query (i.e.
                                  &quot;highlights&quot;)
                    {text}        <A HREF="eval.html#string">string</A>: The query text (unparsed).


==============================================================================

<A HREF="lua.html#Lua">Lua</A> module: vim.treesitter.highlighter                *<A NAME="treesitter-highlighter"></A><B>treesitter-highlighter</B>*


new({tree}, {opts})                                        *<A NAME="highlighter.new()"></A><B>highlighter.new()</B>*
                Creates a new highlighter using

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {tree}  The language tree to use for highlighting
                    {opts}  Table used to configure the highlighter
                            • queries: Table to overwrite queries used by the
                              highlighter


TSHighlighter:destroy({self})                        *<A NAME="TSHighlighter:destroy()"></A><B>TSHighlighter:destroy()</B>*
                Removes all internal references to the highlighter

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {self}


TSHighlighter:get_query({self}, {lang})            *<A NAME="TSHighlighter:get_query()"></A><B>TSHighlighter:get_query()</B>*
                Gets the query used for

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {lang}  A language used by the highlighter.
                    {self}


==============================================================================

<A HREF="lua.html#Lua">Lua</A> module: vim.treesitter.languagetree              *<A NAME="treesitter-languagetree"></A><B>treesitter-languagetree</B>*


LanguageTree:add_child({self}, {lang})              *<A NAME="LanguageTree:add_child()"></A><B>LanguageTree:add_child()</B>*
                Adds a child language to this tree.

                If the language already exists <A HREF="motion.html#as">as</A> a child, <A HREF="motion.html#it">it</A> will first be
                removed.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {lang}  The language to add.
                    {self}


LanguageTree:children({self})                        *<A NAME="LanguageTree:children()"></A><B>LanguageTree:children()</B>*
                Returns a map of language to child tree.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {self}


LanguageTree:contains({self}, {range})               *<A NAME="LanguageTree:contains()"></A><B>LanguageTree:contains()</B>*
                Determines wether This goes down the tree to recursively check childs.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {range}  is contained in this language tree

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {range}  A range, that is a <A HREF="motion.html#`{">`{</A> start_line, start_col,
                             end_line, end_col }` table.
                    {self}


LanguageTree:destroy({self})                          *<A NAME="LanguageTree:destroy()"></A><B>LanguageTree:destroy()</B>*
                Destroys this language tree and all its children.

                Any cleanup logic should be performed here. Note, this DOES
                NOT remove this tree from a parent. `remove_child` must be called on the parent to remove <A HREF="motion.html#it">it</A>.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {self}


                                               *<A NAME="LanguageTree:for_each_child()"></A><B>LanguageTree:for_each_child()</B>*
LanguageTree:for_each_child({self}, {fn}, {include_self})
                Invokes the callback for each LanguageTree and it's children
                recursively

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {fn}            The function to invoke. This is invoked
                                    with arguments (tree: LanguageTree, lang:
                                    <A HREF="eval.html#string">string</A>)
                    {include_self}  Whether to include the invoking tree in
                                    the results.
                    {self}


LanguageTree:for_each_tree({self}, {fn})        *<A NAME="LanguageTree:for_each_tree()"></A><B>LanguageTree:for_each_tree()</B>*
                Invokes the callback for each <A HREF="#treesitter">treesitter</A> trees recursively.

                Note, this includes the invoking language tree's trees <A HREF="motion.html#as">as</A>
                well.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {fn}    The callback to invoke. The callback is invoked
                            with arguments (tree: TSTree, languageTree:
                            LanguageTree)
                    {self}


LanguageTree:included_regions({self})        *<A NAME="LanguageTree:included_regions()"></A><B>LanguageTree:included_regions()</B>*
                Gets the set of included regions

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {self}


LanguageTree:invalidate({self}, {reload})          *<A NAME="LanguageTree:invalidate()"></A><B>LanguageTree:invalidate()</B>*
                Invalidates this parser and all its children

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {self}


LanguageTree:is_valid({self})                        *<A NAME="LanguageTree:is_valid()"></A><B>LanguageTree:is_valid()</B>*
                Determines whether this tree is valid. If the tree is invalid, `parse()` must be called to get the an updated tree.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {self}


LanguageTree:lang({self})                                *<A NAME="LanguageTree:lang()"></A><B>LanguageTree:lang()</B>*
                Gets the language of this tree node.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {self}


                                           *<A NAME="LanguageTree:language_for_range()"></A><B>LanguageTree:language_for_range()</B>*
LanguageTree:language_for_range({self}, {range})
                Gets the appropriate language that contains

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {range}  A text range, see |<A HREF="intro.html#LanguageTree:contains">LanguageTree:contains</A>|
                    {self}


LanguageTree:parse({self})                              *<A NAME="LanguageTree:parse()"></A><B>LanguageTree:parse()</B>*
                Parses all defined regions using a <A HREF="#treesitter">treesitter</A> parser for the
                language this tree represents. This will run the injection
                query for this language to determine if any child languages
                should be created.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {self}


LanguageTree:register_cbs({self}, {cbs})         *<A NAME="LanguageTree:register_cbs()"></A><B>LanguageTree:register_cbs()</B>*
                Registers callbacks for the parser

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {cbs}   An `nvim_buf_attach` -like table argument with the following keys : `on_bytes` : see `nvim_buf_attach` , but this will be called after the parsers callback. `on_changedtree` : a callback that will be called every time the
                            tree has syntactical changes. <A HREF="motion.html#it">it</A> will only be
                            passed one argument, that is a table of the ranges
                            (as node ranges) that changed. `on_child_added` : emitted when a child is added to the tree. `on_child_removed` : emitted when a child is removed from the tree.
                    {self}


LanguageTree:remove_child({self}, {lang})        *<A NAME="LanguageTree:remove_child()"></A><B>LanguageTree:remove_child()</B>*
                Removes a child language from this tree.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {lang}  The language to remove.
                    {self}


                                         *<A NAME="LanguageTree:set_included_regions()"></A><B>LanguageTree:set_included_regions()</B>*
LanguageTree:set_included_regions({self}, {regions})
                Sets the included regions that should be parsed by this
                parser. A region is a set of nodes and/or ranges that will be
                parsed in the same <A HREF="repeat.html#context">context</A>.

                For example, <A HREF="motion.html#`{">`{</A> { node1 }, { node2} }` is two separate
                regions. This will be parsed by the parser in two different
                contexts... thus resulting in two separate trees.

                <A HREF="motion.html#`{">`{</A> { node1, node2 } }` is a single region consisting of two
                nodes. This will be parsed by the parser in a single
                context... thus resulting in a single tree.

                This allows for embedded languages to be parsed together
                across different nodes, which is useful for templating
                languages like ERB and EJS.

                Note, this call invalidates the tree and requires <A HREF="motion.html#it">it</A> to be
                parsed again.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {regions}  A <A HREF="eval.html#list">list</A> of regions this tree should manage and
                               parse.
                    {self}


LanguageTree:source({self})                            *<A NAME="LanguageTree:source()"></A><B>LanguageTree:source()</B>*
                Returns the source content of the language tree (bufnr or
                <A HREF="eval.html#string">string</A>).

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {self}


LanguageTree:trees({self})                              *<A NAME="LanguageTree:trees()"></A><B>LanguageTree:trees()</B>*
                Returns all trees this language tree contains. Does not
                include child languages.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {self}


new({source}, {lang}, {opts})                             *<A NAME="languagetree.new()"></A><B>languagetree.new()</B>*
                Represents a single <A HREF="#treesitter">treesitter</A> parser for a language. The
                language can contain child languages with in its range, hence
                the tree.

<B><FONT color="#54A23D">                Parameters: </FONT></B>
                    {source}           Can be a bufnr or a <A HREF="eval.html#string">string</A> of text to
                                       parse
                    {lang}             The language this tree represents
                    {opts}             Options table
                    {opts.injections}  A table of language to injection query
                                       strings. This is useful for overriding
                                       the built-in runtime file searching for
                                       the injection language query per
                                       language.


==============================================================================

<A HREF="lua.html#Lua">Lua</A> module: vim.treesitter.health                          *<A NAME="treesitter-health"></A><B>treesitter-health</B>*


<A HREF="#check_health()">check_health()</A>                                                *<A NAME="check_health()"></A><B>check_health()</B>*
                TODO: Documentation


<A HREF="#list_parsers()">list_parsers()</A>                                                *<A NAME="list_parsers()"></A><B>list_parsers()</B>*
                <A HREF="eval.html#Lists">Lists</A> the parsers currently installed

<B><FONT color="#54A23D">                Return: </FONT></B>
                    A <A HREF="eval.html#list">list</A> of parsers

<A HREF="#top">top</A> - <A HREF="index.html">main help file</A>
</PRE>
    </div>

    <footer>
      <div class="container">
        Generated Sun Jul 11 05:28:48 UTC 2021 from <a href="https://github.com/neovim/neovim/commit/79fe9dedcfede1d2038b47a21f21a995051deaa2"><code>79fe9de</code></a>.
      </div>
    </footer>
  </body>
</html>
